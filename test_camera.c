/*****************************************************************************
 * File generated by HDevelop for HALCON/C Version 23.11.0.0
 * Non-ASCII strings in this file are encoded in local-8-bit encoding (utf8).
 * Ensure that the interface encoding is set to locale encoding by calling
 * SetHcInterfaceStringEncodingIsUtf8(FALSE) at the beginning of the program.
 * 
 * Please note that non-ASCII characters in string constants are exported
 * as octal codes in order to guarantee that the strings are correctly
 * created on all systems, independent on any compiler settings.
 * 
 * Source files with different encoding should not be mixed in one project.
 *****************************************************************************/
#include "HalconC.h"
#include "halconc/Hdevthread.h"



#ifndef NO_EXPORT_MAIN
/* Main procedure */
void action()
{
  /* Stack for temporary tuples */
  Htuple   TTemp[100];
  int      SP=0;
  /* Stack for temporary tuple vectors */
  Hvector  TVTemp[100] = {0};
  int      SPTV=0;

  /* Local iconic variables */
  Hobject  ho_Image;

  /* Local control variables */
  Htuple  hv_WindowHandle, hv_AcqHandle;

  /* Initialize iconic variables */
  gen_empty_obj(&ho_Image);

  /* Initialize control variables */
  create_tuple(&hv_WindowHandle,0);
  create_tuple(&hv_AcqHandle,0);

  /****************************************************/
  /******************   Begin procedure   *************/
  /****************************************************/

  /*Image Acquisition 01: Code generated by Image Acquisition 01*/
  /*dev_open_window (0, 0, 512, 512, 'black', WindowHandle)*/
  create_tuple_s(&TTemp[SP++],"black");
  create_tuple_s(&TTemp[SP++],"background_color");
  T_set_window_attr(TTemp[SP-1],TTemp[SP-2]);
  destroy_tuple(TTemp[--SP]);
  destroy_tuple(TTemp[--SP]);
  create_tuple_i(&TTemp[SP++],0);
  create_tuple_i(&TTemp[SP++],0);
  create_tuple_i(&TTemp[SP++],512);
  create_tuple_i(&TTemp[SP++],512);
  create_tuple_i(&TTemp[SP++],0);
  create_tuple_s(&TTemp[SP++],"visible");
  create_tuple_s(&TTemp[SP++],"");
  destroy_tuple(hv_WindowHandle);
  /***/T_open_window(TTemp[SP-7],TTemp[SP-6],TTemp[SP-5],TTemp[SP-4],TTemp[SP-3],TTemp[SP-2],TTemp[SP-1],&hv_WindowHandle);
  destroy_tuple(TTemp[--SP]);
  destroy_tuple(TTemp[--SP]);
  destroy_tuple(TTemp[--SP]);
  destroy_tuple(TTemp[--SP]);
  destroy_tuple(TTemp[--SP]);
  destroy_tuple(TTemp[--SP]);
  destroy_tuple(TTemp[--SP]);
  hdev_window_stack_push(hv_WindowHandle);

  /*open_framegrabber ('Video4Linux2', 1, 1, 0, 0, 0, 0, 'progressive', 8, 'default', -1, 'false', 'auto', 'video1', 0, -1, AcqHandle)*/
  create_tuple_s(&TTemp[SP++],"Video4Linux2");
  create_tuple_i(&TTemp[SP++],1);
  create_tuple_i(&TTemp[SP++],1);
  create_tuple_i(&TTemp[SP++],0);
  create_tuple_i(&TTemp[SP++],0);
  create_tuple_i(&TTemp[SP++],0);
  create_tuple_i(&TTemp[SP++],0);
  create_tuple_s(&TTemp[SP++],"progressive");
  create_tuple_i(&TTemp[SP++],8);
  create_tuple_s(&TTemp[SP++],"default");
  create_tuple_i(&TTemp[SP++],-1);
  create_tuple_s(&TTemp[SP++],"false");
  create_tuple_s(&TTemp[SP++],"auto");
  create_tuple_s(&TTemp[SP++],"video1");
  create_tuple_i(&TTemp[SP++],0);
  create_tuple_i(&TTemp[SP++],-1);
  destroy_tuple(hv_AcqHandle);
  /***/T_open_framegrabber(TTemp[SP-16], TTemp[SP-15], TTemp[SP-14], TTemp[SP-13], 
      TTemp[SP-12], TTemp[SP-11], TTemp[SP-10], TTemp[SP-9], TTemp[SP-8], TTemp[SP-7], 
      TTemp[SP-6], TTemp[SP-5], TTemp[SP-4], TTemp[SP-3], TTemp[SP-2], TTemp[SP-1], 
      &hv_AcqHandle);
  destroy_tuple(TTemp[--SP]);
  destroy_tuple(TTemp[--SP]);
  destroy_tuple(TTemp[--SP]);
  destroy_tuple(TTemp[--SP]);
  destroy_tuple(TTemp[--SP]);
  destroy_tuple(TTemp[--SP]);
  destroy_tuple(TTemp[--SP]);
  destroy_tuple(TTemp[--SP]);
  destroy_tuple(TTemp[--SP]);
  destroy_tuple(TTemp[--SP]);
  destroy_tuple(TTemp[--SP]);
  destroy_tuple(TTemp[--SP]);
  destroy_tuple(TTemp[--SP]);
  destroy_tuple(TTemp[--SP]);
  destroy_tuple(TTemp[--SP]);
  destroy_tuple(TTemp[--SP]);

  /*grab_image_start (AcqHandle, -1)*/
  create_tuple_i(&TTemp[SP++],-1);
  /***/T_grab_image_start(hv_AcqHandle, TTemp[SP-1]);
  destroy_tuple(TTemp[--SP]);

  /*========== while (true) ==========*/
  for(;;)
  {
  create_tuple_i(&TTemp[SP++],1);
  if(!get_i(TTemp[SP-1],0)) break;
  destroy_tuple(TTemp[--SP]);
    /*grab_image_async (Image, AcqHandle, -1)*/
    create_tuple_i(&TTemp[SP++],-1);
    clear_obj(ho_Image);
    /***/T_grab_image_async(&ho_Image, hv_AcqHandle, TTemp[SP-1]);
    destroy_tuple(TTemp[--SP]);

    if (hdev_window_stack_is_open())
    {
      Htuple active_win;
      create_tuple(&active_win,0);
      hdev_window_stack_get_active(&active_win);
      /*dev_display (Image)*/
      /***/T_disp_obj(ho_Image, active_win);
      destroy_tuple(active_win);
    }
    /*Image Acquisition 01: Do something*/
  }
  destroy_tuple(TTemp[--SP]);
  /*========== end while =====*/
  /*close_framegrabber (AcqHandle)*/
  /***/T_close_framegrabber(hv_AcqHandle);



  /****************************************************/
  /******************     End procedure   *************/
  /****************************************************/

  /* Clear temporary tuple stack */
  while (SP > 0)
    destroy_tuple(TTemp[--SP]);
  /* Clear temporary tuple vectors stack*/
  while (SPTV > 0)
    V_destroy_vector(TVTemp[--SPTV]);
  /* Clear local iconic variables */
  clear_obj(ho_Image);

  /* Clear local control variables */
  destroy_tuple(hv_WindowHandle);
  destroy_tuple(hv_AcqHandle);

}


#ifndef NO_EXPORT_APP_MAIN

int main(int argc, char *argv[])
{
  /* Default settings used in HDevelop */
  int ret=0;
  Htuple Parameter, Value;

#if defined(_WIN32)
  set_system("use_window_thread", "true");
#endif

  /* file was stored with local-8-bit encoding
   *   -> set the interface encoding accordingly */
  SetHcInterfaceStringEncodingIsUtf8(FALSE);

  create_tuple(&Parameter,2);
  create_tuple(&Value,2);
  set_s(Parameter,"width",0);
  set_i(Value,512,0);
  set_s(Parameter,"height",1);
  set_i(Value,512,1);
  T_set_system(Parameter,Value);
  destroy_tuple(Value);
  destroy_tuple(Parameter);

  action();

#if defined(_WIN32)
  /*
   * On Windows socket communication is no longer possible after returning
   * from main, so HALCON cannot return floating licenses automatically.
   */
  set_system("return_license", "true");
#endif

  return ret;
}

#endif


#endif


