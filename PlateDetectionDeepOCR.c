/*****************************************************************************
 * File generated by HDevelop for HALCON/C Version 23.11.0.0
 * Non-ASCII strings in this file are encoded in local-8-bit encoding (utf8).
 * Ensure that the interface encoding is set to locale encoding by calling
 * SetHcInterfaceStringEncodingIsUtf8(FALSE) at the beginning of the program.
 * 
 * Please note that non-ASCII characters in string constants are exported
 * as octal codes in order to guarantee that the strings are correctly
 * created on all systems, independent on any compiler settings.
 * 
 * Source files with different encoding should not be mixed in one project.
 *****************************************************************************/
#include "HalconC.h"
#include "halconc/Hdevthread.h"


/* Procedure declarations */
/* External procedures */
/* Chapter: Image / Channel*/
void add_colormap_to_image (Hobject ho_GrayValueImage, Hobject ho_Image, Hobject *ho_ColoredImage, 
    Htuple hv_HeatmapColorScheme);
/* Chapter: Image / Channel*/
/* Short Description: Create a lookup table and convert a gray scale image. */
void apply_colorscheme_on_gray_value_image (Hobject ho_InputImage, Hobject *ho_ResultImage, 
    Htuple hv_Schema);
/* Chapter: Deep Learning / Model*/
/* Short Description: Compute zoom factors to fit an image to a target size. */
void calculate_dl_image_zoom_factors (Htuple hv_ImageWidth, Htuple hv_ImageHeight, 
    Htuple hv_TargetWidth, Htuple hv_TargetHeight, Htuple hv_DLPreprocessParam, Htuple *hv_ZoomFactorWidth, 
    Htuple *hv_ZoomFactorHeight);
/* Chapter: Deep Learning / Model*/
/* Short Description: Check the content of the parameter dictionary DLPreprocessParam. */
void check_dl_preprocess_param (Htuple hv_DLPreprocessParam);
/* Chapter: Deep Learning / Model*/
/* Short Description: Compute 3D normals. */
void compute_normals_xyz (Hobject ho_x, Hobject ho_y, Hobject ho_z, Hobject *ho_NXImage, 
    Hobject *ho_NYImage, Hobject *ho_NZImage, Htuple hv_Smoothing);
/* Chapter: OCR / Deep OCR*/
/* Short Description: This procedure converts Deep OCR Detection results to an Object Detection results. */
void convert_ocr_detection_result_to_object_detection (Htuple hv_OcrResults, Htuple *hv_DetectionResults);
/* Chapter: Tools / Geometry*/
/* Short Description: Convert the parameters of rectangles with format rectangle2 to the coordinates of its 4 corner-points. */
void convert_rect2_5to8param (Htuple hv_Row, Htuple hv_Col, Htuple hv_Length1, Htuple hv_Length2, 
    Htuple hv_Phi, Htuple *hv_Row1, Htuple *hv_Col1, Htuple *hv_Row2, Htuple *hv_Col2, 
    Htuple *hv_Row3, Htuple *hv_Col3, Htuple *hv_Row4, Htuple *hv_Col4);
/* Chapter: Tools / Geometry*/
/* Short Description: Convert for four-sided figures the coordinates of the 4 corner-points to the parameters of format rectangle2. */
void convert_rect2_8to5param (Htuple hv_Row1, Htuple hv_Col1, Htuple hv_Row2, Htuple hv_Col2, 
    Htuple hv_Row3, Htuple hv_Col3, Htuple hv_Row4, Htuple hv_Col4, Htuple hv_ForceL1LargerL2, 
    Htuple *hv_Row, Htuple *hv_Col, Htuple *hv_Length1, Htuple *hv_Length2, Htuple *hv_Phi);
/* Chapter: Deep Learning / Model*/
/* Short Description: Crops a given image object based on the given domain handling. */
void crop_dl_sample_image (Hobject ho_Domain, Htuple hv_DLSample, Htuple hv_Key, 
    Htuple hv_DLPreprocessParam);
/* Chapter: Graphics / Output*/
/* Short Description: Display a map of the confidences. */
void dev_display_confidence_regions (Hobject ho_ImageConfidence, Htuple hv_DrawTransparency, 
    Htuple *hv_Colors);
/* Chapter: Deep Learning / Model*/
/* Short Description: Visualize different images, annotations and inference results for a sample. */
void dev_display_dl_data (Htuple hv_DLSample, Htuple hv_DLResult, Htuple hv_DLDatasetInfo, 
    Htuple hv_KeysForDisplay, Htuple hv_GenParam, Htuple hv_WindowHandleDict);
/* Chapter: Deep Learning / Model*/
/* Short Description: Try to guess the maximum class id based on the given sample/result. */
void dev_display_dl_data_get_max_class_id (Htuple hv_DLSample, Htuple *hv_MaxClassId, 
    Htuple *hv_Empty);
/* Chapter: Deep Learning / Anomaly Detection and Global Context Anomaly Detection*/
/* Short Description: Display the ground truth anomaly regions of the given DLSample. */
void dev_display_ground_truth_anomaly_regions (Htuple hv_SampleKeys, Htuple hv_DLSample, 
    Htuple hv_CurrentWindowHandle, Htuple hv_LineWidth, Htuple hv_AnomalyRegionLabelColor, 
    Htuple hv_AnomalyColorTransparency, Htuple *hv_AnomalyRegionExists);
/* Chapter: Graphics / Output*/
/* Short Description: Display the ground truth bounding boxes of DLSample. */
void dev_display_ground_truth_detection (Htuple hv_DLSample, Htuple hv_SampleKeys, 
    Htuple hv_LineWidthBbox, Htuple hv_ClassIDs, Htuple hv_BboxColors, Htuple hv_BboxLabelColor, 
    Htuple hv_WindowImageRatio, Htuple hv_TextColor, Htuple hv_ShowLabels, Htuple hv_ShowDirection, 
    Htuple hv_WindowHandle, Htuple *hv_BboxIDs);
/* Chapter: Graphics / Output*/
/* Short Description: Display a color bar next to an image. */
void dev_display_map_color_bar (Htuple hv_ImageWidth, Htuple hv_ImageHeight, Htuple hv_MapColorBarWidth, 
    Htuple hv_Colors, Htuple hv_MaxValue, Htuple hv_WindowImageRatio, Htuple hv_WindowHandle);
/* Chapter: Deep Learning / Anomaly Detection and Global Context Anomaly Detection*/
/* Short Description: Display the detected anomaly regions. */
void dev_display_result_anomaly_regions (Hobject ho_AnomalyRegion, Htuple hv_CurrentWindowHandle, 
    Htuple hv_LineWidth, Htuple hv_AnomalyRegionResultColor);
/* Chapter: Graphics / Output*/
/* Short Description: Display result bounding boxes. */
void dev_display_result_detection (Htuple hv_DLResult, Htuple hv_ResultKeys, Htuple hv_LineWidthBbox, 
    Htuple hv_ClassIDs, Htuple hv_TextConf, Htuple hv_Colors, Htuple hv_BoxLabelColor, 
    Htuple hv_WindowImageRatio, Htuple hv_TextPositionRow, Htuple hv_TextColor, Htuple hv_ShowLabels, 
    Htuple hv_ShowDirection, Htuple hv_WindowHandle, Htuple *hv_BboxClassIndices);
/* Chapter: Graphics / Output*/
/* Short Description: Display the ground truth/result segmentation as regions. */
void dev_display_segmentation_regions (Hobject ho_SegmentationImage, Htuple hv_ClassIDs, 
    Htuple hv_ColorsSegmentation, Htuple hv_ExcludeClassIDs, Htuple *hv_ImageClassIDs);
/* Chapter: Graphics / Output*/
/* Short Description: Display a map of weights. */
void dev_display_weight_regions (Hobject ho_ImageWeight, Htuple hv_DrawTransparency, 
    Htuple hv_SegMaxWeight, Htuple *hv_Colors);
/* Chapter: Develop*/
/* Short Description: Open a new graphics window that preserves the aspect ratio of the given image size. */
void dev_open_window_fit_size (Htuple hv_Row, Htuple hv_Column, Htuple hv_Width, 
    Htuple hv_Height, Htuple hv_WidthLimit, Htuple hv_HeightLimit, Htuple *hv_WindowHandle);
/* Chapter: Deep Learning / Object Detection and Instance Segmentation*/
/* Short Description: Filter the instance segmentation masks of a DL sample based on a given selection. */
void filter_dl_sample_instance_segmentation_masks (Htuple hv_DLSample, Htuple hv_BBoxSelectionMask);
/* Chapter: XLD / Creation*/
/* Short Description: Create an arrow shaped XLD contour. */
void gen_arrow_contour_xld (Hobject *ho_Arrow, Htuple hv_Row1, Htuple hv_Column1, 
    Htuple hv_Row2, Htuple hv_Column2, Htuple hv_HeadLength, Htuple hv_HeadWidth);
/* Chapter: OCR / Deep OCR*/
/* Short Description: Generate ground truth characters if they don't exist and words to characters mapping. */
void gen_dl_ocr_detection_gt_chars (Htuple hv_DLSampleTargets, Htuple hv_DLSample, 
    Htuple hv_ScaleWidth, Htuple hv_ScaleHeight, Hvector/*{eTupleVector,Dim=1}*/ *hvec_WordsCharsMapping);
/* Chapter: OCR / Deep OCR*/
/* Short Description: Generate target link score map for ocr detection training. */
void gen_dl_ocr_detection_gt_link_map (Hobject *ho_GtLinkMap, Htuple hv_ImageWidth, 
    Htuple hv_ImageHeight, Htuple hv_DLSampleTargets, Hvector/*{eTupleVector,Dim=1}*/ hvec_WordToCharVec, 
    Htuple hv_Alpha);
/* Chapter: OCR / Deep OCR*/
/* Short Description: Generate target orientation score maps for ocr detection training. */
void gen_dl_ocr_detection_gt_orientation_map (Hobject *ho_GtOrientationMaps, Htuple hv_ImageWidth, 
    Htuple hv_ImageHeight, Htuple hv_DLSample);
/* Chapter: OCR / Deep OCR*/
/* Short Description: Generate target text score map for ocr detection training. */
void gen_dl_ocr_detection_gt_score_map (Hobject *ho_TargetText, Htuple hv_DLSample, 
    Htuple hv_BoxCutoff, Htuple hv_RenderCutoff, Htuple hv_ImageWidth, Htuple hv_ImageHeight);
/* Chapter: OCR / Deep OCR*/
/* Short Description: Preprocess dl samples and generate targets and weights for ocr detection training. */
void gen_dl_ocr_detection_targets (Htuple hv_DLSampleOriginal, Htuple hv_DLPreprocessParam);
/* Chapter: OCR / Deep OCR*/
/* Short Description: Generate link score map weight for ocr detection training. */
void gen_dl_ocr_detection_weight_link_map (Hobject ho_LinkMap, Hobject ho_TargetWeight, 
    Hobject *ho_TargetWeightLink, Htuple hv_LinkZeroWeightRadius);
/* Chapter: OCR / Deep OCR*/
/* Short Description: Generate orientation score map weight for ocr detection training. */
void gen_dl_ocr_detection_weight_orientation_map (Hobject ho_InitialWeight, Hobject *ho_OrientationTargetWeight, 
    Htuple hv_DLSample);
/* Chapter: OCR / Deep OCR*/
/* Short Description: Generate text score map weight for ocr detection training. */
void gen_dl_ocr_detection_weight_score_map (Hobject *ho_TargetWeightText, Htuple hv_ImageWidth, 
    Htuple hv_ImageHeight, Htuple hv_DLSample, Htuple hv_BoxCutoff, Htuple hv_WSWeightRenderThreshold, 
    Htuple hv_Confidence);
/* Chapter: Deep Learning / Model*/
/* Short Description: Store the given images in a tuple of dictionaries DLSamples. */
void gen_dl_samples_from_images (Hobject ho_Images, Htuple *hv_DLSampleBatch);
/* Chapter: OCR / Deep OCR*/
/* Short Description: Generate a word to characters mapping. */
void gen_words_chars_mapping (Htuple hv_DLSample, Hvector/*{eTupleVector,Dim=1}*/ *hvec_WordsCharsMapping);
/* Chapter: Deep Learning / Anomaly Detection and Global Context Anomaly Detection*/
/* Short Description: Get the ground truth anomaly label and label ID. */
void get_anomaly_ground_truth_label (Htuple hv_SampleKeys, Htuple hv_DLSample, Htuple *hv_AnomalyLabelGroundTruth, 
    Htuple *hv_AnomalyLabelIDGroundTruth);
/* Chapter: Deep Learning / Anomaly Detection and Global Context Anomaly Detection*/
/* Short Description: Get the anomaly results out of DLResult and apply thresholds (if specified). */
void get_anomaly_result (Hobject *ho_AnomalyImage, Hobject *ho_AnomalyRegion, Htuple hv_DLResult, 
    Htuple hv_AnomalyClassThreshold, Htuple hv_AnomalyRegionThreshold, Htuple hv_AnomalyResultPostfix, 
    Htuple *hv_AnomalyScore, Htuple *hv_AnomalyClassID, Htuple *hv_AnomalyClassThresholdDisplay, 
    Htuple *hv_AnomalyRegionThresholdDisplay);
/* Chapter: Graphics / Window*/
/* Short Description: Get the next child window that can be used for visualization. */
void get_child_window (Htuple hv_HeightImage, Htuple hv_Font, Htuple hv_FontSize, 
    Htuple hv_Text, Htuple hv_PrevWindowCoordinates, Htuple hv_WindowHandleDict, 
    Htuple hv_WindowHandleKey, Htuple *hv_WindowImageRatio, Htuple *hv_PrevWindowCoordinatesOut);
/* Chapter: Deep Learning / Classification*/
/* Short Description: Get the ground truth classification label id. */
void get_classification_ground_truth (Htuple hv_SampleKeys, Htuple hv_DLSample, Htuple *hv_ClassificationLabelIDGroundTruth);
/* Chapter: Deep Learning / Classification*/
/* Short Description: Get the predicted classification class ID. */
void get_classification_result (Htuple hv_ResultKeys, Htuple hv_DLResult, Htuple *hv_ClassificationClassID);
/* Chapter: Deep Learning / Semantic Segmentation and Edge Extraction*/
/* Short Description: Get the confidences of the segmentation result. */
void get_confidence_image (Hobject *ho_ImageConfidence, Htuple hv_ResultKeys, Htuple hv_DLResult);
/* Chapter: Deep Learning / Model*/
/* Short Description: Generate NumColors distinct colors */
void get_distinct_colors (Htuple hv_NumColors, Htuple hv_Random, Htuple hv_StartColor, 
    Htuple hv_EndColor, Htuple *hv_Colors);
/* Chapter: Deep Learning / Model*/
/* Short Description: Generate certain colors for different ClassNames */
void get_dl_class_colors (Htuple hv_ClassNames, Htuple hv_AdditionalGreenClassNames, 
    Htuple *hv_Colors);
/* Chapter: Deep Learning / Model*/
/* Short Description: Get an image of a sample with a certain key. */
void get_dl_sample_image (Hobject *ho_Image, Htuple hv_SampleKeys, Htuple hv_DLSample, 
    Htuple hv_Key);
/* Chapter: 3D Matching / 3D Gripping Point Detection*/
/* Short Description: Extract gripping points from a dictionary. */
void get_gripping_points_from_dict (Htuple hv_DLResult, Htuple *hv_Rows, Htuple *hv_Columns);
/* Chapter: Graphics / Window*/
/* Short Description: Get the next window that can be used for visualization. */
void get_next_window (Htuple hv_Font, Htuple hv_FontSize, Htuple hv_ShowBottomDesc, 
    Htuple hv_WidthImage, Htuple hv_HeightImage, Htuple hv_MapColorBarWidth, Htuple hv_ScaleWindows, 
    Htuple hv_ThresholdWidth, Htuple hv_PrevWindowCoordinates, Htuple hv_WindowHandleDict, 
    Htuple hv_WindowHandleKey, Htuple *hv_CurrentWindowHandle, Htuple *hv_WindowImageRatioHeight, 
    Htuple *hv_PrevWindowCoordinatesOut);
/* Chapter: Deep Learning / Semantic Segmentation and Edge Extraction*/
/* Short Description: Get the ground truth segmentation image. */
void get_segmentation_image_ground_truth (Hobject *ho_SegmentationImagGroundTruth, 
    Htuple hv_SampleKeys, Htuple hv_DLSample);
/* Chapter: Deep Learning / Semantic Segmentation and Edge Extraction*/
/* Short Description: Get the predicted segmentation result image. */
void get_segmentation_image_result (Hobject *ho_SegmentationImageResult, Htuple hv_ResultKeys, 
    Htuple hv_DLResult);
/* Chapter: Deep Learning / Semantic Segmentation and Edge Extraction*/
/* Short Description: Get the weight image of a sample. */
void get_weight_image (Hobject *ho_ImageWeight, Htuple hv_SampleKeys, Htuple hv_DLSample);
/* Chapter: Deep Learning / Model*/
/* Short Description: Shuffle the input colors in a deterministic way */
void make_neighboring_colors_distinguishable (Htuple hv_ColorsRainbow, Htuple *hv_Colors);
/* Chapter: Graphics / Window*/
/* Short Description: Open a window next to the given WindowHandleFather.  */
void open_child_window (Htuple hv_WindowHandleFather, Htuple hv_Font, Htuple hv_FontSize, 
    Htuple hv_Text, Htuple hv_PrevWindowCoordinates, Htuple hv_WindowHandleDict, 
    Htuple hv_WindowHandleKey, Htuple *hv_WindowHandleChild, Htuple *hv_PrevWindowCoordinatesOut);
/* Chapter: Graphics / Window*/
/* Short Description: Open a new window, either next to the last ones, or in a new row. */
void open_next_window (Htuple hv_Font, Htuple hv_FontSize, Htuple hv_ShowBottomDesc, 
    Htuple hv_WidthImage, Htuple hv_HeightImage, Htuple hv_MapColorBarWidth, Htuple hv_ScaleWindows, 
    Htuple hv_ThresholdWidth, Htuple hv_PrevWindowCoordinates, Htuple hv_WindowHandleDict, 
    Htuple hv_WindowHandleKey, Htuple *hv_WindowHandleNew, Htuple *hv_WindowImageRatioHeight, 
    Htuple *hv_PrevWindowCoordinatesOut);
/* Chapter: Deep Learning / Model*/
/* Short Description: Preprocess 3D data for deep-learning-based training and inference. */
void preprocess_dl_model_3d_data (Htuple hv_DLSample, Htuple hv_DLPreprocessParam);
/* Chapter: Deep Learning / Model*/
/* Short Description: Preprocess anomaly images for evaluation and visualization of deep-learning-based anomaly detection or Global Context Anomaly Detection. */
void preprocess_dl_model_anomaly (Hobject ho_AnomalyImages, Hobject *ho_AnomalyImagesPreprocessed, 
    Htuple hv_DLPreprocessParam);
/* Chapter: Deep Learning / Model*/
/* Short Description: Preprocess the provided DLSample image for augmentation purposes. */
void preprocess_dl_model_augmentation_data (Htuple hv_DLSample, Htuple hv_DLPreprocessParam);
/* Chapter: Deep Learning / Object Detection and Instance Segmentation*/
/* Short Description: Preprocess the bounding boxes of type 'rectangle1' for a given sample. */
void preprocess_dl_model_bbox_rect1 (Hobject ho_ImageRaw, Htuple hv_DLSample, Htuple hv_DLPreprocessParam);
/* Chapter: Deep Learning / Object Detection and Instance Segmentation*/
/* Short Description: Preprocess the bounding boxes of type 'rectangle2' for a given sample. */
void preprocess_dl_model_bbox_rect2 (Hobject ho_ImageRaw, Htuple hv_DLSample, Htuple hv_DLPreprocessParam);
/* Chapter: Deep Learning / Model*/
/* Short Description: Preprocess images for deep-learning-based training and inference. */
void preprocess_dl_model_images (Hobject ho_Images, Hobject *ho_ImagesPreprocessed, 
    Htuple hv_DLPreprocessParam);
/* Chapter: OCR / Deep OCR*/
/* Short Description: Preprocess images for deep-learning-based training and inference of Deep OCR detection models. */
void preprocess_dl_model_images_ocr_detection (Hobject ho_Images, Hobject *ho_ImagesPreprocessed, 
    Htuple hv_DLPreprocessParam);
/* Chapter: OCR / Deep OCR*/
/* Short Description: Preprocess images for deep-learning-based training and inference of Deep OCR recognition models. */
void preprocess_dl_model_images_ocr_recognition (Hobject ho_Images, Hobject *ho_ImagesPreprocessed, 
    Htuple hv_DLPreprocessParam);
/* Chapter: Deep Learning / Object Detection and Instance Segmentation*/
/* Short Description: Preprocess the instance segmentation masks for a sample given by the dictionary DLSample. */
void preprocess_dl_model_instance_masks (Hobject ho_ImageRaw, Htuple hv_DLSample, 
    Htuple hv_DLPreprocessParam);
/* Chapter: Deep Learning / Semantic Segmentation and Edge Extraction*/
/* Short Description: Preprocess segmentation and weight images for deep-learning-based segmentation training and inference. */
void preprocess_dl_model_segmentations (Hobject ho_ImagesRaw, Hobject ho_Segmentations, 
    Hobject *ho_SegmentationsPreprocessed, Htuple hv_DLPreprocessParam);
/* Chapter: Deep Learning / Model*/
/* Short Description: Preprocess given DLSamples according to the preprocessing parameters given in DLPreprocessParam. */
void preprocess_dl_samples (Htuple hv_DLSampleBatch, Htuple hv_DLPreprocessParam);
/* Chapter: Image / Manipulation*/
/* Short Description: Change value of ValuesToChange in Image to NewValue. */
void reassign_pixel_values (Hobject ho_Image, Hobject *ho_ImageOut, Htuple hv_ValuesToChange, 
    Htuple hv_NewValue);
/* Chapter: Deep Learning / Model*/
/* Short Description: Remove invalid 3D pixels from a given domain. */
void remove_invalid_3d_pixels (Hobject ho_ImageX, Hobject ho_ImageY, Hobject ho_ImageZ, 
    Hobject ho_Domain, Hobject *ho_DomainOut, Htuple hv_InvalidPixelValue);
/* Chapter: Deep Learning / Model*/
/* Short Description: Replace legacy preprocessing parameters or values. */
void replace_legacy_preprocessing_parameters (Htuple hv_DLPreprocessParam);
/* Chapter: Filters / Arithmetic*/
/* Short Description: Scale the gray values of an image from the interval [Min,Max] to [0,255] */
void scale_image_range (Hobject ho_Image, Hobject *ho_ImageScaled, Htuple hv_Min, 
    Htuple hv_Max);
/* Chapter: Graphics / Text*/
/* Short Description: Set font independent of OS */
void set_display_font (Htuple hv_WindowHandle, Htuple hv_Size, Htuple hv_Font, Htuple hv_Bold, 
    Htuple hv_Slant);
/* Chapter: OCR / Deep OCR*/
/* Short Description: Split rectangle2 into a number of rectangles. */
void split_rectangle2 (Htuple hv_Row, Htuple hv_Column, Htuple hv_Phi, Htuple hv_Length1, 
    Htuple hv_Length2, Htuple hv_NumSplits, Htuple *hv_SplitRow, Htuple *hv_SplitColumn, 
    Htuple *hv_SplitPhi, Htuple *hv_SplitLength1Out, Htuple *hv_SplitLength2Out);
/* Chapter: Graphics / Window*/
/* Short Description: Set and return meta information to display images correctly. */
void update_window_meta_information (Htuple hv_WindowHandle, Htuple hv_WidthImage, 
    Htuple hv_HeightImage, Htuple hv_WindowRow1, Htuple hv_WindowColumn1, Htuple hv_MapColorBarWidth, 
    Htuple hv_MarginBottom, Htuple *hv_WindowImageRatioHeight, Htuple *hv_WindowImageRatioWidth, 
    Htuple *hv_SetPartRow2, Htuple *hv_SetPartColumn2, Htuple *hv_PrevWindowCoordinatesOut);

/* Procedures */
/* External procedures */
/* Chapter: Image / Channel*/
void add_colormap_to_image (Hobject ho_GrayValueImage, Hobject ho_Image, Hobject *ho_ColoredImage, 
    Htuple hv_HeatmapColorScheme)
{


  /* Stack for temporary tuples */
  Htuple   TTemp[100];
  int      SP=0;
  /* Stack for temporary objects */
  Hobject  OTemp[20] = {0};
  int      SPO=0;
  /* Stack for temporary tuple vectors */
  Hvector  TVTemp[100] = {0};
  int      SPTV=0;

  /* Local iconic variables */
  Hobject  ho_RGBValueImage, ho_Channels, ho_ChannelsScaled;
  Hobject  ho_Channel, ho_ChannelScaled, ho_ChannelScaledByte;
  Hobject  ho_ImageByte, ho_ImageByteR, ho_ImageByteG, ho_ImageByteB;

  /* Local control variables */
  Htuple  hv_Type, hv_NumChannels, hv_ChannelIndex;
  Htuple  hv_ChannelMin, hv_ChannelMax, hv__;

  /* Local copy input parameter variables */
  Hobject  ho_GrayValueImage_COPY_INP_TMP;


  /* Initialize iconic variables */
  gen_empty_obj(&ho_RGBValueImage);
  gen_empty_obj(&ho_Channels);
  gen_empty_obj(&ho_ChannelsScaled);
  gen_empty_obj(&ho_Channel);
  gen_empty_obj(&ho_ChannelScaled);
  gen_empty_obj(&ho_ChannelScaledByte);
  gen_empty_obj(&ho_ImageByte);
  gen_empty_obj(&ho_ImageByteR);
  gen_empty_obj(&ho_ImageByteG);
  gen_empty_obj(&ho_ImageByteB);
  gen_empty_obj(&(*ho_ColoredImage));
  copy_obj(ho_GrayValueImage,&ho_GrayValueImage_COPY_INP_TMP,1,-1);

  /* Initialize control variables */
  create_tuple(&hv_Type,0);
  create_tuple(&hv_NumChannels,0);
  create_tuple(&hv_ChannelIndex,0);
  create_tuple(&hv_ChannelMin,0);
  create_tuple(&hv_ChannelMax,0);
  create_tuple(&hv__,0);

  /****************************************************/
  /******************   Begin procedure   *************/
  /****************************************************/

  /**/
  /*This procedure adds a gray-value image to a RGB image with a chosen color map.*/
  /**/
  /*get_image_type (GrayValueImage, Type)*/
  destroy_tuple(hv_Type);
  /***/T_get_image_type(ho_GrayValueImage_COPY_INP_TMP, &hv_Type);

  /*The image LUT needs a byte image. Rescale real images.*/
  /*========== if (Type == 'real') ==========*/
  create_tuple_s(&TTemp[SP++],"real");
  T_tuple_equal(hv_Type,TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-1]=TTemp[SP];
  if(get_i(TTemp[SP-1],0))
  {
    /*scale_image_range (GrayValueImage, GrayValueImage, 0, 1)*/
    create_tuple_i(&TTemp[SP++],0);
    create_tuple_i(&TTemp[SP++],1);
    /***/scale_image_range(ho_GrayValueImage_COPY_INP_TMP, &(OTemp[SPO]), TTemp[SP-2], 
        TTemp[SP-1]);
    SPO++;
    clear_obj(ho_GrayValueImage_COPY_INP_TMP);
    ho_GrayValueImage_COPY_INP_TMP = OTemp[--SPO];
    destroy_tuple(TTemp[--SP]);
    destroy_tuple(TTemp[--SP]);

    /*convert_image_type (GrayValueImage, GrayValueImage, 'byte')*/
    /***/convert_image_type(ho_GrayValueImage_COPY_INP_TMP, &(OTemp[SPO]), "byte");
    SPO++;
    clear_obj(ho_GrayValueImage_COPY_INP_TMP);
    ho_GrayValueImage_COPY_INP_TMP = OTemp[--SPO];

  }
  else
  {
  destroy_tuple(TTemp[--SP]);
  /*========== elseif (Type != 'byte') ==========*/

  create_tuple_s(&TTemp[SP++],"byte");
  T_tuple_not_equal(hv_Type,TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-1]=TTemp[SP];
  if(get_i(TTemp[SP-1],0))
  {
    /* throw(...); only in hdevelop*/
  }
  }
  destroy_tuple(TTemp[--SP]);
  /*========== end if ==========*/
  /**/
  /*Apply the chosen color scheme on the gray value.*/
  /*apply_colorscheme_on_gray_value_image (GrayValueImage, RGBValueImage, HeatmapColorScheme)*/
  clear_obj(ho_RGBValueImage);
  /***/apply_colorscheme_on_gray_value_image(ho_GrayValueImage_COPY_INP_TMP, &ho_RGBValueImage, 
      hv_HeatmapColorScheme);

  /**/
  /*Convert input image to byte image for visualization.*/
  /*image_to_channels (Image, Channels)*/
  clear_obj(ho_Channels);
  /***/image_to_channels(ho_Image, &ho_Channels);

  /*count_channels (Image, NumChannels)*/
  destroy_tuple(hv_NumChannels);
  /***/T_count_channels(ho_Image, &hv_NumChannels);

  /*gen_empty_obj (ChannelsScaled)*/
  clear_obj(ho_ChannelsScaled);
  /***/gen_empty_obj(&ho_ChannelsScaled);

  /*========== for ChannelIndex := 1 to NumChannels by 1 ==========*/
  copy_tuple(hv_NumChannels,&TTemp[SP++]);
  create_tuple_i(&TTemp[SP++],1);
  create_tuple_i(&TTemp[SP++],1);
  T_tuple_greater(TTemp[SP-1],TTemp[SP-3],&TTemp[SP]);
  SP++;
  T_tuple_equal(TTemp[SP-2],TTemp[SP-4],&TTemp[SP]);
  if(get_i(TTemp[SP],0) ||
     (!((( get_i(TTemp[SP-1],0)) && (get_d(TTemp[SP-3],0)>0)) ||
        ((!get_i(TTemp[SP-1],0)) && (get_d(TTemp[SP-3],0)<0)))))
  {
   destroy_tuple(TTemp[SP--]);
   destroy_tuple(TTemp[SP]);
   T_tuple_sub(TTemp[SP-1],TTemp[SP-2],&TTemp[SP]);
   destroy_tuple(hv_ChannelIndex);
   copy_tuple(TTemp[SP],&hv_ChannelIndex);
   destroy_tuple(TTemp[SP--]);
   destroy_tuple(TTemp[SP]);
   for(;;)
   {
   T_tuple_add(hv_ChannelIndex,TTemp[SP-1],&TTemp[SP]);
   destroy_tuple(hv_ChannelIndex);
   copy_tuple(TTemp[SP],&hv_ChannelIndex);
   destroy_tuple(TTemp[SP]);
   if(get_d(TTemp[SP-1],0)<0)
    T_tuple_less(hv_ChannelIndex,TTemp[SP-2],&TTemp[SP]);
   else
    T_tuple_greater(hv_ChannelIndex,TTemp[SP-2],&TTemp[SP]);
   if(get_i(TTemp[SP],0)) break;
   destroy_tuple(TTemp[SP]);
   /*========== for ==========*/

    /*select_obj (Channels, Channel, ChannelIndex)*/
    clear_obj(ho_Channel);
    /***/T_select_obj(ho_Channels, &ho_Channel, hv_ChannelIndex);

    /*min_max_gray (Channel, Channel, 0, ChannelMin, ChannelMax, _)*/
    create_tuple_i(&TTemp[SP++],0);
    destroy_tuple(hv_ChannelMin);
    destroy_tuple(hv_ChannelMax);
    destroy_tuple(hv__);
    /***/T_min_max_gray(ho_Channel, ho_Channel, TTemp[SP-1], &hv_ChannelMin, &hv_ChannelMax, 
        &hv__);
    destroy_tuple(TTemp[--SP]);

    /*scale_image_range (Channel, ChannelScaled, ChannelMin, ChannelMax)*/
    clear_obj(ho_ChannelScaled);
    /***/scale_image_range(ho_Channel, &ho_ChannelScaled, hv_ChannelMin, hv_ChannelMax);

    /*convert_image_type (ChannelScaled, ChannelScaledByte, 'byte')*/
    clear_obj(ho_ChannelScaledByte);
    /***/convert_image_type(ho_ChannelScaled, &ho_ChannelScaledByte, "byte");

    /*concat_obj (ChannelsScaled, ChannelScaledByte, ChannelsScaled)*/
    /***/concat_obj(ho_ChannelsScaled, ho_ChannelScaledByte, &(OTemp[SPO]));
    SPO++;
    clear_obj(ho_ChannelsScaled);
    ho_ChannelsScaled = OTemp[--SPO];

   }
   destroy_tuple(TTemp[SP--]);
   destroy_tuple(TTemp[SP--]);
   destroy_tuple(TTemp[SP]);
  }
  else
  {
   destroy_tuple(TTemp[SP--]);
   destroy_tuple(TTemp[SP--]);
   destroy_tuple(TTemp[SP--]);
   destroy_tuple(TTemp[SP--]);
   destroy_tuple(TTemp[SP]);
  }/*========== end for ========*/

  /*channels_to_image (ChannelsScaled, ImageByte)*/
  clear_obj(ho_ImageByte);
  /***/channels_to_image(ho_ChannelsScaled, &ho_ImageByte);

  /**/
  /*Note that ImageByte needs to have the same number of channels as*/
  /*RGBValueImage to display color map image correctly.*/
  /*count_channels (ImageByte, NumChannels)*/
  destroy_tuple(hv_NumChannels);
  /***/T_count_channels(ho_ImageByte, &hv_NumChannels);

  /*========== if (NumChannels != 3) ==========*/
  create_tuple_i(&TTemp[SP++],3);
  T_tuple_not_equal(hv_NumChannels,TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-1]=TTemp[SP];
  if(get_i(TTemp[SP-1],0))
  {
    /*Just take the first channel and use this to generate*/
    /*an image with 3 channels for visualization.*/
    /*access_channel (ImageByte, ImageByteR, 1)*/
    clear_obj(ho_ImageByteR);
    /***/access_channel(ho_ImageByte, &ho_ImageByteR, 1);

    /*copy_image (ImageByteR, ImageByteG)*/
    clear_obj(ho_ImageByteG);
    /***/copy_image(ho_ImageByteR, &ho_ImageByteG);

    /*copy_image (ImageByteR, ImageByteB)*/
    clear_obj(ho_ImageByteB);
    /***/copy_image(ho_ImageByteR, &ho_ImageByteB);

    /*compose3 (ImageByteR, ImageByteG, ImageByteB, ImageByte)*/
    clear_obj(ho_ImageByte);
    /***/compose3(ho_ImageByteR, ho_ImageByteG, ho_ImageByteB, &ho_ImageByte);

  }
  destroy_tuple(TTemp[--SP]);
  /*========== end if ==========*/
  /**/
  /*add_image (ImageByte, RGBValueImage, RGBValueImage, 0.5, 0)*/
  /***/add_image(ho_ImageByte, ho_RGBValueImage, &(OTemp[SPO]), 0.5, 0);
  SPO++;
  clear_obj(ho_RGBValueImage);
  ho_RGBValueImage = OTemp[--SPO];

  /*ColoredImage := RGBValueImage*/
  clear_obj((*ho_ColoredImage));
  copy_obj(ho_RGBValueImage,&(*ho_ColoredImage),1,-1);

  /**/
  /*========== return ==========*/

  /* Clear temporary tuple stack */
  while (SP > 0)
    destroy_tuple(TTemp[--SP]);
  /* Clear temporary tuple vectors stack*/
  while (SPTV > 0)
    V_destroy_vector(TVTemp[--SPTV]);
  /* Clear local iconic variables */
  clear_obj(ho_RGBValueImage);
  clear_obj(ho_Channels);
  clear_obj(ho_ChannelsScaled);
  clear_obj(ho_Channel);
  clear_obj(ho_ChannelScaled);
  clear_obj(ho_ChannelScaledByte);
  clear_obj(ho_ImageByte);
  clear_obj(ho_ImageByteR);
  clear_obj(ho_ImageByteG);
  clear_obj(ho_ImageByteB);
  clear_obj(ho_GrayValueImage_COPY_INP_TMP);

  /* Clear local control variables */
  destroy_tuple(hv_Type);
  destroy_tuple(hv_NumChannels);
  destroy_tuple(hv_ChannelIndex);
  destroy_tuple(hv_ChannelMin);
  destroy_tuple(hv_ChannelMax);
  destroy_tuple(hv__);

  return;

  /****************************************************/
  /******************     End procedure   *************/
  /****************************************************/

}

/* Chapter: Image / Channel*/
/* Short Description: Create a lookup table and convert a gray scale image. */
void apply_colorscheme_on_gray_value_image (Hobject ho_InputImage, Hobject *ho_ResultImage, 
    Htuple hv_Schema)
{


  /* Stack for temporary tuples */
  Htuple   TTemp[100];
  int      SP=0;
  /* Stack for temporary tuple vectors */
  Hvector  TVTemp[100] = {0};
  int      SPTV=0;

  /* Local iconic variables */
  Hobject  ho_ImageR, ho_ImageG, ho_ImageB;

  /* Local control variables */
  Htuple  hv_X, hv_Low, hv_High, hv_OffR, hv_OffG;
  Htuple  hv_OffB, hv_A1, hv_A0, hv_R, hv_G, hv_B, hv_A0R;
  Htuple  hv_A0G, hv_A0B;

  /* Initialize iconic variables */
  gen_empty_obj(&ho_ImageR);
  gen_empty_obj(&ho_ImageG);
  gen_empty_obj(&ho_ImageB);
  gen_empty_obj(&(*ho_ResultImage));

  /* Initialize control variables */
  create_tuple(&hv_X,0);
  create_tuple(&hv_Low,0);
  create_tuple(&hv_High,0);
  create_tuple(&hv_OffR,0);
  create_tuple(&hv_OffG,0);
  create_tuple(&hv_OffB,0);
  create_tuple(&hv_A1,0);
  create_tuple(&hv_A0,0);
  create_tuple(&hv_R,0);
  create_tuple(&hv_G,0);
  create_tuple(&hv_B,0);
  create_tuple(&hv_A0R,0);
  create_tuple(&hv_A0G,0);
  create_tuple(&hv_A0B,0);

  /****************************************************/
  /******************   Begin procedure   *************/
  /****************************************************/

  /**/
  /*This procedure generates an RGB ResultImage for a gray-value InputImage.*/
  /*In order to do so, create a color distribution as look up table*/
  /*according to the Schema.*/
  /**/
  /*X := [0:255]*/
  create_tuple_i(&TTemp[SP++],0);
  create_tuple_i(&TTemp[SP++],255);
  create_tuple_i(&TTemp[SP++],1);
  T_tuple_gen_sequence(TTemp[SP-3],TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-1]);
  destroy_tuple(TTemp[SP-2]);
  destroy_tuple(TTemp[SP-3]);
  TTemp[SP-3]=TTemp[SP];
  SP=SP-2;
  destroy_tuple(hv_X);
  hv_X=TTemp[--SP];

  /*tuple_gen_const (256, 0, Low)*/
  create_tuple_i(&TTemp[SP++],256);
  create_tuple_i(&TTemp[SP++],0);
  destroy_tuple(hv_Low);
  /***/T_tuple_gen_const(TTemp[SP-2], TTemp[SP-1], &hv_Low);
  destroy_tuple(TTemp[--SP]);
  destroy_tuple(TTemp[--SP]);

  /*tuple_gen_const (256, 255, High)*/
  create_tuple_i(&TTemp[SP++],256);
  create_tuple_i(&TTemp[SP++],255);
  destroy_tuple(hv_High);
  /***/T_tuple_gen_const(TTemp[SP-2], TTemp[SP-1], &hv_High);
  destroy_tuple(TTemp[--SP]);
  destroy_tuple(TTemp[--SP]);

  /**/
  /*========== if (Schema == 'jet') ==========*/
  create_tuple_s(&TTemp[SP++],"jet");
  T_tuple_equal(hv_Schema,TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-1]=TTemp[SP];
  if(get_i(TTemp[SP-1],0))
  {
    /*Scheme Jet: from blue to red*/
    /*OffR := 3.0 * 64.0*/
    create_tuple_d(&TTemp[SP++],3.0);
    create_tuple_d(&TTemp[SP++],64.0);
    T_tuple_mult(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-2]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-2]=TTemp[SP];
    SP--;
    destroy_tuple(hv_OffR);
    hv_OffR=TTemp[--SP];

    /*OffG := 2.0 * 64.0*/
    create_tuple_d(&TTemp[SP++],2.0);
    create_tuple_d(&TTemp[SP++],64.0);
    T_tuple_mult(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-2]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-2]=TTemp[SP];
    SP--;
    destroy_tuple(hv_OffG);
    hv_OffG=TTemp[--SP];

    /*OffB := 64.0*/
    reuse_tuple_d(&hv_OffB,64.0);

    /*A1 := -4.0*/
    reuse_tuple_d(&hv_A1,-4.0);

    /*A0 := 255.0 + 128.0*/
    create_tuple_d(&TTemp[SP++],255.0);
    create_tuple_d(&TTemp[SP++],128.0);
    T_tuple_add(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-2]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-2]=TTemp[SP];
    SP--;
    destroy_tuple(hv_A0);
    hv_A0=TTemp[--SP];

    /*R := min2(max2(abs(X - OffR) * A1 + A0,Low),High)*/
    T_tuple_sub(hv_X,hv_OffR,&TTemp[SP++]);
    T_tuple_abs(TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    T_tuple_mult(TTemp[SP-1],hv_A1,&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    T_tuple_add(TTemp[SP-1],hv_A0,&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    T_tuple_max2(TTemp[SP-1],hv_Low,&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    T_tuple_min2(TTemp[SP-1],hv_High,&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    destroy_tuple(hv_R);
    hv_R=TTemp[--SP];

    /*G := min2(max2(abs(X - OffG) * A1 + A0,Low),High)*/
    T_tuple_sub(hv_X,hv_OffG,&TTemp[SP++]);
    T_tuple_abs(TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    T_tuple_mult(TTemp[SP-1],hv_A1,&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    T_tuple_add(TTemp[SP-1],hv_A0,&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    T_tuple_max2(TTemp[SP-1],hv_Low,&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    T_tuple_min2(TTemp[SP-1],hv_High,&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    destroy_tuple(hv_G);
    hv_G=TTemp[--SP];

    /*B := min2(max2(abs(X - OffB) * A1 + A0,Low),High)*/
    T_tuple_sub(hv_X,hv_OffB,&TTemp[SP++]);
    T_tuple_abs(TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    T_tuple_mult(TTemp[SP-1],hv_A1,&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    T_tuple_add(TTemp[SP-1],hv_A0,&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    T_tuple_max2(TTemp[SP-1],hv_Low,&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    T_tuple_min2(TTemp[SP-1],hv_High,&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    destroy_tuple(hv_B);
    hv_B=TTemp[--SP];

    /**/
  }
  else
  {
  destroy_tuple(TTemp[--SP]);
  /*========== elseif (Schema == 'inverse_jet') ==========*/

  create_tuple_s(&TTemp[SP++],"inverse_jet");
  T_tuple_equal(hv_Schema,TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-1]=TTemp[SP];
  if(get_i(TTemp[SP-1],0))
  {
    /*Scheme InvJet: from red to blue.*/
    /*OffR := 64*/
    reuse_tuple_i(&hv_OffR,64);

    /*OffG := 2 * 64*/
    create_tuple_i(&TTemp[SP++],2);
    create_tuple_i(&TTemp[SP++],64);
    T_tuple_mult(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-2]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-2]=TTemp[SP];
    SP--;
    destroy_tuple(hv_OffG);
    hv_OffG=TTemp[--SP];

    /*OffB := 3 * 64*/
    create_tuple_i(&TTemp[SP++],3);
    create_tuple_i(&TTemp[SP++],64);
    T_tuple_mult(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-2]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-2]=TTemp[SP];
    SP--;
    destroy_tuple(hv_OffB);
    hv_OffB=TTemp[--SP];

    /*A1 := -4.0*/
    reuse_tuple_d(&hv_A1,-4.0);

    /*A0 := 255.0 + 128.0*/
    create_tuple_d(&TTemp[SP++],255.0);
    create_tuple_d(&TTemp[SP++],128.0);
    T_tuple_add(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-2]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-2]=TTemp[SP];
    SP--;
    destroy_tuple(hv_A0);
    hv_A0=TTemp[--SP];

    /*R := min2(max2(abs(X - OffR) * A1 + A0,Low),High)*/
    T_tuple_sub(hv_X,hv_OffR,&TTemp[SP++]);
    T_tuple_abs(TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    T_tuple_mult(TTemp[SP-1],hv_A1,&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    T_tuple_add(TTemp[SP-1],hv_A0,&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    T_tuple_max2(TTemp[SP-1],hv_Low,&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    T_tuple_min2(TTemp[SP-1],hv_High,&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    destroy_tuple(hv_R);
    hv_R=TTemp[--SP];

    /*G := min2(max2(abs(X - OffG) * A1 + A0,Low),High)*/
    T_tuple_sub(hv_X,hv_OffG,&TTemp[SP++]);
    T_tuple_abs(TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    T_tuple_mult(TTemp[SP-1],hv_A1,&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    T_tuple_add(TTemp[SP-1],hv_A0,&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    T_tuple_max2(TTemp[SP-1],hv_Low,&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    T_tuple_min2(TTemp[SP-1],hv_High,&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    destroy_tuple(hv_G);
    hv_G=TTemp[--SP];

    /*B := min2(max2(abs(X - OffB) * A1 + A0,Low),High)*/
    T_tuple_sub(hv_X,hv_OffB,&TTemp[SP++]);
    T_tuple_abs(TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    T_tuple_mult(TTemp[SP-1],hv_A1,&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    T_tuple_add(TTemp[SP-1],hv_A0,&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    T_tuple_max2(TTemp[SP-1],hv_Low,&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    T_tuple_min2(TTemp[SP-1],hv_High,&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    destroy_tuple(hv_B);
    hv_B=TTemp[--SP];

    /**/
  }
  else
  {
  destroy_tuple(TTemp[--SP]);
  /*========== elseif (Schema == 'hot') ==========*/

  create_tuple_s(&TTemp[SP++],"hot");
  T_tuple_equal(hv_Schema,TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-1]=TTemp[SP];
  if(get_i(TTemp[SP-1],0))
  {
    /*Scheme Hot.*/
    /*A1 := 3.0*/
    reuse_tuple_d(&hv_A1,3.0);

    /*A0R := 0.0*/
    reuse_tuple_d(&hv_A0R,0.0);

    /*A0G := 1.0 / 3.0 * A1 * 255.0*/
    create_tuple_d(&TTemp[SP++],1.0);
    create_tuple_d(&TTemp[SP++],3.0);
    T_tuple_div(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-2]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-2]=TTemp[SP];
    SP--;
    T_tuple_mult(TTemp[SP-1],hv_A1,&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    create_tuple_d(&TTemp[SP++],255.0);
    T_tuple_mult(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-2]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-2]=TTemp[SP];
    SP--;
    destroy_tuple(hv_A0G);
    hv_A0G=TTemp[--SP];

    /*A0B := 2.0 / 3.0 * A1 * 255.0*/
    create_tuple_d(&TTemp[SP++],2.0);
    create_tuple_d(&TTemp[SP++],3.0);
    T_tuple_div(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-2]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-2]=TTemp[SP];
    SP--;
    T_tuple_mult(TTemp[SP-1],hv_A1,&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    create_tuple_d(&TTemp[SP++],255.0);
    T_tuple_mult(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-2]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-2]=TTemp[SP];
    SP--;
    destroy_tuple(hv_A0B);
    hv_A0B=TTemp[--SP];

    /*R := min2(max2(X * A1 - A0R,Low),High)*/
    T_tuple_mult(hv_X,hv_A1,&TTemp[SP++]);
    T_tuple_sub(TTemp[SP-1],hv_A0R,&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    T_tuple_max2(TTemp[SP-1],hv_Low,&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    T_tuple_min2(TTemp[SP-1],hv_High,&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    destroy_tuple(hv_R);
    hv_R=TTemp[--SP];

    /*G := min2(max2(X * A1 - A0G,Low),High)*/
    T_tuple_mult(hv_X,hv_A1,&TTemp[SP++]);
    T_tuple_sub(TTemp[SP-1],hv_A0G,&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    T_tuple_max2(TTemp[SP-1],hv_Low,&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    T_tuple_min2(TTemp[SP-1],hv_High,&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    destroy_tuple(hv_G);
    hv_G=TTemp[--SP];

    /*B := min2(max2(X * A1 - A0B,Low),High)*/
    T_tuple_mult(hv_X,hv_A1,&TTemp[SP++]);
    T_tuple_sub(TTemp[SP-1],hv_A0B,&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    T_tuple_max2(TTemp[SP-1],hv_Low,&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    T_tuple_min2(TTemp[SP-1],hv_High,&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    destroy_tuple(hv_B);
    hv_B=TTemp[--SP];

    /**/
  }
  else
  {
  destroy_tuple(TTemp[--SP]);
  /*========== elseif (Schema == 'inverse_hot') ==========*/

  create_tuple_s(&TTemp[SP++],"inverse_hot");
  T_tuple_equal(hv_Schema,TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-1]=TTemp[SP];
  if(get_i(TTemp[SP-1],0))
  {
    /*Scheme Inverse Hot.*/
    /*A1 := -3.0*/
    reuse_tuple_d(&hv_A1,-3.0);

    /*A0R := A1 * 255.0*/
    create_tuple_d(&TTemp[SP++],255.0);
    T_tuple_mult(hv_A1,TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    destroy_tuple(hv_A0R);
    hv_A0R=TTemp[--SP];

    /*A0G := 2.0 / 3.0 * A1 * 255.0*/
    create_tuple_d(&TTemp[SP++],2.0);
    create_tuple_d(&TTemp[SP++],3.0);
    T_tuple_div(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-2]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-2]=TTemp[SP];
    SP--;
    T_tuple_mult(TTemp[SP-1],hv_A1,&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    create_tuple_d(&TTemp[SP++],255.0);
    T_tuple_mult(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-2]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-2]=TTemp[SP];
    SP--;
    destroy_tuple(hv_A0G);
    hv_A0G=TTemp[--SP];

    /*A0B := 1.0 / 3.0 * A1 * 255.0*/
    create_tuple_d(&TTemp[SP++],1.0);
    create_tuple_d(&TTemp[SP++],3.0);
    T_tuple_div(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-2]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-2]=TTemp[SP];
    SP--;
    T_tuple_mult(TTemp[SP-1],hv_A1,&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    create_tuple_d(&TTemp[SP++],255.0);
    T_tuple_mult(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-2]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-2]=TTemp[SP];
    SP--;
    destroy_tuple(hv_A0B);
    hv_A0B=TTemp[--SP];

    /*R := min2(max2(X * A1 - A0R,Low),High)*/
    T_tuple_mult(hv_X,hv_A1,&TTemp[SP++]);
    T_tuple_sub(TTemp[SP-1],hv_A0R,&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    T_tuple_max2(TTemp[SP-1],hv_Low,&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    T_tuple_min2(TTemp[SP-1],hv_High,&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    destroy_tuple(hv_R);
    hv_R=TTemp[--SP];

    /*G := min2(max2(X * A1 - A0G,Low),High)*/
    T_tuple_mult(hv_X,hv_A1,&TTemp[SP++]);
    T_tuple_sub(TTemp[SP-1],hv_A0G,&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    T_tuple_max2(TTemp[SP-1],hv_Low,&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    T_tuple_min2(TTemp[SP-1],hv_High,&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    destroy_tuple(hv_G);
    hv_G=TTemp[--SP];

    /*B := min2(max2(X * A1 - A0B,Low),High)*/
    T_tuple_mult(hv_X,hv_A1,&TTemp[SP++]);
    T_tuple_sub(TTemp[SP-1],hv_A0B,&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    T_tuple_max2(TTemp[SP-1],hv_Low,&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    T_tuple_min2(TTemp[SP-1],hv_High,&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    destroy_tuple(hv_B);
    hv_B=TTemp[--SP];

    /**/
  }
  else
  {
    /**/
    /* throw(...); only in hdevelop*/
    /**/
  }
  }
  }
  }
  destroy_tuple(TTemp[--SP]);
  /*========== end if ==========*/
  /**/
  /*lut_trans (InputImage, ImageR, R)*/
  clear_obj(ho_ImageR);
  /***/T_lut_trans(ho_InputImage, &ho_ImageR, hv_R);

  /*lut_trans (InputImage, ImageG, G)*/
  clear_obj(ho_ImageG);
  /***/T_lut_trans(ho_InputImage, &ho_ImageG, hv_G);

  /*lut_trans (InputImage, ImageB, B)*/
  clear_obj(ho_ImageB);
  /***/T_lut_trans(ho_InputImage, &ho_ImageB, hv_B);

  /*compose3 (ImageR, ImageG, ImageB, ResultImage)*/
  clear_obj((*ho_ResultImage));
  /***/compose3(ho_ImageR, ho_ImageG, ho_ImageB, &(*ho_ResultImage));

  /**/
  /*========== return ==========*/

  /* Clear temporary tuple stack */
  while (SP > 0)
    destroy_tuple(TTemp[--SP]);
  /* Clear temporary tuple vectors stack*/
  while (SPTV > 0)
    V_destroy_vector(TVTemp[--SPTV]);
  /* Clear local iconic variables */
  clear_obj(ho_ImageR);
  clear_obj(ho_ImageG);
  clear_obj(ho_ImageB);

  /* Clear local control variables */
  destroy_tuple(hv_X);
  destroy_tuple(hv_Low);
  destroy_tuple(hv_High);
  destroy_tuple(hv_OffR);
  destroy_tuple(hv_OffG);
  destroy_tuple(hv_OffB);
  destroy_tuple(hv_A1);
  destroy_tuple(hv_A0);
  destroy_tuple(hv_R);
  destroy_tuple(hv_G);
  destroy_tuple(hv_B);
  destroy_tuple(hv_A0R);
  destroy_tuple(hv_A0G);
  destroy_tuple(hv_A0B);

  return;

  /****************************************************/
  /******************     End procedure   *************/
  /****************************************************/

}

/* Chapter: Deep Learning / Model*/
/* Short Description: Compute zoom factors to fit an image to a target size. */
void calculate_dl_image_zoom_factors (Htuple hv_ImageWidth, Htuple hv_ImageHeight, 
    Htuple hv_TargetWidth, Htuple hv_TargetHeight, Htuple hv_DLPreprocessParam, Htuple *hv_ZoomFactorWidth, 
    Htuple *hv_ZoomFactorHeight)
{

  /* Stack for temporary tuples */
  Htuple   TTemp[100];
  int      SP=0;
  /* Stack for temporary tuple vectors */
  Hvector  TVTemp[100] = {0};
  int      SPTV=0;

  /* Local iconic variables */

  /* Local control variables */
  Htuple  hv_ScaleWidthUnit, hv_ScaleHeightUnit;
  Htuple  hv_PreserveAspectRatio, hv_Scale, hv___Tmp_Ctrl_Dict_Init_0;

  /* Initialize control variables */
  create_tuple(&hv_ScaleWidthUnit,0);
  create_tuple(&hv_ScaleHeightUnit,0);
  create_tuple(&hv_PreserveAspectRatio,0);
  create_tuple(&hv_Scale,0);
  create_tuple(&hv___Tmp_Ctrl_Dict_Init_0,0);
  create_tuple(&(*hv_ZoomFactorWidth),0);
  create_tuple(&(*hv_ZoomFactorHeight),0);

  /****************************************************/
  /******************   Begin procedure   *************/
  /****************************************************/

  /*Calculate the unit zoom factors, which zoom the input image to 1px.*/
  /*ScaleWidthUnit := 1.0 / real(ImageWidth)*/
  create_tuple_d(&TTemp[SP++],1.0);
  T_tuple_real(hv_ImageWidth,&TTemp[SP++]);
  T_tuple_div(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-2]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-2]=TTemp[SP];
  SP--;
  destroy_tuple(hv_ScaleWidthUnit);
  hv_ScaleWidthUnit=TTemp[--SP];

  /*ScaleHeightUnit := 1.0 / real(ImageHeight)*/
  create_tuple_d(&TTemp[SP++],1.0);
  T_tuple_real(hv_ImageHeight,&TTemp[SP++]);
  T_tuple_div(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-2]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-2]=TTemp[SP];
  SP--;
  destroy_tuple(hv_ScaleHeightUnit);
  hv_ScaleHeightUnit=TTemp[--SP];

  /**/
  /*Calculate the required zoom factors for the available target size.*/
  /*ZoomFactorWidth := TargetWidth * ScaleWidthUnit*/
  T_tuple_mult(hv_TargetWidth,hv_ScaleWidthUnit,&TTemp[SP++]);
  destroy_tuple((*hv_ZoomFactorWidth));
  (*hv_ZoomFactorWidth)=TTemp[--SP];

  /*ZoomFactorHeight := TargetHeight * ScaleHeightUnit*/
  T_tuple_mult(hv_TargetHeight,hv_ScaleHeightUnit,&TTemp[SP++]);
  destroy_tuple((*hv_ZoomFactorHeight));
  (*hv_ZoomFactorHeight)=TTemp[--SP];

  /**/
  /*Aspect-ratio preserving zoom is supported for model type 'ocr_detection' only.*/
  /*create_dict (__Tmp_Ctrl_Dict_Init_0)*/
  destroy_tuple(hv___Tmp_Ctrl_Dict_Init_0);
  /***/T_create_dict(&hv___Tmp_Ctrl_Dict_Init_0);

  /*set_dict_tuple (__Tmp_Ctrl_Dict_Init_0, ['comp'], 'ocr_detection')*/
  create_tuple_s(&TTemp[SP++],"comp");
  create_tuple_s(&TTemp[SP++],"ocr_detection");
  /***/T_set_dict_tuple(hv___Tmp_Ctrl_Dict_Init_0, TTemp[SP-2], TTemp[SP-1]);
  destroy_tuple(TTemp[--SP]);
  destroy_tuple(TTemp[--SP]);

  /*PreserveAspectRatio := __test_equal_dict_item([DLPreprocessParam, __Tmp_Ctrl_Dict_Init_0], ['model_type'], 'comp')*/
  T_tuple_concat(hv_DLPreprocessParam,hv___Tmp_Ctrl_Dict_Init_0,&TTemp[SP++]);
  create_tuple_s(&TTemp[SP++],"model_type");
  create_tuple_s(&TTemp[SP++],"comp");
  T_test_equal_dict_item(TTemp[SP-3],TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-3]);
  destroy_tuple(TTemp[SP-2]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-3]=TTemp[SP];
  SP=SP-2;
  destroy_tuple(hv_PreserveAspectRatio);
  hv_PreserveAspectRatio=TTemp[--SP];

  /*__Tmp_Ctrl_Dict_Init_0 := constant('HNULL')*/
  create_tuple_s(&TTemp[SP++],"HNULL");
  T_tuple_constant(TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-1]=TTemp[SP];
  destroy_tuple(hv___Tmp_Ctrl_Dict_Init_0);
  hv___Tmp_Ctrl_Dict_Init_0=TTemp[--SP];

  /**/
  /*========== if (PreserveAspectRatio) ==========*/
  copy_tuple(hv_PreserveAspectRatio,&TTemp[SP++]);
  if(get_i(TTemp[SP-1],0))
  {
    /**/
    /*Use smaller scaling factor, which results in unfilled domain*/
    /*on the respective other axis.*/
    /*Scale := min2(ZoomFactorWidth,ZoomFactorHeight)*/
    T_tuple_min2((*hv_ZoomFactorWidth),(*hv_ZoomFactorHeight),&TTemp[SP++]);
    destroy_tuple(hv_Scale);
    hv_Scale=TTemp[--SP];

    /*Ensure that the zoom factors result in lengths of at least 1px.*/
    /*ZoomFactorWidth := max2(Scale,ScaleWidthUnit)*/
    T_tuple_max2(hv_Scale,hv_ScaleWidthUnit,&TTemp[SP++]);
    destroy_tuple((*hv_ZoomFactorWidth));
    (*hv_ZoomFactorWidth)=TTemp[--SP];

    /*ZoomFactorHeight := max2(Scale,ScaleHeightUnit)*/
    T_tuple_max2(hv_Scale,hv_ScaleHeightUnit,&TTemp[SP++]);
    destroy_tuple((*hv_ZoomFactorHeight));
    (*hv_ZoomFactorHeight)=TTemp[--SP];

  }
  destroy_tuple(TTemp[--SP]);
  /*========== end if ==========*/
  /*========== return ==========*/

  /* Clear temporary tuple stack */
  while (SP > 0)
    destroy_tuple(TTemp[--SP]);
  /* Clear temporary tuple vectors stack*/
  while (SPTV > 0)
    V_destroy_vector(TVTemp[--SPTV]);
  /* Clear local control variables */
  destroy_tuple(hv_ScaleWidthUnit);
  destroy_tuple(hv_ScaleHeightUnit);
  destroy_tuple(hv_PreserveAspectRatio);
  destroy_tuple(hv_Scale);
  destroy_tuple(hv___Tmp_Ctrl_Dict_Init_0);

  return;

  /****************************************************/
  /******************     End procedure   *************/
  /****************************************************/

}

/* Chapter: Deep Learning / Model*/
/* Short Description: Check the content of the parameter dictionary DLPreprocessParam. */
void check_dl_preprocess_param (Htuple hv_DLPreprocessParam)
{

  /* Stack for temporary tuples */
  Htuple   TTemp[100];
  int      SP=0;
  /* Stack for temporary tuple vectors */
  Hvector  TVTemp[100] = {0};
  int      SPTV=0;

  /* Local iconic variables */

  /* Local control variables */
  Htuple  hv_CheckParams, hv_KeyExists, hv_DLModelType;
  Htuple  hv_Exception, hv_SupportedModelTypes, hv_Index;
  Htuple  hv_ParamNamesGeneral, hv_ParamNamesSegmentation;
  Htuple  hv_ParamNamesDetectionOptional, hv_ParamNamesPreprocessingOptional;
  Htuple  hv_ParamNames3DGrippingPointsOptional, hv_ParamNamesAll;
  Htuple  hv_ParamNames, hv_KeysExists, hv_I, hv_Exists, hv_InputKeys;
  Htuple  hv_Key, hv_Value, hv_Indices, hv_ValidValues, hv_ValidTypes;
  Htuple  hv_V, hv_T, hv_IsInt, hv_ValidTypesListing, hv_ValidValueListing;
  Htuple  hv_EmptyStrings, hv_ImageRangeMinExists, hv_ImageRangeMaxExists;
  Htuple  hv_ImageRangeMin, hv_ImageRangeMax, hv_IndexParam;
  Htuple  hv_SetBackgroundID, hv_ClassIDsBackground, hv_Intersection;
  Htuple  hv_IgnoreClassIDs, hv_KnownClasses, hv_IgnoreClassID;
  Htuple  hv_OptionalKeysExist, hv_InstanceType, hv_IsInstanceSegmentation;
  Htuple  hv_IgnoreDirection, hv_ClassIDsNoOrientation, hv_SemTypes;

  /* Initialize control variables */
  create_tuple(&hv_CheckParams,0);
  create_tuple(&hv_KeyExists,0);
  create_tuple(&hv_DLModelType,0);
  create_tuple(&hv_Exception,0);
  create_tuple(&hv_SupportedModelTypes,0);
  create_tuple(&hv_Index,0);
  create_tuple(&hv_ParamNamesGeneral,0);
  create_tuple(&hv_ParamNamesSegmentation,0);
  create_tuple(&hv_ParamNamesDetectionOptional,0);
  create_tuple(&hv_ParamNamesPreprocessingOptional,0);
  create_tuple(&hv_ParamNames3DGrippingPointsOptional,0);
  create_tuple(&hv_ParamNamesAll,0);
  create_tuple(&hv_ParamNames,0);
  create_tuple(&hv_KeysExists,0);
  create_tuple(&hv_I,0);
  create_tuple(&hv_Exists,0);
  create_tuple(&hv_InputKeys,0);
  create_tuple(&hv_Key,0);
  create_tuple(&hv_Value,0);
  create_tuple(&hv_Indices,0);
  create_tuple(&hv_ValidValues,0);
  create_tuple(&hv_ValidTypes,0);
  create_tuple(&hv_V,0);
  create_tuple(&hv_T,0);
  create_tuple(&hv_IsInt,0);
  create_tuple(&hv_ValidTypesListing,0);
  create_tuple(&hv_ValidValueListing,0);
  create_tuple(&hv_EmptyStrings,0);
  create_tuple(&hv_ImageRangeMinExists,0);
  create_tuple(&hv_ImageRangeMaxExists,0);
  create_tuple(&hv_ImageRangeMin,0);
  create_tuple(&hv_ImageRangeMax,0);
  create_tuple(&hv_IndexParam,0);
  create_tuple(&hv_SetBackgroundID,0);
  create_tuple(&hv_ClassIDsBackground,0);
  create_tuple(&hv_Intersection,0);
  create_tuple(&hv_IgnoreClassIDs,0);
  create_tuple(&hv_KnownClasses,0);
  create_tuple(&hv_IgnoreClassID,0);
  create_tuple(&hv_OptionalKeysExist,0);
  create_tuple(&hv_InstanceType,0);
  create_tuple(&hv_IsInstanceSegmentation,0);
  create_tuple(&hv_IgnoreDirection,0);
  create_tuple(&hv_ClassIDsNoOrientation,0);
  create_tuple(&hv_SemTypes,0);

  /****************************************************/
  /******************   Begin procedure   *************/
  /****************************************************/

  /**/
  /*This procedure checks a dictionary with parameters for DL preprocessing.*/
  /**/
  /*CheckParams := true*/
  reuse_tuple_i(&hv_CheckParams,1);

  /*If check_params is set to false, do not check anything.*/
  /*get_dict_param (DLPreprocessParam, 'key_exists', 'check_params', KeyExists)*/
  create_tuple_s(&TTemp[SP++],"key_exists");
  create_tuple_s(&TTemp[SP++],"check_params");
  destroy_tuple(hv_KeyExists);
  /***/T_get_dict_param(hv_DLPreprocessParam, TTemp[SP-2], TTemp[SP-1], &hv_KeyExists);
  destroy_tuple(TTemp[--SP]);
  destroy_tuple(TTemp[--SP]);

  /*========== if (KeyExists) ==========*/
  copy_tuple(hv_KeyExists,&TTemp[SP++]);
  if(get_i(TTemp[SP-1],0))
  {
    /*get_dict_tuple (DLPreprocessParam, 'check_params', CheckParams)*/
    create_tuple_s(&TTemp[SP++],"check_params");
    destroy_tuple(hv_CheckParams);
    /***/T_get_dict_tuple(hv_DLPreprocessParam, TTemp[SP-1], &hv_CheckParams);
    destroy_tuple(TTemp[--SP]);

    /*========== if (not CheckParams) ==========*/
    T_tuple_not(hv_CheckParams,&TTemp[SP++]);
    if(get_i(TTemp[SP-1],0))
    {
      /*========== return ==========*/

      /* Clear temporary tuple stack */
      while (SP > 0)
        destroy_tuple(TTemp[--SP]);
      /* Clear temporary tuple vectors stack*/
      while (SPTV > 0)
        V_destroy_vector(TVTemp[--SPTV]);
      /* Clear local control variables */
      destroy_tuple(hv_CheckParams);
      destroy_tuple(hv_KeyExists);
      destroy_tuple(hv_DLModelType);
      destroy_tuple(hv_Exception);
      destroy_tuple(hv_SupportedModelTypes);
      destroy_tuple(hv_Index);
      destroy_tuple(hv_ParamNamesGeneral);
      destroy_tuple(hv_ParamNamesSegmentation);
      destroy_tuple(hv_ParamNamesDetectionOptional);
      destroy_tuple(hv_ParamNamesPreprocessingOptional);
      destroy_tuple(hv_ParamNames3DGrippingPointsOptional);
      destroy_tuple(hv_ParamNamesAll);
      destroy_tuple(hv_ParamNames);
      destroy_tuple(hv_KeysExists);
      destroy_tuple(hv_I);
      destroy_tuple(hv_Exists);
      destroy_tuple(hv_InputKeys);
      destroy_tuple(hv_Key);
      destroy_tuple(hv_Value);
      destroy_tuple(hv_Indices);
      destroy_tuple(hv_ValidValues);
      destroy_tuple(hv_ValidTypes);
      destroy_tuple(hv_V);
      destroy_tuple(hv_T);
      destroy_tuple(hv_IsInt);
      destroy_tuple(hv_ValidTypesListing);
      destroy_tuple(hv_ValidValueListing);
      destroy_tuple(hv_EmptyStrings);
      destroy_tuple(hv_ImageRangeMinExists);
      destroy_tuple(hv_ImageRangeMaxExists);
      destroy_tuple(hv_ImageRangeMin);
      destroy_tuple(hv_ImageRangeMax);
      destroy_tuple(hv_IndexParam);
      destroy_tuple(hv_SetBackgroundID);
      destroy_tuple(hv_ClassIDsBackground);
      destroy_tuple(hv_Intersection);
      destroy_tuple(hv_IgnoreClassIDs);
      destroy_tuple(hv_KnownClasses);
      destroy_tuple(hv_IgnoreClassID);
      destroy_tuple(hv_OptionalKeysExist);
      destroy_tuple(hv_InstanceType);
      destroy_tuple(hv_IsInstanceSegmentation);
      destroy_tuple(hv_IgnoreDirection);
      destroy_tuple(hv_ClassIDsNoOrientation);
      destroy_tuple(hv_SemTypes);

      return;
    }
    destroy_tuple(TTemp[--SP]);
    /*========== end if ==========*/
  }
  destroy_tuple(TTemp[--SP]);
  /*========== end if ==========*/
  /**/
  /* try(...); only in hdevelop*/
    /*get_dict_tuple (DLPreprocessParam, 'model_type', DLModelType)*/
    create_tuple_s(&TTemp[SP++],"model_type");
    destroy_tuple(hv_DLModelType);
    /***/T_get_dict_tuple(hv_DLPreprocessParam, TTemp[SP-1], &hv_DLModelType);
    destroy_tuple(TTemp[--SP]);

  /* catch(...); only in hdevelop*/
    /* throw(...); only in hdevelop*/
  /* endtry(...); only in hdevelop*/
  /**/
  /*Check for correct model type.*/
  /*SupportedModelTypes := ['counting', '3d_gripping_point_detection', 'anomaly_detection', 'classification', 'detection', 'gc_anomaly_detection', 'multi_label_classification', 'ocr_recognition', 'ocr_detection', 'segmentation']*/
  create_tuple(&TTemp[SP++],10);
  set_s(TTemp[SP-1],"counting",0);
  set_s(TTemp[SP-1],"3d_gripping_point_detection",1);
  set_s(TTemp[SP-1],"anomaly_detection",2);
  set_s(TTemp[SP-1],"classification",3);
  set_s(TTemp[SP-1],"detection",4);
  set_s(TTemp[SP-1],"gc_anomaly_detection",5);
  set_s(TTemp[SP-1],"multi_label_classification",6);
  set_s(TTemp[SP-1],"ocr_recognition",7);
  set_s(TTemp[SP-1],"ocr_detection",8);
  set_s(TTemp[SP-1],"segmentation",9);
  destroy_tuple(hv_SupportedModelTypes);
  hv_SupportedModelTypes=TTemp[--SP];

  /*tuple_find (SupportedModelTypes, DLModelType, Index)*/
  destroy_tuple(hv_Index);
  /***/T_tuple_find(hv_SupportedModelTypes, hv_DLModelType, &hv_Index);

  /*========== if ((Index == -1) or (Index == [])) ==========*/
  create_tuple_i(&TTemp[SP++],-1);
  T_tuple_equal(hv_Index,TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-1]=TTemp[SP];
  create_tuple(&TTemp[SP++],0);
  T_tuple_equal(hv_Index,TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-1]=TTemp[SP];
  T_tuple_or(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-2]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-2]=TTemp[SP];
  SP--;
  if(get_i(TTemp[SP-1],0))
  {
    /* throw(...); only in hdevelop*/
    /*========== return ==========*/

    /* Clear temporary tuple stack */
    while (SP > 0)
      destroy_tuple(TTemp[--SP]);
    /* Clear temporary tuple vectors stack*/
    while (SPTV > 0)
      V_destroy_vector(TVTemp[--SPTV]);
    /* Clear local control variables */
    destroy_tuple(hv_CheckParams);
    destroy_tuple(hv_KeyExists);
    destroy_tuple(hv_DLModelType);
    destroy_tuple(hv_Exception);
    destroy_tuple(hv_SupportedModelTypes);
    destroy_tuple(hv_Index);
    destroy_tuple(hv_ParamNamesGeneral);
    destroy_tuple(hv_ParamNamesSegmentation);
    destroy_tuple(hv_ParamNamesDetectionOptional);
    destroy_tuple(hv_ParamNamesPreprocessingOptional);
    destroy_tuple(hv_ParamNames3DGrippingPointsOptional);
    destroy_tuple(hv_ParamNamesAll);
    destroy_tuple(hv_ParamNames);
    destroy_tuple(hv_KeysExists);
    destroy_tuple(hv_I);
    destroy_tuple(hv_Exists);
    destroy_tuple(hv_InputKeys);
    destroy_tuple(hv_Key);
    destroy_tuple(hv_Value);
    destroy_tuple(hv_Indices);
    destroy_tuple(hv_ValidValues);
    destroy_tuple(hv_ValidTypes);
    destroy_tuple(hv_V);
    destroy_tuple(hv_T);
    destroy_tuple(hv_IsInt);
    destroy_tuple(hv_ValidTypesListing);
    destroy_tuple(hv_ValidValueListing);
    destroy_tuple(hv_EmptyStrings);
    destroy_tuple(hv_ImageRangeMinExists);
    destroy_tuple(hv_ImageRangeMaxExists);
    destroy_tuple(hv_ImageRangeMin);
    destroy_tuple(hv_ImageRangeMax);
    destroy_tuple(hv_IndexParam);
    destroy_tuple(hv_SetBackgroundID);
    destroy_tuple(hv_ClassIDsBackground);
    destroy_tuple(hv_Intersection);
    destroy_tuple(hv_IgnoreClassIDs);
    destroy_tuple(hv_KnownClasses);
    destroy_tuple(hv_IgnoreClassID);
    destroy_tuple(hv_OptionalKeysExist);
    destroy_tuple(hv_InstanceType);
    destroy_tuple(hv_IsInstanceSegmentation);
    destroy_tuple(hv_IgnoreDirection);
    destroy_tuple(hv_ClassIDsNoOrientation);
    destroy_tuple(hv_SemTypes);

    return;
  }
  destroy_tuple(TTemp[--SP]);
  /*========== end if ==========*/
  /**/
  /*Parameter names that are required.*/
  /*General parameters.*/
  /*ParamNamesGeneral := ['model_type', 'image_width', 'image_height', 'image_num_channels', 'image_range_min', 'image_range_max', 'normalization_type', 'domain_handling']*/
  create_tuple(&TTemp[SP++],8);
  set_s(TTemp[SP-1],"model_type",0);
  set_s(TTemp[SP-1],"image_width",1);
  set_s(TTemp[SP-1],"image_height",2);
  set_s(TTemp[SP-1],"image_num_channels",3);
  set_s(TTemp[SP-1],"image_range_min",4);
  set_s(TTemp[SP-1],"image_range_max",5);
  set_s(TTemp[SP-1],"normalization_type",6);
  set_s(TTemp[SP-1],"domain_handling",7);
  destroy_tuple(hv_ParamNamesGeneral);
  hv_ParamNamesGeneral=TTemp[--SP];

  /*Segmentation specific parameters.*/
  /*ParamNamesSegmentation := ['ignore_class_ids', 'set_background_id', 'class_ids_background']*/
  create_tuple(&TTemp[SP++],3);
  set_s(TTemp[SP-1],"ignore_class_ids",0);
  set_s(TTemp[SP-1],"set_background_id",1);
  set_s(TTemp[SP-1],"class_ids_background",2);
  destroy_tuple(hv_ParamNamesSegmentation);
  hv_ParamNamesSegmentation=TTemp[--SP];

  /*Detection specific parameters.*/
  /*ParamNamesDetectionOptional := ['instance_type', 'ignore_direction', 'class_ids_no_orientation', 'instance_segmentation']*/
  create_tuple(&TTemp[SP++],4);
  set_s(TTemp[SP-1],"instance_type",0);
  set_s(TTemp[SP-1],"ignore_direction",1);
  set_s(TTemp[SP-1],"class_ids_no_orientation",2);
  set_s(TTemp[SP-1],"instance_segmentation",3);
  destroy_tuple(hv_ParamNamesDetectionOptional);
  hv_ParamNamesDetectionOptional=TTemp[--SP];

  /*Optional preprocessing parameters.*/
  /*ParamNamesPreprocessingOptional := ['mean_values_normalization', 'deviation_values_normalization', 'check_params', 'augmentation']*/
  create_tuple(&TTemp[SP++],4);
  set_s(TTemp[SP-1],"mean_values_normalization",0);
  set_s(TTemp[SP-1],"deviation_values_normalization",1);
  set_s(TTemp[SP-1],"check_params",2);
  set_s(TTemp[SP-1],"augmentation",3);
  destroy_tuple(hv_ParamNamesPreprocessingOptional);
  hv_ParamNamesPreprocessingOptional=TTemp[--SP];

  /*3D Gripping Point Detection specific parameters.*/
  /*ParamNames3DGrippingPointsOptional := ['min_z', 'max_z', 'normal_image_width', 'normal_image_height']*/
  create_tuple(&TTemp[SP++],4);
  set_s(TTemp[SP-1],"min_z",0);
  set_s(TTemp[SP-1],"max_z",1);
  set_s(TTemp[SP-1],"normal_image_width",2);
  set_s(TTemp[SP-1],"normal_image_height",3);
  destroy_tuple(hv_ParamNames3DGrippingPointsOptional);
  hv_ParamNames3DGrippingPointsOptional=TTemp[--SP];

  /*All parameters*/
  /*ParamNamesAll := [ParamNamesGeneral,ParamNamesSegmentation,ParamNamesDetectionOptional,ParamNames3DGrippingPointsOptional,ParamNamesPreprocessingOptional]*/
  T_tuple_concat(hv_ParamNamesGeneral,hv_ParamNamesSegmentation,&TTemp[SP++]);
  T_tuple_concat(TTemp[SP-1],hv_ParamNamesDetectionOptional,&TTemp[SP]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-1]=TTemp[SP];
  T_tuple_concat(TTemp[SP-1],hv_ParamNames3DGrippingPointsOptional,&TTemp[SP]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-1]=TTemp[SP];
  T_tuple_concat(TTemp[SP-1],hv_ParamNamesPreprocessingOptional,&TTemp[SP]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-1]=TTemp[SP];
  destroy_tuple(hv_ParamNamesAll);
  hv_ParamNamesAll=TTemp[--SP];

  /*ParamNames := ParamNamesGeneral*/
  destroy_tuple(hv_ParamNames);
  copy_tuple(hv_ParamNamesGeneral,&hv_ParamNames);

  /*========== if (DLModelType == 'segmentation' or DLModelType == '3d_gripping_point_detection') ==========*/
  create_tuple_s(&TTemp[SP++],"segmentation");
  T_tuple_equal(hv_DLModelType,TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-1]=TTemp[SP];
  create_tuple_s(&TTemp[SP++],"3d_gripping_point_detection");
  T_tuple_equal(hv_DLModelType,TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-1]=TTemp[SP];
  T_tuple_or(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-2]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-2]=TTemp[SP];
  SP--;
  if(get_i(TTemp[SP-1],0))
  {
    /*Extend ParamNames for models of type segmentation.*/
    /*ParamNames := [ParamNames,ParamNamesSegmentation]*/
    copy_tuple(hv_ParamNames,&TTemp[SP++]);
    T_tuple_concat(TTemp[SP-1],hv_ParamNamesSegmentation,&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    destroy_tuple(hv_ParamNames);
    hv_ParamNames=TTemp[--SP];

  }
  destroy_tuple(TTemp[--SP]);
  /*========== end if ==========*/
  /**/
  /*Check if legacy parameter exist.*/
  /*Otherwise map it to the legal parameter.*/
  /*replace_legacy_preprocessing_parameters (DLPreprocessParam)*/
  /***/replace_legacy_preprocessing_parameters(hv_DLPreprocessParam);

  /**/
  /*Check that all necessary parameters are included.*/
  /**/
  /*get_dict_param (DLPreprocessParam, 'key_exists', ParamNames, KeysExists)*/
  create_tuple_s(&TTemp[SP++],"key_exists");
  destroy_tuple(hv_KeysExists);
  /***/T_get_dict_param(hv_DLPreprocessParam, TTemp[SP-1], hv_ParamNames, &hv_KeysExists);
  destroy_tuple(TTemp[--SP]);

  /*========== if (sum(KeysExists [==] 0) > 0) ==========*/
  create_tuple_i(&TTemp[SP++],0);
  T_tuple_equal_elem(hv_KeysExists,TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-1]=TTemp[SP];
  T_tuple_sum(TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-1]=TTemp[SP];
  create_tuple_i(&TTemp[SP++],0);
  T_tuple_greater(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-2]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-2]=TTemp[SP];
  SP--;
  if(get_i(TTemp[SP-1],0))
  {
    /*========== for I := 0 to |KeysExists| by 1 ==========*/
    T_tuple_length(hv_KeysExists,&TTemp[SP++]);
    create_tuple_i(&TTemp[SP++],1);
    create_tuple_i(&TTemp[SP++],0);
    T_tuple_greater(TTemp[SP-1],TTemp[SP-3],&TTemp[SP]);
    SP++;
    T_tuple_equal(TTemp[SP-2],TTemp[SP-4],&TTemp[SP]);
    if(get_i(TTemp[SP],0) ||
       (!((( get_i(TTemp[SP-1],0)) && (get_d(TTemp[SP-3],0)>0)) ||
          ((!get_i(TTemp[SP-1],0)) && (get_d(TTemp[SP-3],0)<0)))))
    {
     destroy_tuple(TTemp[SP--]);
     destroy_tuple(TTemp[SP]);
     T_tuple_sub(TTemp[SP-1],TTemp[SP-2],&TTemp[SP]);
     destroy_tuple(hv_I);
     copy_tuple(TTemp[SP],&hv_I);
     destroy_tuple(TTemp[SP--]);
     destroy_tuple(TTemp[SP]);
     for(;;)
     {
     T_tuple_add(hv_I,TTemp[SP-1],&TTemp[SP]);
     destroy_tuple(hv_I);
     copy_tuple(TTemp[SP],&hv_I);
     destroy_tuple(TTemp[SP]);
     if(get_d(TTemp[SP-1],0)<0)
      T_tuple_less(hv_I,TTemp[SP-2],&TTemp[SP]);
     else
      T_tuple_greater(hv_I,TTemp[SP-2],&TTemp[SP]);
     if(get_i(TTemp[SP],0)) break;
     destroy_tuple(TTemp[SP]);
     /*========== for ==========*/

      /*Exists := KeysExists[I]*/
      T_tuple_select(hv_KeysExists,hv_I,&TTemp[SP++]);
      destroy_tuple(hv_Exists);
      hv_Exists=TTemp[--SP];

      /*========== if (not Exists) ==========*/
      T_tuple_not(hv_Exists,&TTemp[SP++]);
      if(get_i(TTemp[SP-1],0))
      {
        /* throw(...); only in hdevelop*/
      }
      destroy_tuple(TTemp[--SP]);
      /*========== end if ==========*/
     }
     destroy_tuple(TTemp[SP--]);
     destroy_tuple(TTemp[SP--]);
     destroy_tuple(TTemp[SP]);
    }
    else
    {
     destroy_tuple(TTemp[SP--]);
     destroy_tuple(TTemp[SP--]);
     destroy_tuple(TTemp[SP--]);
     destroy_tuple(TTemp[SP--]);
     destroy_tuple(TTemp[SP]);
    }/*========== end for ========*/

  }
  destroy_tuple(TTemp[--SP]);
  /*========== end if ==========*/
  /**/
  /*Check the keys provided.*/
  /*get_dict_param (DLPreprocessParam, 'keys', [], InputKeys)*/
  create_tuple_s(&TTemp[SP++],"keys");
  create_tuple(&TTemp[SP++],0);
  destroy_tuple(hv_InputKeys);
  /***/T_get_dict_param(hv_DLPreprocessParam, TTemp[SP-2], TTemp[SP-1], &hv_InputKeys);
  destroy_tuple(TTemp[--SP]);
  destroy_tuple(TTemp[--SP]);

  /*========== for I := 0 to |InputKeys| - 1 by 1 ==========*/
  T_tuple_length(hv_InputKeys,&TTemp[SP++]);
  create_tuple_i(&TTemp[SP++],1);
  T_tuple_sub(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-2]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-2]=TTemp[SP];
  SP--;
  create_tuple_i(&TTemp[SP++],1);
  create_tuple_i(&TTemp[SP++],0);
  T_tuple_greater(TTemp[SP-1],TTemp[SP-3],&TTemp[SP]);
  SP++;
  T_tuple_equal(TTemp[SP-2],TTemp[SP-4],&TTemp[SP]);
  if(get_i(TTemp[SP],0) ||
     (!((( get_i(TTemp[SP-1],0)) && (get_d(TTemp[SP-3],0)>0)) ||
        ((!get_i(TTemp[SP-1],0)) && (get_d(TTemp[SP-3],0)<0)))))
  {
   destroy_tuple(TTemp[SP--]);
   destroy_tuple(TTemp[SP]);
   T_tuple_sub(TTemp[SP-1],TTemp[SP-2],&TTemp[SP]);
   destroy_tuple(hv_I);
   copy_tuple(TTemp[SP],&hv_I);
   destroy_tuple(TTemp[SP--]);
   destroy_tuple(TTemp[SP]);
   for(;;)
   {
   T_tuple_add(hv_I,TTemp[SP-1],&TTemp[SP]);
   destroy_tuple(hv_I);
   copy_tuple(TTemp[SP],&hv_I);
   destroy_tuple(TTemp[SP]);
   if(get_d(TTemp[SP-1],0)<0)
    T_tuple_less(hv_I,TTemp[SP-2],&TTemp[SP]);
   else
    T_tuple_greater(hv_I,TTemp[SP-2],&TTemp[SP]);
   if(get_i(TTemp[SP],0)) break;
   destroy_tuple(TTemp[SP]);
   /*========== for ==========*/

    /*Key := InputKeys[I]*/
    T_tuple_select(hv_InputKeys,hv_I,&TTemp[SP++]);
    destroy_tuple(hv_Key);
    hv_Key=TTemp[--SP];

    /*get_dict_tuple (DLPreprocessParam, Key, Value)*/
    destroy_tuple(hv_Value);
    /***/T_get_dict_tuple(hv_DLPreprocessParam, hv_Key, &hv_Value);

    /*Check that the key is known.*/
    /*tuple_find (ParamNamesAll, Key, Indices)*/
    destroy_tuple(hv_Indices);
    /***/T_tuple_find(hv_ParamNamesAll, hv_Key, &hv_Indices);

    /*========== if (Indices == -1) ==========*/
    create_tuple_i(&TTemp[SP++],-1);
    T_tuple_equal(hv_Indices,TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    if(get_i(TTemp[SP-1],0))
    {
      /* throw(...); only in hdevelop*/
      /*========== return ==========*/

      /* Clear temporary tuple stack */
      while (SP > 0)
        destroy_tuple(TTemp[--SP]);
      /* Clear temporary tuple vectors stack*/
      while (SPTV > 0)
        V_destroy_vector(TVTemp[--SPTV]);
      /* Clear local control variables */
      destroy_tuple(hv_CheckParams);
      destroy_tuple(hv_KeyExists);
      destroy_tuple(hv_DLModelType);
      destroy_tuple(hv_Exception);
      destroy_tuple(hv_SupportedModelTypes);
      destroy_tuple(hv_Index);
      destroy_tuple(hv_ParamNamesGeneral);
      destroy_tuple(hv_ParamNamesSegmentation);
      destroy_tuple(hv_ParamNamesDetectionOptional);
      destroy_tuple(hv_ParamNamesPreprocessingOptional);
      destroy_tuple(hv_ParamNames3DGrippingPointsOptional);
      destroy_tuple(hv_ParamNamesAll);
      destroy_tuple(hv_ParamNames);
      destroy_tuple(hv_KeysExists);
      destroy_tuple(hv_I);
      destroy_tuple(hv_Exists);
      destroy_tuple(hv_InputKeys);
      destroy_tuple(hv_Key);
      destroy_tuple(hv_Value);
      destroy_tuple(hv_Indices);
      destroy_tuple(hv_ValidValues);
      destroy_tuple(hv_ValidTypes);
      destroy_tuple(hv_V);
      destroy_tuple(hv_T);
      destroy_tuple(hv_IsInt);
      destroy_tuple(hv_ValidTypesListing);
      destroy_tuple(hv_ValidValueListing);
      destroy_tuple(hv_EmptyStrings);
      destroy_tuple(hv_ImageRangeMinExists);
      destroy_tuple(hv_ImageRangeMaxExists);
      destroy_tuple(hv_ImageRangeMin);
      destroy_tuple(hv_ImageRangeMax);
      destroy_tuple(hv_IndexParam);
      destroy_tuple(hv_SetBackgroundID);
      destroy_tuple(hv_ClassIDsBackground);
      destroy_tuple(hv_Intersection);
      destroy_tuple(hv_IgnoreClassIDs);
      destroy_tuple(hv_KnownClasses);
      destroy_tuple(hv_IgnoreClassID);
      destroy_tuple(hv_OptionalKeysExist);
      destroy_tuple(hv_InstanceType);
      destroy_tuple(hv_IsInstanceSegmentation);
      destroy_tuple(hv_IgnoreDirection);
      destroy_tuple(hv_ClassIDsNoOrientation);
      destroy_tuple(hv_SemTypes);

      return;
    }
    destroy_tuple(TTemp[--SP]);
    /*========== end if ==========*/
    /*Set expected values and types.*/
    /*ValidValues := []*/
    create_tuple(&TTemp[SP++],0);
    destroy_tuple(hv_ValidValues);
    hv_ValidValues=TTemp[--SP];

    /*ValidTypes := []*/
    create_tuple(&TTemp[SP++],0);
    destroy_tuple(hv_ValidTypes);
    hv_ValidTypes=TTemp[--SP];

    /*========== if (Key == 'normalization_type') ==========*/
    create_tuple_s(&TTemp[SP++],"normalization_type");
    T_tuple_equal(hv_Key,TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    if(get_i(TTemp[SP-1],0))
    {
      /*ValidValues := ['all_channels', 'first_channel', 'constant_values', 'none']*/
      create_tuple(&TTemp[SP++],4);
      set_s(TTemp[SP-1],"all_channels",0);
      set_s(TTemp[SP-1],"first_channel",1);
      set_s(TTemp[SP-1],"constant_values",2);
      set_s(TTemp[SP-1],"none",3);
      destroy_tuple(hv_ValidValues);
      hv_ValidValues=TTemp[--SP];

    }
    else
    {
    destroy_tuple(TTemp[--SP]);
    /*========== elseif (Key == 'domain_handling') ==========*/

    create_tuple_s(&TTemp[SP++],"domain_handling");
    T_tuple_equal(hv_Key,TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    if(get_i(TTemp[SP-1],0))
    {
      /*========== if (DLModelType == 'anomaly_detection') ==========*/
      create_tuple_s(&TTemp[SP++],"anomaly_detection");
      T_tuple_equal(hv_DLModelType,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      if(get_i(TTemp[SP-1],0))
      {
        /*ValidValues := ['full_domain', 'crop_domain', 'keep_domain']*/
        create_tuple(&TTemp[SP++],3);
        set_s(TTemp[SP-1],"full_domain",0);
        set_s(TTemp[SP-1],"crop_domain",1);
        set_s(TTemp[SP-1],"keep_domain",2);
        destroy_tuple(hv_ValidValues);
        hv_ValidValues=TTemp[--SP];

      }
      else
      {
      destroy_tuple(TTemp[--SP]);
      /*========== elseif (DLModelType == '3d_gripping_point_detection') ==========*/

      create_tuple_s(&TTemp[SP++],"3d_gripping_point_detection");
      T_tuple_equal(hv_DLModelType,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      if(get_i(TTemp[SP-1],0))
      {
        /*ValidValues := ['full_domain', 'crop_domain', 'keep_domain']*/
        create_tuple(&TTemp[SP++],3);
        set_s(TTemp[SP-1],"full_domain",0);
        set_s(TTemp[SP-1],"crop_domain",1);
        set_s(TTemp[SP-1],"keep_domain",2);
        destroy_tuple(hv_ValidValues);
        hv_ValidValues=TTemp[--SP];

      }
      else
      {
        /*ValidValues := ['full_domain', 'crop_domain']*/
        create_tuple(&TTemp[SP++],2);
        set_s(TTemp[SP-1],"full_domain",0);
        set_s(TTemp[SP-1],"crop_domain",1);
        destroy_tuple(hv_ValidValues);
        hv_ValidValues=TTemp[--SP];

      }
      }
      destroy_tuple(TTemp[--SP]);
      /*========== end if ==========*/
    }
    else
    {
    destroy_tuple(TTemp[--SP]);
    /*========== elseif (Key == 'model_type') ==========*/

    create_tuple_s(&TTemp[SP++],"model_type");
    T_tuple_equal(hv_Key,TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    if(get_i(TTemp[SP-1],0))
    {
      /*ValidValues := ['counting', '3d_gripping_point_detection', 'anomaly_detection', 'classification', 'detection', 'gc_anomaly_detection', 'multi_label_classification', 'ocr_recognition', 'ocr_detection', 'segmentation']*/
      create_tuple(&TTemp[SP++],10);
      set_s(TTemp[SP-1],"counting",0);
      set_s(TTemp[SP-1],"3d_gripping_point_detection",1);
      set_s(TTemp[SP-1],"anomaly_detection",2);
      set_s(TTemp[SP-1],"classification",3);
      set_s(TTemp[SP-1],"detection",4);
      set_s(TTemp[SP-1],"gc_anomaly_detection",5);
      set_s(TTemp[SP-1],"multi_label_classification",6);
      set_s(TTemp[SP-1],"ocr_recognition",7);
      set_s(TTemp[SP-1],"ocr_detection",8);
      set_s(TTemp[SP-1],"segmentation",9);
      destroy_tuple(hv_ValidValues);
      hv_ValidValues=TTemp[--SP];

    }
    else
    {
    destroy_tuple(TTemp[--SP]);
    /*========== elseif (Key == 'augmentation') ==========*/

    create_tuple_s(&TTemp[SP++],"augmentation");
    T_tuple_equal(hv_Key,TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    if(get_i(TTemp[SP-1],0))
    {
      /*ValidValues := ['true', 'false']*/
      create_tuple(&TTemp[SP++],2);
      set_s(TTemp[SP-1],"true",0);
      set_s(TTemp[SP-1],"false",1);
      destroy_tuple(hv_ValidValues);
      hv_ValidValues=TTemp[--SP];

    }
    else
    {
    destroy_tuple(TTemp[--SP]);
    /*========== elseif (Key == 'set_background_id') ==========*/

    create_tuple_s(&TTemp[SP++],"set_background_id");
    T_tuple_equal(hv_Key,TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    if(get_i(TTemp[SP-1],0))
    {
      /*ValidTypes := 'int'*/
      reuse_tuple_s(&hv_ValidTypes,"int");
    }
    else
    {
    destroy_tuple(TTemp[--SP]);
    /*========== elseif (Key == 'class_ids_background') ==========*/

    create_tuple_s(&TTemp[SP++],"class_ids_background");
    T_tuple_equal(hv_Key,TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    if(get_i(TTemp[SP-1],0))
    {
      /*ValidTypes := 'int'*/
      reuse_tuple_s(&hv_ValidTypes,"int");
    }
    }
    }
    }
    }
    }
    destroy_tuple(TTemp[--SP]);
    /*========== end if ==========*/
    /*Check that type is valid.*/
    /*========== if (|ValidTypes| > 0) ==========*/
    T_tuple_length(hv_ValidTypes,&TTemp[SP++]);
    create_tuple_i(&TTemp[SP++],0);
    T_tuple_greater(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-2]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-2]=TTemp[SP];
    SP--;
    if(get_i(TTemp[SP-1],0))
    {
      /*========== for V := 0 to |ValidTypes| - 1 by 1 ==========*/
      T_tuple_length(hv_ValidTypes,&TTemp[SP++]);
      create_tuple_i(&TTemp[SP++],1);
      T_tuple_sub(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-2]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-2]=TTemp[SP];
      SP--;
      create_tuple_i(&TTemp[SP++],1);
      create_tuple_i(&TTemp[SP++],0);
      T_tuple_greater(TTemp[SP-1],TTemp[SP-3],&TTemp[SP]);
      SP++;
      T_tuple_equal(TTemp[SP-2],TTemp[SP-4],&TTemp[SP]);
      if(get_i(TTemp[SP],0) ||
         (!((( get_i(TTemp[SP-1],0)) && (get_d(TTemp[SP-3],0)>0)) ||
            ((!get_i(TTemp[SP-1],0)) && (get_d(TTemp[SP-3],0)<0)))))
      {
       destroy_tuple(TTemp[SP--]);
       destroy_tuple(TTemp[SP]);
       T_tuple_sub(TTemp[SP-1],TTemp[SP-2],&TTemp[SP]);
       destroy_tuple(hv_V);
       copy_tuple(TTemp[SP],&hv_V);
       destroy_tuple(TTemp[SP--]);
       destroy_tuple(TTemp[SP]);
       for(;;)
       {
       T_tuple_add(hv_V,TTemp[SP-1],&TTemp[SP]);
       destroy_tuple(hv_V);
       copy_tuple(TTemp[SP],&hv_V);
       destroy_tuple(TTemp[SP]);
       if(get_d(TTemp[SP-1],0)<0)
        T_tuple_less(hv_V,TTemp[SP-2],&TTemp[SP]);
       else
        T_tuple_greater(hv_V,TTemp[SP-2],&TTemp[SP]);
       if(get_i(TTemp[SP],0)) break;
       destroy_tuple(TTemp[SP]);
       /*========== for ==========*/

        /*T := ValidTypes[V]*/
        T_tuple_select(hv_ValidTypes,hv_V,&TTemp[SP++]);
        destroy_tuple(hv_T);
        hv_T=TTemp[--SP];

        /*========== if (T == 'int') ==========*/
        create_tuple_s(&TTemp[SP++],"int");
        T_tuple_equal(hv_T,TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-1]=TTemp[SP];
        if(get_i(TTemp[SP-1],0))
        {
          /*tuple_is_int (Value, IsInt)*/
          destroy_tuple(hv_IsInt);
          /***/T_tuple_is_int(hv_Value, &hv_IsInt);

          /*========== if (not IsInt) ==========*/
          T_tuple_not(hv_IsInt,&TTemp[SP++]);
          if(get_i(TTemp[SP-1],0))
          {
            /*ValidTypes := '\'' + ValidTypes + '\''*/
            create_tuple_s(&TTemp[SP++],"'");
            copy_tuple(hv_ValidTypes,&TTemp[SP++]);
            T_tuple_add(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
            destroy_tuple(TTemp[SP-2]);
            destroy_tuple(TTemp[SP-1]);
            TTemp[SP-2]=TTemp[SP];
            SP--;
            create_tuple_s(&TTemp[SP++],"'");
            T_tuple_add(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
            destroy_tuple(TTemp[SP-2]);
            destroy_tuple(TTemp[SP-1]);
            TTemp[SP-2]=TTemp[SP];
            SP--;
            destroy_tuple(hv_ValidTypes);
            hv_ValidTypes=TTemp[--SP];

            /*========== if (|ValidTypes| < 2) ==========*/
            T_tuple_length(hv_ValidTypes,&TTemp[SP++]);
            create_tuple_i(&TTemp[SP++],2);
            T_tuple_less(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
            destroy_tuple(TTemp[SP-2]);
            destroy_tuple(TTemp[SP-1]);
            TTemp[SP-2]=TTemp[SP];
            SP--;
            if(get_i(TTemp[SP-1],0))
            {
              /*ValidTypesListing := ValidTypes*/
              destroy_tuple(hv_ValidTypesListing);
              copy_tuple(hv_ValidTypes,&hv_ValidTypesListing);

            }
            else
            {
              /*ValidTypesListing := sum(ValidTypes[0:max2(0,|ValidTypes| - 2)] + ', ' + ValidTypes[|ValidTypes| - 1])*/
              create_tuple_i(&TTemp[SP++],0);
              create_tuple_i(&TTemp[SP++],0);
              T_tuple_length(hv_ValidTypes,&TTemp[SP++]);
              create_tuple_i(&TTemp[SP++],2);
              T_tuple_sub(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
              destroy_tuple(TTemp[SP-2]);
              destroy_tuple(TTemp[SP-1]);
              TTemp[SP-2]=TTemp[SP];
              SP--;
              T_tuple_max2(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
              destroy_tuple(TTemp[SP-2]);
              destroy_tuple(TTemp[SP-1]);
              TTemp[SP-2]=TTemp[SP];
              SP--;
              T_tuple_select_range(hv_ValidTypes,TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
              destroy_tuple(TTemp[SP-2]);
              destroy_tuple(TTemp[SP-1]);
              TTemp[SP-2]=TTemp[SP];
              SP=SP-1;
              create_tuple_s(&TTemp[SP++],", ");
              T_tuple_add(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
              destroy_tuple(TTemp[SP-2]);
              destroy_tuple(TTemp[SP-1]);
              TTemp[SP-2]=TTemp[SP];
              SP--;
              T_tuple_length(hv_ValidTypes,&TTemp[SP++]);
              create_tuple_i(&TTemp[SP++],1);
              T_tuple_sub(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
              destroy_tuple(TTemp[SP-2]);
              destroy_tuple(TTemp[SP-1]);
              TTemp[SP-2]=TTemp[SP];
              SP--;
              T_tuple_select(hv_ValidTypes,TTemp[SP-1],&TTemp[SP]);
              destroy_tuple(TTemp[SP-1]);
              TTemp[SP-1]=TTemp[SP];
              T_tuple_add(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
              destroy_tuple(TTemp[SP-2]);
              destroy_tuple(TTemp[SP-1]);
              TTemp[SP-2]=TTemp[SP];
              SP--;
              T_tuple_sum(TTemp[SP-1],&TTemp[SP]);
              destroy_tuple(TTemp[SP-1]);
              TTemp[SP-1]=TTemp[SP];
              destroy_tuple(hv_ValidTypesListing);
              hv_ValidTypesListing=TTemp[--SP];

            }
            destroy_tuple(TTemp[--SP]);
            /*========== end if ==========*/
            /* throw(...); only in hdevelop*/
            /*========== return ==========*/

            /* Clear temporary tuple stack */
            while (SP > 0)
              destroy_tuple(TTemp[--SP]);
            /* Clear temporary tuple vectors stack*/
            while (SPTV > 0)
              V_destroy_vector(TVTemp[--SPTV]);
            /* Clear local control variables */
            destroy_tuple(hv_CheckParams);
            destroy_tuple(hv_KeyExists);
            destroy_tuple(hv_DLModelType);
            destroy_tuple(hv_Exception);
            destroy_tuple(hv_SupportedModelTypes);
            destroy_tuple(hv_Index);
            destroy_tuple(hv_ParamNamesGeneral);
            destroy_tuple(hv_ParamNamesSegmentation);
            destroy_tuple(hv_ParamNamesDetectionOptional);
            destroy_tuple(hv_ParamNamesPreprocessingOptional);
            destroy_tuple(hv_ParamNames3DGrippingPointsOptional);
            destroy_tuple(hv_ParamNamesAll);
            destroy_tuple(hv_ParamNames);
            destroy_tuple(hv_KeysExists);
            destroy_tuple(hv_I);
            destroy_tuple(hv_Exists);
            destroy_tuple(hv_InputKeys);
            destroy_tuple(hv_Key);
            destroy_tuple(hv_Value);
            destroy_tuple(hv_Indices);
            destroy_tuple(hv_ValidValues);
            destroy_tuple(hv_ValidTypes);
            destroy_tuple(hv_V);
            destroy_tuple(hv_T);
            destroy_tuple(hv_IsInt);
            destroy_tuple(hv_ValidTypesListing);
            destroy_tuple(hv_ValidValueListing);
            destroy_tuple(hv_EmptyStrings);
            destroy_tuple(hv_ImageRangeMinExists);
            destroy_tuple(hv_ImageRangeMaxExists);
            destroy_tuple(hv_ImageRangeMin);
            destroy_tuple(hv_ImageRangeMax);
            destroy_tuple(hv_IndexParam);
            destroy_tuple(hv_SetBackgroundID);
            destroy_tuple(hv_ClassIDsBackground);
            destroy_tuple(hv_Intersection);
            destroy_tuple(hv_IgnoreClassIDs);
            destroy_tuple(hv_KnownClasses);
            destroy_tuple(hv_IgnoreClassID);
            destroy_tuple(hv_OptionalKeysExist);
            destroy_tuple(hv_InstanceType);
            destroy_tuple(hv_IsInstanceSegmentation);
            destroy_tuple(hv_IgnoreDirection);
            destroy_tuple(hv_ClassIDsNoOrientation);
            destroy_tuple(hv_SemTypes);

            return;
          }
          destroy_tuple(TTemp[--SP]);
          /*========== end if ==========*/
        }
        else
        {
          /* throw(...); only in hdevelop*/
        }
        destroy_tuple(TTemp[--SP]);
        /*========== end if ==========*/
       }
       destroy_tuple(TTemp[SP--]);
       destroy_tuple(TTemp[SP--]);
       destroy_tuple(TTemp[SP]);
      }
      else
      {
       destroy_tuple(TTemp[SP--]);
       destroy_tuple(TTemp[SP--]);
       destroy_tuple(TTemp[SP--]);
       destroy_tuple(TTemp[SP--]);
       destroy_tuple(TTemp[SP]);
      }/*========== end for ========*/

    }
    destroy_tuple(TTemp[--SP]);
    /*========== end if ==========*/
    /*Check that value is valid.*/
    /*========== if (|ValidValues| > 0) ==========*/
    T_tuple_length(hv_ValidValues,&TTemp[SP++]);
    create_tuple_i(&TTemp[SP++],0);
    T_tuple_greater(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-2]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-2]=TTemp[SP];
    SP--;
    if(get_i(TTemp[SP-1],0))
    {
      /*tuple_find_first (ValidValues, Value, Index)*/
      destroy_tuple(hv_Index);
      /***/T_tuple_find_first(hv_ValidValues, hv_Value, &hv_Index);

      /*========== if (Index == -1) ==========*/
      create_tuple_i(&TTemp[SP++],-1);
      T_tuple_equal(hv_Index,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      if(get_i(TTemp[SP-1],0))
      {
        /*ValidValues := '\'' + ValidValues + '\''*/
        create_tuple_s(&TTemp[SP++],"'");
        copy_tuple(hv_ValidValues,&TTemp[SP++]);
        T_tuple_add(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-2]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-2]=TTemp[SP];
        SP--;
        create_tuple_s(&TTemp[SP++],"'");
        T_tuple_add(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-2]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-2]=TTemp[SP];
        SP--;
        destroy_tuple(hv_ValidValues);
        hv_ValidValues=TTemp[--SP];

        /*========== if (|ValidValues| < 2) ==========*/
        T_tuple_length(hv_ValidValues,&TTemp[SP++]);
        create_tuple_i(&TTemp[SP++],2);
        T_tuple_less(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-2]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-2]=TTemp[SP];
        SP--;
        if(get_i(TTemp[SP-1],0))
        {
          /*ValidValueListing := ValidValues*/
          destroy_tuple(hv_ValidValueListing);
          copy_tuple(hv_ValidValues,&hv_ValidValueListing);

        }
        else
        {
          /*EmptyStrings := gen_tuple_const(|ValidValues| - 2,'')*/
          T_tuple_length(hv_ValidValues,&TTemp[SP++]);
          create_tuple_i(&TTemp[SP++],2);
          T_tuple_sub(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
          destroy_tuple(TTemp[SP-2]);
          destroy_tuple(TTemp[SP-1]);
          TTemp[SP-2]=TTemp[SP];
          SP--;
          create_tuple_s(&TTemp[SP++],"");
          T_tuple_gen_const(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
          destroy_tuple(TTemp[SP-2]);
          destroy_tuple(TTemp[SP-1]);
          TTemp[SP-2]=TTemp[SP];
          SP--;
          destroy_tuple(hv_EmptyStrings);
          hv_EmptyStrings=TTemp[--SP];

          /*ValidValueListing := sum(ValidValues[0:max2(0,|ValidValues| - 2)] + ', ' + [EmptyStrings,ValidValues[|ValidValues| - 1]])*/
          create_tuple_i(&TTemp[SP++],0);
          create_tuple_i(&TTemp[SP++],0);
          T_tuple_length(hv_ValidValues,&TTemp[SP++]);
          create_tuple_i(&TTemp[SP++],2);
          T_tuple_sub(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
          destroy_tuple(TTemp[SP-2]);
          destroy_tuple(TTemp[SP-1]);
          TTemp[SP-2]=TTemp[SP];
          SP--;
          T_tuple_max2(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
          destroy_tuple(TTemp[SP-2]);
          destroy_tuple(TTemp[SP-1]);
          TTemp[SP-2]=TTemp[SP];
          SP--;
          T_tuple_select_range(hv_ValidValues,TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
          destroy_tuple(TTemp[SP-2]);
          destroy_tuple(TTemp[SP-1]);
          TTemp[SP-2]=TTemp[SP];
          SP=SP-1;
          create_tuple_s(&TTemp[SP++],", ");
          T_tuple_add(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
          destroy_tuple(TTemp[SP-2]);
          destroy_tuple(TTemp[SP-1]);
          TTemp[SP-2]=TTemp[SP];
          SP--;
          T_tuple_length(hv_ValidValues,&TTemp[SP++]);
          create_tuple_i(&TTemp[SP++],1);
          T_tuple_sub(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
          destroy_tuple(TTemp[SP-2]);
          destroy_tuple(TTemp[SP-1]);
          TTemp[SP-2]=TTemp[SP];
          SP--;
          T_tuple_select(hv_ValidValues,TTemp[SP-1],&TTemp[SP]);
          destroy_tuple(TTemp[SP-1]);
          TTemp[SP-1]=TTemp[SP];
          T_tuple_concat(hv_EmptyStrings,TTemp[SP-1],&TTemp[SP]);
          destroy_tuple(TTemp[SP-1]);
          TTemp[SP-1]=TTemp[SP];
          T_tuple_add(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
          destroy_tuple(TTemp[SP-2]);
          destroy_tuple(TTemp[SP-1]);
          TTemp[SP-2]=TTemp[SP];
          SP--;
          T_tuple_sum(TTemp[SP-1],&TTemp[SP]);
          destroy_tuple(TTemp[SP-1]);
          TTemp[SP-1]=TTemp[SP];
          destroy_tuple(hv_ValidValueListing);
          hv_ValidValueListing=TTemp[--SP];

        }
        destroy_tuple(TTemp[--SP]);
        /*========== end if ==========*/
        /* throw(...); only in hdevelop*/
      }
      destroy_tuple(TTemp[--SP]);
      /*========== end if ==========*/
    }
    destroy_tuple(TTemp[--SP]);
    /*========== end if ==========*/
   }
   destroy_tuple(TTemp[SP--]);
   destroy_tuple(TTemp[SP--]);
   destroy_tuple(TTemp[SP]);
  }
  else
  {
   destroy_tuple(TTemp[SP--]);
   destroy_tuple(TTemp[SP--]);
   destroy_tuple(TTemp[SP--]);
   destroy_tuple(TTemp[SP--]);
   destroy_tuple(TTemp[SP]);
  }/*========== end for ========*/

  /**/
  /*Check the correct setting of ImageRangeMin and ImageRangeMax.*/
  /*========== if (DLModelType == 'classification' or DLModelType == 'multi_label_classification' or DLModelType == 'detection') ==========*/
  create_tuple_s(&TTemp[SP++],"classification");
  T_tuple_equal(hv_DLModelType,TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-1]=TTemp[SP];
  create_tuple_s(&TTemp[SP++],"multi_label_classification");
  T_tuple_equal(hv_DLModelType,TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-1]=TTemp[SP];
  T_tuple_or(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-2]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-2]=TTemp[SP];
  SP--;
  create_tuple_s(&TTemp[SP++],"detection");
  T_tuple_equal(hv_DLModelType,TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-1]=TTemp[SP];
  T_tuple_or(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-2]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-2]=TTemp[SP];
  SP--;
  if(get_i(TTemp[SP-1],0))
  {
    /*Check ImageRangeMin and ImageRangeMax.*/
    /*get_dict_param (DLPreprocessParam, 'key_exists', 'image_range_min', ImageRangeMinExists)*/
    create_tuple_s(&TTemp[SP++],"key_exists");
    create_tuple_s(&TTemp[SP++],"image_range_min");
    destroy_tuple(hv_ImageRangeMinExists);
    /***/T_get_dict_param(hv_DLPreprocessParam, TTemp[SP-2], TTemp[SP-1], &hv_ImageRangeMinExists);
    destroy_tuple(TTemp[--SP]);
    destroy_tuple(TTemp[--SP]);

    /*get_dict_param (DLPreprocessParam, 'key_exists', 'image_range_max', ImageRangeMaxExists)*/
    create_tuple_s(&TTemp[SP++],"key_exists");
    create_tuple_s(&TTemp[SP++],"image_range_max");
    destroy_tuple(hv_ImageRangeMaxExists);
    /***/T_get_dict_param(hv_DLPreprocessParam, TTemp[SP-2], TTemp[SP-1], &hv_ImageRangeMaxExists);
    destroy_tuple(TTemp[--SP]);
    destroy_tuple(TTemp[--SP]);

    /*If they are present, check that they are set correctly.*/
    /*========== if (ImageRangeMinExists) ==========*/
    copy_tuple(hv_ImageRangeMinExists,&TTemp[SP++]);
    if(get_i(TTemp[SP-1],0))
    {
      /*get_dict_tuple (DLPreprocessParam, 'image_range_min', ImageRangeMin)*/
      create_tuple_s(&TTemp[SP++],"image_range_min");
      destroy_tuple(hv_ImageRangeMin);
      /***/T_get_dict_tuple(hv_DLPreprocessParam, TTemp[SP-1], &hv_ImageRangeMin);
      destroy_tuple(TTemp[--SP]);

      /*========== if (ImageRangeMin != -127) ==========*/
      create_tuple_i(&TTemp[SP++],-127);
      T_tuple_not_equal(hv_ImageRangeMin,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      if(get_i(TTemp[SP-1],0))
      {
        /* throw(...); only in hdevelop*/
      }
      destroy_tuple(TTemp[--SP]);
      /*========== end if ==========*/
    }
    destroy_tuple(TTemp[--SP]);
    /*========== end if ==========*/
    /*========== if (ImageRangeMaxExists) ==========*/
    copy_tuple(hv_ImageRangeMaxExists,&TTemp[SP++]);
    if(get_i(TTemp[SP-1],0))
    {
      /*get_dict_tuple (DLPreprocessParam, 'image_range_max', ImageRangeMax)*/
      create_tuple_s(&TTemp[SP++],"image_range_max");
      destroy_tuple(hv_ImageRangeMax);
      /***/T_get_dict_tuple(hv_DLPreprocessParam, TTemp[SP-1], &hv_ImageRangeMax);
      destroy_tuple(TTemp[--SP]);

      /*========== if (ImageRangeMax != 128) ==========*/
      create_tuple_i(&TTemp[SP++],128);
      T_tuple_not_equal(hv_ImageRangeMax,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      if(get_i(TTemp[SP-1],0))
      {
        /* throw(...); only in hdevelop*/
      }
      destroy_tuple(TTemp[--SP]);
      /*========== end if ==========*/
    }
    destroy_tuple(TTemp[--SP]);
    /*========== end if ==========*/
  }
  destroy_tuple(TTemp[--SP]);
  /*========== end if ==========*/
  /**/
  /*Check segmentation specific parameters.*/
  /*========== if (DLModelType == 'segmentation' or DLModelType == '3d_gripping_point_detection') ==========*/
  create_tuple_s(&TTemp[SP++],"segmentation");
  T_tuple_equal(hv_DLModelType,TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-1]=TTemp[SP];
  create_tuple_s(&TTemp[SP++],"3d_gripping_point_detection");
  T_tuple_equal(hv_DLModelType,TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-1]=TTemp[SP];
  T_tuple_or(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-2]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-2]=TTemp[SP];
  SP--;
  if(get_i(TTemp[SP-1],0))
  {
    /*Check if detection specific parameters are set.*/
    /*get_dict_param (DLPreprocessParam, 'key_exists', ParamNamesDetectionOptional, KeysExists)*/
    create_tuple_s(&TTemp[SP++],"key_exists");
    destroy_tuple(hv_KeysExists);
    /***/T_get_dict_param(hv_DLPreprocessParam, TTemp[SP-1], hv_ParamNamesDetectionOptional, 
        &hv_KeysExists);
    destroy_tuple(TTemp[--SP]);

    /*If they are present, check that they are [].*/
    /*========== for IndexParam := 0 to |ParamNamesDetectionOptional| - 1 by 1 ==========*/
    T_tuple_length(hv_ParamNamesDetectionOptional,&TTemp[SP++]);
    create_tuple_i(&TTemp[SP++],1);
    T_tuple_sub(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-2]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-2]=TTemp[SP];
    SP--;
    create_tuple_i(&TTemp[SP++],1);
    create_tuple_i(&TTemp[SP++],0);
    T_tuple_greater(TTemp[SP-1],TTemp[SP-3],&TTemp[SP]);
    SP++;
    T_tuple_equal(TTemp[SP-2],TTemp[SP-4],&TTemp[SP]);
    if(get_i(TTemp[SP],0) ||
       (!((( get_i(TTemp[SP-1],0)) && (get_d(TTemp[SP-3],0)>0)) ||
          ((!get_i(TTemp[SP-1],0)) && (get_d(TTemp[SP-3],0)<0)))))
    {
     destroy_tuple(TTemp[SP--]);
     destroy_tuple(TTemp[SP]);
     T_tuple_sub(TTemp[SP-1],TTemp[SP-2],&TTemp[SP]);
     destroy_tuple(hv_IndexParam);
     copy_tuple(TTemp[SP],&hv_IndexParam);
     destroy_tuple(TTemp[SP--]);
     destroy_tuple(TTemp[SP]);
     for(;;)
     {
     T_tuple_add(hv_IndexParam,TTemp[SP-1],&TTemp[SP]);
     destroy_tuple(hv_IndexParam);
     copy_tuple(TTemp[SP],&hv_IndexParam);
     destroy_tuple(TTemp[SP]);
     if(get_d(TTemp[SP-1],0)<0)
      T_tuple_less(hv_IndexParam,TTemp[SP-2],&TTemp[SP]);
     else
      T_tuple_greater(hv_IndexParam,TTemp[SP-2],&TTemp[SP]);
     if(get_i(TTemp[SP],0)) break;
     destroy_tuple(TTemp[SP]);
     /*========== for ==========*/

      /*========== if (KeysExists[IndexParam]) ==========*/
      T_tuple_select(hv_KeysExists,hv_IndexParam,&TTemp[SP++]);
      if(get_i(TTemp[SP-1],0))
      {
        /*get_dict_tuple (DLPreprocessParam, ParamNamesDetectionOptional[IndexParam], Value)*/
        T_tuple_select(hv_ParamNamesDetectionOptional,hv_IndexParam,&TTemp[SP++]);
        destroy_tuple(hv_Value);
        /***/T_get_dict_tuple(hv_DLPreprocessParam, TTemp[SP-1], &hv_Value);
        destroy_tuple(TTemp[--SP]);

        /*========== if (Value != []) ==========*/
        create_tuple(&TTemp[SP++],0);
        T_tuple_not_equal(hv_Value,TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-1]=TTemp[SP];
        if(get_i(TTemp[SP-1],0))
        {
          /* throw(...); only in hdevelop*/
        }
        destroy_tuple(TTemp[--SP]);
        /*========== end if ==========*/
      }
      destroy_tuple(TTemp[--SP]);
      /*========== end if ==========*/
     }
     destroy_tuple(TTemp[SP--]);
     destroy_tuple(TTemp[SP--]);
     destroy_tuple(TTemp[SP]);
    }
    else
    {
     destroy_tuple(TTemp[SP--]);
     destroy_tuple(TTemp[SP--]);
     destroy_tuple(TTemp[SP--]);
     destroy_tuple(TTemp[SP--]);
     destroy_tuple(TTemp[SP]);
    }/*========== end for ========*/

    /*Check 'set_background_id'.*/
    /*get_dict_tuple (DLPreprocessParam, 'set_background_id', SetBackgroundID)*/
    create_tuple_s(&TTemp[SP++],"set_background_id");
    destroy_tuple(hv_SetBackgroundID);
    /***/T_get_dict_tuple(hv_DLPreprocessParam, TTemp[SP-1], &hv_SetBackgroundID);
    destroy_tuple(TTemp[--SP]);

    /*========== if (SetBackgroundID != [] and DLModelType == '3d_gripping_point_detection') ==========*/
    create_tuple(&TTemp[SP++],0);
    T_tuple_not_equal(hv_SetBackgroundID,TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    create_tuple_s(&TTemp[SP++],"3d_gripping_point_detection");
    T_tuple_equal(hv_DLModelType,TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    T_tuple_and(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-2]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-2]=TTemp[SP];
    SP--;
    if(get_i(TTemp[SP-1],0))
    {
      /* throw(...); only in hdevelop*/
    }
    destroy_tuple(TTemp[--SP]);
    /*========== end if ==========*/
    /*========== if (|SetBackgroundID| > 1) ==========*/
    T_tuple_length(hv_SetBackgroundID,&TTemp[SP++]);
    create_tuple_i(&TTemp[SP++],1);
    T_tuple_greater(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-2]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-2]=TTemp[SP];
    SP--;
    if(get_i(TTemp[SP-1],0))
    {
      /* throw(...); only in hdevelop*/
    }
    destroy_tuple(TTemp[--SP]);
    /*========== end if ==========*/
    /*Check 'class_ids_background'.*/
    /*get_dict_tuple (DLPreprocessParam, 'class_ids_background', ClassIDsBackground)*/
    create_tuple_s(&TTemp[SP++],"class_ids_background");
    destroy_tuple(hv_ClassIDsBackground);
    /***/T_get_dict_tuple(hv_DLPreprocessParam, TTemp[SP-1], &hv_ClassIDsBackground);
    destroy_tuple(TTemp[--SP]);

    /*========== if (ClassIDsBackground != [] and DLModelType == '3d_gripping_point_detection') ==========*/
    create_tuple(&TTemp[SP++],0);
    T_tuple_not_equal(hv_ClassIDsBackground,TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    create_tuple_s(&TTemp[SP++],"3d_gripping_point_detection");
    T_tuple_equal(hv_DLModelType,TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    T_tuple_and(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-2]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-2]=TTemp[SP];
    SP--;
    if(get_i(TTemp[SP-1],0))
    {
      /* throw(...); only in hdevelop*/
    }
    destroy_tuple(TTemp[--SP]);
    /*========== end if ==========*/
    /*========== if ((|SetBackgroundID| > 0 and not (|ClassIDsBackground| > 0)) or (|ClassIDsBackground| > 0 and not (|SetBackgroundID| > 0))) ==========*/
    T_tuple_length(hv_SetBackgroundID,&TTemp[SP++]);
    create_tuple_i(&TTemp[SP++],0);
    T_tuple_greater(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-2]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-2]=TTemp[SP];
    SP--;
    T_tuple_length(hv_ClassIDsBackground,&TTemp[SP++]);
    create_tuple_i(&TTemp[SP++],0);
    T_tuple_greater(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-2]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-2]=TTemp[SP];
    SP--;
    T_tuple_not(TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    T_tuple_and(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-2]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-2]=TTemp[SP];
    SP--;
    T_tuple_length(hv_ClassIDsBackground,&TTemp[SP++]);
    create_tuple_i(&TTemp[SP++],0);
    T_tuple_greater(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-2]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-2]=TTemp[SP];
    SP--;
    T_tuple_length(hv_SetBackgroundID,&TTemp[SP++]);
    create_tuple_i(&TTemp[SP++],0);
    T_tuple_greater(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-2]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-2]=TTemp[SP];
    SP--;
    T_tuple_not(TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    T_tuple_and(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-2]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-2]=TTemp[SP];
    SP--;
    T_tuple_or(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-2]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-2]=TTemp[SP];
    SP--;
    if(get_i(TTemp[SP-1],0))
    {
      /* throw(...); only in hdevelop*/
    }
    destroy_tuple(TTemp[--SP]);
    /*========== end if ==========*/
    /*Check that 'class_ids_background' and 'set_background_id' are disjoint.*/
    /*========== if (|SetBackgroundID| > 0) ==========*/
    T_tuple_length(hv_SetBackgroundID,&TTemp[SP++]);
    create_tuple_i(&TTemp[SP++],0);
    T_tuple_greater(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-2]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-2]=TTemp[SP];
    SP--;
    if(get_i(TTemp[SP-1],0))
    {
      /*tuple_intersection (SetBackgroundID, ClassIDsBackground, Intersection)*/
      destroy_tuple(hv_Intersection);
      /***/T_tuple_intersection(hv_SetBackgroundID, hv_ClassIDsBackground, &hv_Intersection);

      /*========== if (|Intersection|) ==========*/
      T_tuple_length(hv_Intersection,&TTemp[SP++]);
      if(get_i(TTemp[SP-1],0))
      {
        /* throw(...); only in hdevelop*/
      }
      destroy_tuple(TTemp[--SP]);
      /*========== end if ==========*/
    }
    destroy_tuple(TTemp[--SP]);
    /*========== end if ==========*/
    /*Check 'ignore_class_ids'.*/
    /*get_dict_tuple (DLPreprocessParam, 'ignore_class_ids', IgnoreClassIDs)*/
    create_tuple_s(&TTemp[SP++],"ignore_class_ids");
    destroy_tuple(hv_IgnoreClassIDs);
    /***/T_get_dict_tuple(hv_DLPreprocessParam, TTemp[SP-1], &hv_IgnoreClassIDs);
    destroy_tuple(TTemp[--SP]);

    /*========== if (IgnoreClassIDs != [] and DLModelType == '3d_gripping_point_detection') ==========*/
    create_tuple(&TTemp[SP++],0);
    T_tuple_not_equal(hv_IgnoreClassIDs,TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    create_tuple_s(&TTemp[SP++],"3d_gripping_point_detection");
    T_tuple_equal(hv_DLModelType,TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    T_tuple_and(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-2]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-2]=TTemp[SP];
    SP--;
    if(get_i(TTemp[SP-1],0))
    {
      /* throw(...); only in hdevelop*/
    }
    destroy_tuple(TTemp[--SP]);
    /*========== end if ==========*/
    /*KnownClasses := [SetBackgroundID,ClassIDsBackground]*/
    T_tuple_concat(hv_SetBackgroundID,hv_ClassIDsBackground,&TTemp[SP++]);
    destroy_tuple(hv_KnownClasses);
    hv_KnownClasses=TTemp[--SP];

    /*========== for I := 0 to |IgnoreClassIDs| - 1 by 1 ==========*/
    T_tuple_length(hv_IgnoreClassIDs,&TTemp[SP++]);
    create_tuple_i(&TTemp[SP++],1);
    T_tuple_sub(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-2]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-2]=TTemp[SP];
    SP--;
    create_tuple_i(&TTemp[SP++],1);
    create_tuple_i(&TTemp[SP++],0);
    T_tuple_greater(TTemp[SP-1],TTemp[SP-3],&TTemp[SP]);
    SP++;
    T_tuple_equal(TTemp[SP-2],TTemp[SP-4],&TTemp[SP]);
    if(get_i(TTemp[SP],0) ||
       (!((( get_i(TTemp[SP-1],0)) && (get_d(TTemp[SP-3],0)>0)) ||
          ((!get_i(TTemp[SP-1],0)) && (get_d(TTemp[SP-3],0)<0)))))
    {
     destroy_tuple(TTemp[SP--]);
     destroy_tuple(TTemp[SP]);
     T_tuple_sub(TTemp[SP-1],TTemp[SP-2],&TTemp[SP]);
     destroy_tuple(hv_I);
     copy_tuple(TTemp[SP],&hv_I);
     destroy_tuple(TTemp[SP--]);
     destroy_tuple(TTemp[SP]);
     for(;;)
     {
     T_tuple_add(hv_I,TTemp[SP-1],&TTemp[SP]);
     destroy_tuple(hv_I);
     copy_tuple(TTemp[SP],&hv_I);
     destroy_tuple(TTemp[SP]);
     if(get_d(TTemp[SP-1],0)<0)
      T_tuple_less(hv_I,TTemp[SP-2],&TTemp[SP]);
     else
      T_tuple_greater(hv_I,TTemp[SP-2],&TTemp[SP]);
     if(get_i(TTemp[SP],0)) break;
     destroy_tuple(TTemp[SP]);
     /*========== for ==========*/

      /*IgnoreClassID := IgnoreClassIDs[I]*/
      T_tuple_select(hv_IgnoreClassIDs,hv_I,&TTemp[SP++]);
      destroy_tuple(hv_IgnoreClassID);
      hv_IgnoreClassID=TTemp[--SP];

      /*tuple_find_first (KnownClasses, IgnoreClassID, Index)*/
      destroy_tuple(hv_Index);
      /***/T_tuple_find_first(hv_KnownClasses, hv_IgnoreClassID, &hv_Index);

      /*========== if (|Index| > 0 and Index != -1) ==========*/
      T_tuple_length(hv_Index,&TTemp[SP++]);
      create_tuple_i(&TTemp[SP++],0);
      T_tuple_greater(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-2]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-2]=TTemp[SP];
      SP--;
      create_tuple_i(&TTemp[SP++],-1);
      T_tuple_not_equal(hv_Index,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      T_tuple_and(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-2]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-2]=TTemp[SP];
      SP--;
      if(get_i(TTemp[SP-1],0))
      {
        /* throw(...); only in hdevelop*/
      }
      destroy_tuple(TTemp[--SP]);
      /*========== end if ==========*/
     }
     destroy_tuple(TTemp[SP--]);
     destroy_tuple(TTemp[SP--]);
     destroy_tuple(TTemp[SP]);
    }
    else
    {
     destroy_tuple(TTemp[SP--]);
     destroy_tuple(TTemp[SP--]);
     destroy_tuple(TTemp[SP--]);
     destroy_tuple(TTemp[SP--]);
     destroy_tuple(TTemp[SP]);
    }/*========== end for ========*/

  }
  else
  {
  destroy_tuple(TTemp[--SP]);
  /*========== elseif (DLModelType == 'detection') ==========*/

  create_tuple_s(&TTemp[SP++],"detection");
  T_tuple_equal(hv_DLModelType,TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-1]=TTemp[SP];
  if(get_i(TTemp[SP-1],0))
  {
    /*Check if segmentation specific parameters are set.*/
    /*get_dict_param (DLPreprocessParam, 'key_exists', ParamNamesSegmentation, KeysExists)*/
    create_tuple_s(&TTemp[SP++],"key_exists");
    destroy_tuple(hv_KeysExists);
    /***/T_get_dict_param(hv_DLPreprocessParam, TTemp[SP-1], hv_ParamNamesSegmentation, 
        &hv_KeysExists);
    destroy_tuple(TTemp[--SP]);

    /*If they are present, check that they are [].*/
    /*========== for IndexParam := 0 to |ParamNamesSegmentation| - 1 by 1 ==========*/
    T_tuple_length(hv_ParamNamesSegmentation,&TTemp[SP++]);
    create_tuple_i(&TTemp[SP++],1);
    T_tuple_sub(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-2]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-2]=TTemp[SP];
    SP--;
    create_tuple_i(&TTemp[SP++],1);
    create_tuple_i(&TTemp[SP++],0);
    T_tuple_greater(TTemp[SP-1],TTemp[SP-3],&TTemp[SP]);
    SP++;
    T_tuple_equal(TTemp[SP-2],TTemp[SP-4],&TTemp[SP]);
    if(get_i(TTemp[SP],0) ||
       (!((( get_i(TTemp[SP-1],0)) && (get_d(TTemp[SP-3],0)>0)) ||
          ((!get_i(TTemp[SP-1],0)) && (get_d(TTemp[SP-3],0)<0)))))
    {
     destroy_tuple(TTemp[SP--]);
     destroy_tuple(TTemp[SP]);
     T_tuple_sub(TTemp[SP-1],TTemp[SP-2],&TTemp[SP]);
     destroy_tuple(hv_IndexParam);
     copy_tuple(TTemp[SP],&hv_IndexParam);
     destroy_tuple(TTemp[SP--]);
     destroy_tuple(TTemp[SP]);
     for(;;)
     {
     T_tuple_add(hv_IndexParam,TTemp[SP-1],&TTemp[SP]);
     destroy_tuple(hv_IndexParam);
     copy_tuple(TTemp[SP],&hv_IndexParam);
     destroy_tuple(TTemp[SP]);
     if(get_d(TTemp[SP-1],0)<0)
      T_tuple_less(hv_IndexParam,TTemp[SP-2],&TTemp[SP]);
     else
      T_tuple_greater(hv_IndexParam,TTemp[SP-2],&TTemp[SP]);
     if(get_i(TTemp[SP],0)) break;
     destroy_tuple(TTemp[SP]);
     /*========== for ==========*/

      /*========== if (KeysExists[IndexParam]) ==========*/
      T_tuple_select(hv_KeysExists,hv_IndexParam,&TTemp[SP++]);
      if(get_i(TTemp[SP-1],0))
      {
        /*get_dict_tuple (DLPreprocessParam, ParamNamesSegmentation[IndexParam], Value)*/
        T_tuple_select(hv_ParamNamesSegmentation,hv_IndexParam,&TTemp[SP++]);
        destroy_tuple(hv_Value);
        /***/T_get_dict_tuple(hv_DLPreprocessParam, TTemp[SP-1], &hv_Value);
        destroy_tuple(TTemp[--SP]);

        /*========== if (Value != []) ==========*/
        create_tuple(&TTemp[SP++],0);
        T_tuple_not_equal(hv_Value,TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-1]=TTemp[SP];
        if(get_i(TTemp[SP-1],0))
        {
          /* throw(...); only in hdevelop*/
        }
        destroy_tuple(TTemp[--SP]);
        /*========== end if ==========*/
      }
      destroy_tuple(TTemp[--SP]);
      /*========== end if ==========*/
     }
     destroy_tuple(TTemp[SP--]);
     destroy_tuple(TTemp[SP--]);
     destroy_tuple(TTemp[SP]);
    }
    else
    {
     destroy_tuple(TTemp[SP--]);
     destroy_tuple(TTemp[SP--]);
     destroy_tuple(TTemp[SP--]);
     destroy_tuple(TTemp[SP--]);
     destroy_tuple(TTemp[SP]);
    }/*========== end for ========*/

    /*Check optional parameters.*/
    /*get_dict_param (DLPreprocessParam, 'key_exists', ParamNamesDetectionOptional, OptionalKeysExist)*/
    create_tuple_s(&TTemp[SP++],"key_exists");
    destroy_tuple(hv_OptionalKeysExist);
    /***/T_get_dict_param(hv_DLPreprocessParam, TTemp[SP-1], hv_ParamNamesDetectionOptional, 
        &hv_OptionalKeysExist);
    destroy_tuple(TTemp[--SP]);

    /*========== if (OptionalKeysExist[0]) ==========*/
    create_tuple_i(&TTemp[SP++],0);
    T_tuple_select(hv_OptionalKeysExist,TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    if(get_i(TTemp[SP-1],0))
    {
      /*Check 'instance_type'.*/
      /*get_dict_tuple (DLPreprocessParam, ParamNamesDetectionOptional[0], InstanceType)*/
      create_tuple_i(&TTemp[SP++],0);
      T_tuple_select(hv_ParamNamesDetectionOptional,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      destroy_tuple(hv_InstanceType);
      /***/T_get_dict_tuple(hv_DLPreprocessParam, TTemp[SP-1], &hv_InstanceType);
      destroy_tuple(TTemp[--SP]);

      /*========== if (find(['rectangle1', 'rectangle2', 'mask'],InstanceType) == -1) ==========*/
      create_tuple(&TTemp[SP++],3);
      set_s(TTemp[SP-1],"rectangle1",0);
      set_s(TTemp[SP-1],"rectangle2",1);
      set_s(TTemp[SP-1],"mask",2);
      T_tuple_find(TTemp[SP-1],hv_InstanceType,&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      create_tuple_i(&TTemp[SP++],-1);
      T_tuple_equal(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-2]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-2]=TTemp[SP];
      SP--;
      if(get_i(TTemp[SP-1],0))
      {
        /* throw(...); only in hdevelop*/
      }
      destroy_tuple(TTemp[--SP]);
      /*========== end if ==========*/
    }
    destroy_tuple(TTemp[--SP]);
    /*========== end if ==========*/
    /*If instance_segmentation is set we might overwrite the instance_type for the preprocessing.*/
    /*========== if (OptionalKeysExist[3]) ==========*/
    create_tuple_i(&TTemp[SP++],3);
    T_tuple_select(hv_OptionalKeysExist,TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    if(get_i(TTemp[SP-1],0))
    {
      /*get_dict_tuple (DLPreprocessParam, ParamNamesDetectionOptional[3], IsInstanceSegmentation)*/
      create_tuple_i(&TTemp[SP++],3);
      T_tuple_select(hv_ParamNamesDetectionOptional,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      destroy_tuple(hv_IsInstanceSegmentation);
      /***/T_get_dict_tuple(hv_DLPreprocessParam, TTemp[SP-1], &hv_IsInstanceSegmentation);
      destroy_tuple(TTemp[--SP]);

      /*========== if (find([true, false, 'true', 'false'],IsInstanceSegmentation) == -1) ==========*/
      create_tuple(&TTemp[SP++],4);
      set_i(TTemp[SP-1],1      ,0);
      set_i(TTemp[SP-1],0      ,1);
      set_s(TTemp[SP-1],"true",2);
      set_s(TTemp[SP-1],"false",3);
      T_tuple_find(TTemp[SP-1],hv_IsInstanceSegmentation,&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      create_tuple_i(&TTemp[SP++],-1);
      T_tuple_equal(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-2]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-2]=TTemp[SP];
      SP--;
      if(get_i(TTemp[SP-1],0))
      {
        /* throw(...); only in hdevelop*/
      }
      destroy_tuple(TTemp[--SP]);
      /*========== end if ==========*/
    }
    destroy_tuple(TTemp[--SP]);
    /*========== end if ==========*/
    /*========== if (OptionalKeysExist[1]) ==========*/
    create_tuple_i(&TTemp[SP++],1);
    T_tuple_select(hv_OptionalKeysExist,TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    if(get_i(TTemp[SP-1],0))
    {
      /*Check 'ignore_direction'.*/
      /*get_dict_tuple (DLPreprocessParam, ParamNamesDetectionOptional[1], IgnoreDirection)*/
      create_tuple_i(&TTemp[SP++],1);
      T_tuple_select(hv_ParamNamesDetectionOptional,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      destroy_tuple(hv_IgnoreDirection);
      /***/T_get_dict_tuple(hv_DLPreprocessParam, TTemp[SP-1], &hv_IgnoreDirection);
      destroy_tuple(TTemp[--SP]);

      /*========== if (find([true, false],IgnoreDirection) == -1) ==========*/
      create_tuple(&TTemp[SP++],2);
      set_i(TTemp[SP-1],1      ,0);
      set_i(TTemp[SP-1],0      ,1);
      T_tuple_find(TTemp[SP-1],hv_IgnoreDirection,&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      create_tuple_i(&TTemp[SP++],-1);
      T_tuple_equal(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-2]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-2]=TTemp[SP];
      SP--;
      if(get_i(TTemp[SP-1],0))
      {
        /* throw(...); only in hdevelop*/
      }
      destroy_tuple(TTemp[--SP]);
      /*========== end if ==========*/
    }
    destroy_tuple(TTemp[--SP]);
    /*========== end if ==========*/
    /*========== if (OptionalKeysExist[2]) ==========*/
    create_tuple_i(&TTemp[SP++],2);
    T_tuple_select(hv_OptionalKeysExist,TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    if(get_i(TTemp[SP-1],0))
    {
      /*Check 'class_ids_no_orientation'.*/
      /*get_dict_tuple (DLPreprocessParam, ParamNamesDetectionOptional[2], ClassIDsNoOrientation)*/
      create_tuple_i(&TTemp[SP++],2);
      T_tuple_select(hv_ParamNamesDetectionOptional,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      destroy_tuple(hv_ClassIDsNoOrientation);
      /***/T_get_dict_tuple(hv_DLPreprocessParam, TTemp[SP-1], &hv_ClassIDsNoOrientation);
      destroy_tuple(TTemp[--SP]);

      /*tuple_sem_type_elem (ClassIDsNoOrientation, SemTypes)*/
      destroy_tuple(hv_SemTypes);
      /***/T_tuple_sem_type_elem(hv_ClassIDsNoOrientation, &hv_SemTypes);

      /*========== if (ClassIDsNoOrientation != [] and sum(SemTypes [==] 'integer') != |ClassIDsNoOrientation|) ==========*/
      create_tuple(&TTemp[SP++],0);
      T_tuple_not_equal(hv_ClassIDsNoOrientation,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      create_tuple_s(&TTemp[SP++],"integer");
      T_tuple_equal_elem(hv_SemTypes,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      T_tuple_sum(TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      T_tuple_length(hv_ClassIDsNoOrientation,&TTemp[SP++]);
      T_tuple_not_equal(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-2]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-2]=TTemp[SP];
      SP--;
      T_tuple_and(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-2]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-2]=TTemp[SP];
      SP--;
      if(get_i(TTemp[SP-1],0))
      {
        /* throw(...); only in hdevelop*/
      }
      else
      {
        /*========== if (ClassIDsNoOrientation != [] and sum(ClassIDsNoOrientation [>=] 0) != |ClassIDsNoOrientation|) ==========*/
        create_tuple(&TTemp[SP++],0);
        T_tuple_not_equal(hv_ClassIDsNoOrientation,TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-1]=TTemp[SP];
        create_tuple_i(&TTemp[SP++],0);
        T_tuple_greater_equal_elem(hv_ClassIDsNoOrientation,TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-1]=TTemp[SP];
        T_tuple_sum(TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-1]=TTemp[SP];
        T_tuple_length(hv_ClassIDsNoOrientation,&TTemp[SP++]);
        T_tuple_not_equal(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-2]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-2]=TTemp[SP];
        SP--;
        T_tuple_and(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-2]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-2]=TTemp[SP];
        SP--;
        if(get_i(TTemp[SP-1],0))
        {
          /* throw(...); only in hdevelop*/
        }
        destroy_tuple(TTemp[--SP]);
        /*========== end if ==========*/
      }
      destroy_tuple(TTemp[--SP]);
      /*========== end if ==========*/
    }
    destroy_tuple(TTemp[--SP]);
    /*========== end if ==========*/
  }
  }
  destroy_tuple(TTemp[--SP]);
  /*========== end if ==========*/
  /**/
  /*========== return ==========*/

  /* Clear temporary tuple stack */
  while (SP > 0)
    destroy_tuple(TTemp[--SP]);
  /* Clear temporary tuple vectors stack*/
  while (SPTV > 0)
    V_destroy_vector(TVTemp[--SPTV]);
  /* Clear local control variables */
  destroy_tuple(hv_CheckParams);
  destroy_tuple(hv_KeyExists);
  destroy_tuple(hv_DLModelType);
  destroy_tuple(hv_Exception);
  destroy_tuple(hv_SupportedModelTypes);
  destroy_tuple(hv_Index);
  destroy_tuple(hv_ParamNamesGeneral);
  destroy_tuple(hv_ParamNamesSegmentation);
  destroy_tuple(hv_ParamNamesDetectionOptional);
  destroy_tuple(hv_ParamNamesPreprocessingOptional);
  destroy_tuple(hv_ParamNames3DGrippingPointsOptional);
  destroy_tuple(hv_ParamNamesAll);
  destroy_tuple(hv_ParamNames);
  destroy_tuple(hv_KeysExists);
  destroy_tuple(hv_I);
  destroy_tuple(hv_Exists);
  destroy_tuple(hv_InputKeys);
  destroy_tuple(hv_Key);
  destroy_tuple(hv_Value);
  destroy_tuple(hv_Indices);
  destroy_tuple(hv_ValidValues);
  destroy_tuple(hv_ValidTypes);
  destroy_tuple(hv_V);
  destroy_tuple(hv_T);
  destroy_tuple(hv_IsInt);
  destroy_tuple(hv_ValidTypesListing);
  destroy_tuple(hv_ValidValueListing);
  destroy_tuple(hv_EmptyStrings);
  destroy_tuple(hv_ImageRangeMinExists);
  destroy_tuple(hv_ImageRangeMaxExists);
  destroy_tuple(hv_ImageRangeMin);
  destroy_tuple(hv_ImageRangeMax);
  destroy_tuple(hv_IndexParam);
  destroy_tuple(hv_SetBackgroundID);
  destroy_tuple(hv_ClassIDsBackground);
  destroy_tuple(hv_Intersection);
  destroy_tuple(hv_IgnoreClassIDs);
  destroy_tuple(hv_KnownClasses);
  destroy_tuple(hv_IgnoreClassID);
  destroy_tuple(hv_OptionalKeysExist);
  destroy_tuple(hv_InstanceType);
  destroy_tuple(hv_IsInstanceSegmentation);
  destroy_tuple(hv_IgnoreDirection);
  destroy_tuple(hv_ClassIDsNoOrientation);
  destroy_tuple(hv_SemTypes);

  return;

  /****************************************************/
  /******************     End procedure   *************/
  /****************************************************/

}

/* Chapter: Deep Learning / Model*/
/* Short Description: Compute 3D normals. */
void compute_normals_xyz (Hobject ho_x, Hobject ho_y, Hobject ho_z, Hobject *ho_NXImage, 
    Hobject *ho_NYImage, Hobject *ho_NZImage, Htuple hv_Smoothing)
{


  /* Stack for temporary tuples */
  Htuple   TTemp[100];
  int      SP=0;
  /* Stack for temporary objects */
  Hobject  OTemp[20] = {0};
  int      SPO=0;
  /* Stack for temporary tuple vectors */
  Hvector  TVTemp[100] = {0};
  int      SPTV=0;

  /* Local iconic variables */
  Hobject  ho_xScaled, ho_yScaled, ho_zScaled, ho_xDiffRow;
  Hobject  ho_xDiffCol, ho_yDiffRow, ho_yDiffCol, ho_zDiffRow;
  Hobject  ho_zDiffCol, ho_ImageResult, ho_ImageResult2, ho_NXRaw;
  Hobject  ho_NYRaw, ho_NZRaw, ho_NXSquare, ho_NYSquare, ho_NZSquare;
  Hobject  ho_ImageResult1, ho_SqrtImage;

  /* Local control variables */
  Htuple  hv_Factor, hv_MaskRow, hv_MaskCol;

  /* Initialize iconic variables */
  gen_empty_obj(&ho_xScaled);
  gen_empty_obj(&ho_yScaled);
  gen_empty_obj(&ho_zScaled);
  gen_empty_obj(&ho_xDiffRow);
  gen_empty_obj(&ho_xDiffCol);
  gen_empty_obj(&ho_yDiffRow);
  gen_empty_obj(&ho_yDiffCol);
  gen_empty_obj(&ho_zDiffRow);
  gen_empty_obj(&ho_zDiffCol);
  gen_empty_obj(&ho_ImageResult);
  gen_empty_obj(&ho_ImageResult2);
  gen_empty_obj(&ho_NXRaw);
  gen_empty_obj(&ho_NYRaw);
  gen_empty_obj(&ho_NZRaw);
  gen_empty_obj(&ho_NXSquare);
  gen_empty_obj(&ho_NYSquare);
  gen_empty_obj(&ho_NZSquare);
  gen_empty_obj(&ho_ImageResult1);
  gen_empty_obj(&ho_SqrtImage);
  gen_empty_obj(&(*ho_NXImage));
  gen_empty_obj(&(*ho_NYImage));
  gen_empty_obj(&(*ho_NZImage));

  /* Initialize control variables */
  create_tuple(&hv_Factor,0);
  create_tuple(&hv_MaskRow,0);
  create_tuple(&hv_MaskCol,0);

  /****************************************************/
  /******************   Begin procedure   *************/
  /****************************************************/

  /*For numerical reasons we scale the input data*/
  /*Factor := 1e6*/
  reuse_tuple_d(&hv_Factor,1e6);

  /*scale_image (x, xScaled, Factor, 0)*/
  create_tuple_i(&TTemp[SP++],0);
  clear_obj(ho_xScaled);
  /***/T_scale_image(ho_x, &ho_xScaled, hv_Factor, TTemp[SP-1]);
  destroy_tuple(TTemp[--SP]);

  /*scale_image (y, yScaled, Factor, 0)*/
  create_tuple_i(&TTemp[SP++],0);
  clear_obj(ho_yScaled);
  /***/T_scale_image(ho_y, &ho_yScaled, hv_Factor, TTemp[SP-1]);
  destroy_tuple(TTemp[--SP]);

  /*scale_image (z, zScaled, Factor, 0)*/
  create_tuple_i(&TTemp[SP++],0);
  clear_obj(ho_zScaled);
  /***/T_scale_image(ho_z, &ho_zScaled, hv_Factor, TTemp[SP-1]);
  destroy_tuple(TTemp[--SP]);


  /*Filter for diffs in row/col direction*/
  /*MaskRow := [2, 1, 1.0, 1, -1]*/
  create_tuple(&TTemp[SP++],5);
  set_i(TTemp[SP-1],2  ,0);
  set_i(TTemp[SP-1],1  ,1);
  set_d(TTemp[SP-1],1.0  ,2);
  set_i(TTemp[SP-1],1  ,3);
  set_i(TTemp[SP-1],-1  ,4);
  destroy_tuple(hv_MaskRow);
  hv_MaskRow=TTemp[--SP];

  /*MaskCol := [1, 2, 1.0, -1, 1]*/
  create_tuple(&TTemp[SP++],5);
  set_i(TTemp[SP-1],1  ,0);
  set_i(TTemp[SP-1],2  ,1);
  set_d(TTemp[SP-1],1.0  ,2);
  set_i(TTemp[SP-1],-1  ,3);
  set_i(TTemp[SP-1],1  ,4);
  destroy_tuple(hv_MaskCol);
  hv_MaskCol=TTemp[--SP];

  /*convol_image (xScaled, xDiffRow, MaskRow, 'continued')*/
  create_tuple_s(&TTemp[SP++],"continued");
  clear_obj(ho_xDiffRow);
  /***/T_convol_image(ho_xScaled, &ho_xDiffRow, hv_MaskRow, TTemp[SP-1]);
  destroy_tuple(TTemp[--SP]);

  /*convol_image (xScaled, xDiffCol, MaskCol, 'continued')*/
  create_tuple_s(&TTemp[SP++],"continued");
  clear_obj(ho_xDiffCol);
  /***/T_convol_image(ho_xScaled, &ho_xDiffCol, hv_MaskCol, TTemp[SP-1]);
  destroy_tuple(TTemp[--SP]);

  /*convol_image (yScaled, yDiffRow, MaskRow, 'continued')*/
  create_tuple_s(&TTemp[SP++],"continued");
  clear_obj(ho_yDiffRow);
  /***/T_convol_image(ho_yScaled, &ho_yDiffRow, hv_MaskRow, TTemp[SP-1]);
  destroy_tuple(TTemp[--SP]);

  /*convol_image (yScaled, yDiffCol, MaskCol, 'continued')*/
  create_tuple_s(&TTemp[SP++],"continued");
  clear_obj(ho_yDiffCol);
  /***/T_convol_image(ho_yScaled, &ho_yDiffCol, hv_MaskCol, TTemp[SP-1]);
  destroy_tuple(TTemp[--SP]);

  /*convol_image (zScaled, zDiffRow, MaskRow, 'continued')*/
  create_tuple_s(&TTemp[SP++],"continued");
  clear_obj(ho_zDiffRow);
  /***/T_convol_image(ho_zScaled, &ho_zDiffRow, hv_MaskRow, TTemp[SP-1]);
  destroy_tuple(TTemp[--SP]);

  /*convol_image (zScaled, zDiffCol, MaskCol, 'continued')*/
  create_tuple_s(&TTemp[SP++],"continued");
  clear_obj(ho_zDiffCol);
  /***/T_convol_image(ho_zScaled, &ho_zDiffCol, hv_MaskCol, TTemp[SP-1]);
  destroy_tuple(TTemp[--SP]);

  /**/
  /*Calculate normal as cross product*/
  /*mult_image (yDiffRow, zDiffCol, ImageResult, 1.0, 0)*/
  clear_obj(ho_ImageResult);
  /***/mult_image(ho_yDiffRow, ho_zDiffCol, &ho_ImageResult, 1.0, 0);

  /*mult_image (zDiffRow, yDiffCol, ImageResult2, -1.0, 0)*/
  clear_obj(ho_ImageResult2);
  /***/mult_image(ho_zDiffRow, ho_yDiffCol, &ho_ImageResult2, -1.0, 0);

  /*add_image (ImageResult, ImageResult2, NXRaw, 1.0, 0)*/
  clear_obj(ho_NXRaw);
  /***/add_image(ho_ImageResult, ho_ImageResult2, &ho_NXRaw, 1.0, 0);

  /**/
  /*mult_image (xDiffRow, zDiffCol, ImageResult, -1.0, 0)*/
  clear_obj(ho_ImageResult);
  /***/mult_image(ho_xDiffRow, ho_zDiffCol, &ho_ImageResult, -1.0, 0);

  /*mult_image (zDiffRow, xDiffCol, ImageResult2, 1.0, 0)*/
  clear_obj(ho_ImageResult2);
  /***/mult_image(ho_zDiffRow, ho_xDiffCol, &ho_ImageResult2, 1.0, 0);

  /*add_image (ImageResult, ImageResult2, NYRaw, 1.0, 0)*/
  clear_obj(ho_NYRaw);
  /***/add_image(ho_ImageResult, ho_ImageResult2, &ho_NYRaw, 1.0, 0);

  /**/
  /*mult_image (xDiffRow, yDiffCol, ImageResult, 1.0, 0)*/
  clear_obj(ho_ImageResult);
  /***/mult_image(ho_xDiffRow, ho_yDiffCol, &ho_ImageResult, 1.0, 0);

  /*mult_image (yDiffRow, xDiffCol, ImageResult2, -1.0, 0)*/
  clear_obj(ho_ImageResult2);
  /***/mult_image(ho_yDiffRow, ho_xDiffCol, &ho_ImageResult2, -1.0, 0);

  /*add_image (ImageResult, ImageResult2, NZRaw, 1.0, 0)*/
  clear_obj(ho_NZRaw);
  /***/add_image(ho_ImageResult, ho_ImageResult2, &ho_NZRaw, 1.0, 0);


  /*Smooth*/
  /*-> 5 is used as it is used in surface_normals_object_model_3d - 'xyz_mapping'*/
  /*========== if (Smoothing) ==========*/
  copy_tuple(hv_Smoothing,&TTemp[SP++]);
  if(get_i(TTemp[SP-1],0))
  {
    /*mean_image (NXRaw, NXRaw, 5, 5)*/
    /***/mean_image(ho_NXRaw, &(OTemp[SPO]), 5, 5);
    SPO++;
    clear_obj(ho_NXRaw);
    ho_NXRaw = OTemp[--SPO];

    /*mean_image (NYRaw, NYRaw, 5, 5)*/
    /***/mean_image(ho_NYRaw, &(OTemp[SPO]), 5, 5);
    SPO++;
    clear_obj(ho_NYRaw);
    ho_NYRaw = OTemp[--SPO];

    /*mean_image (NZRaw, NZRaw, 5, 5)*/
    /***/mean_image(ho_NZRaw, &(OTemp[SPO]), 5, 5);
    SPO++;
    clear_obj(ho_NZRaw);
    ho_NZRaw = OTemp[--SPO];

  }
  destroy_tuple(TTemp[--SP]);
  /*========== end if ==========*/

  /*Normalize*/
  /*mult_image (NXRaw, NXRaw, NXSquare, 1.0, 0)*/
  clear_obj(ho_NXSquare);
  /***/mult_image(ho_NXRaw, ho_NXRaw, &ho_NXSquare, 1.0, 0);

  /*mult_image (NYRaw, NYRaw, NYSquare, 1.0, 0)*/
  clear_obj(ho_NYSquare);
  /***/mult_image(ho_NYRaw, ho_NYRaw, &ho_NYSquare, 1.0, 0);

  /*mult_image (NZRaw, NZRaw, NZSquare, 1.0, 0)*/
  clear_obj(ho_NZSquare);
  /***/mult_image(ho_NZRaw, ho_NZRaw, &ho_NZSquare, 1.0, 0);

  /*add_image (NXSquare, NYSquare, ImageResult1, 1.0, 0)*/
  clear_obj(ho_ImageResult1);
  /***/add_image(ho_NXSquare, ho_NYSquare, &ho_ImageResult1, 1.0, 0);

  /*add_image (ImageResult1, NZSquare, ImageResult2, 1.0, 0)*/
  clear_obj(ho_ImageResult2);
  /***/add_image(ho_ImageResult1, ho_NZSquare, &ho_ImageResult2, 1.0, 0);

  /*sqrt_image (ImageResult2, SqrtImage)*/
  clear_obj(ho_SqrtImage);
  /***/sqrt_image(ho_ImageResult2, &ho_SqrtImage);

  /**/
  /*div_image (NXRaw, SqrtImage, NXImage, 1.0, 0)*/
  clear_obj((*ho_NXImage));
  /***/div_image(ho_NXRaw, ho_SqrtImage, &(*ho_NXImage), 1.0, 0);

  /*div_image (NYRaw, SqrtImage, NYImage, 1.0, 0)*/
  clear_obj((*ho_NYImage));
  /***/div_image(ho_NYRaw, ho_SqrtImage, &(*ho_NYImage), 1.0, 0);

  /*div_image (NZRaw, SqrtImage, NZImage, 1.0, 0)*/
  clear_obj((*ho_NZImage));
  /***/div_image(ho_NZRaw, ho_SqrtImage, &(*ho_NZImage), 1.0, 0);

  /*========== return ==========*/

  /* Clear temporary tuple stack */
  while (SP > 0)
    destroy_tuple(TTemp[--SP]);
  /* Clear temporary tuple vectors stack*/
  while (SPTV > 0)
    V_destroy_vector(TVTemp[--SPTV]);
  /* Clear local iconic variables */
  clear_obj(ho_xScaled);
  clear_obj(ho_yScaled);
  clear_obj(ho_zScaled);
  clear_obj(ho_xDiffRow);
  clear_obj(ho_xDiffCol);
  clear_obj(ho_yDiffRow);
  clear_obj(ho_yDiffCol);
  clear_obj(ho_zDiffRow);
  clear_obj(ho_zDiffCol);
  clear_obj(ho_ImageResult);
  clear_obj(ho_ImageResult2);
  clear_obj(ho_NXRaw);
  clear_obj(ho_NYRaw);
  clear_obj(ho_NZRaw);
  clear_obj(ho_NXSquare);
  clear_obj(ho_NYSquare);
  clear_obj(ho_NZSquare);
  clear_obj(ho_ImageResult1);
  clear_obj(ho_SqrtImage);

  /* Clear local control variables */
  destroy_tuple(hv_Factor);
  destroy_tuple(hv_MaskRow);
  destroy_tuple(hv_MaskCol);

  return;

  /****************************************************/
  /******************     End procedure   *************/
  /****************************************************/

}

/* Chapter: OCR / Deep OCR*/
/* Short Description: This procedure converts Deep OCR Detection results to an Object Detection results. */
void convert_ocr_detection_result_to_object_detection (Htuple hv_OcrResults, Htuple *hv_DetectionResults)
{

  /* Stack for temporary tuples */
  Htuple   TTemp[100];
  int      SP=0;
  /* Stack for temporary objects */
  Hobject  OTemp[100] = {0};
  int      SPO=0;
  /* Stack for temporary tuple vectors */
  Hvector  TVTemp[100] = {0};
  int      SPTV=0;
  /* Stack for temporary object vectors */
  Hvector  OVTemp[100] = {0};
  int      SPOV=0;

  /* Local iconic variables */

  /* Local control variables */
  Htuple  hv_Index, hv_OcrResult, hv_RequiredKeysExist;
  Htuple  hv_DetectionResult, hv___Tmp_Ctrl_Type;

  /* Initialize control variables */
  create_tuple(&hv_Index,0);
  create_tuple(&hv_OcrResult,0);
  create_tuple(&hv_RequiredKeysExist,0);
  create_tuple(&hv_DetectionResult,0);
  create_tuple(&hv___Tmp_Ctrl_Type,0);
  create_tuple(&(*hv_DetectionResults),0);

  /****************************************************/
  /******************   Begin procedure   *************/
  /****************************************************/

  /**/
  /*Convert Deep OCR Detection results*/
  /*to Object Detection results.*/
  /**/
  /*Create DetectionResults Dict*/
  /*tuple_gen_const (|OcrResults|, constant('HNULL'), DetectionResults)*/
  T_tuple_length(hv_OcrResults,&TTemp[SP++]);
  create_tuple_s(&TTemp[SP++],"HNULL");
  T_tuple_constant(TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-1]=TTemp[SP];
  destroy_tuple((*hv_DetectionResults));
  /***/T_tuple_gen_const(TTemp[SP-2], TTemp[SP-1], &(*hv_DetectionResults));
  destroy_tuple(TTemp[--SP]);
  destroy_tuple(TTemp[--SP]);

  /*========== for Index := 0 to |OcrResults| - 1 by 1 ==========*/
  T_tuple_length(hv_OcrResults,&TTemp[SP++]);
  create_tuple_i(&TTemp[SP++],1);
  T_tuple_sub(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-2]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-2]=TTemp[SP];
  SP--;
  create_tuple_i(&TTemp[SP++],1);
  create_tuple_i(&TTemp[SP++],0);
  T_tuple_greater(TTemp[SP-1],TTemp[SP-3],&TTemp[SP]);
  SP++;
  T_tuple_equal(TTemp[SP-2],TTemp[SP-4],&TTemp[SP]);
  if(get_i(TTemp[SP],0) ||
     (!((( get_i(TTemp[SP-1],0)) && (get_d(TTemp[SP-3],0)>0)) ||
        ((!get_i(TTemp[SP-1],0)) && (get_d(TTemp[SP-3],0)<0)))))
  {
   destroy_tuple(TTemp[SP--]);
   destroy_tuple(TTemp[SP]);
   T_tuple_sub(TTemp[SP-1],TTemp[SP-2],&TTemp[SP]);
   destroy_tuple(hv_Index);
   copy_tuple(TTemp[SP],&hv_Index);
   destroy_tuple(TTemp[SP--]);
   destroy_tuple(TTemp[SP]);
   for(;;)
   {
   T_tuple_add(hv_Index,TTemp[SP-1],&TTemp[SP]);
   destroy_tuple(hv_Index);
   copy_tuple(TTemp[SP],&hv_Index);
   destroy_tuple(TTemp[SP]);
   if(get_d(TTemp[SP-1],0)<0)
    T_tuple_less(hv_Index,TTemp[SP-2],&TTemp[SP]);
   else
    T_tuple_greater(hv_Index,TTemp[SP-2],&TTemp[SP]);
   if(get_i(TTemp[SP],0)) break;
   destroy_tuple(TTemp[SP]);
   /*========== for ==========*/

    /*OcrResult := OcrResults[Index]*/
    T_tuple_select(hv_OcrResults,hv_Index,&TTemp[SP++]);
    destroy_tuple(hv_OcrResult);
    hv_OcrResult=TTemp[--SP];

    /*Check if input is valid*/
    /*get_dict_param (OcrResult, 'key_exists', 'words', RequiredKeysExist)*/
    create_tuple_s(&TTemp[SP++],"key_exists");
    create_tuple_s(&TTemp[SP++],"words");
    destroy_tuple(hv_RequiredKeysExist);
    /***/T_get_dict_param(hv_OcrResult, TTemp[SP-2], TTemp[SP-1], &hv_RequiredKeysExist);
    destroy_tuple(TTemp[--SP]);
    destroy_tuple(TTemp[--SP]);

    /*========== if (sum(RequiredKeysExist) != |RequiredKeysExist|) ==========*/
    T_tuple_sum(hv_RequiredKeysExist,&TTemp[SP++]);
    T_tuple_length(hv_RequiredKeysExist,&TTemp[SP++]);
    T_tuple_not_equal(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-2]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-2]=TTemp[SP];
    SP--;
    if(get_i(TTemp[SP-1],0))
    {
      /* throw(...); only in hdevelop*/
    }
    destroy_tuple(TTemp[--SP]);
    /*========== end if ==========*/
    /*get_dict_param (__get_dict_tuple( OcrResult, 'words'), 'key_exists', ['row', 'col', 'phi', 'length1', 'length2'], RequiredKeysExist)*/
    create_tuple_s(&TTemp[SP++],"words");
    T_get_dict_tuple(hv_OcrResult,TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    create_tuple_s(&TTemp[SP++],"key_exists");
    create_tuple(&TTemp[SP++],5);
    set_s(TTemp[SP-1],"row",0);
    set_s(TTemp[SP-1],"col",1);
    set_s(TTemp[SP-1],"phi",2);
    set_s(TTemp[SP-1],"length1",3);
    set_s(TTemp[SP-1],"length2",4);
    destroy_tuple(hv_RequiredKeysExist);
    /***/T_get_dict_param(TTemp[SP-3], TTemp[SP-2], TTemp[SP-1], &hv_RequiredKeysExist);
    destroy_tuple(TTemp[--SP]);
    destroy_tuple(TTemp[--SP]);
    destroy_tuple(TTemp[--SP]);

    /*========== if (sum(RequiredKeysExist) != |RequiredKeysExist|) ==========*/
    T_tuple_sum(hv_RequiredKeysExist,&TTemp[SP++]);
    T_tuple_length(hv_RequiredKeysExist,&TTemp[SP++]);
    T_tuple_not_equal(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-2]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-2]=TTemp[SP];
    SP--;
    if(get_i(TTemp[SP-1],0))
    {
      /* throw(...); only in hdevelop*/
    }
    destroy_tuple(TTemp[--SP]);
    /*========== end if ==========*/
    /*Convert ocr detection result to object detection*/
    /*create_dict (DetectionResult)*/
    destroy_tuple(hv_DetectionResult);
    /***/T_create_dict(&hv_DetectionResult);

    /*get_dict_param (__get_dict_tuple( OcrResult, ['words']), 'key_data_type', ['row'], __Tmp_Ctrl_Type)*/
    create_tuple_s(&TTemp[SP++],"words");
    T_get_dict_tuple(hv_OcrResult,TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    create_tuple_s(&TTemp[SP++],"key_data_type");
    create_tuple_s(&TTemp[SP++],"row");
    destroy_tuple(hv___Tmp_Ctrl_Type);
    /***/T_get_dict_param(TTemp[SP-3], TTemp[SP-2], TTemp[SP-1], &hv___Tmp_Ctrl_Type);
    destroy_tuple(TTemp[--SP]);
    destroy_tuple(TTemp[--SP]);
    destroy_tuple(TTemp[--SP]);

    /*========== if (__Tmp_Ctrl_Type == 'object') ==========*/
    create_tuple_s(&TTemp[SP++],"object");
    T_tuple_equal(hv___Tmp_Ctrl_Type,TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    if(get_i(TTemp[SP-1],0))
    {
      /*set_dict_object (__get_dict_object( __get_dict_tuple( OcrResult, ['words']), ['row']), DetectionResult, ['bbox_row'])*/
      create_tuple_s(&TTemp[SP++],"words");
      T_get_dict_tuple(hv_OcrResult,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      create_tuple_s(&TTemp[SP++],"row");
      T_get_dict_object(&OTemp[SPO++],TTemp[SP-2],TTemp[SP-1]);
      destroy_tuple(TTemp[SP-2]);
      destroy_tuple(TTemp[SP-1]);
      SP-=2;
      create_tuple_s(&TTemp[SP++],"bbox_row");
      /***/T_set_dict_object(OTemp[SPO-1], hv_DetectionResult, TTemp[SP-1]);
      clear_obj(OTemp[--SPO]);
      destroy_tuple(TTemp[--SP]);

    }
    else
    {
      /*set_dict_tuple (DetectionResult, ['bbox_row'], __get_dict_tuple( __get_dict_tuple( OcrResult, ['words']), ['row']))*/
      create_tuple_s(&TTemp[SP++],"bbox_row");
      create_tuple_s(&TTemp[SP++],"words");
      T_get_dict_tuple(hv_OcrResult,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      create_tuple_s(&TTemp[SP++],"row");
      T_get_dict_tuple(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-2]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-2]=TTemp[SP];
      SP--;
      /***/T_set_dict_tuple(hv_DetectionResult, TTemp[SP-2], TTemp[SP-1]);
      destroy_tuple(TTemp[--SP]);
      destroy_tuple(TTemp[--SP]);

    }
    destroy_tuple(TTemp[--SP]);
    /*========== end if ==========*/
    /*get_dict_param (__get_dict_tuple( OcrResult, ['words']), 'key_data_type', ['col'], __Tmp_Ctrl_Type)*/
    create_tuple_s(&TTemp[SP++],"words");
    T_get_dict_tuple(hv_OcrResult,TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    create_tuple_s(&TTemp[SP++],"key_data_type");
    create_tuple_s(&TTemp[SP++],"col");
    destroy_tuple(hv___Tmp_Ctrl_Type);
    /***/T_get_dict_param(TTemp[SP-3], TTemp[SP-2], TTemp[SP-1], &hv___Tmp_Ctrl_Type);
    destroy_tuple(TTemp[--SP]);
    destroy_tuple(TTemp[--SP]);
    destroy_tuple(TTemp[--SP]);

    /*========== if (__Tmp_Ctrl_Type == 'object') ==========*/
    create_tuple_s(&TTemp[SP++],"object");
    T_tuple_equal(hv___Tmp_Ctrl_Type,TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    if(get_i(TTemp[SP-1],0))
    {
      /*set_dict_object (__get_dict_object( __get_dict_tuple( OcrResult, ['words']), ['col']), DetectionResult, ['bbox_col'])*/
      create_tuple_s(&TTemp[SP++],"words");
      T_get_dict_tuple(hv_OcrResult,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      create_tuple_s(&TTemp[SP++],"col");
      T_get_dict_object(&OTemp[SPO++],TTemp[SP-2],TTemp[SP-1]);
      destroy_tuple(TTemp[SP-2]);
      destroy_tuple(TTemp[SP-1]);
      SP-=2;
      create_tuple_s(&TTemp[SP++],"bbox_col");
      /***/T_set_dict_object(OTemp[SPO-1], hv_DetectionResult, TTemp[SP-1]);
      clear_obj(OTemp[--SPO]);
      destroy_tuple(TTemp[--SP]);

    }
    else
    {
      /*set_dict_tuple (DetectionResult, ['bbox_col'], __get_dict_tuple( __get_dict_tuple( OcrResult, ['words']), ['col']))*/
      create_tuple_s(&TTemp[SP++],"bbox_col");
      create_tuple_s(&TTemp[SP++],"words");
      T_get_dict_tuple(hv_OcrResult,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      create_tuple_s(&TTemp[SP++],"col");
      T_get_dict_tuple(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-2]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-2]=TTemp[SP];
      SP--;
      /***/T_set_dict_tuple(hv_DetectionResult, TTemp[SP-2], TTemp[SP-1]);
      destroy_tuple(TTemp[--SP]);
      destroy_tuple(TTemp[--SP]);

    }
    destroy_tuple(TTemp[--SP]);
    /*========== end if ==========*/
    /*get_dict_param (__get_dict_tuple( OcrResult, ['words']), 'key_data_type', ['phi'], __Tmp_Ctrl_Type)*/
    create_tuple_s(&TTemp[SP++],"words");
    T_get_dict_tuple(hv_OcrResult,TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    create_tuple_s(&TTemp[SP++],"key_data_type");
    create_tuple_s(&TTemp[SP++],"phi");
    destroy_tuple(hv___Tmp_Ctrl_Type);
    /***/T_get_dict_param(TTemp[SP-3], TTemp[SP-2], TTemp[SP-1], &hv___Tmp_Ctrl_Type);
    destroy_tuple(TTemp[--SP]);
    destroy_tuple(TTemp[--SP]);
    destroy_tuple(TTemp[--SP]);

    /*========== if (__Tmp_Ctrl_Type == 'object') ==========*/
    create_tuple_s(&TTemp[SP++],"object");
    T_tuple_equal(hv___Tmp_Ctrl_Type,TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    if(get_i(TTemp[SP-1],0))
    {
      /*set_dict_object (__get_dict_object( __get_dict_tuple( OcrResult, ['words']), ['phi']), DetectionResult, ['bbox_phi'])*/
      create_tuple_s(&TTemp[SP++],"words");
      T_get_dict_tuple(hv_OcrResult,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      create_tuple_s(&TTemp[SP++],"phi");
      T_get_dict_object(&OTemp[SPO++],TTemp[SP-2],TTemp[SP-1]);
      destroy_tuple(TTemp[SP-2]);
      destroy_tuple(TTemp[SP-1]);
      SP-=2;
      create_tuple_s(&TTemp[SP++],"bbox_phi");
      /***/T_set_dict_object(OTemp[SPO-1], hv_DetectionResult, TTemp[SP-1]);
      clear_obj(OTemp[--SPO]);
      destroy_tuple(TTemp[--SP]);

    }
    else
    {
      /*set_dict_tuple (DetectionResult, ['bbox_phi'], __get_dict_tuple( __get_dict_tuple( OcrResult, ['words']), ['phi']))*/
      create_tuple_s(&TTemp[SP++],"bbox_phi");
      create_tuple_s(&TTemp[SP++],"words");
      T_get_dict_tuple(hv_OcrResult,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      create_tuple_s(&TTemp[SP++],"phi");
      T_get_dict_tuple(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-2]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-2]=TTemp[SP];
      SP--;
      /***/T_set_dict_tuple(hv_DetectionResult, TTemp[SP-2], TTemp[SP-1]);
      destroy_tuple(TTemp[--SP]);
      destroy_tuple(TTemp[--SP]);

    }
    destroy_tuple(TTemp[--SP]);
    /*========== end if ==========*/
    /*get_dict_param (__get_dict_tuple( OcrResult, ['words']), 'key_data_type', ['length1'], __Tmp_Ctrl_Type)*/
    create_tuple_s(&TTemp[SP++],"words");
    T_get_dict_tuple(hv_OcrResult,TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    create_tuple_s(&TTemp[SP++],"key_data_type");
    create_tuple_s(&TTemp[SP++],"length1");
    destroy_tuple(hv___Tmp_Ctrl_Type);
    /***/T_get_dict_param(TTemp[SP-3], TTemp[SP-2], TTemp[SP-1], &hv___Tmp_Ctrl_Type);
    destroy_tuple(TTemp[--SP]);
    destroy_tuple(TTemp[--SP]);
    destroy_tuple(TTemp[--SP]);

    /*========== if (__Tmp_Ctrl_Type == 'object') ==========*/
    create_tuple_s(&TTemp[SP++],"object");
    T_tuple_equal(hv___Tmp_Ctrl_Type,TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    if(get_i(TTemp[SP-1],0))
    {
      /*set_dict_object (__get_dict_object( __get_dict_tuple( OcrResult, ['words']), ['length1']), DetectionResult, ['bbox_length1'])*/
      create_tuple_s(&TTemp[SP++],"words");
      T_get_dict_tuple(hv_OcrResult,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      create_tuple_s(&TTemp[SP++],"length1");
      T_get_dict_object(&OTemp[SPO++],TTemp[SP-2],TTemp[SP-1]);
      destroy_tuple(TTemp[SP-2]);
      destroy_tuple(TTemp[SP-1]);
      SP-=2;
      create_tuple_s(&TTemp[SP++],"bbox_length1");
      /***/T_set_dict_object(OTemp[SPO-1], hv_DetectionResult, TTemp[SP-1]);
      clear_obj(OTemp[--SPO]);
      destroy_tuple(TTemp[--SP]);

    }
    else
    {
      /*set_dict_tuple (DetectionResult, ['bbox_length1'], __get_dict_tuple( __get_dict_tuple( OcrResult, ['words']), ['length1']))*/
      create_tuple_s(&TTemp[SP++],"bbox_length1");
      create_tuple_s(&TTemp[SP++],"words");
      T_get_dict_tuple(hv_OcrResult,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      create_tuple_s(&TTemp[SP++],"length1");
      T_get_dict_tuple(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-2]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-2]=TTemp[SP];
      SP--;
      /***/T_set_dict_tuple(hv_DetectionResult, TTemp[SP-2], TTemp[SP-1]);
      destroy_tuple(TTemp[--SP]);
      destroy_tuple(TTemp[--SP]);

    }
    destroy_tuple(TTemp[--SP]);
    /*========== end if ==========*/
    /*get_dict_param (__get_dict_tuple( OcrResult, ['words']), 'key_data_type', ['length2'], __Tmp_Ctrl_Type)*/
    create_tuple_s(&TTemp[SP++],"words");
    T_get_dict_tuple(hv_OcrResult,TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    create_tuple_s(&TTemp[SP++],"key_data_type");
    create_tuple_s(&TTemp[SP++],"length2");
    destroy_tuple(hv___Tmp_Ctrl_Type);
    /***/T_get_dict_param(TTemp[SP-3], TTemp[SP-2], TTemp[SP-1], &hv___Tmp_Ctrl_Type);
    destroy_tuple(TTemp[--SP]);
    destroy_tuple(TTemp[--SP]);
    destroy_tuple(TTemp[--SP]);

    /*========== if (__Tmp_Ctrl_Type == 'object') ==========*/
    create_tuple_s(&TTemp[SP++],"object");
    T_tuple_equal(hv___Tmp_Ctrl_Type,TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    if(get_i(TTemp[SP-1],0))
    {
      /*set_dict_object (__get_dict_object( __get_dict_tuple( OcrResult, ['words']), ['length2']), DetectionResult, ['bbox_length2'])*/
      create_tuple_s(&TTemp[SP++],"words");
      T_get_dict_tuple(hv_OcrResult,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      create_tuple_s(&TTemp[SP++],"length2");
      T_get_dict_object(&OTemp[SPO++],TTemp[SP-2],TTemp[SP-1]);
      destroy_tuple(TTemp[SP-2]);
      destroy_tuple(TTemp[SP-1]);
      SP-=2;
      create_tuple_s(&TTemp[SP++],"bbox_length2");
      /***/T_set_dict_object(OTemp[SPO-1], hv_DetectionResult, TTemp[SP-1]);
      clear_obj(OTemp[--SPO]);
      destroy_tuple(TTemp[--SP]);

    }
    else
    {
      /*set_dict_tuple (DetectionResult, ['bbox_length2'], __get_dict_tuple( __get_dict_tuple( OcrResult, ['words']), ['length2']))*/
      create_tuple_s(&TTemp[SP++],"bbox_length2");
      create_tuple_s(&TTemp[SP++],"words");
      T_get_dict_tuple(hv_OcrResult,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      create_tuple_s(&TTemp[SP++],"length2");
      T_get_dict_tuple(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-2]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-2]=TTemp[SP];
      SP--;
      /***/T_set_dict_tuple(hv_DetectionResult, TTemp[SP-2], TTemp[SP-1]);
      destroy_tuple(TTemp[--SP]);
      destroy_tuple(TTemp[--SP]);

    }
    destroy_tuple(TTemp[--SP]);
    /*========== end if ==========*/
    /*set_dict_tuple (DetectionResult, ['bbox_confidence'], gen_tuple_const(|__get_dict_tuple( DetectionResult, ['bbox_row'])|,1.0))*/
    create_tuple_s(&TTemp[SP++],"bbox_confidence");
    create_tuple_s(&TTemp[SP++],"bbox_row");
    T_get_dict_tuple(hv_DetectionResult,TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    T_tuple_length(TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    create_tuple_d(&TTemp[SP++],1.0);
    T_tuple_gen_const(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-2]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-2]=TTemp[SP];
    SP--;
    /***/T_set_dict_tuple(hv_DetectionResult, TTemp[SP-2], TTemp[SP-1]);
    destroy_tuple(TTemp[--SP]);
    destroy_tuple(TTemp[--SP]);

    /*set_dict_tuple (DetectionResult, ['bbox_class_id'], gen_tuple_const(|__get_dict_tuple( DetectionResult, ['bbox_row'])|,0))*/
    create_tuple_s(&TTemp[SP++],"bbox_class_id");
    create_tuple_s(&TTemp[SP++],"bbox_row");
    T_get_dict_tuple(hv_DetectionResult,TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    T_tuple_length(TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    create_tuple_i(&TTemp[SP++],0);
    T_tuple_gen_const(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-2]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-2]=TTemp[SP];
    SP--;
    /***/T_set_dict_tuple(hv_DetectionResult, TTemp[SP-2], TTemp[SP-1]);
    destroy_tuple(TTemp[--SP]);
    destroy_tuple(TTemp[--SP]);

    /*DetectionResults[Index] := DetectionResult*/
    replace_elements(&(*hv_DetectionResults),&hv_Index,&hv_DetectionResult);
   }
   destroy_tuple(TTemp[SP--]);
   destroy_tuple(TTemp[SP--]);
   destroy_tuple(TTemp[SP]);
  }
  else
  {
   destroy_tuple(TTemp[SP--]);
   destroy_tuple(TTemp[SP--]);
   destroy_tuple(TTemp[SP--]);
   destroy_tuple(TTemp[SP--]);
   destroy_tuple(TTemp[SP]);
  }/*========== end for ========*/



  /*========== return ==========*/

  /* Clear temporary tuple stack */
  while (SP > 0)
    destroy_tuple(TTemp[--SP]);
  /* Clear temporary object stack */
  while (SPO > 0)
    clear_obj(OTemp[--SPO]);
  /* Clear temporary tuple vectors stack*/
  while (SPTV > 0)
    V_destroy_vector(TVTemp[--SPTV]);
  /* Clear temporary object vectors stack */
  while (SPOV > 0)
    V_destroy_vector(OVTemp[--SPOV]);
  /* Clear local control variables */
  destroy_tuple(hv_Index);
  destroy_tuple(hv_OcrResult);
  destroy_tuple(hv_RequiredKeysExist);
  destroy_tuple(hv_DetectionResult);
  destroy_tuple(hv___Tmp_Ctrl_Type);

  return;

  /****************************************************/
  /******************     End procedure   *************/
  /****************************************************/

}

/* Chapter: Tools / Geometry*/
/* Short Description: Convert the parameters of rectangles with format rectangle2 to the coordinates of its 4 corner-points. */
void convert_rect2_5to8param (Htuple hv_Row, Htuple hv_Col, Htuple hv_Length1, Htuple hv_Length2, 
    Htuple hv_Phi, Htuple *hv_Row1, Htuple *hv_Col1, Htuple *hv_Row2, Htuple *hv_Col2, 
    Htuple *hv_Row3, Htuple *hv_Col3, Htuple *hv_Row4, Htuple *hv_Col4)
{

  /* Stack for temporary tuples */
  Htuple   TTemp[100];
  int      SP=0;
  /* Stack for temporary tuple vectors */
  Hvector  TVTemp[100] = {0};
  int      SPTV=0;

  /* Local iconic variables */

  /* Local control variables */
  Htuple  hv_Co1, hv_Co2, hv_Si1, hv_Si2;

  /* Initialize control variables */
  create_tuple(&hv_Co1,0);
  create_tuple(&hv_Co2,0);
  create_tuple(&hv_Si1,0);
  create_tuple(&hv_Si2,0);
  create_tuple(&(*hv_Row1),0);
  create_tuple(&(*hv_Col1),0);
  create_tuple(&(*hv_Row2),0);
  create_tuple(&(*hv_Col2),0);
  create_tuple(&(*hv_Row3),0);
  create_tuple(&(*hv_Col3),0);
  create_tuple(&(*hv_Row4),0);
  create_tuple(&(*hv_Col4),0);

  /****************************************************/
  /******************   Begin procedure   *************/
  /****************************************************/

  /*This procedure takes the parameters for a rectangle of type 'rectangle2'*/
  /*and returns the coordinates of the four corners.*/
  /**/
  /*Co1 := cos(Phi) * Length1*/
  T_tuple_cos(hv_Phi,&TTemp[SP++]);
  T_tuple_mult(TTemp[SP-1],hv_Length1,&TTemp[SP]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-1]=TTemp[SP];
  destroy_tuple(hv_Co1);
  hv_Co1=TTemp[--SP];

  /*Co2 := cos(Phi) * Length2*/
  T_tuple_cos(hv_Phi,&TTemp[SP++]);
  T_tuple_mult(TTemp[SP-1],hv_Length2,&TTemp[SP]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-1]=TTemp[SP];
  destroy_tuple(hv_Co2);
  hv_Co2=TTemp[--SP];

  /*Si1 := sin(Phi) * Length1*/
  T_tuple_sin(hv_Phi,&TTemp[SP++]);
  T_tuple_mult(TTemp[SP-1],hv_Length1,&TTemp[SP]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-1]=TTemp[SP];
  destroy_tuple(hv_Si1);
  hv_Si1=TTemp[--SP];

  /*Si2 := sin(Phi) * Length2*/
  T_tuple_sin(hv_Phi,&TTemp[SP++]);
  T_tuple_mult(TTemp[SP-1],hv_Length2,&TTemp[SP]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-1]=TTemp[SP];
  destroy_tuple(hv_Si2);
  hv_Si2=TTemp[--SP];


  /*Col1 := Co1 - Si2 + Col*/
  T_tuple_sub(hv_Co1,hv_Si2,&TTemp[SP++]);
  T_tuple_add(TTemp[SP-1],hv_Col,&TTemp[SP]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-1]=TTemp[SP];
  destroy_tuple((*hv_Col1));
  (*hv_Col1)=TTemp[--SP];

  /*Row1 := -Si1 - Co2 + Row*/
  T_tuple_neg(hv_Si1,&TTemp[SP++]);
  T_tuple_sub(TTemp[SP-1],hv_Co2,&TTemp[SP]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-1]=TTemp[SP];
  T_tuple_add(TTemp[SP-1],hv_Row,&TTemp[SP]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-1]=TTemp[SP];
  destroy_tuple((*hv_Row1));
  (*hv_Row1)=TTemp[--SP];

  /*Col2 := -Co1 - Si2 + Col*/
  T_tuple_neg(hv_Co1,&TTemp[SP++]);
  T_tuple_sub(TTemp[SP-1],hv_Si2,&TTemp[SP]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-1]=TTemp[SP];
  T_tuple_add(TTemp[SP-1],hv_Col,&TTemp[SP]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-1]=TTemp[SP];
  destroy_tuple((*hv_Col2));
  (*hv_Col2)=TTemp[--SP];

  /*Row2 := Si1 - Co2 + Row*/
  T_tuple_sub(hv_Si1,hv_Co2,&TTemp[SP++]);
  T_tuple_add(TTemp[SP-1],hv_Row,&TTemp[SP]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-1]=TTemp[SP];
  destroy_tuple((*hv_Row2));
  (*hv_Row2)=TTemp[--SP];

  /*Col3 := -Co1 + Si2 + Col*/
  T_tuple_neg(hv_Co1,&TTemp[SP++]);
  T_tuple_add(TTemp[SP-1],hv_Si2,&TTemp[SP]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-1]=TTemp[SP];
  T_tuple_add(TTemp[SP-1],hv_Col,&TTemp[SP]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-1]=TTemp[SP];
  destroy_tuple((*hv_Col3));
  (*hv_Col3)=TTemp[--SP];

  /*Row3 := Si1 + Co2 + Row*/
  T_tuple_add(hv_Si1,hv_Co2,&TTemp[SP++]);
  T_tuple_add(TTemp[SP-1],hv_Row,&TTemp[SP]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-1]=TTemp[SP];
  destroy_tuple((*hv_Row3));
  (*hv_Row3)=TTemp[--SP];

  /*Col4 := Co1 + Si2 + Col*/
  T_tuple_add(hv_Co1,hv_Si2,&TTemp[SP++]);
  T_tuple_add(TTemp[SP-1],hv_Col,&TTemp[SP]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-1]=TTemp[SP];
  destroy_tuple((*hv_Col4));
  (*hv_Col4)=TTemp[--SP];

  /*Row4 := -Si1 + Co2 + Row*/
  T_tuple_neg(hv_Si1,&TTemp[SP++]);
  T_tuple_add(TTemp[SP-1],hv_Co2,&TTemp[SP]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-1]=TTemp[SP];
  T_tuple_add(TTemp[SP-1],hv_Row,&TTemp[SP]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-1]=TTemp[SP];
  destroy_tuple((*hv_Row4));
  (*hv_Row4)=TTemp[--SP];


  /*========== return ==========*/

  /* Clear temporary tuple stack */
  while (SP > 0)
    destroy_tuple(TTemp[--SP]);
  /* Clear temporary tuple vectors stack*/
  while (SPTV > 0)
    V_destroy_vector(TVTemp[--SPTV]);
  /* Clear local control variables */
  destroy_tuple(hv_Co1);
  destroy_tuple(hv_Co2);
  destroy_tuple(hv_Si1);
  destroy_tuple(hv_Si2);

  return;

  /****************************************************/
  /******************     End procedure   *************/
  /****************************************************/

}

/* Chapter: Tools / Geometry*/
/* Short Description: Convert for four-sided figures the coordinates of the 4 corner-points to the parameters of format rectangle2. */
void convert_rect2_8to5param (Htuple hv_Row1, Htuple hv_Col1, Htuple hv_Row2, Htuple hv_Col2, 
    Htuple hv_Row3, Htuple hv_Col3, Htuple hv_Row4, Htuple hv_Col4, Htuple hv_ForceL1LargerL2, 
    Htuple *hv_Row, Htuple *hv_Col, Htuple *hv_Length1, Htuple *hv_Length2, Htuple *hv_Phi)
{

  /* Stack for temporary tuples */
  Htuple   TTemp[100];
  int      SP=0;
  /* Stack for temporary tuple vectors */
  Hvector  TVTemp[100] = {0};
  int      SPTV=0;

  /* Local iconic variables */

  /* Local control variables */
  Htuple  hv_Hor, hv_Vert, hv_IdxSwap, hv_Tmp;

  /* Initialize control variables */
  create_tuple(&hv_Hor,0);
  create_tuple(&hv_Vert,0);
  create_tuple(&hv_IdxSwap,0);
  create_tuple(&hv_Tmp,0);
  create_tuple(&(*hv_Row),0);
  create_tuple(&(*hv_Col),0);
  create_tuple(&(*hv_Length1),0);
  create_tuple(&(*hv_Length2),0);
  create_tuple(&(*hv_Phi),0);

  /****************************************************/
  /******************   Begin procedure   *************/
  /****************************************************/

  /*This procedure takes the corners of four-sided figures*/
  /*and returns the parameters of type 'rectangle2'.*/
  /**/
  /*Calculate center row and column.*/
  /*Row := (Row1 + Row2 + Row3 + Row4) / 4.0*/
  T_tuple_add(hv_Row1,hv_Row2,&TTemp[SP++]);
  T_tuple_add(TTemp[SP-1],hv_Row3,&TTemp[SP]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-1]=TTemp[SP];
  T_tuple_add(TTemp[SP-1],hv_Row4,&TTemp[SP]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-1]=TTemp[SP];
  create_tuple_d(&TTemp[SP++],4.0);
  T_tuple_div(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-2]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-2]=TTemp[SP];
  SP--;
  destroy_tuple((*hv_Row));
  (*hv_Row)=TTemp[--SP];

  /*Col := (Col1 + Col2 + Col3 + Col4) / 4.0*/
  T_tuple_add(hv_Col1,hv_Col2,&TTemp[SP++]);
  T_tuple_add(TTemp[SP-1],hv_Col3,&TTemp[SP]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-1]=TTemp[SP];
  T_tuple_add(TTemp[SP-1],hv_Col4,&TTemp[SP]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-1]=TTemp[SP];
  create_tuple_d(&TTemp[SP++],4.0);
  T_tuple_div(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-2]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-2]=TTemp[SP];
  SP--;
  destroy_tuple((*hv_Col));
  (*hv_Col)=TTemp[--SP];

  /*Length1 and Length2.*/
  /*Length1 := sqrt((Row1 - Row2) * (Row1 - Row2) + (Col1 - Col2) * (Col1 - Col2)) / 2.0*/
  T_tuple_sub(hv_Row1,hv_Row2,&TTemp[SP++]);
  T_tuple_sub(hv_Row1,hv_Row2,&TTemp[SP++]);
  T_tuple_mult(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-2]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-2]=TTemp[SP];
  SP--;
  T_tuple_sub(hv_Col1,hv_Col2,&TTemp[SP++]);
  T_tuple_sub(hv_Col1,hv_Col2,&TTemp[SP++]);
  T_tuple_mult(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-2]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-2]=TTemp[SP];
  SP--;
  T_tuple_add(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-2]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-2]=TTemp[SP];
  SP--;
  T_tuple_sqrt(TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-1]=TTemp[SP];
  create_tuple_d(&TTemp[SP++],2.0);
  T_tuple_div(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-2]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-2]=TTemp[SP];
  SP--;
  destroy_tuple((*hv_Length1));
  (*hv_Length1)=TTemp[--SP];

  /*Length2 := sqrt((Row2 - Row3) * (Row2 - Row3) + (Col2 - Col3) * (Col2 - Col3)) / 2.0*/
  T_tuple_sub(hv_Row2,hv_Row3,&TTemp[SP++]);
  T_tuple_sub(hv_Row2,hv_Row3,&TTemp[SP++]);
  T_tuple_mult(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-2]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-2]=TTemp[SP];
  SP--;
  T_tuple_sub(hv_Col2,hv_Col3,&TTemp[SP++]);
  T_tuple_sub(hv_Col2,hv_Col3,&TTemp[SP++]);
  T_tuple_mult(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-2]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-2]=TTemp[SP];
  SP--;
  T_tuple_add(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-2]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-2]=TTemp[SP];
  SP--;
  T_tuple_sqrt(TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-1]=TTemp[SP];
  create_tuple_d(&TTemp[SP++],2.0);
  T_tuple_div(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-2]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-2]=TTemp[SP];
  SP--;
  destroy_tuple((*hv_Length2));
  (*hv_Length2)=TTemp[--SP];

  /*Calculate the angle phi.*/
  /*Hor := Col1 - Col2*/
  T_tuple_sub(hv_Col1,hv_Col2,&TTemp[SP++]);
  destroy_tuple(hv_Hor);
  hv_Hor=TTemp[--SP];

  /*Vert := Row2 - Row1*/
  T_tuple_sub(hv_Row2,hv_Row1,&TTemp[SP++]);
  destroy_tuple(hv_Vert);
  hv_Vert=TTemp[--SP];

  /*========== if (ForceL1LargerL2) ==========*/
  copy_tuple(hv_ForceL1LargerL2,&TTemp[SP++]);
  if(get_i(TTemp[SP-1],0))
  {
    /*Swap length1 and length2 if necessary.*/
    /*IdxSwap := find((Length2 - Length1) [>] 1e-9,1)*/
    T_tuple_sub((*hv_Length2),(*hv_Length1),&TTemp[SP++]);
    create_tuple_d(&TTemp[SP++],1e-9);
    T_tuple_greater_elem(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-2]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-2]=TTemp[SP];
    SP--;
    create_tuple_i(&TTemp[SP++],1);
    T_tuple_find(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-2]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-2]=TTemp[SP];
    SP--;
    destroy_tuple(hv_IdxSwap);
    hv_IdxSwap=TTemp[--SP];

    /*========== if (IdxSwap != -1) ==========*/
    create_tuple_i(&TTemp[SP++],-1);
    T_tuple_not_equal(hv_IdxSwap,TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    if(get_i(TTemp[SP-1],0))
    {
      /*Tmp := Length1[IdxSwap]*/
      T_tuple_select((*hv_Length1),hv_IdxSwap,&TTemp[SP++]);
      destroy_tuple(hv_Tmp);
      hv_Tmp=TTemp[--SP];

      /*Length1[IdxSwap] := Length2[IdxSwap]*/
      T_tuple_select((*hv_Length2),hv_IdxSwap,&TTemp[SP++]);
      replace_elements(&(*hv_Length1),&hv_IdxSwap,&TTemp[SP-1]);
      destroy_tuple(TTemp[--SP]);
      /*Length2[IdxSwap] := Tmp*/
      replace_elements(&(*hv_Length2),&hv_IdxSwap,&hv_Tmp);
      /*Hor[IdxSwap] := Col2[IdxSwap] - Col3[IdxSwap]*/
      T_tuple_select(hv_Col2,hv_IdxSwap,&TTemp[SP++]);
      T_tuple_select(hv_Col3,hv_IdxSwap,&TTemp[SP++]);
      T_tuple_sub(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-2]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-2]=TTemp[SP];
      SP--;
      replace_elements(&hv_Hor,&hv_IdxSwap,&TTemp[SP-1]);
      destroy_tuple(TTemp[--SP]);
      /*Vert[IdxSwap] := Row3[IdxSwap] - Row2[IdxSwap]*/
      T_tuple_select(hv_Row3,hv_IdxSwap,&TTemp[SP++]);
      T_tuple_select(hv_Row2,hv_IdxSwap,&TTemp[SP++]);
      T_tuple_sub(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-2]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-2]=TTemp[SP];
      SP--;
      replace_elements(&hv_Vert,&hv_IdxSwap,&TTemp[SP-1]);
      destroy_tuple(TTemp[--SP]);
    }
    destroy_tuple(TTemp[--SP]);
    /*========== end if ==========*/
  }
  destroy_tuple(TTemp[--SP]);
  /*========== end if ==========*/
  /*Phi := atan2(Vert,Hor)*/
  T_tuple_atan2(hv_Vert,hv_Hor,&TTemp[SP++]);
  destroy_tuple((*hv_Phi));
  (*hv_Phi)=TTemp[--SP];

  /**/
  /*========== return ==========*/

  /* Clear temporary tuple stack */
  while (SP > 0)
    destroy_tuple(TTemp[--SP]);
  /* Clear temporary tuple vectors stack*/
  while (SPTV > 0)
    V_destroy_vector(TVTemp[--SPTV]);
  /* Clear local control variables */
  destroy_tuple(hv_Hor);
  destroy_tuple(hv_Vert);
  destroy_tuple(hv_IdxSwap);
  destroy_tuple(hv_Tmp);

  return;

  /****************************************************/
  /******************     End procedure   *************/
  /****************************************************/

}

/* Chapter: Deep Learning / Model*/
/* Short Description: Crops a given image object based on the given domain handling. */
void crop_dl_sample_image (Hobject ho_Domain, Htuple hv_DLSample, Htuple hv_Key, 
    Htuple hv_DLPreprocessParam)
{


  /* Stack for temporary tuples */
  Htuple   TTemp[100];
  int      SP=0;
  /* Stack for temporary objects */
  Hobject  OTemp[100] = {0};
  int      SPO=0;
  /* Stack for temporary tuple vectors */
  Hvector  TVTemp[100] = {0};
  int      SPTV=0;
  /* Stack for temporary object vectors */
  Hvector  OVTemp[100] = {0};
  int      SPOV=0;

  /* Local iconic variables */
  Hobject  ho___Tmp_Obj_0;

  /* Local control variables */
  Htuple  hv_KeyExists, hv_Row1, hv_Column1, hv_Row2;
  Htuple  hv_Column2, hv___Tmp_Ctrl_Dict_Init_0;

  /* Initialize iconic variables */
  gen_empty_obj(&ho___Tmp_Obj_0);

  /* Initialize control variables */
  create_tuple(&hv_KeyExists,0);
  create_tuple(&hv_Row1,0);
  create_tuple(&hv_Column1,0);
  create_tuple(&hv_Row2,0);
  create_tuple(&hv_Column2,0);
  create_tuple(&hv___Tmp_Ctrl_Dict_Init_0,0);

  /****************************************************/
  /******************   Begin procedure   *************/
  /****************************************************/

  /*get_dict_param (DLSample, 'key_exists', Key, KeyExists)*/
  create_tuple_s(&TTemp[SP++],"key_exists");
  destroy_tuple(hv_KeyExists);
  /***/T_get_dict_param(hv_DLSample, TTemp[SP-1], hv_Key, &hv_KeyExists);
  destroy_tuple(TTemp[--SP]);

  /*========== if (KeyExists) ==========*/
  copy_tuple(hv_KeyExists,&TTemp[SP++]);
  if(get_i(TTemp[SP-1],0))
  {
    /*create_dict (__Tmp_Ctrl_Dict_Init_0)*/
    destroy_tuple(hv___Tmp_Ctrl_Dict_Init_0);
    /***/T_create_dict(&hv___Tmp_Ctrl_Dict_Init_0);

    /*set_dict_tuple (__Tmp_Ctrl_Dict_Init_0, ['comp'], 'crop_domain')*/
    create_tuple_s(&TTemp[SP++],"comp");
    create_tuple_s(&TTemp[SP++],"crop_domain");
    /***/T_set_dict_tuple(hv___Tmp_Ctrl_Dict_Init_0, TTemp[SP-2], TTemp[SP-1]);
    destroy_tuple(TTemp[--SP]);
    destroy_tuple(TTemp[--SP]);

    /*========== if (__test_equal_dict_item([DLPreprocessParam, __Tmp_Ctrl_Dict_Init_0], ['domain_handling'], 'comp')) ==========*/
    T_tuple_concat(hv_DLPreprocessParam,hv___Tmp_Ctrl_Dict_Init_0,&TTemp[SP++]);
    create_tuple_s(&TTemp[SP++],"domain_handling");
    create_tuple_s(&TTemp[SP++],"comp");
    T_test_equal_dict_item(TTemp[SP-3],TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-3]);
    destroy_tuple(TTemp[SP-2]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-3]=TTemp[SP];
    SP=SP-2;
    if(get_i(TTemp[SP-1],0))
    {
      /*smallest_rectangle1 (Domain, Row1, Column1, Row2, Column2)*/
      destroy_tuple(hv_Row1);
      destroy_tuple(hv_Column1);
      destroy_tuple(hv_Row2);
      destroy_tuple(hv_Column2);
      /***/T_smallest_rectangle1(ho_Domain, &hv_Row1, &hv_Column1, &hv_Row2, &hv_Column2);

      /*crop_part (__get_dict_object( DLSample, Key), __Tmp_Obj_0, Row1, Column1, Column2 - Column1 + 1, Row2 - Row1 + 1)*/
      T_get_dict_object(&OTemp[SPO++],hv_DLSample,hv_Key);
      T_tuple_sub(hv_Column2,hv_Column1,&TTemp[SP++]);
      create_tuple_i(&TTemp[SP++],1);
      T_tuple_add(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-2]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-2]=TTemp[SP];
      SP--;
      T_tuple_sub(hv_Row2,hv_Row1,&TTemp[SP++]);
      create_tuple_i(&TTemp[SP++],1);
      T_tuple_add(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-2]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-2]=TTemp[SP];
      SP--;
      clear_obj(ho___Tmp_Obj_0);
      /***/T_crop_part(OTemp[SPO-1], &ho___Tmp_Obj_0, hv_Row1, hv_Column1, TTemp[SP-2], 
          TTemp[SP-1]);
      clear_obj(OTemp[--SPO]);
      destroy_tuple(TTemp[--SP]);
      destroy_tuple(TTemp[--SP]);

      /*set_dict_object (__Tmp_Obj_0, DLSample, Key)*/
      /***/T_set_dict_object(ho___Tmp_Obj_0, hv_DLSample, hv_Key);

    }
    destroy_tuple(TTemp[--SP]);
    /*========== end if ==========*/
    /*__Tmp_Ctrl_Dict_Init_0 := constant('HNULL')*/
    create_tuple_s(&TTemp[SP++],"HNULL");
    T_tuple_constant(TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    destroy_tuple(hv___Tmp_Ctrl_Dict_Init_0);
    hv___Tmp_Ctrl_Dict_Init_0=TTemp[--SP];

  }
  destroy_tuple(TTemp[--SP]);
  /*========== end if ==========*/
  /*========== return ==========*/

  /* Clear temporary tuple stack */
  while (SP > 0)
    destroy_tuple(TTemp[--SP]);
  /* Clear temporary object stack */
  while (SPO > 0)
    clear_obj(OTemp[--SPO]);
  /* Clear temporary tuple vectors stack*/
  while (SPTV > 0)
    V_destroy_vector(TVTemp[--SPTV]);
  /* Clear temporary object vectors stack */
  while (SPOV > 0)
    V_destroy_vector(OVTemp[--SPOV]);
  /* Clear local iconic variables */
  clear_obj(ho___Tmp_Obj_0);

  /* Clear local control variables */
  destroy_tuple(hv_KeyExists);
  destroy_tuple(hv_Row1);
  destroy_tuple(hv_Column1);
  destroy_tuple(hv_Row2);
  destroy_tuple(hv_Column2);
  destroy_tuple(hv___Tmp_Ctrl_Dict_Init_0);

  return;

  /****************************************************/
  /******************     End procedure   *************/
  /****************************************************/

}

/* Chapter: Graphics / Output*/
/* Short Description: Display a map of the confidences. */
void dev_display_confidence_regions (Hobject ho_ImageConfidence, Htuple hv_DrawTransparency, 
    Htuple *hv_Colors)
{


  /* Stack for temporary tuples */
  Htuple   TTemp[100];
  int      SP=0;
  /* Stack for temporary tuple vectors */
  Hvector  TVTemp[100] = {0};
  int      SPTV=0;

  /* Local iconic variables */
  Hobject  ho_Region;

  /* Local control variables */
  Htuple  hv_NumColors, hv_WeightsColorsAlpha, hv_ColorIndex;
  Htuple  hv_Threshold, hv_MinGray, hv_MaxGray;

  /* Initialize iconic variables */
  gen_empty_obj(&ho_Region);

  /* Initialize control variables */
  create_tuple(&hv_NumColors,0);
  create_tuple(&hv_WeightsColorsAlpha,0);
  create_tuple(&hv_ColorIndex,0);
  create_tuple(&hv_Threshold,0);
  create_tuple(&hv_MinGray,0);
  create_tuple(&hv_MaxGray,0);
  create_tuple(&(*hv_Colors),0);

  /****************************************************/
  /******************   Begin procedure   *************/
  /****************************************************/

  /**/
  /*This procedure displays a map of the confidences*/
  /*given in ImageConfidence as regions.*/
  /*DrawTransparency determines the alpha value of the colors.*/
  /*The used colors are returned.*/
  /**/
  /*Define colors.*/
  /*NumColors := 20*/
  reuse_tuple_i(&hv_NumColors,20);

  /*get_distinct_colors (NumColors, false, 0, 100, Colors)*/
  create_tuple_i(&TTemp[SP++],0);
  create_tuple_i(&TTemp[SP++],0);
  create_tuple_i(&TTemp[SP++],100);
  destroy_tuple((*hv_Colors));
  /***/get_distinct_colors(hv_NumColors, TTemp[SP-3], TTemp[SP-2], TTemp[SP-1], &(*hv_Colors));
  destroy_tuple(TTemp[--SP]);
  destroy_tuple(TTemp[--SP]);
  destroy_tuple(TTemp[--SP]);

  /*WeightsColorsAlpha := Colors + DrawTransparency*/
  T_tuple_add((*hv_Colors),hv_DrawTransparency,&TTemp[SP++]);
  destroy_tuple(hv_WeightsColorsAlpha);
  hv_WeightsColorsAlpha=TTemp[--SP];

  /*ColorIndex := 0*/
  reuse_tuple_i(&hv_ColorIndex,0);

  /**/
  /*Threshold the image according to*/
  /*the number of colors and*/
  /*display resulting regions.*/
  /*========== for ColorIndex := 0 to NumColors - 1 by 1 ==========*/
  create_tuple_i(&TTemp[SP++],1);
  T_tuple_sub(hv_NumColors,TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-1]=TTemp[SP];
  create_tuple_i(&TTemp[SP++],1);
  create_tuple_i(&TTemp[SP++],0);
  T_tuple_greater(TTemp[SP-1],TTemp[SP-3],&TTemp[SP]);
  SP++;
  T_tuple_equal(TTemp[SP-2],TTemp[SP-4],&TTemp[SP]);
  if(get_i(TTemp[SP],0) ||
     (!((( get_i(TTemp[SP-1],0)) && (get_d(TTemp[SP-3],0)>0)) ||
        ((!get_i(TTemp[SP-1],0)) && (get_d(TTemp[SP-3],0)<0)))))
  {
   destroy_tuple(TTemp[SP--]);
   destroy_tuple(TTemp[SP]);
   T_tuple_sub(TTemp[SP-1],TTemp[SP-2],&TTemp[SP]);
   destroy_tuple(hv_ColorIndex);
   copy_tuple(TTemp[SP],&hv_ColorIndex);
   destroy_tuple(TTemp[SP--]);
   destroy_tuple(TTemp[SP]);
   for(;;)
   {
   T_tuple_add(hv_ColorIndex,TTemp[SP-1],&TTemp[SP]);
   destroy_tuple(hv_ColorIndex);
   copy_tuple(TTemp[SP],&hv_ColorIndex);
   destroy_tuple(TTemp[SP]);
   if(get_d(TTemp[SP-1],0)<0)
    T_tuple_less(hv_ColorIndex,TTemp[SP-2],&TTemp[SP]);
   else
    T_tuple_greater(hv_ColorIndex,TTemp[SP-2],&TTemp[SP]);
   if(get_i(TTemp[SP],0)) break;
   destroy_tuple(TTemp[SP]);
   /*========== for ==========*/

    /*Threshold := ColorIndex * (1.0 / NumColors)*/
    create_tuple_d(&TTemp[SP++],1.0);
    T_tuple_div(TTemp[SP-1],hv_NumColors,&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    T_tuple_mult(hv_ColorIndex,TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    destroy_tuple(hv_Threshold);
    hv_Threshold=TTemp[--SP];

    /*MinGray := Threshold*/
    destroy_tuple(hv_MinGray);
    copy_tuple(hv_Threshold,&hv_MinGray);

    /*MaxGray := Threshold + 1 / NumColors*/
    create_tuple_i(&TTemp[SP++],1);
    T_tuple_div(TTemp[SP-1],hv_NumColors,&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    T_tuple_add(hv_Threshold,TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    destroy_tuple(hv_MaxGray);
    hv_MaxGray=TTemp[--SP];

    /*threshold (ImageConfidence, Region, Threshold, Threshold + (1.0 / NumColors))*/
    create_tuple_d(&TTemp[SP++],1.0);
    T_tuple_div(TTemp[SP-1],hv_NumColors,&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    T_tuple_add(hv_Threshold,TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    clear_obj(ho_Region);
    /***/T_threshold(ho_ImageConfidence, &ho_Region, hv_Threshold, TTemp[SP-1]);
    destroy_tuple(TTemp[--SP]);

    if (hdev_window_stack_is_open())
    {
      Htuple active_win;
      create_tuple(&active_win,0);
      hdev_window_stack_get_active(&active_win);
      /*dev_set_color (WeightsColorsAlpha[ColorIndex])*/
      T_tuple_select(hv_WeightsColorsAlpha,hv_ColorIndex,&TTemp[SP++]);
      /***/T_set_color(active_win,TTemp[SP-1]);
      destroy_tuple(TTemp[--SP]);
      destroy_tuple(active_win);
    }
    if (hdev_window_stack_is_open())
    {
      Htuple active_win;
      create_tuple(&active_win,0);
      hdev_window_stack_get_active(&active_win);
      /*dev_display (Region)*/
      /***/T_disp_obj(ho_Region, active_win);
      destroy_tuple(active_win);
    }
   }
   destroy_tuple(TTemp[SP--]);
   destroy_tuple(TTemp[SP--]);
   destroy_tuple(TTemp[SP]);
  }
  else
  {
   destroy_tuple(TTemp[SP--]);
   destroy_tuple(TTemp[SP--]);
   destroy_tuple(TTemp[SP--]);
   destroy_tuple(TTemp[SP--]);
   destroy_tuple(TTemp[SP]);
  }/*========== end for ========*/

  /*========== return ==========*/

  /* Clear temporary tuple stack */
  while (SP > 0)
    destroy_tuple(TTemp[--SP]);
  /* Clear temporary tuple vectors stack*/
  while (SPTV > 0)
    V_destroy_vector(TVTemp[--SPTV]);
  /* Clear local iconic variables */
  clear_obj(ho_Region);

  /* Clear local control variables */
  destroy_tuple(hv_NumColors);
  destroy_tuple(hv_WeightsColorsAlpha);
  destroy_tuple(hv_ColorIndex);
  destroy_tuple(hv_Threshold);
  destroy_tuple(hv_MinGray);
  destroy_tuple(hv_MaxGray);

  return;

  /****************************************************/
  /******************     End procedure   *************/
  /****************************************************/

}

/* Chapter: Deep Learning / Model*/
/* Short Description: Visualize different images, annotations and inference results for a sample. */
void dev_display_dl_data (Htuple hv_DLSample, Htuple hv_DLResult, Htuple hv_DLDatasetInfo, 
    Htuple hv_KeysForDisplay, Htuple hv_GenParam, Htuple hv_WindowHandleDict)
{

  /* Stack for temporary tuples */
  Htuple   TTemp[100];
  int      SP=0;
  /* Stack for temporary objects */
  Hobject  OTemp[100] = {0};
  int      SPO=0;
  /* Stack for temporary tuple vectors */
  Hvector  TVTemp[100] = {0};
  int      SPTV=0;
  /* Stack for temporary object vectors */
  Hvector  OVTemp[100] = {0};
  int      SPOV=0;

  /* Local iconic variables */
  Hobject  ho_Image, ho_Domain, ho_GrippingMapImageResult;
  Hobject  ho_Cross, ho_GrippingMapGroundTruth, ho_X, ho_Y;
  Hobject  ho_Z, ho_AnomalyImage, ho_AnomalyRegion, ho_ConfidenceImage;
  Hobject  ho_HeatmapScene, ho_ScoreMaps, ho_CharacterScoreMap;
  Hobject  ho_LinkScoreMap, ho_OrientationSinScoreMap, ho_OrientationCosScoreMap;
  Hobject  ho_ScoreMap, ho_OrientationScoreMap, ho_PredictionColorFrame;
  Hobject  ho_ImageHeatmap, ho_PredictionSymbol, ho_CrossLineH;
  Hobject  ho_CrossLineV, ho_ImageConfidence, ho_SegmentationImagGroundTruth;
  Hobject  ho_SegmentationImageResult, ho_ImageAbsDiff, ho_DiffRegion;
  Hobject  ho_ImageWeight;

  /* Local control variables */
  Htuple  hv_Params, hv_GenParamNames, hv_ParamIndex;
  Htuple  hv_GenParamName, hv_KeyExists, hv_SampleKeys, hv_ResultKeys;
  Htuple  hv_ImageIDExists, hv_ImageID, hv_ImageIDString;
  Htuple  hv_ImageIDStringBraces, hv_ImageIDStringCapital;
  Htuple  hv_IsOCRDetection, hv_AdditionalGreenClassNames;
  Htuple  hv_KeyIndex, hv_OcrResult, hv_MaxClassIdSample;
  Htuple  hv_EmptySample, hv_MaxClassIdResult, hv_EmptyResult;
  Htuple  hv_MaxClassId, hv_ClassNames, hv_ClassIDs, hv_ClassNameKey;
  Htuple  hv_ClassIdKey, hv_ResultClassNames, hv_ResultClassIds;
  Htuple  hv_SortIndices, hv_UniqueClassIds, hv_UniqueClassNames;
  Htuple  hv_Colors, hv_ClassesLegend, hv_InvalidInput, hv_ClassKeys;
  Htuple  hv_ClassKeysExist, hv_DLDatasetInfoKeys, hv_Index;
  Htuple  hv_ClassIDstoIndex, hv_I, hv_PrevWindowCoordinates;
  Htuple  hv_Keys, hv_Exception, hv_MetaInfoExists, hv_FlushValues;
  Htuple  hv_WindowHandleKeys, hv_WindowHandles, hv_WindowIndex;
  Htuple  hv_FlushValue, hv_WidthImage, hv_HeightImage, hv_CurrentWindowHandle;
  Htuple  hv_WindowImageRatio, hv_ColorsGrippingGroundTruth;
  Htuple  hv_ImageClassIDs, hv_GrippingPointsExists, hv_Rows;
  Htuple  hv_Columns, hv_AnomalyImages, hv_PossibleKeysForDisplay;
  Htuple  hv_AddDisplayKey, hv_AnomalyLabelGroundTruth, hv_AnomalyLabelIDGroundTruth;
  Htuple  hv_AnomalyResultPostfix, hv_AnomalyScore, hv_AnomalyClassID;
  Htuple  hv_AnomalyClassThresholdDisplay, hv_AnomalyRegionThresholdDisplay;
  Htuple  hv_WindowHandleName, hv_AnomalyRegionGroundTruthExists;
  Htuple  hv_Text, hv_PredictionColor, hv_LineColors, hv_ResultColorOffset;
  Htuple  hv_AnomalyRegionExists, hv_AnomalyImageKey, hv_AnomalyScoreKey;
  Htuple  hv_AnomalyResultKey, hv_AnomalyRegionKey, hv_DisplayDirectionTemp;
  Htuple  hv_BboxLabelIndex, hv_BboxConfidences, hv_TextConf;
  Htuple  hv_BboxClassIndex, hv_BboxColorsBoth, hv_BboxClassLabelIndexUniq;
  Htuple  hv_BboxIDs, hv_BboxColors, hv_BboxIDsUniq, hv_BboxColorsResults;
  Htuple  hv_BboxClassIndexUniq, hv_ClassificationLabelIDGroundTruth;
  Htuple  hv_ClassificationLabelIDResult, hv_PredictionText;
  Htuple  hv_BoarderOffset, hv_MetaInfo, hv_WindowImageRatioHeight;
  Htuple  hv_WindowImageRatioWidth, hv_BoarderOffsetRow, hv_BoarderOffsetCol;
  Htuple  hv_MarginBottom, hv_WindowCoordinates, hv_CurrentWindowHeight;
  Htuple  hv__, hv_MaxHeight, hv_PluralPostfix, hv_ClassificationLabelIDGroundTruthList;
  Htuple  hv_C, hv_ClassificationLabelIDResultList, hv_HasConfidences;
  Htuple  hv_TPIndices, hv_RIdx, hv_ResultLine, hv_HasFalseNegatives;
  Htuple  hv_FalseNegativeClassIDs, hv_FNIdx, hv_FNClassIdx;
  Htuple  hv_FNLine, hv_NumFNLines, hv_IsMLC, hv_ResultColors;
  Htuple  hv_SelectedHeatmapMethod, hv_DictHeatmap, hv_MethodName;
  Htuple  hv_HeatmapKeys, hv_HeatmapImageName, hv_TargetClassID;
  Htuple  hv_Confidences, hv_MaxDeviation, hv_ClassificationLabelNameResult;
  Htuple  hv_TargetClassConfidence, hv_ClassificationLabelNamesGroundTruth;
  Htuple  hv_ShowGT, hv_ShowResult, hv_NumLines, hv_Type;
  Htuple  hv_GTWordKeyExists, hv_HeightWindow, hv_HeightMarginBottom;
  Htuple  hv_Size, hv_Length, hv_Row, hv_Column, hv_HomMat2DIdentity;
  Htuple  hv_HomMat2DRotate, hv_HomMat2DCompose, hv_PredictionForegroundColor;
  Htuple  hv_PredictionBackgroundColor, hv_Spaces, hv_ConfidenceColors;
  Htuple  hv_ColorsResults, hv_GroundTruthIDs, hv_ResultIDs;
  Htuple  hv_ImageClassIDsUniq, hv_ImageClassIDsIndices, hv_ImageClassIDsIndex;
  Htuple  hv_StringSegExcludeClassIDs, hv_StringIndex, hv_Min;
  Htuple  hv_Max, hv_Range, hv_ColorsSegmentation, hv_DrawMode;
  Htuple  hv_Width, hv_MinWeight, hv_WeightsColors, hv_Indices;
  Htuple  hv_WindowHandleKeysNew, hv___Tmp_Ctrl_Dict_Init_2;
  Htuple  hv___Tmp_Ctrl_Dict_Init_3, hv___Tmp_Ctrl_Dict_Init_4;
  Htuple  hv___Tmp_Ctrl_Dict_Init_5, hv___Tmp_Ctrl_Dict_Init_6;
  Htuple  hv___Tmp_Ctrl_Dict_Init_7, hv___Tmp_Ctrl_Dict_Init_8;
  Htuple  hv___Tmp_Ctrl_1, hv___Tmp_Ctrl_Type;

  /* Local copy input parameter variables */
  Htuple   hv_DLResult_COPY_INP_TMP;
  Htuple   hv_KeysForDisplay_COPY_INP_TMP;


  /* Array for temporary output ctrl variables */
  Htuple  CExpDummyOCvar[3];

  /* Initialize iconic variables */
  gen_empty_obj(&ho_Image);
  gen_empty_obj(&ho_Domain);
  gen_empty_obj(&ho_GrippingMapImageResult);
  gen_empty_obj(&ho_Cross);
  gen_empty_obj(&ho_GrippingMapGroundTruth);
  gen_empty_obj(&ho_X);
  gen_empty_obj(&ho_Y);
  gen_empty_obj(&ho_Z);
  gen_empty_obj(&ho_AnomalyImage);
  gen_empty_obj(&ho_AnomalyRegion);
  gen_empty_obj(&ho_ConfidenceImage);
  gen_empty_obj(&ho_HeatmapScene);
  gen_empty_obj(&ho_ScoreMaps);
  gen_empty_obj(&ho_CharacterScoreMap);
  gen_empty_obj(&ho_LinkScoreMap);
  gen_empty_obj(&ho_OrientationSinScoreMap);
  gen_empty_obj(&ho_OrientationCosScoreMap);
  gen_empty_obj(&ho_ScoreMap);
  gen_empty_obj(&ho_OrientationScoreMap);
  gen_empty_obj(&ho_PredictionColorFrame);
  gen_empty_obj(&ho_ImageHeatmap);
  gen_empty_obj(&ho_PredictionSymbol);
  gen_empty_obj(&ho_CrossLineH);
  gen_empty_obj(&ho_CrossLineV);
  gen_empty_obj(&ho_ImageConfidence);
  gen_empty_obj(&ho_SegmentationImagGroundTruth);
  gen_empty_obj(&ho_SegmentationImageResult);
  gen_empty_obj(&ho_ImageAbsDiff);
  gen_empty_obj(&ho_DiffRegion);
  gen_empty_obj(&ho_ImageWeight);

  /* Initialize control variables */
  create_tuple(&hv_Params,0);
  create_tuple(&hv_GenParamNames,0);
  create_tuple(&hv_ParamIndex,0);
  create_tuple(&hv_GenParamName,0);
  create_tuple(&hv_KeyExists,0);
  create_tuple(&hv_SampleKeys,0);
  create_tuple(&hv_ResultKeys,0);
  create_tuple(&hv_ImageIDExists,0);
  create_tuple(&hv_ImageID,0);
  create_tuple(&hv_ImageIDString,0);
  create_tuple(&hv_ImageIDStringBraces,0);
  create_tuple(&hv_ImageIDStringCapital,0);
  create_tuple(&hv_IsOCRDetection,0);
  create_tuple(&hv_AdditionalGreenClassNames,0);
  create_tuple(&hv_KeyIndex,0);
  create_tuple(&hv_OcrResult,0);
  create_tuple(&hv_MaxClassIdSample,0);
  create_tuple(&hv_EmptySample,0);
  create_tuple(&hv_MaxClassIdResult,0);
  create_tuple(&hv_EmptyResult,0);
  create_tuple(&hv_MaxClassId,0);
  create_tuple(&hv_ClassNames,0);
  create_tuple(&hv_ClassIDs,0);
  create_tuple(&hv_ClassNameKey,0);
  create_tuple(&hv_ClassIdKey,0);
  create_tuple(&hv_ResultClassNames,0);
  create_tuple(&hv_ResultClassIds,0);
  create_tuple(&hv_SortIndices,0);
  create_tuple(&hv_UniqueClassIds,0);
  create_tuple(&hv_UniqueClassNames,0);
  create_tuple(&hv_Colors,0);
  create_tuple(&hv_ClassesLegend,0);
  create_tuple(&hv_InvalidInput,0);
  create_tuple(&hv_ClassKeys,0);
  create_tuple(&hv_ClassKeysExist,0);
  create_tuple(&hv_DLDatasetInfoKeys,0);
  create_tuple(&hv_Index,0);
  create_tuple(&hv_ClassIDstoIndex,0);
  create_tuple(&hv_I,0);
  create_tuple(&hv_PrevWindowCoordinates,0);
  create_tuple(&hv_Keys,0);
  create_tuple(&hv_Exception,0);
  create_tuple(&hv_MetaInfoExists,0);
  create_tuple(&hv_FlushValues,0);
  create_tuple(&hv_WindowHandleKeys,0);
  create_tuple(&hv_WindowHandles,0);
  create_tuple(&hv_WindowIndex,0);
  create_tuple(&hv_FlushValue,0);
  create_tuple(&hv_WidthImage,0);
  create_tuple(&hv_HeightImage,0);
  create_tuple(&hv_CurrentWindowHandle,0);
  create_tuple(&hv_WindowImageRatio,0);
  create_tuple(&hv_ColorsGrippingGroundTruth,0);
  create_tuple(&hv_ImageClassIDs,0);
  create_tuple(&hv_GrippingPointsExists,0);
  create_tuple(&hv_Rows,0);
  create_tuple(&hv_Columns,0);
  create_tuple(&hv_AnomalyImages,0);
  create_tuple(&hv_PossibleKeysForDisplay,0);
  create_tuple(&hv_AddDisplayKey,0);
  create_tuple(&hv_AnomalyLabelGroundTruth,0);
  create_tuple(&hv_AnomalyLabelIDGroundTruth,0);
  create_tuple(&hv_AnomalyResultPostfix,0);
  create_tuple(&hv_AnomalyScore,0);
  create_tuple(&hv_AnomalyClassID,0);
  create_tuple(&hv_AnomalyClassThresholdDisplay,0);
  create_tuple(&hv_AnomalyRegionThresholdDisplay,0);
  create_tuple(&hv_WindowHandleName,0);
  create_tuple(&hv_AnomalyRegionGroundTruthExists,0);
  create_tuple(&hv_Text,0);
  create_tuple(&hv_PredictionColor,0);
  create_tuple(&hv_LineColors,0);
  create_tuple(&hv_ResultColorOffset,0);
  create_tuple(&hv_AnomalyRegionExists,0);
  create_tuple(&hv_AnomalyImageKey,0);
  create_tuple(&hv_AnomalyScoreKey,0);
  create_tuple(&hv_AnomalyResultKey,0);
  create_tuple(&hv_AnomalyRegionKey,0);
  create_tuple(&hv_DisplayDirectionTemp,0);
  create_tuple(&hv_BboxLabelIndex,0);
  create_tuple(&hv_BboxConfidences,0);
  create_tuple(&hv_TextConf,0);
  create_tuple(&hv_BboxClassIndex,0);
  create_tuple(&hv_BboxColorsBoth,0);
  create_tuple(&hv_BboxClassLabelIndexUniq,0);
  create_tuple(&hv_BboxIDs,0);
  create_tuple(&hv_BboxColors,0);
  create_tuple(&hv_BboxIDsUniq,0);
  create_tuple(&hv_BboxColorsResults,0);
  create_tuple(&hv_BboxClassIndexUniq,0);
  create_tuple(&hv_ClassificationLabelIDGroundTruth,0);
  create_tuple(&hv_ClassificationLabelIDResult,0);
  create_tuple(&hv_PredictionText,0);
  create_tuple(&hv_BoarderOffset,0);
  create_tuple(&hv_MetaInfo,0);
  create_tuple(&hv_WindowImageRatioHeight,0);
  create_tuple(&hv_WindowImageRatioWidth,0);
  create_tuple(&hv_BoarderOffsetRow,0);
  create_tuple(&hv_BoarderOffsetCol,0);
  create_tuple(&hv_MarginBottom,0);
  create_tuple(&hv_WindowCoordinates,0);
  create_tuple(&hv_CurrentWindowHeight,0);
  create_tuple(&hv__,0);
  create_tuple(&hv_MaxHeight,0);
  create_tuple(&hv_PluralPostfix,0);
  create_tuple(&hv_ClassificationLabelIDGroundTruthList,0);
  create_tuple(&hv_C,0);
  create_tuple(&hv_ClassificationLabelIDResultList,0);
  create_tuple(&hv_HasConfidences,0);
  create_tuple(&hv_TPIndices,0);
  create_tuple(&hv_RIdx,0);
  create_tuple(&hv_ResultLine,0);
  create_tuple(&hv_HasFalseNegatives,0);
  create_tuple(&hv_FalseNegativeClassIDs,0);
  create_tuple(&hv_FNIdx,0);
  create_tuple(&hv_FNClassIdx,0);
  create_tuple(&hv_FNLine,0);
  create_tuple(&hv_NumFNLines,0);
  create_tuple(&hv_IsMLC,0);
  create_tuple(&hv_ResultColors,0);
  create_tuple(&hv_SelectedHeatmapMethod,0);
  create_tuple(&hv_DictHeatmap,0);
  create_tuple(&hv_MethodName,0);
  create_tuple(&hv_HeatmapKeys,0);
  create_tuple(&hv_HeatmapImageName,0);
  create_tuple(&hv_TargetClassID,0);
  create_tuple(&hv_Confidences,0);
  create_tuple(&hv_MaxDeviation,0);
  create_tuple(&hv_ClassificationLabelNameResult,0);
  create_tuple(&hv_TargetClassConfidence,0);
  create_tuple(&hv_ClassificationLabelNamesGroundTruth,0);
  create_tuple(&hv_ShowGT,0);
  create_tuple(&hv_ShowResult,0);
  create_tuple(&hv_NumLines,0);
  create_tuple(&hv_Type,0);
  create_tuple(&hv_GTWordKeyExists,0);
  create_tuple(&hv_HeightWindow,0);
  create_tuple(&hv_HeightMarginBottom,0);
  create_tuple(&hv_Size,0);
  create_tuple(&hv_Length,0);
  create_tuple(&hv_Row,0);
  create_tuple(&hv_Column,0);
  create_tuple(&hv_HomMat2DIdentity,0);
  create_tuple(&hv_HomMat2DRotate,0);
  create_tuple(&hv_HomMat2DCompose,0);
  create_tuple(&hv_PredictionForegroundColor,0);
  create_tuple(&hv_PredictionBackgroundColor,0);
  create_tuple(&hv_Spaces,0);
  create_tuple(&hv_ConfidenceColors,0);
  create_tuple(&hv_ColorsResults,0);
  create_tuple(&hv_GroundTruthIDs,0);
  create_tuple(&hv_ResultIDs,0);
  create_tuple(&hv_ImageClassIDsUniq,0);
  create_tuple(&hv_ImageClassIDsIndices,0);
  create_tuple(&hv_ImageClassIDsIndex,0);
  create_tuple(&hv_StringSegExcludeClassIDs,0);
  create_tuple(&hv_StringIndex,0);
  create_tuple(&hv_Min,0);
  create_tuple(&hv_Max,0);
  create_tuple(&hv_Range,0);
  create_tuple(&hv_ColorsSegmentation,0);
  create_tuple(&hv_DrawMode,0);
  create_tuple(&hv_Width,0);
  create_tuple(&hv_MinWeight,0);
  create_tuple(&hv_WeightsColors,0);
  create_tuple(&hv_Indices,0);
  create_tuple(&hv_WindowHandleKeysNew,0);
  create_tuple(&hv___Tmp_Ctrl_Dict_Init_2,0);
  create_tuple(&hv___Tmp_Ctrl_Dict_Init_3,0);
  create_tuple(&hv___Tmp_Ctrl_Dict_Init_4,0);
  create_tuple(&hv___Tmp_Ctrl_Dict_Init_5,0);
  create_tuple(&hv___Tmp_Ctrl_Dict_Init_6,0);
  create_tuple(&hv___Tmp_Ctrl_Dict_Init_7,0);
  create_tuple(&hv___Tmp_Ctrl_Dict_Init_8,0);
  create_tuple(&hv___Tmp_Ctrl_1,0);
  create_tuple(&hv___Tmp_Ctrl_Type,0);
  copy_tuple(hv_DLResult,&hv_DLResult_COPY_INP_TMP);
  copy_tuple(hv_KeysForDisplay,&hv_KeysForDisplay_COPY_INP_TMP);

  /****************************************************/
  /******************   Begin procedure   *************/
  /****************************************************/

  /**/
  /*This procedure displays the content of the provided DLSample and/or DLResult*/
  /*depending on the input string KeysForDisplay.*/
  /*DLDatasetInfo is a dictionary containing the information about the dataset.*/
  /*The visualization can be adapted with GenParam.*/
  /**/
  /*** Set the default values: ****/
  /*create_dict (Params)*/
  destroy_tuple(hv_Params);
  /***/T_create_dict(&hv_Params);

  /**/
  /*Define the screen width when a new window row is started.*/
  /*set_dict_tuple (Params, ['threshold_width'], 1024)*/
  create_tuple_s(&TTemp[SP++],"threshold_width");
  create_tuple_i(&TTemp[SP++],1024);
  /***/T_set_dict_tuple(hv_Params, TTemp[SP-2], TTemp[SP-1]);
  destroy_tuple(TTemp[--SP]);
  destroy_tuple(TTemp[--SP]);

  /*Since potentially a lot of windows are opened,*/
  /*scale the windows consistently.*/
  /*set_dict_tuple (Params, ['scale_windows'], 0.8)*/
  create_tuple_s(&TTemp[SP++],"scale_windows");
  create_tuple_d(&TTemp[SP++],0.8);
  /***/T_set_dict_tuple(hv_Params, TTemp[SP-2], TTemp[SP-1]);
  destroy_tuple(TTemp[--SP]);
  destroy_tuple(TTemp[--SP]);

  /*Set a font and a font size.*/
  /*set_dict_tuple (Params, ['font'], 'mono')*/
  create_tuple_s(&TTemp[SP++],"font");
  create_tuple_s(&TTemp[SP++],"mono");
  /***/T_set_dict_tuple(hv_Params, TTemp[SP-2], TTemp[SP-1]);
  destroy_tuple(TTemp[--SP]);
  destroy_tuple(TTemp[--SP]);

  /*set_dict_tuple (Params, ['font_size'], 14)*/
  create_tuple_s(&TTemp[SP++],"font_size");
  create_tuple_i(&TTemp[SP++],14);
  /***/T_set_dict_tuple(hv_Params, TTemp[SP-2], TTemp[SP-1]);
  destroy_tuple(TTemp[--SP]);
  destroy_tuple(TTemp[--SP]);

  /**/
  /*set_dict_tuple (Params, ['line_width'], 2)*/
  create_tuple_s(&TTemp[SP++],"line_width");
  create_tuple_i(&TTemp[SP++],2);
  /***/T_set_dict_tuple(hv_Params, TTemp[SP-2], TTemp[SP-1]);
  destroy_tuple(TTemp[--SP]);
  destroy_tuple(TTemp[--SP]);

  /*set_dict_tuple (Params, ['map_transparency'], 'cc')*/
  create_tuple_s(&TTemp[SP++],"map_transparency");
  create_tuple_s(&TTemp[SP++],"cc");
  /***/T_set_dict_tuple(hv_Params, TTemp[SP-2], TTemp[SP-1]);
  destroy_tuple(TTemp[--SP]);
  destroy_tuple(TTemp[--SP]);

  /*set_dict_tuple (Params, ['map_color_bar_width'], 140)*/
  create_tuple_s(&TTemp[SP++],"map_color_bar_width");
  create_tuple_i(&TTemp[SP++],140);
  /***/T_set_dict_tuple(hv_Params, TTemp[SP-2], TTemp[SP-1]);
  destroy_tuple(TTemp[--SP]);
  destroy_tuple(TTemp[--SP]);

  /**/
  /*Define parameter values specifically for 3d_gripping_point_detection*/
  /*set_dict_tuple (Params, ['gripping_point_color'], '#00FF0099')*/
  create_tuple_s(&TTemp[SP++],"gripping_point_color");
  create_tuple_s(&TTemp[SP++],"#00FF0099");
  /***/T_set_dict_tuple(hv_Params, TTemp[SP-2], TTemp[SP-1]);
  destroy_tuple(TTemp[--SP]);
  destroy_tuple(TTemp[--SP]);

  /*set_dict_tuple (Params, ['gripping_point_size'], 6)*/
  create_tuple_s(&TTemp[SP++],"gripping_point_size");
  create_tuple_i(&TTemp[SP++],6);
  /***/T_set_dict_tuple(hv_Params, TTemp[SP-2], TTemp[SP-1]);
  destroy_tuple(TTemp[--SP]);
  destroy_tuple(TTemp[--SP]);

  /*set_dict_tuple (Params, ['region_color'], '#FF000040')*/
  create_tuple_s(&TTemp[SP++],"region_color");
  create_tuple_s(&TTemp[SP++],"#FF000040");
  /***/T_set_dict_tuple(hv_Params, TTemp[SP-2], TTemp[SP-1]);
  destroy_tuple(TTemp[--SP]);
  destroy_tuple(TTemp[--SP]);

  /*set_dict_tuple (Params, ['gripping_point_map_color'], '#83000080')*/
  create_tuple_s(&TTemp[SP++],"gripping_point_map_color");
  create_tuple_s(&TTemp[SP++],"#83000080");
  /***/T_set_dict_tuple(hv_Params, TTemp[SP-2], TTemp[SP-1]);
  destroy_tuple(TTemp[--SP]);
  destroy_tuple(TTemp[--SP]);

  /*set_dict_tuple (Params, ['gripping_point_background_color'], '#00007F80')*/
  create_tuple_s(&TTemp[SP++],"gripping_point_background_color");
  create_tuple_s(&TTemp[SP++],"#00007F80");
  /***/T_set_dict_tuple(hv_Params, TTemp[SP-2], TTemp[SP-1]);
  destroy_tuple(TTemp[--SP]);
  destroy_tuple(TTemp[--SP]);

  /**/
  /*Define parameter values specifically for anomaly detection*/
  /*and Global Context Anomaly Detection.*/
  /*set_dict_tuple (Params, ['anomaly_region_threshold'], -1)*/
  create_tuple_s(&TTemp[SP++],"anomaly_region_threshold");
  create_tuple_i(&TTemp[SP++],-1);
  /***/T_set_dict_tuple(hv_Params, TTemp[SP-2], TTemp[SP-1]);
  destroy_tuple(TTemp[--SP]);
  destroy_tuple(TTemp[--SP]);

  /*set_dict_tuple (Params, ['anomaly_classification_threshold'], -1)*/
  create_tuple_s(&TTemp[SP++],"anomaly_classification_threshold");
  create_tuple_i(&TTemp[SP++],-1);
  /***/T_set_dict_tuple(hv_Params, TTemp[SP-2], TTemp[SP-1]);
  destroy_tuple(TTemp[--SP]);
  destroy_tuple(TTemp[--SP]);

  /*set_dict_tuple (Params, ['anomaly_region_label_color'], '#40e0d0')*/
  create_tuple_s(&TTemp[SP++],"anomaly_region_label_color");
  create_tuple_s(&TTemp[SP++],"#40e0d0");
  /***/T_set_dict_tuple(hv_Params, TTemp[SP-2], TTemp[SP-1]);
  destroy_tuple(TTemp[--SP]);
  destroy_tuple(TTemp[--SP]);

  /*set_dict_tuple (Params, ['anomaly_color_transparency'], '40')*/
  create_tuple_s(&TTemp[SP++],"anomaly_color_transparency");
  create_tuple_s(&TTemp[SP++],"40");
  /***/T_set_dict_tuple(hv_Params, TTemp[SP-2], TTemp[SP-1]);
  destroy_tuple(TTemp[--SP]);
  destroy_tuple(TTemp[--SP]);

  /*set_dict_tuple (Params, ['anomaly_region_result_color'], '#ff0000c0')*/
  create_tuple_s(&TTemp[SP++],"anomaly_region_result_color");
  create_tuple_s(&TTemp[SP++],"#ff0000c0");
  /***/T_set_dict_tuple(hv_Params, TTemp[SP-2], TTemp[SP-1]);
  destroy_tuple(TTemp[--SP]);
  destroy_tuple(TTemp[--SP]);

  /**/
  /*Define segmentation-specific parameter values.*/
  /*set_dict_tuple (Params, ['segmentation_max_weight'], 0)*/
  create_tuple_s(&TTemp[SP++],"segmentation_max_weight");
  create_tuple_i(&TTemp[SP++],0);
  /***/T_set_dict_tuple(hv_Params, TTemp[SP-2], TTemp[SP-1]);
  destroy_tuple(TTemp[--SP]);
  destroy_tuple(TTemp[--SP]);

  /*set_dict_tuple (Params, ['segmentation_draw'], 'fill')*/
  create_tuple_s(&TTemp[SP++],"segmentation_draw");
  create_tuple_s(&TTemp[SP++],"fill");
  /***/T_set_dict_tuple(hv_Params, TTemp[SP-2], TTemp[SP-1]);
  destroy_tuple(TTemp[--SP]);
  destroy_tuple(TTemp[--SP]);

  /*set_dict_tuple (Params, ['segmentation_transparency'], 'aa')*/
  create_tuple_s(&TTemp[SP++],"segmentation_transparency");
  create_tuple_s(&TTemp[SP++],"aa");
  /***/T_set_dict_tuple(hv_Params, TTemp[SP-2], TTemp[SP-1]);
  destroy_tuple(TTemp[--SP]);
  destroy_tuple(TTemp[--SP]);

  /*set_dict_tuple (Params, ['segmentation_exclude_class_ids'], [])*/
  create_tuple_s(&TTemp[SP++],"segmentation_exclude_class_ids");
  create_tuple(&TTemp[SP++],0);
  /***/T_set_dict_tuple(hv_Params, TTemp[SP-2], TTemp[SP-1]);
  destroy_tuple(TTemp[--SP]);
  destroy_tuple(TTemp[--SP]);

  /**/
  /*Define bounding box-specific parameter values.*/
  /*set_dict_tuple (Params, ['bbox_label_color'], '#000000' + '99')*/
  create_tuple_s(&TTemp[SP++],"bbox_label_color");
  create_tuple_s(&TTemp[SP++],"#000000");
  create_tuple_s(&TTemp[SP++],"99");
  T_tuple_add(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-2]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-2]=TTemp[SP];
  SP--;
  /***/T_set_dict_tuple(hv_Params, TTemp[SP-2], TTemp[SP-1]);
  destroy_tuple(TTemp[--SP]);
  destroy_tuple(TTemp[--SP]);

  /*set_dict_tuple (Params, ['bbox_display_confidence'], 1)*/
  create_tuple_s(&TTemp[SP++],"bbox_display_confidence");
  create_tuple_i(&TTemp[SP++],1);
  /***/T_set_dict_tuple(hv_Params, TTemp[SP-2], TTemp[SP-1]);
  destroy_tuple(TTemp[--SP]);
  destroy_tuple(TTemp[--SP]);

  /*set_dict_tuple (Params, ['bbox_text_color'], '#eeeeee')*/
  create_tuple_s(&TTemp[SP++],"bbox_text_color");
  create_tuple_s(&TTemp[SP++],"#eeeeee");
  /***/T_set_dict_tuple(hv_Params, TTemp[SP-2], TTemp[SP-1]);
  destroy_tuple(TTemp[--SP]);
  destroy_tuple(TTemp[--SP]);

  /**/
  /*By default, display a description on the bottom.*/
  /*set_dict_tuple (Params, ['display_bottom_desc'], true)*/
  create_tuple_s(&TTemp[SP++],"display_bottom_desc");
  create_tuple_i(&TTemp[SP++],1);
  /***/T_set_dict_tuple(hv_Params, TTemp[SP-2], TTemp[SP-1]);
  destroy_tuple(TTemp[--SP]);
  destroy_tuple(TTemp[--SP]);

  /**/
  /*By default, show a legend with class IDs.*/
  /*set_dict_tuple (Params, ['display_legend'], true)*/
  create_tuple_s(&TTemp[SP++],"display_legend");
  create_tuple_i(&TTemp[SP++],1);
  /***/T_set_dict_tuple(hv_Params, TTemp[SP-2], TTemp[SP-1]);
  destroy_tuple(TTemp[--SP]);
  destroy_tuple(TTemp[--SP]);

  /**/
  /*By default, show the anomaly ground truth regions.*/
  /*set_dict_tuple (Params, ['display_ground_truth_anomaly_regions'], true)*/
  create_tuple_s(&TTemp[SP++],"display_ground_truth_anomaly_regions");
  create_tuple_i(&TTemp[SP++],1);
  /***/T_set_dict_tuple(hv_Params, TTemp[SP-2], TTemp[SP-1]);
  destroy_tuple(TTemp[--SP]);
  destroy_tuple(TTemp[--SP]);

  /**/
  /*By default, show class IDs and color frames for classification ground truth/results.*/
  /*set_dict_tuple (Params, ['display_classification_ids'], true)*/
  create_tuple_s(&TTemp[SP++],"display_classification_ids");
  create_tuple_i(&TTemp[SP++],1);
  /***/T_set_dict_tuple(hv_Params, TTemp[SP-2], TTemp[SP-1]);
  destroy_tuple(TTemp[--SP]);
  destroy_tuple(TTemp[--SP]);

  /*set_dict_tuple (Params, ['display_classification_color_frame'], true)*/
  create_tuple_s(&TTemp[SP++],"display_classification_color_frame");
  create_tuple_i(&TTemp[SP++],1);
  /***/T_set_dict_tuple(hv_Params, TTemp[SP-2], TTemp[SP-1]);
  destroy_tuple(TTemp[--SP]);
  destroy_tuple(TTemp[--SP]);

  /**/
  /*By default, show class labels for detection ground truth/results.*/
  /*set_dict_tuple (Params, ['display_labels'], true)*/
  create_tuple_s(&TTemp[SP++],"display_labels");
  create_tuple_i(&TTemp[SP++],1);
  /***/T_set_dict_tuple(hv_Params, TTemp[SP-2], TTemp[SP-1]);
  destroy_tuple(TTemp[--SP]);
  destroy_tuple(TTemp[--SP]);

  /**/
  /*By default, show direction of the ground truth/results instances for detection with instance_type 'rectangle2'.*/
  /*set_dict_tuple (Params, ['display_direction'], true)*/
  create_tuple_s(&TTemp[SP++],"display_direction");
  create_tuple_i(&TTemp[SP++],1);
  /***/T_set_dict_tuple(hv_Params, TTemp[SP-2], TTemp[SP-1]);
  destroy_tuple(TTemp[--SP]);
  destroy_tuple(TTemp[--SP]);

  /**/
  /*By default, use color scheme 'Jet' for the heatmap display.*/
  /*set_dict_tuple (Params, ['heatmap_color_scheme'], 'jet')*/
  create_tuple_s(&TTemp[SP++],"heatmap_color_scheme");
  create_tuple_s(&TTemp[SP++],"jet");
  /***/T_set_dict_tuple(hv_Params, TTemp[SP-2], TTemp[SP-1]);
  destroy_tuple(TTemp[--SP]);
  destroy_tuple(TTemp[--SP]);

  /*** Set user-defined values: ****/
  /**/
  /*Overwrite default values by given generic parameters.*/
  /*========== if (GenParam != []) ==========*/
  create_tuple(&TTemp[SP++],0);
  T_tuple_not_equal(hv_GenParam,TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-1]=TTemp[SP];
  if(get_i(TTemp[SP-1],0))
  {
    /*get_dict_param (GenParam, 'keys', [], GenParamNames)*/
    create_tuple_s(&TTemp[SP++],"keys");
    create_tuple(&TTemp[SP++],0);
    destroy_tuple(hv_GenParamNames);
    /***/T_get_dict_param(hv_GenParam, TTemp[SP-2], TTemp[SP-1], &hv_GenParamNames);
    destroy_tuple(TTemp[--SP]);
    destroy_tuple(TTemp[--SP]);

    /*========== for ParamIndex := 0 to |GenParamNames| - 1 by 1 ==========*/
    T_tuple_length(hv_GenParamNames,&TTemp[SP++]);
    create_tuple_i(&TTemp[SP++],1);
    T_tuple_sub(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-2]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-2]=TTemp[SP];
    SP--;
    create_tuple_i(&TTemp[SP++],1);
    create_tuple_i(&TTemp[SP++],0);
    T_tuple_greater(TTemp[SP-1],TTemp[SP-3],&TTemp[SP]);
    SP++;
    T_tuple_equal(TTemp[SP-2],TTemp[SP-4],&TTemp[SP]);
    if(get_i(TTemp[SP],0) ||
       (!((( get_i(TTemp[SP-1],0)) && (get_d(TTemp[SP-3],0)>0)) ||
          ((!get_i(TTemp[SP-1],0)) && (get_d(TTemp[SP-3],0)<0)))))
    {
     destroy_tuple(TTemp[SP--]);
     destroy_tuple(TTemp[SP]);
     T_tuple_sub(TTemp[SP-1],TTemp[SP-2],&TTemp[SP]);
     destroy_tuple(hv_ParamIndex);
     copy_tuple(TTemp[SP],&hv_ParamIndex);
     destroy_tuple(TTemp[SP--]);
     destroy_tuple(TTemp[SP]);
     for(;;)
     {
     T_tuple_add(hv_ParamIndex,TTemp[SP-1],&TTemp[SP]);
     destroy_tuple(hv_ParamIndex);
     copy_tuple(TTemp[SP],&hv_ParamIndex);
     destroy_tuple(TTemp[SP]);
     if(get_d(TTemp[SP-1],0)<0)
      T_tuple_less(hv_ParamIndex,TTemp[SP-2],&TTemp[SP]);
     else
      T_tuple_greater(hv_ParamIndex,TTemp[SP-2],&TTemp[SP]);
     if(get_i(TTemp[SP],0)) break;
     destroy_tuple(TTemp[SP]);
     /*========== for ==========*/

      /*GenParamName := GenParamNames[ParamIndex]*/
      T_tuple_select(hv_GenParamNames,hv_ParamIndex,&TTemp[SP++]);
      destroy_tuple(hv_GenParamName);
      hv_GenParamName=TTemp[--SP];

      /*get_dict_param (Params, 'key_exists', GenParamName, KeyExists)*/
      create_tuple_s(&TTemp[SP++],"key_exists");
      destroy_tuple(hv_KeyExists);
      /***/T_get_dict_param(hv_Params, TTemp[SP-1], hv_GenParamName, &hv_KeyExists);
      destroy_tuple(TTemp[--SP]);

      /*========== if (not KeyExists) ==========*/
      T_tuple_not(hv_KeyExists,&TTemp[SP++]);
      if(get_i(TTemp[SP-1],0))
      {
        /* throw(...); only in hdevelop*/
      }
      destroy_tuple(TTemp[--SP]);
      /*========== end if ==========*/
      /*get_dict_param (GenParam, 'key_data_type', GenParamName, __Tmp_Ctrl_Type)*/
      create_tuple_s(&TTemp[SP++],"key_data_type");
      destroy_tuple(hv___Tmp_Ctrl_Type);
      /***/T_get_dict_param(hv_GenParam, TTemp[SP-1], hv_GenParamName, &hv___Tmp_Ctrl_Type);
      destroy_tuple(TTemp[--SP]);

      /*========== if (__Tmp_Ctrl_Type == 'object') ==========*/
      create_tuple_s(&TTemp[SP++],"object");
      T_tuple_equal(hv___Tmp_Ctrl_Type,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      if(get_i(TTemp[SP-1],0))
      {
        /*set_dict_object (__get_dict_object( GenParam, GenParamName), Params, GenParamName)*/
        T_get_dict_object(&OTemp[SPO++],hv_GenParam,hv_GenParamName);
        /***/T_set_dict_object(OTemp[SPO-1], hv_Params, hv_GenParamName);
        clear_obj(OTemp[--SPO]);

      }
      else
      {
        /*set_dict_tuple (Params, GenParamName, __get_dict_tuple( GenParam, GenParamName))*/
        T_get_dict_tuple(hv_GenParam,hv_GenParamName,&TTemp[SP++]);
        /***/T_set_dict_tuple(hv_Params, hv_GenParamName, TTemp[SP-1]);
        destroy_tuple(TTemp[--SP]);

      }
      destroy_tuple(TTemp[--SP]);
      /*========== end if ==========*/
     }
     destroy_tuple(TTemp[SP--]);
     destroy_tuple(TTemp[SP--]);
     destroy_tuple(TTemp[SP]);
    }
    else
    {
     destroy_tuple(TTemp[SP--]);
     destroy_tuple(TTemp[SP--]);
     destroy_tuple(TTemp[SP--]);
     destroy_tuple(TTemp[SP--]);
     destroy_tuple(TTemp[SP]);
    }/*========== end for ========*/

  }
  destroy_tuple(TTemp[--SP]);
  /*========== end if ==========*/
  /**/
  /*========== if (|DLSample| > 1 or |DLResult| > 1) ==========*/
  T_tuple_length(hv_DLSample,&TTemp[SP++]);
  create_tuple_i(&TTemp[SP++],1);
  T_tuple_greater(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-2]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-2]=TTemp[SP];
  SP--;
  T_tuple_length(hv_DLResult_COPY_INP_TMP,&TTemp[SP++]);
  create_tuple_i(&TTemp[SP++],1);
  T_tuple_greater(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-2]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-2]=TTemp[SP];
  SP--;
  T_tuple_or(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-2]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-2]=TTemp[SP];
  SP--;
  if(get_i(TTemp[SP-1],0))
  {
    /* throw(...); only in hdevelop*/
  }
  destroy_tuple(TTemp[--SP]);
  /*========== end if ==========*/
  /**/
  /*Get the dictionary keys.*/
  /*get_dict_param (DLSample, 'keys', [], SampleKeys)*/
  create_tuple_s(&TTemp[SP++],"keys");
  create_tuple(&TTemp[SP++],0);
  destroy_tuple(hv_SampleKeys);
  /***/T_get_dict_param(hv_DLSample, TTemp[SP-2], TTemp[SP-1], &hv_SampleKeys);
  destroy_tuple(TTemp[--SP]);
  destroy_tuple(TTemp[--SP]);

  /*========== if (DLResult != []) ==========*/
  create_tuple(&TTemp[SP++],0);
  T_tuple_not_equal(hv_DLResult_COPY_INP_TMP,TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-1]=TTemp[SP];
  if(get_i(TTemp[SP-1],0))
  {
    /*get_dict_param (DLResult, 'keys', [], ResultKeys)*/
    create_tuple_s(&TTemp[SP++],"keys");
    create_tuple(&TTemp[SP++],0);
    destroy_tuple(hv_ResultKeys);
    /***/T_get_dict_param(hv_DLResult_COPY_INP_TMP, TTemp[SP-2], TTemp[SP-1], &hv_ResultKeys);
    destroy_tuple(TTemp[--SP]);
    destroy_tuple(TTemp[--SP]);

  }
  destroy_tuple(TTemp[--SP]);
  /*========== end if ==========*/
  /**/
  /*Get image ID if it is available.*/
  /*get_dict_param (DLSample, 'key_exists', 'image_id', ImageIDExists)*/
  create_tuple_s(&TTemp[SP++],"key_exists");
  create_tuple_s(&TTemp[SP++],"image_id");
  destroy_tuple(hv_ImageIDExists);
  /***/T_get_dict_param(hv_DLSample, TTemp[SP-2], TTemp[SP-1], &hv_ImageIDExists);
  destroy_tuple(TTemp[--SP]);
  destroy_tuple(TTemp[--SP]);

  /*========== if (ImageIDExists) ==========*/
  copy_tuple(hv_ImageIDExists,&TTemp[SP++]);
  if(get_i(TTemp[SP-1],0))
  {
    /*get_dict_tuple (DLSample, 'image_id', ImageID)*/
    create_tuple_s(&TTemp[SP++],"image_id");
    destroy_tuple(hv_ImageID);
    /***/T_get_dict_tuple(hv_DLSample, TTemp[SP-1], &hv_ImageID);
    destroy_tuple(TTemp[--SP]);

    /*ImageIDString := 'image ID ' + ImageID*/
    create_tuple_s(&TTemp[SP++],"image ID ");
    T_tuple_add(TTemp[SP-1],hv_ImageID,&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    destroy_tuple(hv_ImageIDString);
    hv_ImageIDString=TTemp[--SP];

    /*ImageIDStringBraces := '(image ID ' + ImageID + ')'*/
    create_tuple_s(&TTemp[SP++],"(image ID ");
    T_tuple_add(TTemp[SP-1],hv_ImageID,&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    create_tuple_s(&TTemp[SP++],")");
    T_tuple_add(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-2]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-2]=TTemp[SP];
    SP--;
    destroy_tuple(hv_ImageIDStringBraces);
    hv_ImageIDStringBraces=TTemp[--SP];

    /*ImageIDStringCapital := 'Image ID ' + ImageID*/
    create_tuple_s(&TTemp[SP++],"Image ID ");
    T_tuple_add(TTemp[SP-1],hv_ImageID,&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    destroy_tuple(hv_ImageIDStringCapital);
    hv_ImageIDStringCapital=TTemp[--SP];

  }
  else
  {
    /*ImageIDString := ''*/
    reuse_tuple_s(&hv_ImageIDString,"");
    /*ImageIDStringBraces := ImageIDString*/
    destroy_tuple(hv_ImageIDStringBraces);
    copy_tuple(hv_ImageIDString,&hv_ImageIDStringBraces);

    /*ImageIDStringCapital := ImageIDString*/
    destroy_tuple(hv_ImageIDStringCapital);
    copy_tuple(hv_ImageIDString,&hv_ImageIDStringCapital);

  }
  destroy_tuple(TTemp[--SP]);
  /*========== end if ==========*/
  /**/
  /*** Convert a Deep OCR Detection result to an Object Detection result if necessary ****/
  /**/
  /*IsOCRDetection := false*/
  reuse_tuple_i(&hv_IsOCRDetection,0);

  /*AdditionalGreenClassNames := []*/
  create_tuple(&TTemp[SP++],0);
  destroy_tuple(hv_AdditionalGreenClassNames);
  hv_AdditionalGreenClassNames=TTemp[--SP];

  /*KeyIndex := 0*/
  reuse_tuple_i(&hv_KeyIndex,0);

  /*========== for KeyIndex := 0 to |KeysForDisplay| - 1 by 1 ==========*/
  T_tuple_length(hv_KeysForDisplay_COPY_INP_TMP,&TTemp[SP++]);
  create_tuple_i(&TTemp[SP++],1);
  T_tuple_sub(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-2]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-2]=TTemp[SP];
  SP--;
  create_tuple_i(&TTemp[SP++],1);
  create_tuple_i(&TTemp[SP++],0);
  T_tuple_greater(TTemp[SP-1],TTemp[SP-3],&TTemp[SP]);
  SP++;
  T_tuple_equal(TTemp[SP-2],TTemp[SP-4],&TTemp[SP]);
  if(get_i(TTemp[SP],0) ||
     (!((( get_i(TTemp[SP-1],0)) && (get_d(TTemp[SP-3],0)>0)) ||
        ((!get_i(TTemp[SP-1],0)) && (get_d(TTemp[SP-3],0)<0)))))
  {
   destroy_tuple(TTemp[SP--]);
   destroy_tuple(TTemp[SP]);
   T_tuple_sub(TTemp[SP-1],TTemp[SP-2],&TTemp[SP]);
   destroy_tuple(hv_KeyIndex);
   copy_tuple(TTemp[SP],&hv_KeyIndex);
   destroy_tuple(TTemp[SP--]);
   destroy_tuple(TTemp[SP]);
   for(;;)
   {
   T_tuple_add(hv_KeyIndex,TTemp[SP-1],&TTemp[SP]);
   destroy_tuple(hv_KeyIndex);
   copy_tuple(TTemp[SP],&hv_KeyIndex);
   destroy_tuple(TTemp[SP]);
   if(get_d(TTemp[SP-1],0)<0)
    T_tuple_less(hv_KeyIndex,TTemp[SP-2],&TTemp[SP]);
   else
    T_tuple_greater(hv_KeyIndex,TTemp[SP-2],&TTemp[SP]);
   if(get_i(TTemp[SP],0)) break;
   destroy_tuple(TTemp[SP]);
   /*========== for ==========*/

    /*Check if Deep OCR Detection case*/
    /*tuple_strstr (KeysForDisplay[KeyIndex], 'ocr_detection', IsOCRDetection)*/
    T_tuple_select(hv_KeysForDisplay_COPY_INP_TMP,hv_KeyIndex,&TTemp[SP++]);
    create_tuple_s(&TTemp[SP++],"ocr_detection");
    destroy_tuple(hv_IsOCRDetection);
    /***/T_tuple_strstr(TTemp[SP-2], TTemp[SP-1], &hv_IsOCRDetection);
    destroy_tuple(TTemp[--SP]);
    destroy_tuple(TTemp[--SP]);

    /*IsOCRDetection := IsOCRDetection == 0*/
    copy_tuple(hv_IsOCRDetection,&TTemp[SP++]);
    create_tuple_i(&TTemp[SP++],0);
    T_tuple_equal(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-2]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-2]=TTemp[SP];
    SP--;
    destroy_tuple(hv_IsOCRDetection);
    hv_IsOCRDetection=TTemp[--SP];

    /*========== if (IsOCRDetection) ==========*/
    copy_tuple(hv_IsOCRDetection,&TTemp[SP++]);
    if(get_i(TTemp[SP-1],0))
    {
      /*Turn off labels*/
      /*set_dict_tuple (Params, ['bbox_display_confidence'], false)*/
      create_tuple_s(&TTemp[SP++],"bbox_display_confidence");
      create_tuple_i(&TTemp[SP++],0);
      /***/T_set_dict_tuple(hv_Params, TTemp[SP-2], TTemp[SP-1]);
      destroy_tuple(TTemp[--SP]);
      destroy_tuple(TTemp[--SP]);

      /*set_dict_tuple (Params, ['display_labels'], false)*/
      create_tuple_s(&TTemp[SP++],"display_labels");
      create_tuple_i(&TTemp[SP++],0);
      /***/T_set_dict_tuple(hv_Params, TTemp[SP-2], TTemp[SP-1]);
      destroy_tuple(TTemp[--SP]);
      destroy_tuple(TTemp[--SP]);

      /*Mark the class 'word' as green*/
      /*AdditionalGreenClassNames := 'word'*/
      reuse_tuple_s(&hv_AdditionalGreenClassNames,"word");
      /*========== if (DLResult != []) ==========*/
      create_tuple(&TTemp[SP++],0);
      T_tuple_not_equal(hv_DLResult_COPY_INP_TMP,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      if(get_i(TTemp[SP-1],0))
      {
        /*OcrResult := DLResult*/
        destroy_tuple(hv_OcrResult);
        copy_tuple(hv_DLResult_COPY_INP_TMP,&hv_OcrResult);

        /*convert_ocr_detection_result_to_object_detection (OcrResult, DLResult)*/
        destroy_tuple(hv_DLResult_COPY_INP_TMP);
        /***/convert_ocr_detection_result_to_object_detection(hv_OcrResult, &hv_DLResult_COPY_INP_TMP);

        /*get_dict_param (DLResult, 'keys', [], ResultKeys)*/
        create_tuple_s(&TTemp[SP++],"keys");
        create_tuple(&TTemp[SP++],0);
        destroy_tuple(hv_ResultKeys);
        /***/T_get_dict_param(hv_DLResult_COPY_INP_TMP, TTemp[SP-2], TTemp[SP-1], 
            &hv_ResultKeys);
        destroy_tuple(TTemp[--SP]);
        destroy_tuple(TTemp[--SP]);

        /*break*/
        destroy_tuple(TTemp[--SP]);
        destroy_tuple(TTemp[--SP]);
        create_tuple(&TTemp[SP],0);
        break;
      }
      destroy_tuple(TTemp[--SP]);
      /*========== end if ==========*/
    }
    destroy_tuple(TTemp[--SP]);
    /*========== end if ==========*/
   }
   destroy_tuple(TTemp[SP--]);
   destroy_tuple(TTemp[SP--]);
   destroy_tuple(TTemp[SP]);
  }
  else
  {
   destroy_tuple(TTemp[SP--]);
   destroy_tuple(TTemp[SP--]);
   destroy_tuple(TTemp[SP--]);
   destroy_tuple(TTemp[SP--]);
   destroy_tuple(TTemp[SP]);
  }/*========== end for ========*/

  /**/
  /*Check if DLDatasetInfo is valid.*/
  /**/
  /*========== if (DLDatasetInfo == []) ==========*/
  create_tuple(&TTemp[SP++],0);
  T_tuple_equal(hv_DLDatasetInfo,TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-1]=TTemp[SP];
  if(get_i(TTemp[SP-1],0))
  {
    /*dev_display_dl_data_get_max_class_id (DLSample, MaxClassIdSample, EmptySample)*/
    destroy_tuple(hv_MaxClassIdSample);
    destroy_tuple(hv_EmptySample);
    /***/dev_display_dl_data_get_max_class_id(hv_DLSample, &hv_MaxClassIdSample, 
        &hv_EmptySample);

    /*dev_display_dl_data_get_max_class_id (DLResult, MaxClassIdResult, EmptyResult)*/
    destroy_tuple(hv_MaxClassIdResult);
    destroy_tuple(hv_EmptyResult);
    /***/dev_display_dl_data_get_max_class_id(hv_DLResult_COPY_INP_TMP, &hv_MaxClassIdResult, 
        &hv_EmptyResult);

    /*MaxClassId := max2(MaxClassIdSample,MaxClassIdResult)*/
    T_tuple_max2(hv_MaxClassIdSample,hv_MaxClassIdResult,&TTemp[SP++]);
    destroy_tuple(hv_MaxClassId);
    hv_MaxClassId=TTemp[--SP];

    /*========== if (EmptySample and EmptyResult) ==========*/
    T_tuple_and(hv_EmptySample,hv_EmptyResult,&TTemp[SP++]);
    if(get_i(TTemp[SP-1],0))
    {
      /*MaxClassId := 1*/
      reuse_tuple_i(&hv_MaxClassId,1);

    }
    destroy_tuple(TTemp[--SP]);
    /*========== end if ==========*/
    /*========== if (MaxClassId == -1) ==========*/
    create_tuple_i(&TTemp[SP++],-1);
    T_tuple_equal(hv_MaxClassId,TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    if(get_i(TTemp[SP-1],0))
    {
      /*MaxClassId := 1000*/
      reuse_tuple_i(&hv_MaxClassId,1000);

    }
    destroy_tuple(TTemp[--SP]);
    /*========== end if ==========*/
    /*========== if (IsOCRDetection) ==========*/
    copy_tuple(hv_IsOCRDetection,&TTemp[SP++]);
    if(get_i(TTemp[SP-1],0))
    {
      /*ClassNames := ['word', 'char', 'ignore']*/
      create_tuple(&TTemp[SP++],3);
      set_s(TTemp[SP-1],"word",0);
      set_s(TTemp[SP-1],"char",1);
      set_s(TTemp[SP-1],"ignore",2);
      destroy_tuple(hv_ClassNames);
      hv_ClassNames=TTemp[--SP];

      /*tuple_gen_sequence (0, |ClassNames| - 1, 1, ClassIDs)*/
      create_tuple_i(&TTemp[SP++],0);
      T_tuple_length(hv_ClassNames,&TTemp[SP++]);
      create_tuple_i(&TTemp[SP++],1);
      T_tuple_sub(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-2]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-2]=TTemp[SP];
      SP--;
      create_tuple_i(&TTemp[SP++],1);
      destroy_tuple(hv_ClassIDs);
      /***/T_tuple_gen_sequence(TTemp[SP-3], TTemp[SP-2], TTemp[SP-1], &hv_ClassIDs);
      destroy_tuple(TTemp[--SP]);
      destroy_tuple(TTemp[--SP]);
      destroy_tuple(TTemp[--SP]);

    }
    else
    {
      /*tuple_gen_sequence (0, MaxClassId, 1, ClassIDs)*/
      create_tuple_i(&TTemp[SP++],0);
      create_tuple_i(&TTemp[SP++],1);
      destroy_tuple(hv_ClassIDs);
      /***/T_tuple_gen_sequence(TTemp[SP-2], hv_MaxClassId, TTemp[SP-1], &hv_ClassIDs);
      destroy_tuple(TTemp[--SP]);
      destroy_tuple(TTemp[--SP]);

      /*tuple_gen_const (MaxClassId + 1, 'unknown', ClassNames)*/
      create_tuple_i(&TTemp[SP++],1);
      T_tuple_add(hv_MaxClassId,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      create_tuple_s(&TTemp[SP++],"unknown");
      destroy_tuple(hv_ClassNames);
      /***/T_tuple_gen_const(TTemp[SP-2], TTemp[SP-1], &hv_ClassNames);
      destroy_tuple(TTemp[--SP]);
      destroy_tuple(TTemp[--SP]);

    }
    destroy_tuple(TTemp[--SP]);
    /*========== end if ==========*/
    /*Try to get the class names from the result dictionary.*/
    /*This works only for detection and classification results.*/
    /*========== if (DLResult != []) ==========*/
    create_tuple(&TTemp[SP++],0);
    T_tuple_not_equal(hv_DLResult_COPY_INP_TMP,TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    if(get_i(TTemp[SP-1],0))
    {
      /*tuple_regexp_select (ResultKeys, '.*class_name.*', ClassNameKey)*/
      create_tuple_s(&TTemp[SP++],".*class_name.*");
      destroy_tuple(hv_ClassNameKey);
      /***/T_tuple_regexp_select(hv_ResultKeys, TTemp[SP-1], &hv_ClassNameKey);
      destroy_tuple(TTemp[--SP]);

      /*tuple_regexp_select (ResultKeys, '.*class_id.*', ClassIdKey)*/
      create_tuple_s(&TTemp[SP++],".*class_id.*");
      destroy_tuple(hv_ClassIdKey);
      /***/T_tuple_regexp_select(hv_ResultKeys, TTemp[SP-1], &hv_ClassIdKey);
      destroy_tuple(TTemp[--SP]);

      /*========== if (|ClassNameKey| == 1 and |ClassIdKey| == 1) ==========*/
      T_tuple_length(hv_ClassNameKey,&TTemp[SP++]);
      create_tuple_i(&TTemp[SP++],1);
      T_tuple_equal(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-2]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-2]=TTemp[SP];
      SP--;
      T_tuple_length(hv_ClassIdKey,&TTemp[SP++]);
      create_tuple_i(&TTemp[SP++],1);
      T_tuple_equal(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-2]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-2]=TTemp[SP];
      SP--;
      T_tuple_and(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-2]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-2]=TTemp[SP];
      SP--;
      if(get_i(TTemp[SP-1],0))
      {
        /*get_dict_tuple (DLResult, ClassNameKey, ResultClassNames)*/
        destroy_tuple(hv_ResultClassNames);
        /***/T_get_dict_tuple(hv_DLResult_COPY_INP_TMP, hv_ClassNameKey, &hv_ResultClassNames);

        /*get_dict_tuple (DLResult, ClassIdKey, ResultClassIds)*/
        destroy_tuple(hv_ResultClassIds);
        /***/T_get_dict_tuple(hv_DLResult_COPY_INP_TMP, hv_ClassIdKey, &hv_ResultClassIds);

        /*tuple_sort_index (ResultClassIds, SortIndices)*/
        destroy_tuple(hv_SortIndices);
        /***/T_tuple_sort_index(hv_ResultClassIds, &hv_SortIndices);

        /*tuple_uniq (ResultClassIds[SortIndices], UniqueClassIds)*/
        T_tuple_select(hv_ResultClassIds,hv_SortIndices,&TTemp[SP++]);
        destroy_tuple(hv_UniqueClassIds);
        /***/T_tuple_uniq(TTemp[SP-1], &hv_UniqueClassIds);
        destroy_tuple(TTemp[--SP]);

        /*tuple_uniq (ResultClassNames[SortIndices], UniqueClassNames)*/
        T_tuple_select(hv_ResultClassNames,hv_SortIndices,&TTemp[SP++]);
        destroy_tuple(hv_UniqueClassNames);
        /***/T_tuple_uniq(TTemp[SP-1], &hv_UniqueClassNames);
        destroy_tuple(TTemp[--SP]);

        /*ClassNames[UniqueClassIds] := UniqueClassNames*/
        replace_elements(&hv_ClassNames,&hv_UniqueClassIds,&hv_UniqueClassNames);
      }
      destroy_tuple(TTemp[--SP]);
      /*========== end if ==========*/
    }
    destroy_tuple(TTemp[--SP]);
    /*========== end if ==========*/
    /*get_dl_class_colors (ClassNames, AdditionalGreenClassNames, Colors)*/
    destroy_tuple(hv_Colors);
    /***/get_dl_class_colors(hv_ClassNames, hv_AdditionalGreenClassNames, &hv_Colors);

    /*ClassesLegend := ClassIDs + ' : ' + ClassNames*/
    create_tuple_s(&TTemp[SP++]," : ");
    T_tuple_add(hv_ClassIDs,TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    T_tuple_add(TTemp[SP-1],hv_ClassNames,&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    destroy_tuple(hv_ClassesLegend);
    hv_ClassesLegend=TTemp[--SP];

    /*InvalidInput := false*/
    reuse_tuple_i(&hv_InvalidInput,0);

  }
  else
  {
    /*Check if DLDatasetInfo contains necessary keys.*/
    /*ClassKeys := ['class_names', 'class_ids']*/
    create_tuple(&TTemp[SP++],2);
    set_s(TTemp[SP-1],"class_names",0);
    set_s(TTemp[SP-1],"class_ids",1);
    destroy_tuple(hv_ClassKeys);
    hv_ClassKeys=TTemp[--SP];

    /*get_handle_param (DLDatasetInfo, 'key_exists', ClassKeys, ClassKeysExist)*/
    create_tuple_s(&TTemp[SP++],"key_exists");
    destroy_tuple(hv_ClassKeysExist);
    /***/T_get_handle_param(hv_DLDatasetInfo, TTemp[SP-1], hv_ClassKeys, &hv_ClassKeysExist);
    destroy_tuple(TTemp[--SP]);

    /*========== if (min(ClassKeysExist) == 0) ==========*/
    T_tuple_min(hv_ClassKeysExist,&TTemp[SP++]);
    create_tuple_i(&TTemp[SP++],0);
    T_tuple_equal(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-2]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-2]=TTemp[SP];
    SP--;
    if(get_i(TTemp[SP-1],0))
    {
      /*In that case we expect that the class names and ids are never used.*/
    }
    else
    {
      /*get_handle_param (DLDatasetInfo, 'keys', [], DLDatasetInfoKeys)*/
      create_tuple_s(&TTemp[SP++],"keys");
      create_tuple(&TTemp[SP++],0);
      destroy_tuple(hv_DLDatasetInfoKeys);
      /***/T_get_handle_param(hv_DLDatasetInfo, TTemp[SP-2], TTemp[SP-1], &hv_DLDatasetInfoKeys);
      destroy_tuple(TTemp[--SP]);
      destroy_tuple(TTemp[--SP]);

      /*========== for Index := 0 to |ClassKeys| - 1 by 1 ==========*/
      T_tuple_length(hv_ClassKeys,&TTemp[SP++]);
      create_tuple_i(&TTemp[SP++],1);
      T_tuple_sub(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-2]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-2]=TTemp[SP];
      SP--;
      create_tuple_i(&TTemp[SP++],1);
      create_tuple_i(&TTemp[SP++],0);
      T_tuple_greater(TTemp[SP-1],TTemp[SP-3],&TTemp[SP]);
      SP++;
      T_tuple_equal(TTemp[SP-2],TTemp[SP-4],&TTemp[SP]);
      if(get_i(TTemp[SP],0) ||
         (!((( get_i(TTemp[SP-1],0)) && (get_d(TTemp[SP-3],0)>0)) ||
            ((!get_i(TTemp[SP-1],0)) && (get_d(TTemp[SP-3],0)<0)))))
      {
       destroy_tuple(TTemp[SP--]);
       destroy_tuple(TTemp[SP]);
       T_tuple_sub(TTemp[SP-1],TTemp[SP-2],&TTemp[SP]);
       destroy_tuple(hv_Index);
       copy_tuple(TTemp[SP],&hv_Index);
       destroy_tuple(TTemp[SP--]);
       destroy_tuple(TTemp[SP]);
       for(;;)
       {
       T_tuple_add(hv_Index,TTemp[SP-1],&TTemp[SP]);
       destroy_tuple(hv_Index);
       copy_tuple(TTemp[SP],&hv_Index);
       destroy_tuple(TTemp[SP]);
       if(get_d(TTemp[SP-1],0)<0)
        T_tuple_less(hv_Index,TTemp[SP-2],&TTemp[SP]);
       else
        T_tuple_greater(hv_Index,TTemp[SP-2],&TTemp[SP]);
       if(get_i(TTemp[SP],0)) break;
       destroy_tuple(TTemp[SP]);
       /*========== for ==========*/

        /*========== if (find_first(DLDatasetInfoKeys,ClassKeys[Index]) == -1) ==========*/
        T_tuple_select(hv_ClassKeys,hv_Index,&TTemp[SP++]);
        T_tuple_find_first(hv_DLDatasetInfoKeys,TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-1]=TTemp[SP];
        create_tuple_i(&TTemp[SP++],-1);
        T_tuple_equal(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-2]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-2]=TTemp[SP];
        SP--;
        if(get_i(TTemp[SP-1],0))
        {
          /* throw(...); only in hdevelop*/
        }
        destroy_tuple(TTemp[--SP]);
        /*========== end if ==========*/
       }
       destroy_tuple(TTemp[SP--]);
       destroy_tuple(TTemp[SP--]);
       destroy_tuple(TTemp[SP]);
      }
      else
      {
       destroy_tuple(TTemp[SP--]);
       destroy_tuple(TTemp[SP--]);
       destroy_tuple(TTemp[SP--]);
       destroy_tuple(TTemp[SP--]);
       destroy_tuple(TTemp[SP]);
      }/*========== end for ========*/

      /**/
      /*Get the general dataset information, if available.*/
      /*get_handle_tuple (DLDatasetInfo, 'class_names', ClassNames)*/
      create_tuple_s(&TTemp[SP++],"class_names");
      destroy_tuple(hv_ClassNames);
      /***/T_get_handle_tuple(hv_DLDatasetInfo, TTemp[SP-1], &hv_ClassNames);
      destroy_tuple(TTemp[--SP]);

      /*get_handle_tuple (DLDatasetInfo, 'class_ids', ClassIDs)*/
      create_tuple_s(&TTemp[SP++],"class_ids");
      destroy_tuple(hv_ClassIDs);
      /***/T_get_handle_tuple(hv_DLDatasetInfo, TTemp[SP-1], &hv_ClassIDs);
      destroy_tuple(TTemp[--SP]);

      /**/
      /*Define distinct colors for the classes.*/
      /*get_dl_class_colors (ClassNames, AdditionalGreenClassNames, Colors)*/
      destroy_tuple(hv_Colors);
      /***/get_dl_class_colors(hv_ClassNames, hv_AdditionalGreenClassNames, &hv_Colors);

      /**/
      /*ClassesLegend := ClassIDs + ' : ' + ClassNames*/
      create_tuple_s(&TTemp[SP++]," : ");
      T_tuple_add(hv_ClassIDs,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      T_tuple_add(TTemp[SP-1],hv_ClassNames,&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      destroy_tuple(hv_ClassesLegend);
      hv_ClassesLegend=TTemp[--SP];

      /*Create a Classes map so that we index the other tuples easily*/
      /*create_dict (ClassIDstoIndex)*/
      destroy_tuple(hv_ClassIDstoIndex);
      /***/T_create_dict(&hv_ClassIDstoIndex);

      /*========== for I := 0 to |ClassIDs| - 1 by 1 ==========*/
      T_tuple_length(hv_ClassIDs,&TTemp[SP++]);
      create_tuple_i(&TTemp[SP++],1);
      T_tuple_sub(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-2]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-2]=TTemp[SP];
      SP--;
      create_tuple_i(&TTemp[SP++],1);
      create_tuple_i(&TTemp[SP++],0);
      T_tuple_greater(TTemp[SP-1],TTemp[SP-3],&TTemp[SP]);
      SP++;
      T_tuple_equal(TTemp[SP-2],TTemp[SP-4],&TTemp[SP]);
      if(get_i(TTemp[SP],0) ||
         (!((( get_i(TTemp[SP-1],0)) && (get_d(TTemp[SP-3],0)>0)) ||
            ((!get_i(TTemp[SP-1],0)) && (get_d(TTemp[SP-3],0)<0)))))
      {
       destroy_tuple(TTemp[SP--]);
       destroy_tuple(TTemp[SP]);
       T_tuple_sub(TTemp[SP-1],TTemp[SP-2],&TTemp[SP]);
       destroy_tuple(hv_I);
       copy_tuple(TTemp[SP],&hv_I);
       destroy_tuple(TTemp[SP--]);
       destroy_tuple(TTemp[SP]);
       for(;;)
       {
       T_tuple_add(hv_I,TTemp[SP-1],&TTemp[SP]);
       destroy_tuple(hv_I);
       copy_tuple(TTemp[SP],&hv_I);
       destroy_tuple(TTemp[SP]);
       if(get_d(TTemp[SP-1],0)<0)
        T_tuple_less(hv_I,TTemp[SP-2],&TTemp[SP]);
       else
        T_tuple_greater(hv_I,TTemp[SP-2],&TTemp[SP]);
       if(get_i(TTemp[SP],0)) break;
       destroy_tuple(TTemp[SP]);
       /*========== for ==========*/

        /*set_dict_tuple (ClassIDstoIndex, ClassIDs[I], I)*/
        T_tuple_select(hv_ClassIDs,hv_I,&TTemp[SP++]);
        /***/T_set_dict_tuple(hv_ClassIDstoIndex, TTemp[SP-1], hv_I);
        destroy_tuple(TTemp[--SP]);

       }
       destroy_tuple(TTemp[SP--]);
       destroy_tuple(TTemp[SP--]);
       destroy_tuple(TTemp[SP]);
      }
      else
      {
       destroy_tuple(TTemp[SP--]);
       destroy_tuple(TTemp[SP--]);
       destroy_tuple(TTemp[SP--]);
       destroy_tuple(TTemp[SP--]);
       destroy_tuple(TTemp[SP]);
      }/*========== end for ========*/

    }
    destroy_tuple(TTemp[--SP]);
    /*========== end if ==========*/
  }
  destroy_tuple(TTemp[--SP]);
  /*========== end if ==========*/
  /**/
  /*** Set window parameters: ****/
  /**/
  /*Set previous window coordinates.*/
  /*PrevWindowCoordinates := [0, 0, 0, 0]*/
  create_tuple(&TTemp[SP++],4);
  set_i(TTemp[SP-1],0  ,0);
  set_i(TTemp[SP-1],0  ,1);
  set_i(TTemp[SP-1],0  ,2);
  set_i(TTemp[SP-1],0  ,3);
  destroy_tuple(hv_PrevWindowCoordinates);
  hv_PrevWindowCoordinates=TTemp[--SP];

  /**/
  /*Check that the WindowHandleDict is of type dictionary.*/
  /* try(...); only in hdevelop*/
    /*get_dict_param (WindowHandleDict, 'keys', [], Keys)*/
    create_tuple_s(&TTemp[SP++],"keys");
    create_tuple(&TTemp[SP++],0);
    destroy_tuple(hv_Keys);
    /***/T_get_dict_param(hv_WindowHandleDict, TTemp[SP-2], TTemp[SP-1], &hv_Keys);
    destroy_tuple(TTemp[--SP]);
    destroy_tuple(TTemp[--SP]);

  /* catch(...); only in hdevelop*/
    /* if(...); only in hdevelop*/
      /* throw(...); only in hdevelop*/
    /* else(...); only in hdevelop*/
      /* throw(...); only in hdevelop*/
    /* endif(...); only in hdevelop*/
  /* endtry(...); only in hdevelop*/
  /*For better usage, add meta information about the window handles in WindowHandleDict.*/
  /*get_dict_param (WindowHandleDict, 'key_exists', 'meta_information', MetaInfoExists)*/
  create_tuple_s(&TTemp[SP++],"key_exists");
  create_tuple_s(&TTemp[SP++],"meta_information");
  destroy_tuple(hv_MetaInfoExists);
  /***/T_get_dict_param(hv_WindowHandleDict, TTemp[SP-2], TTemp[SP-1], &hv_MetaInfoExists);
  destroy_tuple(TTemp[--SP]);
  destroy_tuple(TTemp[--SP]);

  /*========== if (not MetaInfoExists) ==========*/
  T_tuple_not(hv_MetaInfoExists,&TTemp[SP++]);
  if(get_i(TTemp[SP-1],0))
  {
    /*create_dict (__Tmp_Ctrl_Dict_Init_2)*/
    destroy_tuple(hv___Tmp_Ctrl_Dict_Init_2);
    /***/T_create_dict(&hv___Tmp_Ctrl_Dict_Init_2);

    /*set_dict_tuple (WindowHandleDict, ['meta_information'], __Tmp_Ctrl_Dict_Init_2)*/
    create_tuple_s(&TTemp[SP++],"meta_information");
    /***/T_set_dict_tuple(hv_WindowHandleDict, TTemp[SP-1], hv___Tmp_Ctrl_Dict_Init_2);
    destroy_tuple(TTemp[--SP]);

    /*__Tmp_Ctrl_Dict_Init_2 := constant('HNULL')*/
    create_tuple_s(&TTemp[SP++],"HNULL");
    T_tuple_constant(TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    destroy_tuple(hv___Tmp_Ctrl_Dict_Init_2);
    hv___Tmp_Ctrl_Dict_Init_2=TTemp[--SP];

  }
  destroy_tuple(TTemp[--SP]);
  /*========== end if ==========*/
  /**/
  /*For each window, set 'flush' to 'false' to avoid flickering.*/
  /*FlushValues := []*/
  create_tuple(&TTemp[SP++],0);
  destroy_tuple(hv_FlushValues);
  hv_FlushValues=TTemp[--SP];

  /*get_dict_param (WindowHandleDict, 'keys', [], WindowHandleKeys)*/
  create_tuple_s(&TTemp[SP++],"keys");
  create_tuple(&TTemp[SP++],0);
  destroy_tuple(hv_WindowHandleKeys);
  /***/T_get_dict_param(hv_WindowHandleDict, TTemp[SP-2], TTemp[SP-1], &hv_WindowHandleKeys);
  destroy_tuple(TTemp[--SP]);
  destroy_tuple(TTemp[--SP]);

  /*========== for Index := 0 to |WindowHandleKeys| - 1 by 1 ==========*/
  T_tuple_length(hv_WindowHandleKeys,&TTemp[SP++]);
  create_tuple_i(&TTemp[SP++],1);
  T_tuple_sub(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-2]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-2]=TTemp[SP];
  SP--;
  create_tuple_i(&TTemp[SP++],1);
  create_tuple_i(&TTemp[SP++],0);
  T_tuple_greater(TTemp[SP-1],TTemp[SP-3],&TTemp[SP]);
  SP++;
  T_tuple_equal(TTemp[SP-2],TTemp[SP-4],&TTemp[SP]);
  if(get_i(TTemp[SP],0) ||
     (!((( get_i(TTemp[SP-1],0)) && (get_d(TTemp[SP-3],0)>0)) ||
        ((!get_i(TTemp[SP-1],0)) && (get_d(TTemp[SP-3],0)<0)))))
  {
   destroy_tuple(TTemp[SP--]);
   destroy_tuple(TTemp[SP]);
   T_tuple_sub(TTemp[SP-1],TTemp[SP-2],&TTemp[SP]);
   destroy_tuple(hv_Index);
   copy_tuple(TTemp[SP],&hv_Index);
   destroy_tuple(TTemp[SP--]);
   destroy_tuple(TTemp[SP]);
   for(;;)
   {
   T_tuple_add(hv_Index,TTemp[SP-1],&TTemp[SP]);
   destroy_tuple(hv_Index);
   copy_tuple(TTemp[SP],&hv_Index);
   destroy_tuple(TTemp[SP]);
   if(get_d(TTemp[SP-1],0)<0)
    T_tuple_less(hv_Index,TTemp[SP-2],&TTemp[SP]);
   else
    T_tuple_greater(hv_Index,TTemp[SP-2],&TTemp[SP]);
   if(get_i(TTemp[SP],0)) break;
   destroy_tuple(TTemp[SP]);
   /*========== for ==========*/

    /*Only consider the WindowHandleKeys that are needed for the current visualization.*/
    /*KeyIndex := find(KeysForDisplay,WindowHandleKeys[Index])*/
    T_tuple_select(hv_WindowHandleKeys,hv_Index,&TTemp[SP++]);
    T_tuple_find(hv_KeysForDisplay_COPY_INP_TMP,TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    destroy_tuple(hv_KeyIndex);
    hv_KeyIndex=TTemp[--SP];

    /*========== if (KeyIndex != -1 and KeyIndex != []) ==========*/
    create_tuple_i(&TTemp[SP++],-1);
    T_tuple_not_equal(hv_KeyIndex,TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    create_tuple(&TTemp[SP++],0);
    T_tuple_not_equal(hv_KeyIndex,TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    T_tuple_and(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-2]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-2]=TTemp[SP];
    SP--;
    if(get_i(TTemp[SP-1],0))
    {
      /*get_dict_tuple (WindowHandleDict, WindowHandleKeys[Index], WindowHandles)*/
      T_tuple_select(hv_WindowHandleKeys,hv_Index,&TTemp[SP++]);
      destroy_tuple(hv_WindowHandles);
      /***/T_get_dict_tuple(hv_WindowHandleDict, TTemp[SP-1], &hv_WindowHandles);
      destroy_tuple(TTemp[--SP]);

      /*========== for WindowIndex := 0 to |WindowHandles| - 1 by 1 ==========*/
      T_tuple_length(hv_WindowHandles,&TTemp[SP++]);
      create_tuple_i(&TTemp[SP++],1);
      T_tuple_sub(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-2]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-2]=TTemp[SP];
      SP--;
      create_tuple_i(&TTemp[SP++],1);
      create_tuple_i(&TTemp[SP++],0);
      T_tuple_greater(TTemp[SP-1],TTemp[SP-3],&TTemp[SP]);
      SP++;
      T_tuple_equal(TTemp[SP-2],TTemp[SP-4],&TTemp[SP]);
      if(get_i(TTemp[SP],0) ||
         (!((( get_i(TTemp[SP-1],0)) && (get_d(TTemp[SP-3],0)>0)) ||
            ((!get_i(TTemp[SP-1],0)) && (get_d(TTemp[SP-3],0)<0)))))
      {
       destroy_tuple(TTemp[SP--]);
       destroy_tuple(TTemp[SP]);
       T_tuple_sub(TTemp[SP-1],TTemp[SP-2],&TTemp[SP]);
       destroy_tuple(hv_WindowIndex);
       copy_tuple(TTemp[SP],&hv_WindowIndex);
       destroy_tuple(TTemp[SP--]);
       destroy_tuple(TTemp[SP]);
       for(;;)
       {
       T_tuple_add(hv_WindowIndex,TTemp[SP-1],&TTemp[SP]);
       destroy_tuple(hv_WindowIndex);
       copy_tuple(TTemp[SP],&hv_WindowIndex);
       destroy_tuple(TTemp[SP]);
       if(get_d(TTemp[SP-1],0)<0)
        T_tuple_less(hv_WindowIndex,TTemp[SP-2],&TTemp[SP]);
       else
        T_tuple_greater(hv_WindowIndex,TTemp[SP-2],&TTemp[SP]);
       if(get_i(TTemp[SP],0)) break;
       destroy_tuple(TTemp[SP]);
       /*========== for ==========*/

        /*get_window_param (WindowHandles[WindowIndex], 'flush', FlushValue)*/
        T_tuple_select(hv_WindowHandles,hv_WindowIndex,&TTemp[SP++]);
        create_tuple_s(&TTemp[SP++],"flush");
        destroy_tuple(hv_FlushValue);
        /***/T_get_window_param(TTemp[SP-2], TTemp[SP-1], &hv_FlushValue);
        destroy_tuple(TTemp[--SP]);
        destroy_tuple(TTemp[--SP]);

        /*FlushValues := [FlushValues,FlushValue]*/
        copy_tuple(hv_FlushValues,&TTemp[SP++]);
        T_tuple_concat(TTemp[SP-1],hv_FlushValue,&TTemp[SP]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-1]=TTemp[SP];
        destroy_tuple(hv_FlushValues);
        hv_FlushValues=TTemp[--SP];

        /*set_window_param (WindowHandles[WindowIndex], 'flush', 'false')*/
        T_tuple_select(hv_WindowHandles,hv_WindowIndex,&TTemp[SP++]);
        create_tuple_s(&TTemp[SP++],"flush");
        create_tuple_s(&TTemp[SP++],"false");
        /***/T_set_window_param(TTemp[SP-3], TTemp[SP-2], TTemp[SP-1]);
        destroy_tuple(TTemp[--SP]);
        destroy_tuple(TTemp[--SP]);
        destroy_tuple(TTemp[--SP]);

       }
       destroy_tuple(TTemp[SP--]);
       destroy_tuple(TTemp[SP--]);
       destroy_tuple(TTemp[SP]);
      }
      else
      {
       destroy_tuple(TTemp[SP--]);
       destroy_tuple(TTemp[SP--]);
       destroy_tuple(TTemp[SP--]);
       destroy_tuple(TTemp[SP--]);
       destroy_tuple(TTemp[SP]);
      }/*========== end for ========*/

    }
    destroy_tuple(TTemp[--SP]);
    /*========== end if ==========*/
   }
   destroy_tuple(TTemp[SP--]);
   destroy_tuple(TTemp[SP--]);
   destroy_tuple(TTemp[SP]);
  }
  else
  {
   destroy_tuple(TTemp[SP--]);
   destroy_tuple(TTemp[SP--]);
   destroy_tuple(TTemp[SP--]);
   destroy_tuple(TTemp[SP--]);
   destroy_tuple(TTemp[SP]);
  }/*========== end for ========*/

  /**/
  /*** Display the data: ****/
  /**/
  /*Display data dictionaries.*/
  /*KeyIndex := 0*/
  reuse_tuple_i(&hv_KeyIndex,0);

  /*========== while (KeyIndex < |KeysForDisplay|) ==========*/
  for(;;)
  {
  T_tuple_length(hv_KeysForDisplay_COPY_INP_TMP,&TTemp[SP++]);
  T_tuple_less(hv_KeyIndex,TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-1]=TTemp[SP];
  if(!get_i(TTemp[SP-1],0)) break;
  destroy_tuple(TTemp[--SP]);
    /**/
    /*Is it an Deep OCR detection case?*/
    /*tuple_strstr (KeysForDisplay[KeyIndex], 'ocr_detection', IsOCRDetection)*/
    T_tuple_select(hv_KeysForDisplay_COPY_INP_TMP,hv_KeyIndex,&TTemp[SP++]);
    create_tuple_s(&TTemp[SP++],"ocr_detection");
    destroy_tuple(hv_IsOCRDetection);
    /***/T_tuple_strstr(TTemp[SP-2], TTemp[SP-1], &hv_IsOCRDetection);
    destroy_tuple(TTemp[--SP]);
    destroy_tuple(TTemp[--SP]);

    /*IsOCRDetection := IsOCRDetection == 0*/
    copy_tuple(hv_IsOCRDetection,&TTemp[SP++]);
    create_tuple_i(&TTemp[SP++],0);
    T_tuple_equal(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-2]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-2]=TTemp[SP];
    SP--;
    destroy_tuple(hv_IsOCRDetection);
    hv_IsOCRDetection=TTemp[--SP];

    /**/
    /*========== if (KeysForDisplay[KeyIndex] == 'image') ==========*/
    T_tuple_select(hv_KeysForDisplay_COPY_INP_TMP,hv_KeyIndex,&TTemp[SP++]);
    create_tuple_s(&TTemp[SP++],"image");
    T_tuple_equal(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-2]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-2]=TTemp[SP];
    SP--;
    if(get_i(TTemp[SP-1],0))
    {
      /**/
      /*Image.*/
      /*get_dl_sample_image (Image, SampleKeys, DLSample, KeysForDisplay[KeyIndex])*/
      T_tuple_select(hv_KeysForDisplay_COPY_INP_TMP,hv_KeyIndex,&TTemp[SP++]);
      clear_obj(ho_Image);
      /***/get_dl_sample_image(&ho_Image, hv_SampleKeys, hv_DLSample, TTemp[SP-1]);
      destroy_tuple(TTemp[--SP]);

      /**/
      /*Get or open next window.*/
      /*get_image_size (Image, WidthImage, HeightImage)*/
      destroy_tuple(hv_WidthImage);
      destroy_tuple(hv_HeightImage);
      /***/T_get_image_size(ho_Image, &hv_WidthImage, &hv_HeightImage);

      /*get_next_window (__get_dict_tuple( Params, ['font']), __get_dict_tuple( Params, ['font_size']), __get_dict_tuple( Params, ['display_bottom_desc']), WidthImage, HeightImage, 0, __get_dict_tuple( Params, ['scale_windows']), __get_dict_tuple( Params, ['threshold_width']), PrevWindowCoordinates, WindowHandleDict, KeysForDisplay[KeyIndex], CurrentWindowHandle, WindowImageRatio, PrevWindowCoordinates)*/
      create_tuple_s(&TTemp[SP++],"font");
      T_get_dict_tuple(hv_Params,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      create_tuple_s(&TTemp[SP++],"font_size");
      T_get_dict_tuple(hv_Params,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      create_tuple_s(&TTemp[SP++],"display_bottom_desc");
      T_get_dict_tuple(hv_Params,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      create_tuple_i(&TTemp[SP++],0);
      create_tuple_s(&TTemp[SP++],"scale_windows");
      T_get_dict_tuple(hv_Params,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      create_tuple_s(&TTemp[SP++],"threshold_width");
      T_get_dict_tuple(hv_Params,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      copy_tuple(hv_PrevWindowCoordinates,&TTemp[SP++]);
      T_tuple_select(hv_KeysForDisplay_COPY_INP_TMP,hv_KeyIndex,&TTemp[SP++]);
      destroy_tuple(hv_CurrentWindowHandle);
      destroy_tuple(hv_WindowImageRatio);
      destroy_tuple(hv_PrevWindowCoordinates);
      /***/get_next_window(TTemp[SP-8], TTemp[SP-7], TTemp[SP-6], hv_WidthImage, 
          hv_HeightImage, TTemp[SP-5], TTemp[SP-4], TTemp[SP-3], TTemp[SP-2], hv_WindowHandleDict, 
          TTemp[SP-1], &hv_CurrentWindowHandle, &hv_WindowImageRatio, &hv_PrevWindowCoordinates);
      destroy_tuple(TTemp[--SP]);
      destroy_tuple(TTemp[--SP]);
      destroy_tuple(TTemp[--SP]);
      destroy_tuple(TTemp[--SP]);
      destroy_tuple(TTemp[--SP]);
      destroy_tuple(TTemp[--SP]);
      destroy_tuple(TTemp[--SP]);
      destroy_tuple(TTemp[--SP]);

      /**/
      /*full_domain (Image, Image)*/
      /***/full_domain(ho_Image, &(OTemp[SPO]));
      SPO++;
      clear_obj(ho_Image);
      ho_Image = OTemp[--SPO];

      if (hdev_window_stack_is_open())
      {
        Htuple active_win;
        create_tuple(&active_win,0);
        hdev_window_stack_get_active(&active_win);
        /*dev_display (Image)*/
        /***/T_disp_obj(ho_Image, active_win);
        destroy_tuple(active_win);
      }
      /*========== if (__get_dict_tuple( Params, ['display_bottom_desc'])) ==========*/
      create_tuple_s(&TTemp[SP++],"display_bottom_desc");
      T_get_dict_tuple(hv_Params,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      if(get_i(TTemp[SP-1],0))
      {
        if (hdev_window_stack_is_open())
        {
          Htuple active_win;
          create_tuple(&active_win,0);
          hdev_window_stack_get_active(&active_win);
          /*dev_disp_text (ImageIDStringCapital, 'window', 'bottom', 'left', 'white', 'box', 'false')*/
          create_tuple_s(&TTemp[SP++],"window");
          create_tuple_s(&TTemp[SP++],"bottom");
          create_tuple_s(&TTemp[SP++],"left");
          create_tuple_s(&TTemp[SP++],"white");
          create_tuple_s(&TTemp[SP++],"box");
          create_tuple_s(&TTemp[SP++],"false");
          /***/T_disp_text(active_win,hv_ImageIDStringCapital, TTemp[SP-6], TTemp[SP-5], 
              TTemp[SP-4], TTemp[SP-3], TTemp[SP-2], TTemp[SP-1]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(active_win);
        }
      }
      destroy_tuple(TTemp[--SP]);
      /*========== end if ==========*/
    }
    else
    {
    destroy_tuple(TTemp[--SP]);
    /*========== elseif (KeysForDisplay[KeyIndex] == 'image_with_domain') ==========*/

    T_tuple_select(hv_KeysForDisplay_COPY_INP_TMP,hv_KeyIndex,&TTemp[SP++]);
    create_tuple_s(&TTemp[SP++],"image_with_domain");
    T_tuple_equal(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-2]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-2]=TTemp[SP];
    SP--;
    if(get_i(TTemp[SP-1],0))
    {
      /**/
      /*Image.*/
      /*get_dl_sample_image (Image, SampleKeys, DLSample, 'image')*/
      create_tuple_s(&TTemp[SP++],"image");
      clear_obj(ho_Image);
      /***/get_dl_sample_image(&ho_Image, hv_SampleKeys, hv_DLSample, TTemp[SP-1]);
      destroy_tuple(TTemp[--SP]);

      /*get_domain (Image, Domain)*/
      clear_obj(ho_Domain);
      /***/get_domain(ho_Image, &ho_Domain);

      /**/
      /*Get or open next window.*/
      /*get_image_size (Image, WidthImage, HeightImage)*/
      destroy_tuple(hv_WidthImage);
      destroy_tuple(hv_HeightImage);
      /***/T_get_image_size(ho_Image, &hv_WidthImage, &hv_HeightImage);

      /*get_next_window (__get_dict_tuple( Params, ['font']), __get_dict_tuple( Params, ['font_size']), __get_dict_tuple( Params, ['display_bottom_desc']), WidthImage, HeightImage, 0, __get_dict_tuple( Params, ['scale_windows']), __get_dict_tuple( Params, ['threshold_width']), PrevWindowCoordinates, WindowHandleDict, KeysForDisplay[KeyIndex], CurrentWindowHandle, WindowImageRatio, PrevWindowCoordinates)*/
      create_tuple_s(&TTemp[SP++],"font");
      T_get_dict_tuple(hv_Params,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      create_tuple_s(&TTemp[SP++],"font_size");
      T_get_dict_tuple(hv_Params,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      create_tuple_s(&TTemp[SP++],"display_bottom_desc");
      T_get_dict_tuple(hv_Params,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      create_tuple_i(&TTemp[SP++],0);
      create_tuple_s(&TTemp[SP++],"scale_windows");
      T_get_dict_tuple(hv_Params,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      create_tuple_s(&TTemp[SP++],"threshold_width");
      T_get_dict_tuple(hv_Params,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      copy_tuple(hv_PrevWindowCoordinates,&TTemp[SP++]);
      T_tuple_select(hv_KeysForDisplay_COPY_INP_TMP,hv_KeyIndex,&TTemp[SP++]);
      destroy_tuple(hv_CurrentWindowHandle);
      destroy_tuple(hv_WindowImageRatio);
      destroy_tuple(hv_PrevWindowCoordinates);
      /***/get_next_window(TTemp[SP-8], TTemp[SP-7], TTemp[SP-6], hv_WidthImage, 
          hv_HeightImage, TTemp[SP-5], TTemp[SP-4], TTemp[SP-3], TTemp[SP-2], hv_WindowHandleDict, 
          TTemp[SP-1], &hv_CurrentWindowHandle, &hv_WindowImageRatio, &hv_PrevWindowCoordinates);
      destroy_tuple(TTemp[--SP]);
      destroy_tuple(TTemp[--SP]);
      destroy_tuple(TTemp[--SP]);
      destroy_tuple(TTemp[--SP]);
      destroy_tuple(TTemp[--SP]);
      destroy_tuple(TTemp[--SP]);
      destroy_tuple(TTemp[--SP]);
      destroy_tuple(TTemp[--SP]);

      /**/
      if (hdev_window_stack_is_open())
      {
        Htuple active_win;
        create_tuple(&active_win,0);
        hdev_window_stack_get_active(&active_win);
        /*dev_set_color (__get_dict_tuple( Params, ['region_color']))*/
        create_tuple_s(&TTemp[SP++],"region_color");
        T_get_dict_tuple(hv_Params,TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-1]=TTemp[SP];
        /***/T_set_color(active_win,TTemp[SP-1]);
        destroy_tuple(TTemp[--SP]);
        destroy_tuple(active_win);
      }
      if (hdev_window_stack_is_open())
      {
        Htuple active_win;
        create_tuple(&active_win,0);
        hdev_window_stack_get_active(&active_win);
        /*dev_display (Image)*/
        /***/T_disp_obj(ho_Image, active_win);
        destroy_tuple(active_win);
      }
      if (hdev_window_stack_is_open())
      {
        Htuple active_win;
        create_tuple(&active_win,0);
        hdev_window_stack_get_active(&active_win);
        /*dev_display (Domain)*/
        /***/T_disp_obj(ho_Domain, active_win);
        destroy_tuple(active_win);
      }
      /*========== if (__get_dict_tuple( Params, ['display_bottom_desc'])) ==========*/
      create_tuple_s(&TTemp[SP++],"display_bottom_desc");
      T_get_dict_tuple(hv_Params,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      if(get_i(TTemp[SP-1],0))
      {
        if (hdev_window_stack_is_open())
        {
          Htuple active_win;
          create_tuple(&active_win,0);
          hdev_window_stack_get_active(&active_win);
          /*dev_disp_text (ImageIDStringCapital, 'window', 'bottom', 'left', 'white', 'box', 'false')*/
          create_tuple_s(&TTemp[SP++],"window");
          create_tuple_s(&TTemp[SP++],"bottom");
          create_tuple_s(&TTemp[SP++],"left");
          create_tuple_s(&TTemp[SP++],"white");
          create_tuple_s(&TTemp[SP++],"box");
          create_tuple_s(&TTemp[SP++],"false");
          /***/T_disp_text(active_win,hv_ImageIDStringCapital, TTemp[SP-6], TTemp[SP-5], 
              TTemp[SP-4], TTemp[SP-3], TTemp[SP-2], TTemp[SP-1]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(active_win);
        }
      }
      destroy_tuple(TTemp[--SP]);
      /*========== end if ==========*/
    }
    else
    {
    destroy_tuple(TTemp[--SP]);
    /*========== elseif (KeysForDisplay[KeyIndex] == 'normals') ==========*/

    T_tuple_select(hv_KeysForDisplay_COPY_INP_TMP,hv_KeyIndex,&TTemp[SP++]);
    create_tuple_s(&TTemp[SP++],"normals");
    T_tuple_equal(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-2]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-2]=TTemp[SP];
    SP--;
    if(get_i(TTemp[SP-1],0))
    {
      /**/
      /*Normal image.*/
      /*get_dl_sample_image (Image, SampleKeys, DLSample, KeysForDisplay[KeyIndex])*/
      T_tuple_select(hv_KeysForDisplay_COPY_INP_TMP,hv_KeyIndex,&TTemp[SP++]);
      clear_obj(ho_Image);
      /***/get_dl_sample_image(&ho_Image, hv_SampleKeys, hv_DLSample, TTemp[SP-1]);
      destroy_tuple(TTemp[--SP]);

      /**/
      /*Get or open next window.*/
      /*get_image_size (Image, WidthImage, HeightImage)*/
      destroy_tuple(hv_WidthImage);
      destroy_tuple(hv_HeightImage);
      /***/T_get_image_size(ho_Image, &hv_WidthImage, &hv_HeightImage);

      /*get_next_window (__get_dict_tuple( Params, ['font']), __get_dict_tuple( Params, ['font_size']), __get_dict_tuple( Params, ['display_bottom_desc']), WidthImage, HeightImage, 0, __get_dict_tuple( Params, ['scale_windows']), __get_dict_tuple( Params, ['threshold_width']), PrevWindowCoordinates, WindowHandleDict, KeysForDisplay[KeyIndex], CurrentWindowHandle, WindowImageRatio, PrevWindowCoordinates)*/
      create_tuple_s(&TTemp[SP++],"font");
      T_get_dict_tuple(hv_Params,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      create_tuple_s(&TTemp[SP++],"font_size");
      T_get_dict_tuple(hv_Params,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      create_tuple_s(&TTemp[SP++],"display_bottom_desc");
      T_get_dict_tuple(hv_Params,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      create_tuple_i(&TTemp[SP++],0);
      create_tuple_s(&TTemp[SP++],"scale_windows");
      T_get_dict_tuple(hv_Params,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      create_tuple_s(&TTemp[SP++],"threshold_width");
      T_get_dict_tuple(hv_Params,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      copy_tuple(hv_PrevWindowCoordinates,&TTemp[SP++]);
      T_tuple_select(hv_KeysForDisplay_COPY_INP_TMP,hv_KeyIndex,&TTemp[SP++]);
      destroy_tuple(hv_CurrentWindowHandle);
      destroy_tuple(hv_WindowImageRatio);
      destroy_tuple(hv_PrevWindowCoordinates);
      /***/get_next_window(TTemp[SP-8], TTemp[SP-7], TTemp[SP-6], hv_WidthImage, 
          hv_HeightImage, TTemp[SP-5], TTemp[SP-4], TTemp[SP-3], TTemp[SP-2], hv_WindowHandleDict, 
          TTemp[SP-1], &hv_CurrentWindowHandle, &hv_WindowImageRatio, &hv_PrevWindowCoordinates);
      destroy_tuple(TTemp[--SP]);
      destroy_tuple(TTemp[--SP]);
      destroy_tuple(TTemp[--SP]);
      destroy_tuple(TTemp[--SP]);
      destroy_tuple(TTemp[--SP]);
      destroy_tuple(TTemp[--SP]);
      destroy_tuple(TTemp[--SP]);
      destroy_tuple(TTemp[--SP]);

      /**/
      /*full_domain (Image, Image)*/
      /***/full_domain(ho_Image, &(OTemp[SPO]));
      SPO++;
      clear_obj(ho_Image);
      ho_Image = OTemp[--SPO];

      if (hdev_window_stack_is_open())
      {
        Htuple active_win;
        create_tuple(&active_win,0);
        hdev_window_stack_get_active(&active_win);
        /*dev_display (Image)*/
        /***/T_disp_obj(ho_Image, active_win);
        destroy_tuple(active_win);
      }
      /*========== if (__get_dict_tuple( Params, ['display_bottom_desc'])) ==========*/
      create_tuple_s(&TTemp[SP++],"display_bottom_desc");
      T_get_dict_tuple(hv_Params,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      if(get_i(TTemp[SP-1],0))
      {
        if (hdev_window_stack_is_open())
        {
          Htuple active_win;
          create_tuple(&active_win,0);
          hdev_window_stack_get_active(&active_win);
          /*dev_disp_text (ImageIDStringCapital, 'window', 'bottom', 'left', 'white', 'box', 'false')*/
          create_tuple_s(&TTemp[SP++],"window");
          create_tuple_s(&TTemp[SP++],"bottom");
          create_tuple_s(&TTemp[SP++],"left");
          create_tuple_s(&TTemp[SP++],"white");
          create_tuple_s(&TTemp[SP++],"box");
          create_tuple_s(&TTemp[SP++],"false");
          /***/T_disp_text(active_win,hv_ImageIDStringCapital, TTemp[SP-6], TTemp[SP-5], 
              TTemp[SP-4], TTemp[SP-3], TTemp[SP-2], TTemp[SP-1]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(active_win);
        }
      }
      destroy_tuple(TTemp[--SP]);
      /*========== end if ==========*/
    }
    else
    {
    destroy_tuple(TTemp[--SP]);
    /*========== elseif (KeysForDisplay[KeyIndex] == 'gripping_confidence') ==========*/

    T_tuple_select(hv_KeysForDisplay_COPY_INP_TMP,hv_KeyIndex,&TTemp[SP++]);
    create_tuple_s(&TTemp[SP++],"gripping_confidence");
    T_tuple_equal(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-2]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-2]=TTemp[SP];
    SP--;
    if(get_i(TTemp[SP-1],0))
    {
      /**/
      /*Confidence image.*/
      /*========== if (DLResult == []) ==========*/
      create_tuple(&TTemp[SP++],0);
      T_tuple_equal(hv_DLResult_COPY_INP_TMP,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      if(get_i(TTemp[SP-1],0))
      {
        /* throw(...); only in hdevelop*/
      }
      destroy_tuple(TTemp[--SP]);
      /*========== end if ==========*/
      /*========== if (find(ResultKeys,KeysForDisplay[KeyIndex]) != -1) ==========*/
      T_tuple_select(hv_KeysForDisplay_COPY_INP_TMP,hv_KeyIndex,&TTemp[SP++]);
      T_tuple_find(hv_ResultKeys,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      create_tuple_i(&TTemp[SP++],-1);
      T_tuple_not_equal(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-2]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-2]=TTemp[SP];
      SP--;
      if(get_i(TTemp[SP-1],0))
      {
        /*get_dict_object (Image, DLResult, KeysForDisplay[KeyIndex])*/
        T_tuple_select(hv_KeysForDisplay_COPY_INP_TMP,hv_KeyIndex,&TTemp[SP++]);
        clear_obj(ho_Image);
        /***/T_get_dict_object(&ho_Image, hv_DLResult_COPY_INP_TMP, TTemp[SP-1]);
        destroy_tuple(TTemp[--SP]);

      }
      else
      {
        /* throw(...); only in hdevelop*/
      }
      destroy_tuple(TTemp[--SP]);
      /*========== end if ==========*/
      /**/
      /*Get or open next window.*/
      /*get_image_size (Image, WidthImage, HeightImage)*/
      destroy_tuple(hv_WidthImage);
      destroy_tuple(hv_HeightImage);
      /***/T_get_image_size(ho_Image, &hv_WidthImage, &hv_HeightImage);

      /*get_next_window (__get_dict_tuple( Params, ['font']), __get_dict_tuple( Params, ['font_size']), __get_dict_tuple( Params, ['display_bottom_desc']), WidthImage, HeightImage, 0, __get_dict_tuple( Params, ['scale_windows']), __get_dict_tuple( Params, ['threshold_width']), PrevWindowCoordinates, WindowHandleDict, KeysForDisplay[KeyIndex], CurrentWindowHandle, WindowImageRatio, PrevWindowCoordinates)*/
      create_tuple_s(&TTemp[SP++],"font");
      T_get_dict_tuple(hv_Params,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      create_tuple_s(&TTemp[SP++],"font_size");
      T_get_dict_tuple(hv_Params,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      create_tuple_s(&TTemp[SP++],"display_bottom_desc");
      T_get_dict_tuple(hv_Params,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      create_tuple_i(&TTemp[SP++],0);
      create_tuple_s(&TTemp[SP++],"scale_windows");
      T_get_dict_tuple(hv_Params,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      create_tuple_s(&TTemp[SP++],"threshold_width");
      T_get_dict_tuple(hv_Params,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      copy_tuple(hv_PrevWindowCoordinates,&TTemp[SP++]);
      T_tuple_select(hv_KeysForDisplay_COPY_INP_TMP,hv_KeyIndex,&TTemp[SP++]);
      destroy_tuple(hv_CurrentWindowHandle);
      destroy_tuple(hv_WindowImageRatio);
      destroy_tuple(hv_PrevWindowCoordinates);
      /***/get_next_window(TTemp[SP-8], TTemp[SP-7], TTemp[SP-6], hv_WidthImage, 
          hv_HeightImage, TTemp[SP-5], TTemp[SP-4], TTemp[SP-3], TTemp[SP-2], hv_WindowHandleDict, 
          TTemp[SP-1], &hv_CurrentWindowHandle, &hv_WindowImageRatio, &hv_PrevWindowCoordinates);
      destroy_tuple(TTemp[--SP]);
      destroy_tuple(TTemp[--SP]);
      destroy_tuple(TTemp[--SP]);
      destroy_tuple(TTemp[--SP]);
      destroy_tuple(TTemp[--SP]);
      destroy_tuple(TTemp[--SP]);
      destroy_tuple(TTemp[--SP]);
      destroy_tuple(TTemp[--SP]);

      /**/
      /*full_domain (Image, Image)*/
      /***/full_domain(ho_Image, &(OTemp[SPO]));
      SPO++;
      clear_obj(ho_Image);
      ho_Image = OTemp[--SPO];

      if (hdev_window_stack_is_open())
      {
        Htuple active_win;
        create_tuple(&active_win,0);
        hdev_window_stack_get_active(&active_win);
        /*dev_display (Image)*/
        /***/T_disp_obj(ho_Image, active_win);
        destroy_tuple(active_win);
      }
      /*========== if (__get_dict_tuple( Params, ['display_bottom_desc'])) ==========*/
      create_tuple_s(&TTemp[SP++],"display_bottom_desc");
      T_get_dict_tuple(hv_Params,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      if(get_i(TTemp[SP-1],0))
      {
        if (hdev_window_stack_is_open())
        {
          Htuple active_win;
          create_tuple(&active_win,0);
          hdev_window_stack_get_active(&active_win);
          /*dev_disp_text (ImageIDStringCapital, 'window', 'bottom', 'left', 'white', 'box', 'false')*/
          create_tuple_s(&TTemp[SP++],"window");
          create_tuple_s(&TTemp[SP++],"bottom");
          create_tuple_s(&TTemp[SP++],"left");
          create_tuple_s(&TTemp[SP++],"white");
          create_tuple_s(&TTemp[SP++],"box");
          create_tuple_s(&TTemp[SP++],"false");
          /***/T_disp_text(active_win,hv_ImageIDStringCapital, TTemp[SP-6], TTemp[SP-5], 
              TTemp[SP-4], TTemp[SP-3], TTemp[SP-2], TTemp[SP-1]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(active_win);
        }
      }
      destroy_tuple(TTemp[--SP]);
      /*========== end if ==========*/
      if (hdev_window_stack_is_open())
      {
        Htuple active_win;
        create_tuple(&active_win,0);
        hdev_window_stack_get_active(&active_win);
        /*dev_disp_text ('Gripping confidence', 'window', 'top', 'left', 'black', 'box', 'true')*/
        create_tuple_s(&TTemp[SP++],"Gripping confidence");
        create_tuple_s(&TTemp[SP++],"window");
        create_tuple_s(&TTemp[SP++],"top");
        create_tuple_s(&TTemp[SP++],"left");
        create_tuple_s(&TTemp[SP++],"black");
        create_tuple_s(&TTemp[SP++],"box");
        create_tuple_s(&TTemp[SP++],"true");
        /***/T_disp_text(active_win,TTemp[SP-7], TTemp[SP-6], TTemp[SP-5], TTemp[SP-4], 
            TTemp[SP-3], TTemp[SP-2], TTemp[SP-1]);
        destroy_tuple(TTemp[--SP]);
        destroy_tuple(TTemp[--SP]);
        destroy_tuple(TTemp[--SP]);
        destroy_tuple(TTemp[--SP]);
        destroy_tuple(TTemp[--SP]);
        destroy_tuple(TTemp[--SP]);
        destroy_tuple(TTemp[--SP]);
        destroy_tuple(active_win);
      }
    }
    else
    {
    destroy_tuple(TTemp[--SP]);
    /*========== elseif (KeysForDisplay[KeyIndex] == 'gripping_map') ==========*/

    T_tuple_select(hv_KeysForDisplay_COPY_INP_TMP,hv_KeyIndex,&TTemp[SP++]);
    create_tuple_s(&TTemp[SP++],"gripping_map");
    T_tuple_equal(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-2]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-2]=TTemp[SP];
    SP--;
    if(get_i(TTemp[SP-1],0))
    {
      /**/
      /*Image.*/
      /*get_dl_sample_image (Image, SampleKeys, DLSample, 'image')*/
      create_tuple_s(&TTemp[SP++],"image");
      clear_obj(ho_Image);
      /***/get_dl_sample_image(&ho_Image, hv_SampleKeys, hv_DLSample, TTemp[SP-1]);
      destroy_tuple(TTemp[--SP]);

      /**/
      /*Gripping map image result.*/
      /*========== if (DLResult == []) ==========*/
      create_tuple(&TTemp[SP++],0);
      T_tuple_equal(hv_DLResult_COPY_INP_TMP,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      if(get_i(TTemp[SP-1],0))
      {
        /* throw(...); only in hdevelop*/
      }
      destroy_tuple(TTemp[--SP]);
      /*========== end if ==========*/
      /*========== if (find(ResultKeys,'gripping_map') != -1) ==========*/
      create_tuple_s(&TTemp[SP++],"gripping_map");
      T_tuple_find(hv_ResultKeys,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      create_tuple_i(&TTemp[SP++],-1);
      T_tuple_not_equal(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-2]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-2]=TTemp[SP];
      SP--;
      if(get_i(TTemp[SP-1],0))
      {
        /*get_dict_object (GrippingMapImageResult, DLResult, 'gripping_map')*/
        create_tuple_s(&TTemp[SP++],"gripping_map");
        clear_obj(ho_GrippingMapImageResult);
        /***/T_get_dict_object(&ho_GrippingMapImageResult, hv_DLResult_COPY_INP_TMP, 
            TTemp[SP-1]);
        destroy_tuple(TTemp[--SP]);

      }
      else
      {
        /* throw(...); only in hdevelop*/
      }
      destroy_tuple(TTemp[--SP]);
      /*========== end if ==========*/
      /**/
      /*Get or open next window.*/
      /*get_image_size (Image, WidthImage, HeightImage)*/
      destroy_tuple(hv_WidthImage);
      destroy_tuple(hv_HeightImage);
      /***/T_get_image_size(ho_Image, &hv_WidthImage, &hv_HeightImage);

      /*get_next_window (__get_dict_tuple( Params, ['font']), __get_dict_tuple( Params, ['font_size']), __get_dict_tuple( Params, ['display_bottom_desc']), WidthImage, HeightImage, 0, __get_dict_tuple( Params, ['scale_windows']), __get_dict_tuple( Params, ['threshold_width']), PrevWindowCoordinates, WindowHandleDict, KeysForDisplay[KeyIndex], CurrentWindowHandle, WindowImageRatio, PrevWindowCoordinates)*/
      create_tuple_s(&TTemp[SP++],"font");
      T_get_dict_tuple(hv_Params,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      create_tuple_s(&TTemp[SP++],"font_size");
      T_get_dict_tuple(hv_Params,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      create_tuple_s(&TTemp[SP++],"display_bottom_desc");
      T_get_dict_tuple(hv_Params,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      create_tuple_i(&TTemp[SP++],0);
      create_tuple_s(&TTemp[SP++],"scale_windows");
      T_get_dict_tuple(hv_Params,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      create_tuple_s(&TTemp[SP++],"threshold_width");
      T_get_dict_tuple(hv_Params,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      copy_tuple(hv_PrevWindowCoordinates,&TTemp[SP++]);
      T_tuple_select(hv_KeysForDisplay_COPY_INP_TMP,hv_KeyIndex,&TTemp[SP++]);
      destroy_tuple(hv_CurrentWindowHandle);
      destroy_tuple(hv_WindowImageRatio);
      destroy_tuple(hv_PrevWindowCoordinates);
      /***/get_next_window(TTemp[SP-8], TTemp[SP-7], TTemp[SP-6], hv_WidthImage, 
          hv_HeightImage, TTemp[SP-5], TTemp[SP-4], TTemp[SP-3], TTemp[SP-2], hv_WindowHandleDict, 
          TTemp[SP-1], &hv_CurrentWindowHandle, &hv_WindowImageRatio, &hv_PrevWindowCoordinates);
      destroy_tuple(TTemp[--SP]);
      destroy_tuple(TTemp[--SP]);
      destroy_tuple(TTemp[--SP]);
      destroy_tuple(TTemp[--SP]);
      destroy_tuple(TTemp[--SP]);
      destroy_tuple(TTemp[--SP]);
      destroy_tuple(TTemp[--SP]);
      destroy_tuple(TTemp[--SP]);

      /**/
      /*Visualization.*/
      /*set_window_param (CurrentWindowHandle, 'background_color', '#000000')*/
      create_tuple_s(&TTemp[SP++],"background_color");
      create_tuple_s(&TTemp[SP++],"#000000");
      /***/T_set_window_param(hv_CurrentWindowHandle, TTemp[SP-2], TTemp[SP-1]);
      destroy_tuple(TTemp[--SP]);
      destroy_tuple(TTemp[--SP]);

      if (hdev_window_stack_is_open())
      {
        Htuple active_win;
        create_tuple(&active_win,0);
        hdev_window_stack_get_active(&active_win);
        /*dev_clear_window ()*/
        /***/T_clear_window(active_win);
        destroy_tuple(active_win);
      }
      /*get_domain (GrippingMapImageResult, Domain)*/
      clear_obj(ho_Domain);
      /***/get_domain(ho_GrippingMapImageResult, &ho_Domain);

      /*reduce_domain (Image, Domain, Image)*/
      /***/reduce_domain(ho_Image, ho_Domain, &(OTemp[SPO]));
      SPO++;
      clear_obj(ho_Image);
      ho_Image = OTemp[--SPO];

      /**/
      if (hdev_window_stack_is_open())
      {
        Htuple active_win;
        create_tuple(&active_win,0);
        hdev_window_stack_get_active(&active_win);
        /*dev_display (Image)*/
        /***/T_disp_obj(ho_Image, active_win);
        destroy_tuple(active_win);
      }
      /*Display gripping regions.*/
      /*ColorsGrippingGroundTruth := [__get_dict_tuple( Params, ['gripping_point_map_color']),__get_dict_tuple( Params, ['gripping_point_background_color'])]*/
      create_tuple_s(&TTemp[SP++],"gripping_point_map_color");
      T_get_dict_tuple(hv_Params,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      create_tuple_s(&TTemp[SP++],"gripping_point_background_color");
      T_get_dict_tuple(hv_Params,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      T_tuple_concat(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-2]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-2]=TTemp[SP];
      SP--;
      destroy_tuple(hv_ColorsGrippingGroundTruth);
      hv_ColorsGrippingGroundTruth=TTemp[--SP];

      /*dev_display_segmentation_regions (GrippingMapImageResult, [1, 0], ColorsGrippingGroundTruth, [], ImageClassIDs)*/
      create_tuple(&TTemp[SP++],2);
      set_i(TTemp[SP-1],1      ,0);
      set_i(TTemp[SP-1],0      ,1);
      create_tuple(&TTemp[SP++],0);
      destroy_tuple(hv_ImageClassIDs);
      /***/dev_display_segmentation_regions(ho_GrippingMapImageResult, TTemp[SP-2], 
          hv_ColorsGrippingGroundTruth, TTemp[SP-1], &hv_ImageClassIDs);
      destroy_tuple(TTemp[--SP]);
      destroy_tuple(TTemp[--SP]);

      /*Display gripping points.*/
      /*get_dict_param (DLResult, 'key_exists', 'gripping_points', GrippingPointsExists)*/
      create_tuple_s(&TTemp[SP++],"key_exists");
      create_tuple_s(&TTemp[SP++],"gripping_points");
      destroy_tuple(hv_GrippingPointsExists);
      /***/T_get_dict_param(hv_DLResult_COPY_INP_TMP, TTemp[SP-2], TTemp[SP-1], &hv_GrippingPointsExists);
      destroy_tuple(TTemp[--SP]);
      destroy_tuple(TTemp[--SP]);

      /*========== if (GrippingPointsExists) ==========*/
      copy_tuple(hv_GrippingPointsExists,&TTemp[SP++]);
      if(get_i(TTemp[SP-1],0))
      {
        /*get_gripping_points_from_dict (DLResult, Rows, Columns)*/
        destroy_tuple(hv_Rows);
        destroy_tuple(hv_Columns);
        /***/get_gripping_points_from_dict(hv_DLResult_COPY_INP_TMP, &hv_Rows, &hv_Columns);

        /*gen_cross_contour_xld (Cross, Rows, Columns, __get_dict_tuple( Params, ['gripping_point_size']), 0.785398)*/
        create_tuple_s(&TTemp[SP++],"gripping_point_size");
        T_get_dict_tuple(hv_Params,TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-1]=TTemp[SP];
        create_tuple_d(&TTemp[SP++],0.785398);
        clear_obj(ho_Cross);
        /***/T_gen_cross_contour_xld(&ho_Cross, hv_Rows, hv_Columns, TTemp[SP-2], 
            TTemp[SP-1]);
        destroy_tuple(TTemp[--SP]);
        destroy_tuple(TTemp[--SP]);

        if (hdev_window_stack_is_open())
        {
          Htuple active_win;
          create_tuple(&active_win,0);
          hdev_window_stack_get_active(&active_win);
          /*dev_set_line_width (__get_dict_tuple( Params, ['line_width']))*/
          create_tuple_s(&TTemp[SP++],"line_width");
          T_get_dict_tuple(hv_Params,TTemp[SP-1],&TTemp[SP]);
          destroy_tuple(TTemp[SP-1]);
          TTemp[SP-1]=TTemp[SP];
          /***/T_set_line_width(active_win,TTemp[SP-1]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(active_win);
        }
        if (hdev_window_stack_is_open())
        {
          Htuple active_win;
          create_tuple(&active_win,0);
          hdev_window_stack_get_active(&active_win);
          /*dev_set_color (__get_dict_tuple( Params, ['gripping_point_color']))*/
          create_tuple_s(&TTemp[SP++],"gripping_point_color");
          T_get_dict_tuple(hv_Params,TTemp[SP-1],&TTemp[SP]);
          destroy_tuple(TTemp[SP-1]);
          TTemp[SP-1]=TTemp[SP];
          /***/T_set_color(active_win,TTemp[SP-1]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(active_win);
        }
        if (hdev_window_stack_is_open())
        {
          Htuple active_win;
          create_tuple(&active_win,0);
          hdev_window_stack_get_active(&active_win);
          /*dev_display (Cross)*/
          /***/T_disp_obj(ho_Cross, active_win);
          destroy_tuple(active_win);
        }
      }
      destroy_tuple(TTemp[--SP]);
      /*========== end if ==========*/
      /**/
      /*========== if (__get_dict_tuple( Params, ['display_bottom_desc'])) ==========*/
      create_tuple_s(&TTemp[SP++],"display_bottom_desc");
      T_get_dict_tuple(hv_Params,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      if(get_i(TTemp[SP-1],0))
      {
        if (hdev_window_stack_is_open())
        {
          Htuple active_win;
          create_tuple(&active_win,0);
          hdev_window_stack_get_active(&active_win);
          /*dev_disp_text (ImageIDStringCapital, 'window', 'bottom', 'left', 'white', 'box', 'false')*/
          create_tuple_s(&TTemp[SP++],"window");
          create_tuple_s(&TTemp[SP++],"bottom");
          create_tuple_s(&TTemp[SP++],"left");
          create_tuple_s(&TTemp[SP++],"white");
          create_tuple_s(&TTemp[SP++],"box");
          create_tuple_s(&TTemp[SP++],"false");
          /***/T_disp_text(active_win,hv_ImageIDStringCapital, TTemp[SP-6], TTemp[SP-5], 
              TTemp[SP-4], TTemp[SP-3], TTemp[SP-2], TTemp[SP-1]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(active_win);
        }
      }
      destroy_tuple(TTemp[--SP]);
      /*========== end if ==========*/
      /**/
    }
    else
    {
    destroy_tuple(TTemp[--SP]);
    /*========== elseif (KeysForDisplay[KeyIndex] == 'gripping_map_ground_truth') ==========*/

    T_tuple_select(hv_KeysForDisplay_COPY_INP_TMP,hv_KeyIndex,&TTemp[SP++]);
    create_tuple_s(&TTemp[SP++],"gripping_map_ground_truth");
    T_tuple_equal(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-2]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-2]=TTemp[SP];
    SP--;
    if(get_i(TTemp[SP-1],0))
    {
      /**/
      /*Image.*/
      /*get_dl_sample_image (Image, SampleKeys, DLSample, 'image')*/
      create_tuple_s(&TTemp[SP++],"image");
      clear_obj(ho_Image);
      /***/get_dl_sample_image(&ho_Image, hv_SampleKeys, hv_DLSample, TTemp[SP-1]);
      destroy_tuple(TTemp[--SP]);

      /**/
      /*Gripping map ground truth.*/
      /*========== if (find(SampleKeys,'segmentation_image') != -1) ==========*/
      create_tuple_s(&TTemp[SP++],"segmentation_image");
      T_tuple_find(hv_SampleKeys,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      create_tuple_i(&TTemp[SP++],-1);
      T_tuple_not_equal(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-2]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-2]=TTemp[SP];
      SP--;
      if(get_i(TTemp[SP-1],0))
      {
        /*get_dict_object (GrippingMapGroundTruth, DLSample, 'segmentation_image')*/
        create_tuple_s(&TTemp[SP++],"segmentation_image");
        clear_obj(ho_GrippingMapGroundTruth);
        /***/T_get_dict_object(&ho_GrippingMapGroundTruth, hv_DLSample, TTemp[SP-1]);
        destroy_tuple(TTemp[--SP]);

      }
      else
      {
        /* throw(...); only in hdevelop*/
      }
      destroy_tuple(TTemp[--SP]);
      /*========== end if ==========*/
      /**/
      /*Get or open next window.*/
      /*get_image_size (Image, WidthImage, HeightImage)*/
      destroy_tuple(hv_WidthImage);
      destroy_tuple(hv_HeightImage);
      /***/T_get_image_size(ho_Image, &hv_WidthImage, &hv_HeightImage);

      /*get_next_window (__get_dict_tuple( Params, ['font']), __get_dict_tuple( Params, ['font_size']), __get_dict_tuple( Params, ['display_bottom_desc']), WidthImage, HeightImage, 0, __get_dict_tuple( Params, ['scale_windows']), __get_dict_tuple( Params, ['threshold_width']), PrevWindowCoordinates, WindowHandleDict, KeysForDisplay[KeyIndex], CurrentWindowHandle, WindowImageRatio, PrevWindowCoordinates)*/
      create_tuple_s(&TTemp[SP++],"font");
      T_get_dict_tuple(hv_Params,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      create_tuple_s(&TTemp[SP++],"font_size");
      T_get_dict_tuple(hv_Params,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      create_tuple_s(&TTemp[SP++],"display_bottom_desc");
      T_get_dict_tuple(hv_Params,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      create_tuple_i(&TTemp[SP++],0);
      create_tuple_s(&TTemp[SP++],"scale_windows");
      T_get_dict_tuple(hv_Params,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      create_tuple_s(&TTemp[SP++],"threshold_width");
      T_get_dict_tuple(hv_Params,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      copy_tuple(hv_PrevWindowCoordinates,&TTemp[SP++]);
      T_tuple_select(hv_KeysForDisplay_COPY_INP_TMP,hv_KeyIndex,&TTemp[SP++]);
      destroy_tuple(hv_CurrentWindowHandle);
      destroy_tuple(hv_WindowImageRatio);
      destroy_tuple(hv_PrevWindowCoordinates);
      /***/get_next_window(TTemp[SP-8], TTemp[SP-7], TTemp[SP-6], hv_WidthImage, 
          hv_HeightImage, TTemp[SP-5], TTemp[SP-4], TTemp[SP-3], TTemp[SP-2], hv_WindowHandleDict, 
          TTemp[SP-1], &hv_CurrentWindowHandle, &hv_WindowImageRatio, &hv_PrevWindowCoordinates);
      destroy_tuple(TTemp[--SP]);
      destroy_tuple(TTemp[--SP]);
      destroy_tuple(TTemp[--SP]);
      destroy_tuple(TTemp[--SP]);
      destroy_tuple(TTemp[--SP]);
      destroy_tuple(TTemp[--SP]);
      destroy_tuple(TTemp[--SP]);
      destroy_tuple(TTemp[--SP]);

      /**/
      /*Visualization.*/
      if (hdev_window_stack_is_open())
      {
        Htuple active_win;
        create_tuple(&active_win,0);
        hdev_window_stack_get_active(&active_win);
        /*dev_display (Image)*/
        /***/T_disp_obj(ho_Image, active_win);
        destroy_tuple(active_win);
      }
      /**/
      /*Display gripping regions.*/
      /*ColorsGrippingGroundTruth := [__get_dict_tuple( Params, ['gripping_point_map_color']),__get_dict_tuple( Params, ['gripping_point_background_color'])]*/
      create_tuple_s(&TTemp[SP++],"gripping_point_map_color");
      T_get_dict_tuple(hv_Params,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      create_tuple_s(&TTemp[SP++],"gripping_point_background_color");
      T_get_dict_tuple(hv_Params,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      T_tuple_concat(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-2]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-2]=TTemp[SP];
      SP--;
      destroy_tuple(hv_ColorsGrippingGroundTruth);
      hv_ColorsGrippingGroundTruth=TTemp[--SP];

      /*dev_display_segmentation_regions (GrippingMapGroundTruth, ClassIDs, ColorsGrippingGroundTruth, [], ImageClassIDs)*/
      create_tuple(&TTemp[SP++],0);
      destroy_tuple(hv_ImageClassIDs);
      /***/dev_display_segmentation_regions(ho_GrippingMapGroundTruth, hv_ClassIDs, 
          hv_ColorsGrippingGroundTruth, TTemp[SP-1], &hv_ImageClassIDs);
      destroy_tuple(TTemp[--SP]);

      /*========== if (__get_dict_tuple( Params, ['display_bottom_desc'])) ==========*/
      create_tuple_s(&TTemp[SP++],"display_bottom_desc");
      T_get_dict_tuple(hv_Params,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      if(get_i(TTemp[SP-1],0))
      {
        if (hdev_window_stack_is_open())
        {
          Htuple active_win;
          create_tuple(&active_win,0);
          hdev_window_stack_get_active(&active_win);
          /*dev_disp_text (ImageIDStringCapital, 'window', 'bottom', 'left', 'white', 'box', 'false')*/
          create_tuple_s(&TTemp[SP++],"window");
          create_tuple_s(&TTemp[SP++],"bottom");
          create_tuple_s(&TTemp[SP++],"left");
          create_tuple_s(&TTemp[SP++],"white");
          create_tuple_s(&TTemp[SP++],"box");
          create_tuple_s(&TTemp[SP++],"false");
          /***/T_disp_text(active_win,hv_ImageIDStringCapital, TTemp[SP-6], TTemp[SP-5], 
              TTemp[SP-4], TTemp[SP-3], TTemp[SP-2], TTemp[SP-1]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(active_win);
        }
      }
      destroy_tuple(TTemp[--SP]);
      /*========== end if ==========*/
      if (hdev_window_stack_is_open())
      {
        Htuple active_win;
        create_tuple(&active_win,0);
        hdev_window_stack_get_active(&active_win);
        /*dev_disp_text ('Gripping map ground truth', 'window', 'top', 'left', 'black', 'box', 'true')*/
        create_tuple_s(&TTemp[SP++],"Gripping map ground truth");
        create_tuple_s(&TTemp[SP++],"window");
        create_tuple_s(&TTemp[SP++],"top");
        create_tuple_s(&TTemp[SP++],"left");
        create_tuple_s(&TTemp[SP++],"black");
        create_tuple_s(&TTemp[SP++],"box");
        create_tuple_s(&TTemp[SP++],"true");
        /***/T_disp_text(active_win,TTemp[SP-7], TTemp[SP-6], TTemp[SP-5], TTemp[SP-4], 
            TTemp[SP-3], TTemp[SP-2], TTemp[SP-1]);
        destroy_tuple(TTemp[--SP]);
        destroy_tuple(TTemp[--SP]);
        destroy_tuple(TTemp[--SP]);
        destroy_tuple(TTemp[--SP]);
        destroy_tuple(TTemp[--SP]);
        destroy_tuple(TTemp[--SP]);
        destroy_tuple(TTemp[--SP]);
        destroy_tuple(active_win);
      }
      /**/
    }
    else
    {
    destroy_tuple(TTemp[--SP]);
    /*========== elseif (KeysForDisplay[KeyIndex] == 'x') ==========*/

    T_tuple_select(hv_KeysForDisplay_COPY_INP_TMP,hv_KeyIndex,&TTemp[SP++]);
    create_tuple_s(&TTemp[SP++],"x");
    T_tuple_equal(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-2]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-2]=TTemp[SP];
    SP--;
    if(get_i(TTemp[SP-1],0))
    {
      /**/
      /*X.*/
      /*get_dl_sample_image (Image, SampleKeys, DLSample, KeysForDisplay[KeyIndex])*/
      T_tuple_select(hv_KeysForDisplay_COPY_INP_TMP,hv_KeyIndex,&TTemp[SP++]);
      clear_obj(ho_Image);
      /***/get_dl_sample_image(&ho_Image, hv_SampleKeys, hv_DLSample, TTemp[SP-1]);
      destroy_tuple(TTemp[--SP]);

      /**/
      /*Get or open next window.*/
      /*get_image_size (Image, WidthImage, HeightImage)*/
      destroy_tuple(hv_WidthImage);
      destroy_tuple(hv_HeightImage);
      /***/T_get_image_size(ho_Image, &hv_WidthImage, &hv_HeightImage);

      /*get_next_window (__get_dict_tuple( Params, ['font']), __get_dict_tuple( Params, ['font_size']), __get_dict_tuple( Params, ['display_bottom_desc']), WidthImage, HeightImage, 0, __get_dict_tuple( Params, ['scale_windows']), __get_dict_tuple( Params, ['threshold_width']), PrevWindowCoordinates, WindowHandleDict, KeysForDisplay[KeyIndex], CurrentWindowHandle, WindowImageRatio, PrevWindowCoordinates)*/
      create_tuple_s(&TTemp[SP++],"font");
      T_get_dict_tuple(hv_Params,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      create_tuple_s(&TTemp[SP++],"font_size");
      T_get_dict_tuple(hv_Params,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      create_tuple_s(&TTemp[SP++],"display_bottom_desc");
      T_get_dict_tuple(hv_Params,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      create_tuple_i(&TTemp[SP++],0);
      create_tuple_s(&TTemp[SP++],"scale_windows");
      T_get_dict_tuple(hv_Params,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      create_tuple_s(&TTemp[SP++],"threshold_width");
      T_get_dict_tuple(hv_Params,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      copy_tuple(hv_PrevWindowCoordinates,&TTemp[SP++]);
      T_tuple_select(hv_KeysForDisplay_COPY_INP_TMP,hv_KeyIndex,&TTemp[SP++]);
      destroy_tuple(hv_CurrentWindowHandle);
      destroy_tuple(hv_WindowImageRatio);
      destroy_tuple(hv_PrevWindowCoordinates);
      /***/get_next_window(TTemp[SP-8], TTemp[SP-7], TTemp[SP-6], hv_WidthImage, 
          hv_HeightImage, TTemp[SP-5], TTemp[SP-4], TTemp[SP-3], TTemp[SP-2], hv_WindowHandleDict, 
          TTemp[SP-1], &hv_CurrentWindowHandle, &hv_WindowImageRatio, &hv_PrevWindowCoordinates);
      destroy_tuple(TTemp[--SP]);
      destroy_tuple(TTemp[--SP]);
      destroy_tuple(TTemp[--SP]);
      destroy_tuple(TTemp[--SP]);
      destroy_tuple(TTemp[--SP]);
      destroy_tuple(TTemp[--SP]);
      destroy_tuple(TTemp[--SP]);
      destroy_tuple(TTemp[--SP]);

      /**/
      /*full_domain (Image, Image)*/
      /***/full_domain(ho_Image, &(OTemp[SPO]));
      SPO++;
      clear_obj(ho_Image);
      ho_Image = OTemp[--SPO];

      if (hdev_window_stack_is_open())
      {
        Htuple active_win;
        create_tuple(&active_win,0);
        hdev_window_stack_get_active(&active_win);
        /*dev_display (Image)*/
        /***/T_disp_obj(ho_Image, active_win);
        destroy_tuple(active_win);
      }
      /*========== if (__get_dict_tuple( Params, ['display_bottom_desc'])) ==========*/
      create_tuple_s(&TTemp[SP++],"display_bottom_desc");
      T_get_dict_tuple(hv_Params,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      if(get_i(TTemp[SP-1],0))
      {
        if (hdev_window_stack_is_open())
        {
          Htuple active_win;
          create_tuple(&active_win,0);
          hdev_window_stack_get_active(&active_win);
          /*dev_disp_text (ImageIDStringCapital, 'window', 'bottom', 'left', 'white', 'box', 'false')*/
          create_tuple_s(&TTemp[SP++],"window");
          create_tuple_s(&TTemp[SP++],"bottom");
          create_tuple_s(&TTemp[SP++],"left");
          create_tuple_s(&TTemp[SP++],"white");
          create_tuple_s(&TTemp[SP++],"box");
          create_tuple_s(&TTemp[SP++],"false");
          /***/T_disp_text(active_win,hv_ImageIDStringCapital, TTemp[SP-6], TTemp[SP-5], 
              TTemp[SP-4], TTemp[SP-3], TTemp[SP-2], TTemp[SP-1]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(active_win);
        }
      }
      destroy_tuple(TTemp[--SP]);
      /*========== end if ==========*/
    }
    else
    {
    destroy_tuple(TTemp[--SP]);
    /*========== elseif (KeysForDisplay[KeyIndex] == 'xyz') ==========*/

    T_tuple_select(hv_KeysForDisplay_COPY_INP_TMP,hv_KeyIndex,&TTemp[SP++]);
    create_tuple_s(&TTemp[SP++],"xyz");
    T_tuple_equal(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-2]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-2]=TTemp[SP];
    SP--;
    if(get_i(TTemp[SP-1],0))
    {
      /**/
      /*XYZ.*/
      /*get_dl_sample_image (X, SampleKeys, DLSample, 'x')*/
      create_tuple_s(&TTemp[SP++],"x");
      clear_obj(ho_X);
      /***/get_dl_sample_image(&ho_X, hv_SampleKeys, hv_DLSample, TTemp[SP-1]);
      destroy_tuple(TTemp[--SP]);

      /*get_dl_sample_image (Y, SampleKeys, DLSample, 'y')*/
      create_tuple_s(&TTemp[SP++],"y");
      clear_obj(ho_Y);
      /***/get_dl_sample_image(&ho_Y, hv_SampleKeys, hv_DLSample, TTemp[SP-1]);
      destroy_tuple(TTemp[--SP]);

      /*get_dl_sample_image (Z, SampleKeys, DLSample, 'z')*/
      create_tuple_s(&TTemp[SP++],"z");
      clear_obj(ho_Z);
      /***/get_dl_sample_image(&ho_Z, hv_SampleKeys, hv_DLSample, TTemp[SP-1]);
      destroy_tuple(TTemp[--SP]);

      /*compose3 (X, Y, Z, Image)*/
      clear_obj(ho_Image);
      /***/compose3(ho_X, ho_Y, ho_Z, &ho_Image);

      /**/
      /*Get or open next window.*/
      /*get_image_size (Image, WidthImage, HeightImage)*/
      destroy_tuple(hv_WidthImage);
      destroy_tuple(hv_HeightImage);
      /***/T_get_image_size(ho_Image, &hv_WidthImage, &hv_HeightImage);

      /*get_next_window (__get_dict_tuple( Params, ['font']), __get_dict_tuple( Params, ['font_size']), __get_dict_tuple( Params, ['display_bottom_desc']), WidthImage, HeightImage, 0, __get_dict_tuple( Params, ['scale_windows']), __get_dict_tuple( Params, ['threshold_width']), PrevWindowCoordinates, WindowHandleDict, KeysForDisplay[KeyIndex], CurrentWindowHandle, WindowImageRatio, PrevWindowCoordinates)*/
      create_tuple_s(&TTemp[SP++],"font");
      T_get_dict_tuple(hv_Params,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      create_tuple_s(&TTemp[SP++],"font_size");
      T_get_dict_tuple(hv_Params,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      create_tuple_s(&TTemp[SP++],"display_bottom_desc");
      T_get_dict_tuple(hv_Params,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      create_tuple_i(&TTemp[SP++],0);
      create_tuple_s(&TTemp[SP++],"scale_windows");
      T_get_dict_tuple(hv_Params,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      create_tuple_s(&TTemp[SP++],"threshold_width");
      T_get_dict_tuple(hv_Params,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      copy_tuple(hv_PrevWindowCoordinates,&TTemp[SP++]);
      T_tuple_select(hv_KeysForDisplay_COPY_INP_TMP,hv_KeyIndex,&TTemp[SP++]);
      destroy_tuple(hv_CurrentWindowHandle);
      destroy_tuple(hv_WindowImageRatio);
      destroy_tuple(hv_PrevWindowCoordinates);
      /***/get_next_window(TTemp[SP-8], TTemp[SP-7], TTemp[SP-6], hv_WidthImage, 
          hv_HeightImage, TTemp[SP-5], TTemp[SP-4], TTemp[SP-3], TTemp[SP-2], hv_WindowHandleDict, 
          TTemp[SP-1], &hv_CurrentWindowHandle, &hv_WindowImageRatio, &hv_PrevWindowCoordinates);
      destroy_tuple(TTemp[--SP]);
      destroy_tuple(TTemp[--SP]);
      destroy_tuple(TTemp[--SP]);
      destroy_tuple(TTemp[--SP]);
      destroy_tuple(TTemp[--SP]);
      destroy_tuple(TTemp[--SP]);
      destroy_tuple(TTemp[--SP]);
      destroy_tuple(TTemp[--SP]);

      /**/
      /*full_domain (Image, Image)*/
      /***/full_domain(ho_Image, &(OTemp[SPO]));
      SPO++;
      clear_obj(ho_Image);
      ho_Image = OTemp[--SPO];

      if (hdev_window_stack_is_open())
      {
        Htuple active_win;
        create_tuple(&active_win,0);
        hdev_window_stack_get_active(&active_win);
        /*dev_display (Image)*/
        /***/T_disp_obj(ho_Image, active_win);
        destroy_tuple(active_win);
      }
      /*========== if (__get_dict_tuple( Params, ['display_bottom_desc'])) ==========*/
      create_tuple_s(&TTemp[SP++],"display_bottom_desc");
      T_get_dict_tuple(hv_Params,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      if(get_i(TTemp[SP-1],0))
      {
        if (hdev_window_stack_is_open())
        {
          Htuple active_win;
          create_tuple(&active_win,0);
          hdev_window_stack_get_active(&active_win);
          /*dev_disp_text (ImageIDStringCapital, 'window', 'bottom', 'left', 'white', 'box', 'false')*/
          create_tuple_s(&TTemp[SP++],"window");
          create_tuple_s(&TTemp[SP++],"bottom");
          create_tuple_s(&TTemp[SP++],"left");
          create_tuple_s(&TTemp[SP++],"white");
          create_tuple_s(&TTemp[SP++],"box");
          create_tuple_s(&TTemp[SP++],"false");
          /***/T_disp_text(active_win,hv_ImageIDStringCapital, TTemp[SP-6], TTemp[SP-5], 
              TTemp[SP-4], TTemp[SP-3], TTemp[SP-2], TTemp[SP-1]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(active_win);
        }
      }
      destroy_tuple(TTemp[--SP]);
      /*========== end if ==========*/
    }
    else
    {
    destroy_tuple(TTemp[--SP]);
    /*========== elseif (KeysForDisplay[KeyIndex] == 'y') ==========*/

    T_tuple_select(hv_KeysForDisplay_COPY_INP_TMP,hv_KeyIndex,&TTemp[SP++]);
    create_tuple_s(&TTemp[SP++],"y");
    T_tuple_equal(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-2]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-2]=TTemp[SP];
    SP--;
    if(get_i(TTemp[SP-1],0))
    {
      /**/
      /*Y.*/
      /*get_dl_sample_image (Image, SampleKeys, DLSample, KeysForDisplay[KeyIndex])*/
      T_tuple_select(hv_KeysForDisplay_COPY_INP_TMP,hv_KeyIndex,&TTemp[SP++]);
      clear_obj(ho_Image);
      /***/get_dl_sample_image(&ho_Image, hv_SampleKeys, hv_DLSample, TTemp[SP-1]);
      destroy_tuple(TTemp[--SP]);

      /**/
      /*Get or open next window.*/
      /*get_image_size (Image, WidthImage, HeightImage)*/
      destroy_tuple(hv_WidthImage);
      destroy_tuple(hv_HeightImage);
      /***/T_get_image_size(ho_Image, &hv_WidthImage, &hv_HeightImage);

      /*get_next_window (__get_dict_tuple( Params, ['font']), __get_dict_tuple( Params, ['font_size']), __get_dict_tuple( Params, ['display_bottom_desc']), WidthImage, HeightImage, 0, __get_dict_tuple( Params, ['scale_windows']), __get_dict_tuple( Params, ['threshold_width']), PrevWindowCoordinates, WindowHandleDict, KeysForDisplay[KeyIndex], CurrentWindowHandle, WindowImageRatio, PrevWindowCoordinates)*/
      create_tuple_s(&TTemp[SP++],"font");
      T_get_dict_tuple(hv_Params,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      create_tuple_s(&TTemp[SP++],"font_size");
      T_get_dict_tuple(hv_Params,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      create_tuple_s(&TTemp[SP++],"display_bottom_desc");
      T_get_dict_tuple(hv_Params,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      create_tuple_i(&TTemp[SP++],0);
      create_tuple_s(&TTemp[SP++],"scale_windows");
      T_get_dict_tuple(hv_Params,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      create_tuple_s(&TTemp[SP++],"threshold_width");
      T_get_dict_tuple(hv_Params,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      copy_tuple(hv_PrevWindowCoordinates,&TTemp[SP++]);
      T_tuple_select(hv_KeysForDisplay_COPY_INP_TMP,hv_KeyIndex,&TTemp[SP++]);
      destroy_tuple(hv_CurrentWindowHandle);
      destroy_tuple(hv_WindowImageRatio);
      destroy_tuple(hv_PrevWindowCoordinates);
      /***/get_next_window(TTemp[SP-8], TTemp[SP-7], TTemp[SP-6], hv_WidthImage, 
          hv_HeightImage, TTemp[SP-5], TTemp[SP-4], TTemp[SP-3], TTemp[SP-2], hv_WindowHandleDict, 
          TTemp[SP-1], &hv_CurrentWindowHandle, &hv_WindowImageRatio, &hv_PrevWindowCoordinates);
      destroy_tuple(TTemp[--SP]);
      destroy_tuple(TTemp[--SP]);
      destroy_tuple(TTemp[--SP]);
      destroy_tuple(TTemp[--SP]);
      destroy_tuple(TTemp[--SP]);
      destroy_tuple(TTemp[--SP]);
      destroy_tuple(TTemp[--SP]);
      destroy_tuple(TTemp[--SP]);

      /**/
      /*full_domain (Image, Image)*/
      /***/full_domain(ho_Image, &(OTemp[SPO]));
      SPO++;
      clear_obj(ho_Image);
      ho_Image = OTemp[--SPO];

      if (hdev_window_stack_is_open())
      {
        Htuple active_win;
        create_tuple(&active_win,0);
        hdev_window_stack_get_active(&active_win);
        /*dev_display (Image)*/
        /***/T_disp_obj(ho_Image, active_win);
        destroy_tuple(active_win);
      }
      /*========== if (__get_dict_tuple( Params, ['display_bottom_desc'])) ==========*/
      create_tuple_s(&TTemp[SP++],"display_bottom_desc");
      T_get_dict_tuple(hv_Params,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      if(get_i(TTemp[SP-1],0))
      {
        if (hdev_window_stack_is_open())
        {
          Htuple active_win;
          create_tuple(&active_win,0);
          hdev_window_stack_get_active(&active_win);
          /*dev_disp_text (ImageIDStringCapital, 'window', 'bottom', 'left', 'white', 'box', 'false')*/
          create_tuple_s(&TTemp[SP++],"window");
          create_tuple_s(&TTemp[SP++],"bottom");
          create_tuple_s(&TTemp[SP++],"left");
          create_tuple_s(&TTemp[SP++],"white");
          create_tuple_s(&TTemp[SP++],"box");
          create_tuple_s(&TTemp[SP++],"false");
          /***/T_disp_text(active_win,hv_ImageIDStringCapital, TTemp[SP-6], TTemp[SP-5], 
              TTemp[SP-4], TTemp[SP-3], TTemp[SP-2], TTemp[SP-1]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(active_win);
        }
      }
      destroy_tuple(TTemp[--SP]);
      /*========== end if ==========*/
    }
    else
    {
    destroy_tuple(TTemp[--SP]);
    /*========== elseif (KeysForDisplay[KeyIndex] == 'z') ==========*/

    T_tuple_select(hv_KeysForDisplay_COPY_INP_TMP,hv_KeyIndex,&TTemp[SP++]);
    create_tuple_s(&TTemp[SP++],"z");
    T_tuple_equal(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-2]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-2]=TTemp[SP];
    SP--;
    if(get_i(TTemp[SP-1],0))
    {
      /**/
      /*Z.*/
      /*get_dl_sample_image (Image, SampleKeys, DLSample, KeysForDisplay[KeyIndex])*/
      T_tuple_select(hv_KeysForDisplay_COPY_INP_TMP,hv_KeyIndex,&TTemp[SP++]);
      clear_obj(ho_Image);
      /***/get_dl_sample_image(&ho_Image, hv_SampleKeys, hv_DLSample, TTemp[SP-1]);
      destroy_tuple(TTemp[--SP]);

      /**/
      /*Get or open next window.*/
      /*get_image_size (Image, WidthImage, HeightImage)*/
      destroy_tuple(hv_WidthImage);
      destroy_tuple(hv_HeightImage);
      /***/T_get_image_size(ho_Image, &hv_WidthImage, &hv_HeightImage);

      /*get_next_window (__get_dict_tuple( Params, ['font']), __get_dict_tuple( Params, ['font_size']), __get_dict_tuple( Params, ['display_bottom_desc']), WidthImage, HeightImage, 0, __get_dict_tuple( Params, ['scale_windows']), __get_dict_tuple( Params, ['threshold_width']), PrevWindowCoordinates, WindowHandleDict, KeysForDisplay[KeyIndex], CurrentWindowHandle, WindowImageRatio, PrevWindowCoordinates)*/
      create_tuple_s(&TTemp[SP++],"font");
      T_get_dict_tuple(hv_Params,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      create_tuple_s(&TTemp[SP++],"font_size");
      T_get_dict_tuple(hv_Params,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      create_tuple_s(&TTemp[SP++],"display_bottom_desc");
      T_get_dict_tuple(hv_Params,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      create_tuple_i(&TTemp[SP++],0);
      create_tuple_s(&TTemp[SP++],"scale_windows");
      T_get_dict_tuple(hv_Params,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      create_tuple_s(&TTemp[SP++],"threshold_width");
      T_get_dict_tuple(hv_Params,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      copy_tuple(hv_PrevWindowCoordinates,&TTemp[SP++]);
      T_tuple_select(hv_KeysForDisplay_COPY_INP_TMP,hv_KeyIndex,&TTemp[SP++]);
      destroy_tuple(hv_CurrentWindowHandle);
      destroy_tuple(hv_WindowImageRatio);
      destroy_tuple(hv_PrevWindowCoordinates);
      /***/get_next_window(TTemp[SP-8], TTemp[SP-7], TTemp[SP-6], hv_WidthImage, 
          hv_HeightImage, TTemp[SP-5], TTemp[SP-4], TTemp[SP-3], TTemp[SP-2], hv_WindowHandleDict, 
          TTemp[SP-1], &hv_CurrentWindowHandle, &hv_WindowImageRatio, &hv_PrevWindowCoordinates);
      destroy_tuple(TTemp[--SP]);
      destroy_tuple(TTemp[--SP]);
      destroy_tuple(TTemp[--SP]);
      destroy_tuple(TTemp[--SP]);
      destroy_tuple(TTemp[--SP]);
      destroy_tuple(TTemp[--SP]);
      destroy_tuple(TTemp[--SP]);
      destroy_tuple(TTemp[--SP]);

      /**/
      /*full_domain (Image, Image)*/
      /***/full_domain(ho_Image, &(OTemp[SPO]));
      SPO++;
      clear_obj(ho_Image);
      ho_Image = OTemp[--SPO];

      if (hdev_window_stack_is_open())
      {
        Htuple active_win;
        create_tuple(&active_win,0);
        hdev_window_stack_get_active(&active_win);
        /*dev_display (Image)*/
        /***/T_disp_obj(ho_Image, active_win);
        destroy_tuple(active_win);
      }
      /*========== if (__get_dict_tuple( Params, ['display_bottom_desc'])) ==========*/
      create_tuple_s(&TTemp[SP++],"display_bottom_desc");
      T_get_dict_tuple(hv_Params,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      if(get_i(TTemp[SP-1],0))
      {
        if (hdev_window_stack_is_open())
        {
          Htuple active_win;
          create_tuple(&active_win,0);
          hdev_window_stack_get_active(&active_win);
          /*dev_disp_text (ImageIDStringCapital, 'window', 'bottom', 'left', 'white', 'box', 'false')*/
          create_tuple_s(&TTemp[SP++],"window");
          create_tuple_s(&TTemp[SP++],"bottom");
          create_tuple_s(&TTemp[SP++],"left");
          create_tuple_s(&TTemp[SP++],"white");
          create_tuple_s(&TTemp[SP++],"box");
          create_tuple_s(&TTemp[SP++],"false");
          /***/T_disp_text(active_win,hv_ImageIDStringCapital, TTemp[SP-6], TTemp[SP-5], 
              TTemp[SP-4], TTemp[SP-3], TTemp[SP-2], TTemp[SP-1]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(active_win);
        }
      }
      destroy_tuple(TTemp[--SP]);
      /*========== end if ==========*/
    }
    else
    {
    destroy_tuple(TTemp[--SP]);
    /*========== elseif (KeysForDisplay[KeyIndex] == 'gripping_point_cloud') ==========*/

    T_tuple_select(hv_KeysForDisplay_COPY_INP_TMP,hv_KeyIndex,&TTemp[SP++]);
    create_tuple_s(&TTemp[SP++],"gripping_point_cloud");
    T_tuple_equal(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-2]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-2]=TTemp[SP];
    SP--;
    if(get_i(TTemp[SP-1],0))
    {
      /**/
      /*In case of 'gripping_point_cloud' provide a window that can be used by the procedure*/
      /*dev_display_dl_3d_data. No actual drawing happens  in this procedure to keep it*/
      /*free from operators not belonging either to the Foundation or Deep Learning*/
      /*license modules.*/
      /*get_dict_param (DLSample, 'keys', [], SampleKeys)*/
      create_tuple_s(&TTemp[SP++],"keys");
      create_tuple(&TTemp[SP++],0);
      destroy_tuple(hv_SampleKeys);
      /***/T_get_dict_param(hv_DLSample, TTemp[SP-2], TTemp[SP-1], &hv_SampleKeys);
      destroy_tuple(TTemp[--SP]);
      destroy_tuple(TTemp[--SP]);

      /*get_dl_sample_image (Image, SampleKeys, DLSample, 'image')*/
      create_tuple_s(&TTemp[SP++],"image");
      clear_obj(ho_Image);
      /***/get_dl_sample_image(&ho_Image, hv_SampleKeys, hv_DLSample, TTemp[SP-1]);
      destroy_tuple(TTemp[--SP]);

      /**/
      /*Get or open next window.*/
      /*get_image_size (Image, WidthImage, HeightImage)*/
      destroy_tuple(hv_WidthImage);
      destroy_tuple(hv_HeightImage);
      /***/T_get_image_size(ho_Image, &hv_WidthImage, &hv_HeightImage);

      /*get_next_window (__get_dict_tuple( Params, ['font']), __get_dict_tuple( Params, ['font_size']), __get_dict_tuple( Params, ['display_bottom_desc']), WidthImage, HeightImage, 0, __get_dict_tuple( Params, ['scale_windows']), __get_dict_tuple( Params, ['threshold_width']), PrevWindowCoordinates, WindowHandleDict, KeysForDisplay[KeyIndex], CurrentWindowHandle, WindowImageRatio, PrevWindowCoordinates)*/
      create_tuple_s(&TTemp[SP++],"font");
      T_get_dict_tuple(hv_Params,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      create_tuple_s(&TTemp[SP++],"font_size");
      T_get_dict_tuple(hv_Params,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      create_tuple_s(&TTemp[SP++],"display_bottom_desc");
      T_get_dict_tuple(hv_Params,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      create_tuple_i(&TTemp[SP++],0);
      create_tuple_s(&TTemp[SP++],"scale_windows");
      T_get_dict_tuple(hv_Params,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      create_tuple_s(&TTemp[SP++],"threshold_width");
      T_get_dict_tuple(hv_Params,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      copy_tuple(hv_PrevWindowCoordinates,&TTemp[SP++]);
      T_tuple_select(hv_KeysForDisplay_COPY_INP_TMP,hv_KeyIndex,&TTemp[SP++]);
      destroy_tuple(hv_CurrentWindowHandle);
      destroy_tuple(hv_WindowImageRatio);
      destroy_tuple(hv_PrevWindowCoordinates);
      /***/get_next_window(TTemp[SP-8], TTemp[SP-7], TTemp[SP-6], hv_WidthImage, 
          hv_HeightImage, TTemp[SP-5], TTemp[SP-4], TTemp[SP-3], TTemp[SP-2], hv_WindowHandleDict, 
          TTemp[SP-1], &hv_CurrentWindowHandle, &hv_WindowImageRatio, &hv_PrevWindowCoordinates);
      destroy_tuple(TTemp[--SP]);
      destroy_tuple(TTemp[--SP]);
      destroy_tuple(TTemp[--SP]);
      destroy_tuple(TTemp[--SP]);
      destroy_tuple(TTemp[--SP]);
      destroy_tuple(TTemp[--SP]);
      destroy_tuple(TTemp[--SP]);
      destroy_tuple(TTemp[--SP]);

      /**/
      /*Do nothing here and draw later*/
      /**/
    }
    else
    {
    destroy_tuple(TTemp[--SP]);
    /*========== elseif (KeysForDisplay[KeyIndex] == 'anomaly_both' or KeysForDisplay[KeyIndex] == 'anomaly_both_local' or KeysForDisplay[KeyIndex] == 'anomaly_both_global') ==========*/

    T_tuple_select(hv_KeysForDisplay_COPY_INP_TMP,hv_KeyIndex,&TTemp[SP++]);
    create_tuple_s(&TTemp[SP++],"anomaly_both");
    T_tuple_equal(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-2]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-2]=TTemp[SP];
    SP--;
    T_tuple_select(hv_KeysForDisplay_COPY_INP_TMP,hv_KeyIndex,&TTemp[SP++]);
    create_tuple_s(&TTemp[SP++],"anomaly_both_local");
    T_tuple_equal(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-2]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-2]=TTemp[SP];
    SP--;
    T_tuple_or(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-2]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-2]=TTemp[SP];
    SP--;
    T_tuple_select(hv_KeysForDisplay_COPY_INP_TMP,hv_KeyIndex,&TTemp[SP++]);
    create_tuple_s(&TTemp[SP++],"anomaly_both_global");
    T_tuple_equal(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-2]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-2]=TTemp[SP];
    SP--;
    T_tuple_or(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-2]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-2]=TTemp[SP];
    SP--;
    if(get_i(TTemp[SP-1],0))
    {
      /**/
      /*In case of 'anomaly_both', also plot 'anomaly_both_local'*/
      /*and 'anomaly_both_global', if available.*/
      /*tuple_regexp_select (ResultKeys, '.*anomaly_image.*', AnomalyImages)*/
      create_tuple_s(&TTemp[SP++],".*anomaly_image.*");
      destroy_tuple(hv_AnomalyImages);
      /***/T_tuple_regexp_select(hv_ResultKeys, TTemp[SP-1], &hv_AnomalyImages);
      destroy_tuple(TTemp[--SP]);

      /*========== if (KeysForDisplay[KeyIndex] == 'anomaly_both') ==========*/
      T_tuple_select(hv_KeysForDisplay_COPY_INP_TMP,hv_KeyIndex,&TTemp[SP++]);
      create_tuple_s(&TTemp[SP++],"anomaly_both");
      T_tuple_equal(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-2]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-2]=TTemp[SP];
      SP--;
      if(get_i(TTemp[SP-1],0))
      {
        /*tuple_regexp_replace (AnomalyImages, 'image', 'both', PossibleKeysForDisplay)*/
        create_tuple_s(&TTemp[SP++],"image");
        create_tuple_s(&TTemp[SP++],"both");
        destroy_tuple(hv_PossibleKeysForDisplay);
        /***/T_tuple_regexp_replace(hv_AnomalyImages, TTemp[SP-2], TTemp[SP-1], &hv_PossibleKeysForDisplay);
        destroy_tuple(TTemp[--SP]);
        destroy_tuple(TTemp[--SP]);

        /*AddDisplayKey := false*/
        reuse_tuple_i(&hv_AddDisplayKey,0);

        /*========== for Index := 0 to |PossibleKeysForDisplay| - 1 by 1 ==========*/
        T_tuple_length(hv_PossibleKeysForDisplay,&TTemp[SP++]);
        create_tuple_i(&TTemp[SP++],1);
        T_tuple_sub(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-2]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-2]=TTemp[SP];
        SP--;
        create_tuple_i(&TTemp[SP++],1);
        create_tuple_i(&TTemp[SP++],0);
        T_tuple_greater(TTemp[SP-1],TTemp[SP-3],&TTemp[SP]);
        SP++;
        T_tuple_equal(TTemp[SP-2],TTemp[SP-4],&TTemp[SP]);
        if(get_i(TTemp[SP],0) ||
           (!((( get_i(TTemp[SP-1],0)) && (get_d(TTemp[SP-3],0)>0)) ||
              ((!get_i(TTemp[SP-1],0)) && (get_d(TTemp[SP-3],0)<0)))))
        {
         destroy_tuple(TTemp[SP--]);
         destroy_tuple(TTemp[SP]);
         T_tuple_sub(TTemp[SP-1],TTemp[SP-2],&TTemp[SP]);
         destroy_tuple(hv_Index);
         copy_tuple(TTemp[SP],&hv_Index);
         destroy_tuple(TTemp[SP--]);
         destroy_tuple(TTemp[SP]);
         for(;;)
         {
         T_tuple_add(hv_Index,TTemp[SP-1],&TTemp[SP]);
         destroy_tuple(hv_Index);
         copy_tuple(TTemp[SP],&hv_Index);
         destroy_tuple(TTemp[SP]);
         if(get_d(TTemp[SP-1],0)<0)
          T_tuple_less(hv_Index,TTemp[SP-2],&TTemp[SP]);
         else
          T_tuple_greater(hv_Index,TTemp[SP-2],&TTemp[SP]);
         if(get_i(TTemp[SP],0)) break;
         destroy_tuple(TTemp[SP]);
         /*========== for ==========*/

          /*========== if (find_first(KeysForDisplay,PossibleKeysForDisplay[Index]) == -1) ==========*/
          T_tuple_select(hv_PossibleKeysForDisplay,hv_Index,&TTemp[SP++]);
          T_tuple_find_first(hv_KeysForDisplay_COPY_INP_TMP,TTemp[SP-1],&TTemp[SP]);
          destroy_tuple(TTemp[SP-1]);
          TTemp[SP-1]=TTemp[SP];
          create_tuple_i(&TTemp[SP++],-1);
          T_tuple_equal(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
          destroy_tuple(TTemp[SP-2]);
          destroy_tuple(TTemp[SP-1]);
          TTemp[SP-2]=TTemp[SP];
          SP--;
          if(get_i(TTemp[SP-1],0))
          {
            /*KeysForDisplay := [KeysForDisplay,PossibleKeysForDisplay[Index]]*/
            copy_tuple(hv_KeysForDisplay_COPY_INP_TMP,&TTemp[SP++]);
            T_tuple_select(hv_PossibleKeysForDisplay,hv_Index,&TTemp[SP++]);
            T_tuple_concat(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
            destroy_tuple(TTemp[SP-2]);
            destroy_tuple(TTemp[SP-1]);
            TTemp[SP-2]=TTemp[SP];
            SP--;
            destroy_tuple(hv_KeysForDisplay_COPY_INP_TMP);
            hv_KeysForDisplay_COPY_INP_TMP=TTemp[--SP];

            /*AddDisplayKey := true*/
            reuse_tuple_i(&hv_AddDisplayKey,1);

          }
          destroy_tuple(TTemp[--SP]);
          /*========== end if ==========*/
         }
         destroy_tuple(TTemp[SP--]);
         destroy_tuple(TTemp[SP--]);
         destroy_tuple(TTemp[SP]);
        }
        else
        {
         destroy_tuple(TTemp[SP--]);
         destroy_tuple(TTemp[SP--]);
         destroy_tuple(TTemp[SP--]);
         destroy_tuple(TTemp[SP--]);
         destroy_tuple(TTemp[SP]);
        }/*========== end for ========*/

        /**/
        /*Display not possible for 'anomaly_both' if key 'anomaly_image' is missing.*/
        /*========== if (find_first(PossibleKeysForDisplay,KeysForDisplay[KeyIndex]) == -1 and AddDisplayKey) ==========*/
        T_tuple_select(hv_KeysForDisplay_COPY_INP_TMP,hv_KeyIndex,&TTemp[SP++]);
        T_tuple_find_first(hv_PossibleKeysForDisplay,TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-1]=TTemp[SP];
        create_tuple_i(&TTemp[SP++],-1);
        T_tuple_equal(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-2]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-2]=TTemp[SP];
        SP--;
        T_tuple_and(TTemp[SP-1],hv_AddDisplayKey,&TTemp[SP]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-1]=TTemp[SP];
        if(get_i(TTemp[SP-1],0))
        {
          /*KeyIndex := KeyIndex + 1*/
          create_tuple_i(&TTemp[SP++],1);
          T_tuple_add(hv_KeyIndex,TTemp[SP-1],&TTemp[SP]);
          destroy_tuple(hv_KeyIndex);
          hv_KeyIndex=TTemp[SP];
          destroy_tuple(TTemp[--SP]);

          /*continue*/
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(TTemp[--SP]);
          continue;
        }
        destroy_tuple(TTemp[--SP]);
        /*========== end if ==========*/
      }
      destroy_tuple(TTemp[--SP]);
      /*========== end if ==========*/
      /**/
      /*Get image and ground truth.*/
      /*get_dl_sample_image (Image, SampleKeys, DLSample, 'image')*/
      create_tuple_s(&TTemp[SP++],"image");
      clear_obj(ho_Image);
      /***/get_dl_sample_image(&ho_Image, hv_SampleKeys, hv_DLSample, TTemp[SP-1]);
      destroy_tuple(TTemp[--SP]);

      /*get_anomaly_ground_truth_label (SampleKeys, DLSample, AnomalyLabelGroundTruth, AnomalyLabelIDGroundTruth)*/
      destroy_tuple(hv_AnomalyLabelGroundTruth);
      destroy_tuple(hv_AnomalyLabelIDGroundTruth);
      /***/get_anomaly_ground_truth_label(hv_SampleKeys, hv_DLSample, &hv_AnomalyLabelGroundTruth, 
          &hv_AnomalyLabelIDGroundTruth);

      /**/
      /*Get the anomaly results either by applying the specified thresholds or out of DLResult.*/
      /*tuple_regexp_match (KeysForDisplay[KeyIndex], 'anomaly_both(.*)', AnomalyResultPostfix)*/
      T_tuple_select(hv_KeysForDisplay_COPY_INP_TMP,hv_KeyIndex,&TTemp[SP++]);
      create_tuple_s(&TTemp[SP++],"anomaly_both(.*)");
      destroy_tuple(hv_AnomalyResultPostfix);
      /***/T_tuple_regexp_match(TTemp[SP-2], TTemp[SP-1], &hv_AnomalyResultPostfix);
      destroy_tuple(TTemp[--SP]);
      destroy_tuple(TTemp[--SP]);

      /*get_anomaly_result (AnomalyImage, AnomalyRegion, DLResult, __get_dict_tuple( Params, ['anomaly_classification_threshold']), __get_dict_tuple( Params, ['anomaly_region_threshold']), AnomalyResultPostfix, AnomalyScore, AnomalyClassID, AnomalyClassThresholdDisplay, AnomalyRegionThresholdDisplay)*/
      create_tuple_s(&TTemp[SP++],"anomaly_classification_threshold");
      T_get_dict_tuple(hv_Params,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      create_tuple_s(&TTemp[SP++],"anomaly_region_threshold");
      T_get_dict_tuple(hv_Params,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      clear_obj(ho_AnomalyImage);
      clear_obj(ho_AnomalyRegion);
      destroy_tuple(hv_AnomalyScore);
      destroy_tuple(hv_AnomalyClassID);
      destroy_tuple(hv_AnomalyClassThresholdDisplay);
      destroy_tuple(hv_AnomalyRegionThresholdDisplay);
      /***/get_anomaly_result(&ho_AnomalyImage, &ho_AnomalyRegion, hv_DLResult_COPY_INP_TMP, 
          TTemp[SP-2], TTemp[SP-1], hv_AnomalyResultPostfix, &hv_AnomalyScore, &hv_AnomalyClassID, 
          &hv_AnomalyClassThresholdDisplay, &hv_AnomalyRegionThresholdDisplay);
      destroy_tuple(TTemp[--SP]);
      destroy_tuple(TTemp[--SP]);

      /**/
      /*Get open next window.*/
      /*get_image_size (Image, WidthImage, HeightImage)*/
      destroy_tuple(hv_WidthImage);
      destroy_tuple(hv_HeightImage);
      /***/T_get_image_size(ho_Image, &hv_WidthImage, &hv_HeightImage);

      /*WindowHandleName := KeysForDisplay[KeyIndex]*/
      T_tuple_select(hv_KeysForDisplay_COPY_INP_TMP,hv_KeyIndex,&TTemp[SP++]);
      destroy_tuple(hv_WindowHandleName);
      hv_WindowHandleName=TTemp[--SP];

      /*get_next_window (__get_dict_tuple( Params, ['font']), __get_dict_tuple( Params, ['font_size']), __get_dict_tuple( Params, ['display_bottom_desc']), WidthImage, HeightImage, 0, __get_dict_tuple( Params, ['scale_windows']), __get_dict_tuple( Params, ['threshold_width']), PrevWindowCoordinates, WindowHandleDict, WindowHandleName, CurrentWindowHandle, WindowImageRatio, PrevWindowCoordinates)*/
      create_tuple_s(&TTemp[SP++],"font");
      T_get_dict_tuple(hv_Params,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      create_tuple_s(&TTemp[SP++],"font_size");
      T_get_dict_tuple(hv_Params,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      create_tuple_s(&TTemp[SP++],"display_bottom_desc");
      T_get_dict_tuple(hv_Params,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      create_tuple_i(&TTemp[SP++],0);
      create_tuple_s(&TTemp[SP++],"scale_windows");
      T_get_dict_tuple(hv_Params,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      create_tuple_s(&TTemp[SP++],"threshold_width");
      T_get_dict_tuple(hv_Params,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      copy_tuple(hv_PrevWindowCoordinates,&TTemp[SP++]);
      destroy_tuple(hv_CurrentWindowHandle);
      destroy_tuple(hv_WindowImageRatio);
      destroy_tuple(hv_PrevWindowCoordinates);
      /***/get_next_window(TTemp[SP-7], TTemp[SP-6], TTemp[SP-5], hv_WidthImage, 
          hv_HeightImage, TTemp[SP-4], TTemp[SP-3], TTemp[SP-2], TTemp[SP-1], hv_WindowHandleDict, 
          hv_WindowHandleName, &hv_CurrentWindowHandle, &hv_WindowImageRatio, &hv_PrevWindowCoordinates);
      destroy_tuple(TTemp[--SP]);
      destroy_tuple(TTemp[--SP]);
      destroy_tuple(TTemp[--SP]);
      destroy_tuple(TTemp[--SP]);
      destroy_tuple(TTemp[--SP]);
      destroy_tuple(TTemp[--SP]);
      destroy_tuple(TTemp[--SP]);

      /**/
      /*Visualize image, ground truth (if available), and result regions.*/
      if (hdev_window_stack_is_open())
      {
        Htuple active_win;
        create_tuple(&active_win,0);
        hdev_window_stack_get_active(&active_win);
        /*dev_display (Image)*/
        /***/T_disp_obj(ho_Image, active_win);
        destroy_tuple(active_win);
      }
      /*AnomalyRegionGroundTruthExists := 'false'*/
      reuse_tuple_s(&hv_AnomalyRegionGroundTruthExists,"false");
      /*========== if (__get_dict_tuple( Params, ['display_ground_truth_anomaly_regions'])) ==========*/
      create_tuple_s(&TTemp[SP++],"display_ground_truth_anomaly_regions");
      T_get_dict_tuple(hv_Params,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      if(get_i(TTemp[SP-1],0))
      {
        /*dev_display_ground_truth_anomaly_regions (SampleKeys, DLSample, CurrentWindowHandle, __get_dict_tuple( Params, ['line_width']), __get_dict_tuple( Params, ['anomaly_region_label_color']), __get_dict_tuple( Params, ['anomaly_color_transparency']), AnomalyRegionGroundTruthExists)*/
        create_tuple_s(&TTemp[SP++],"line_width");
        T_get_dict_tuple(hv_Params,TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-1]=TTemp[SP];
        create_tuple_s(&TTemp[SP++],"anomaly_region_label_color");
        T_get_dict_tuple(hv_Params,TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-1]=TTemp[SP];
        create_tuple_s(&TTemp[SP++],"anomaly_color_transparency");
        T_get_dict_tuple(hv_Params,TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-1]=TTemp[SP];
        destroy_tuple(hv_AnomalyRegionGroundTruthExists);
        /***/dev_display_ground_truth_anomaly_regions(hv_SampleKeys, hv_DLSample, 
            hv_CurrentWindowHandle, TTemp[SP-3], TTemp[SP-2], TTemp[SP-1], &hv_AnomalyRegionGroundTruthExists);
        destroy_tuple(TTemp[--SP]);
        destroy_tuple(TTemp[--SP]);
        destroy_tuple(TTemp[--SP]);

      }
      destroy_tuple(TTemp[--SP]);
      /*========== end if ==========*/
      /**/
      /*Display anomaly regions defined by the specified threshold or out of DLResult.*/
      /*create_dict (__Tmp_Ctrl_Dict_Init_3)*/
      destroy_tuple(hv___Tmp_Ctrl_Dict_Init_3);
      /***/T_create_dict(&hv___Tmp_Ctrl_Dict_Init_3);

      /*set_dict_tuple (__Tmp_Ctrl_Dict_Init_3, ['comp'], -1)*/
      create_tuple_s(&TTemp[SP++],"comp");
      create_tuple_i(&TTemp[SP++],-1);
      /***/T_set_dict_tuple(hv___Tmp_Ctrl_Dict_Init_3, TTemp[SP-2], TTemp[SP-1]);
      destroy_tuple(TTemp[--SP]);
      destroy_tuple(TTemp[--SP]);

      /*========== if (not __test_equal_dict_item([Params, __Tmp_Ctrl_Dict_Init_3], ['anomaly_region_threshold'], 'comp') or find(ResultKeys,'anomaly_region' + AnomalyResultPostfix) != -1) ==========*/
      T_tuple_concat(hv_Params,hv___Tmp_Ctrl_Dict_Init_3,&TTemp[SP++]);
      create_tuple_s(&TTemp[SP++],"anomaly_region_threshold");
      create_tuple_s(&TTemp[SP++],"comp");
      T_test_equal_dict_item(TTemp[SP-3],TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-3]);
      destroy_tuple(TTemp[SP-2]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-3]=TTemp[SP];
      SP=SP-2;
      T_tuple_not(TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      create_tuple_s(&TTemp[SP++],"anomaly_region");
      T_tuple_add(TTemp[SP-1],hv_AnomalyResultPostfix,&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      T_tuple_find(hv_ResultKeys,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      create_tuple_i(&TTemp[SP++],-1);
      T_tuple_not_equal(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-2]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-2]=TTemp[SP];
      SP--;
      T_tuple_or(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-2]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-2]=TTemp[SP];
      SP--;
      if(get_i(TTemp[SP-1],0))
      {
        /*dev_display_result_anomaly_regions (AnomalyRegion, CurrentWindowHandle, __get_dict_tuple( Params, ['line_width']), __get_dict_tuple( Params, ['anomaly_region_result_color']))*/
        create_tuple_s(&TTemp[SP++],"line_width");
        T_get_dict_tuple(hv_Params,TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-1]=TTemp[SP];
        create_tuple_s(&TTemp[SP++],"anomaly_region_result_color");
        T_get_dict_tuple(hv_Params,TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-1]=TTemp[SP];
        /***/dev_display_result_anomaly_regions(ho_AnomalyRegion, hv_CurrentWindowHandle, 
            TTemp[SP-2], TTemp[SP-1]);
        destroy_tuple(TTemp[--SP]);
        destroy_tuple(TTemp[--SP]);

      }
      destroy_tuple(TTemp[--SP]);
      /*========== end if ==========*/
      /*__Tmp_Ctrl_Dict_Init_3 := constant('HNULL')*/
      create_tuple_s(&TTemp[SP++],"HNULL");
      T_tuple_constant(TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      destroy_tuple(hv___Tmp_Ctrl_Dict_Init_3);
      hv___Tmp_Ctrl_Dict_Init_3=TTemp[--SP];

      /**/
      /*Text := 'GT and detected anomalies ' + ImageIDStringBraces*/
      create_tuple_s(&TTemp[SP++],"GT and detected anomalies ");
      T_tuple_add(TTemp[SP-1],hv_ImageIDStringBraces,&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      destroy_tuple(hv_Text);
      hv_Text=TTemp[--SP];

      /*========== if (__get_dict_tuple( Params, ['display_bottom_desc'])) ==========*/
      create_tuple_s(&TTemp[SP++],"display_bottom_desc");
      T_get_dict_tuple(hv_Params,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      if(get_i(TTemp[SP-1],0))
      {
        if (hdev_window_stack_is_open())
        {
          Htuple active_win;
          create_tuple(&active_win,0);
          hdev_window_stack_get_active(&active_win);
          /*dev_disp_text (Text, 'window', 'bottom', 'left', 'white', 'box', 'false')*/
          create_tuple_s(&TTemp[SP++],"window");
          create_tuple_s(&TTemp[SP++],"bottom");
          create_tuple_s(&TTemp[SP++],"left");
          create_tuple_s(&TTemp[SP++],"white");
          create_tuple_s(&TTemp[SP++],"box");
          create_tuple_s(&TTemp[SP++],"false");
          /***/T_disp_text(active_win,hv_Text, TTemp[SP-6], TTemp[SP-5], TTemp[SP-4], 
              TTemp[SP-3], TTemp[SP-2], TTemp[SP-1]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(active_win);
        }
      }
      destroy_tuple(TTemp[--SP]);
      /*========== end if ==========*/
      /**/
      /*Get prediction color.*/
      /*PredictionColor := 'white'*/
      reuse_tuple_s(&hv_PredictionColor,"white");
      /*========== if (AnomalyLabelIDGroundTruth == AnomalyClassID) ==========*/
      T_tuple_equal(hv_AnomalyLabelIDGroundTruth,hv_AnomalyClassID,&TTemp[SP++]);
      if(get_i(TTemp[SP-1],0))
      {
        /*PredictionColor := 'green'*/
        reuse_tuple_s(&hv_PredictionColor,"green");
      }
      else
      {
      destroy_tuple(TTemp[--SP]);
      /*========== elseif (AnomalyClassID != -1) ==========*/

      create_tuple_i(&TTemp[SP++],-1);
      T_tuple_not_equal(hv_AnomalyClassID,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      if(get_i(TTemp[SP-1],0))
      {
        /*PredictionColor := 'red'*/
        reuse_tuple_s(&hv_PredictionColor,"red");
      }
      }
      destroy_tuple(TTemp[--SP]);
      /*========== end if ==========*/
      /**/
      /*Display the legend.*/
      /*========== if (__get_dict_tuple( Params, ['display_legend'])) ==========*/
      create_tuple_s(&TTemp[SP++],"display_legend");
      T_get_dict_tuple(hv_Params,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      if(get_i(TTemp[SP-1],0))
      {
        /*Text[|Text|] := ''*/
        copy_tuple(hv_Text,&TTemp[SP++]);
        T_tuple_length(TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-1]=TTemp[SP];
        create_tuple_s(&TTemp[SP++],"");
        replace_elements(&hv_Text,&TTemp[SP-2],&TTemp[SP-1]);
        destroy_tuple(TTemp[--SP]);
        destroy_tuple(TTemp[--SP]);
        /*Text[|Text|] := '---------------'*/
        copy_tuple(hv_Text,&TTemp[SP++]);
        T_tuple_length(TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-1]=TTemp[SP];
        create_tuple_s(&TTemp[SP++],"---------------");
        replace_elements(&hv_Text,&TTemp[SP-2],&TTemp[SP-1]);
        destroy_tuple(TTemp[--SP]);
        destroy_tuple(TTemp[--SP]);
        /*Text[|Text|] := 'Ground truth '*/
        copy_tuple(hv_Text,&TTemp[SP++]);
        T_tuple_length(TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-1]=TTemp[SP];
        create_tuple_s(&TTemp[SP++],"Ground truth ");
        replace_elements(&hv_Text,&TTemp[SP-2],&TTemp[SP-1]);
        destroy_tuple(TTemp[--SP]);
        destroy_tuple(TTemp[--SP]);
        /*Text[|Text|] := '---------------'*/
        copy_tuple(hv_Text,&TTemp[SP++]);
        T_tuple_length(TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-1]=TTemp[SP];
        create_tuple_s(&TTemp[SP++],"---------------");
        replace_elements(&hv_Text,&TTemp[SP-2],&TTemp[SP-1]);
        destroy_tuple(TTemp[--SP]);
        destroy_tuple(TTemp[--SP]);
        /*Text[|Text|] := AnomalyLabelIDGroundTruth + ' : \'' + AnomalyLabelGroundTruth + '\''*/
        copy_tuple(hv_Text,&TTemp[SP++]);
        T_tuple_length(TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-1]=TTemp[SP];
        create_tuple_s(&TTemp[SP++]," : '");
        T_tuple_add(hv_AnomalyLabelIDGroundTruth,TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-1]=TTemp[SP];
        T_tuple_add(TTemp[SP-1],hv_AnomalyLabelGroundTruth,&TTemp[SP]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-1]=TTemp[SP];
        create_tuple_s(&TTemp[SP++],"'");
        T_tuple_add(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-2]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-2]=TTemp[SP];
        SP--;
        replace_elements(&hv_Text,&TTemp[SP-2],&TTemp[SP-1]);
        destroy_tuple(TTemp[--SP]);
        destroy_tuple(TTemp[--SP]);
        /*========== if (AnomalyRegionGroundTruthExists == 'false' and AnomalyLabelIDGroundTruth == 1 and __get_dict_tuple( Params, ['display_ground_truth_anomaly_regions'])) ==========*/
        create_tuple_s(&TTemp[SP++],"false");
        T_tuple_equal(hv_AnomalyRegionGroundTruthExists,TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-1]=TTemp[SP];
        create_tuple_i(&TTemp[SP++],1);
        T_tuple_equal(hv_AnomalyLabelIDGroundTruth,TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-1]=TTemp[SP];
        T_tuple_and(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-2]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-2]=TTemp[SP];
        SP--;
        create_tuple_s(&TTemp[SP++],"display_ground_truth_anomaly_regions");
        T_get_dict_tuple(hv_Params,TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-1]=TTemp[SP];
        T_tuple_and(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-2]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-2]=TTemp[SP];
        SP--;
        if(get_i(TTemp[SP-1],0))
        {
          /*Text[|Text|] := ''*/
          copy_tuple(hv_Text,&TTemp[SP++]);
          T_tuple_length(TTemp[SP-1],&TTemp[SP]);
          destroy_tuple(TTemp[SP-1]);
          TTemp[SP-1]=TTemp[SP];
          create_tuple_s(&TTemp[SP++],"");
          replace_elements(&hv_Text,&TTemp[SP-2],&TTemp[SP-1]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(TTemp[--SP]);
          /*Text[|Text|] := 'No segmentation ground truth found'*/
          copy_tuple(hv_Text,&TTemp[SP++]);
          T_tuple_length(TTemp[SP-1],&TTemp[SP]);
          destroy_tuple(TTemp[SP-1]);
          TTemp[SP-1]=TTemp[SP];
          create_tuple_s(&TTemp[SP++],"No segmentation ground truth found");
          replace_elements(&hv_Text,&TTemp[SP-2],&TTemp[SP-1]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(TTemp[--SP]);
        }
        destroy_tuple(TTemp[--SP]);
        /*========== end if ==========*/
        /*Text[|Text|] := ''*/
        copy_tuple(hv_Text,&TTemp[SP++]);
        T_tuple_length(TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-1]=TTemp[SP];
        create_tuple_s(&TTemp[SP++],"");
        replace_elements(&hv_Text,&TTemp[SP-2],&TTemp[SP-1]);
        destroy_tuple(TTemp[--SP]);
        destroy_tuple(TTemp[--SP]);
        /*Text[|Text|] := '---------------'*/
        copy_tuple(hv_Text,&TTemp[SP++]);
        T_tuple_length(TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-1]=TTemp[SP];
        create_tuple_s(&TTemp[SP++],"---------------");
        replace_elements(&hv_Text,&TTemp[SP-2],&TTemp[SP-1]);
        destroy_tuple(TTemp[--SP]);
        destroy_tuple(TTemp[--SP]);
        /*Text[|Text|] := 'Results '*/
        copy_tuple(hv_Text,&TTemp[SP++]);
        T_tuple_length(TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-1]=TTemp[SP];
        create_tuple_s(&TTemp[SP++],"Results ");
        replace_elements(&hv_Text,&TTemp[SP-2],&TTemp[SP-1]);
        destroy_tuple(TTemp[--SP]);
        destroy_tuple(TTemp[--SP]);
        /*Text[|Text|] := '---------------'*/
        copy_tuple(hv_Text,&TTemp[SP++]);
        T_tuple_length(TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-1]=TTemp[SP];
        create_tuple_s(&TTemp[SP++],"---------------");
        replace_elements(&hv_Text,&TTemp[SP-2],&TTemp[SP-1]);
        destroy_tuple(TTemp[--SP]);
        destroy_tuple(TTemp[--SP]);
        /*========== if (AnomalyClassID == 1) ==========*/
        create_tuple_i(&TTemp[SP++],1);
        T_tuple_equal(hv_AnomalyClassID,TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-1]=TTemp[SP];
        if(get_i(TTemp[SP-1],0))
        {
          /*Text[|Text|] := AnomalyClassID + ' : \'nok\''*/
          copy_tuple(hv_Text,&TTemp[SP++]);
          T_tuple_length(TTemp[SP-1],&TTemp[SP]);
          destroy_tuple(TTemp[SP-1]);
          TTemp[SP-1]=TTemp[SP];
          create_tuple_s(&TTemp[SP++]," : 'nok'");
          T_tuple_add(hv_AnomalyClassID,TTemp[SP-1],&TTemp[SP]);
          destroy_tuple(TTemp[SP-1]);
          TTemp[SP-1]=TTemp[SP];
          replace_elements(&hv_Text,&TTemp[SP-2],&TTemp[SP-1]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(TTemp[--SP]);
        }
        else
        {
        destroy_tuple(TTemp[--SP]);
        /*========== elseif (AnomalyClassID == 0) ==========*/

        create_tuple_i(&TTemp[SP++],0);
        T_tuple_equal(hv_AnomalyClassID,TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-1]=TTemp[SP];
        if(get_i(TTemp[SP-1],0))
        {
          /*Text[|Text|] := AnomalyClassID + ' : \'ok\''*/
          copy_tuple(hv_Text,&TTemp[SP++]);
          T_tuple_length(TTemp[SP-1],&TTemp[SP]);
          destroy_tuple(TTemp[SP-1]);
          TTemp[SP-1]=TTemp[SP];
          create_tuple_s(&TTemp[SP++]," : 'ok'");
          T_tuple_add(hv_AnomalyClassID,TTemp[SP-1],&TTemp[SP]);
          destroy_tuple(TTemp[SP-1]);
          TTemp[SP-1]=TTemp[SP];
          replace_elements(&hv_Text,&TTemp[SP-2],&TTemp[SP-1]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(TTemp[--SP]);
        }
        else
        {
          /*Text[|Text|] := 'No classification result found'*/
          copy_tuple(hv_Text,&TTemp[SP++]);
          T_tuple_length(TTemp[SP-1],&TTemp[SP]);
          destroy_tuple(TTemp[SP-1]);
          TTemp[SP-1]=TTemp[SP];
          create_tuple_s(&TTemp[SP++],"No classification result found");
          replace_elements(&hv_Text,&TTemp[SP-2],&TTemp[SP-1]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(TTemp[--SP]);
        }
        }
        destroy_tuple(TTemp[--SP]);
        /*========== end if ==========*/
        /*create_dict (__Tmp_Ctrl_Dict_Init_4)*/
        destroy_tuple(hv___Tmp_Ctrl_Dict_Init_4);
        /***/T_create_dict(&hv___Tmp_Ctrl_Dict_Init_4);

        /*set_dict_tuple (__Tmp_Ctrl_Dict_Init_4, ['comp'], -1)*/
        create_tuple_s(&TTemp[SP++],"comp");
        create_tuple_i(&TTemp[SP++],-1);
        /***/T_set_dict_tuple(hv___Tmp_Ctrl_Dict_Init_4, TTemp[SP-2], TTemp[SP-1]);
        destroy_tuple(TTemp[--SP]);
        destroy_tuple(TTemp[--SP]);

        /*========== if (__test_equal_dict_item([Params, __Tmp_Ctrl_Dict_Init_4], ['anomaly_region_threshold'], 'comp') and find(ResultKeys,'anomaly_region' + AnomalyResultPostfix) == -1) ==========*/
        T_tuple_concat(hv_Params,hv___Tmp_Ctrl_Dict_Init_4,&TTemp[SP++]);
        create_tuple_s(&TTemp[SP++],"anomaly_region_threshold");
        create_tuple_s(&TTemp[SP++],"comp");
        T_test_equal_dict_item(TTemp[SP-3],TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-3]);
        destroy_tuple(TTemp[SP-2]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-3]=TTemp[SP];
        SP=SP-2;
        create_tuple_s(&TTemp[SP++],"anomaly_region");
        T_tuple_add(TTemp[SP-1],hv_AnomalyResultPostfix,&TTemp[SP]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-1]=TTemp[SP];
        T_tuple_find(hv_ResultKeys,TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-1]=TTemp[SP];
        create_tuple_i(&TTemp[SP++],-1);
        T_tuple_equal(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-2]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-2]=TTemp[SP];
        SP--;
        T_tuple_and(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-2]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-2]=TTemp[SP];
        SP--;
        if(get_i(TTemp[SP-1],0))
        {
          /*Text[|Text|] := ''*/
          copy_tuple(hv_Text,&TTemp[SP++]);
          T_tuple_length(TTemp[SP-1],&TTemp[SP]);
          destroy_tuple(TTemp[SP-1]);
          TTemp[SP-1]=TTemp[SP];
          create_tuple_s(&TTemp[SP++],"");
          replace_elements(&hv_Text,&TTemp[SP-2],&TTemp[SP-1]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(TTemp[--SP]);
          /*Text[|Text|] := 'No segmentation result found'*/
          copy_tuple(hv_Text,&TTemp[SP++]);
          T_tuple_length(TTemp[SP-1],&TTemp[SP]);
          destroy_tuple(TTemp[SP-1]);
          TTemp[SP-1]=TTemp[SP];
          create_tuple_s(&TTemp[SP++],"No segmentation result found");
          replace_elements(&hv_Text,&TTemp[SP-2],&TTemp[SP-1]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(TTemp[--SP]);
        }
        destroy_tuple(TTemp[--SP]);
        /*========== end if ==========*/
        /*__Tmp_Ctrl_Dict_Init_4 := constant('HNULL')*/
        create_tuple_s(&TTemp[SP++],"HNULL");
        T_tuple_constant(TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-1]=TTemp[SP];
        destroy_tuple(hv___Tmp_Ctrl_Dict_Init_4);
        hv___Tmp_Ctrl_Dict_Init_4=TTemp[--SP];

        /*Text[|Text|] := ''*/
        copy_tuple(hv_Text,&TTemp[SP++]);
        T_tuple_length(TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-1]=TTemp[SP];
        create_tuple_s(&TTemp[SP++],"");
        replace_elements(&hv_Text,&TTemp[SP-2],&TTemp[SP-1]);
        destroy_tuple(TTemp[--SP]);
        destroy_tuple(TTemp[--SP]);
        /*Text[|Text|] := 'anomaly_score' + AnomalyResultPostfix + ': ' + AnomalyScore$'.3f'*/
        copy_tuple(hv_Text,&TTemp[SP++]);
        T_tuple_length(TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-1]=TTemp[SP];
        create_tuple_s(&TTemp[SP++],"anomaly_score");
        T_tuple_add(TTemp[SP-1],hv_AnomalyResultPostfix,&TTemp[SP]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-1]=TTemp[SP];
        create_tuple_s(&TTemp[SP++],": ");
        T_tuple_add(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-2]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-2]=TTemp[SP];
        SP--;
        create_tuple_s(&TTemp[SP++],".3f");
        T_tuple_string(hv_AnomalyScore,TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-1]=TTemp[SP];
        T_tuple_add(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-2]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-2]=TTemp[SP];
        SP--;
        replace_elements(&hv_Text,&TTemp[SP-2],&TTemp[SP-1]);
        destroy_tuple(TTemp[--SP]);
        destroy_tuple(TTemp[--SP]);
        /*Text[|Text|] := ''*/
        copy_tuple(hv_Text,&TTemp[SP++]);
        T_tuple_length(TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-1]=TTemp[SP];
        create_tuple_s(&TTemp[SP++],"");
        replace_elements(&hv_Text,&TTemp[SP-2],&TTemp[SP-1]);
        destroy_tuple(TTemp[--SP]);
        destroy_tuple(TTemp[--SP]);
        /*========== if (AnomalyClassThresholdDisplay != -1 or AnomalyRegionThresholdDisplay != -1) ==========*/
        create_tuple_i(&TTemp[SP++],-1);
        T_tuple_not_equal(hv_AnomalyClassThresholdDisplay,TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-1]=TTemp[SP];
        create_tuple_i(&TTemp[SP++],-1);
        T_tuple_not_equal(hv_AnomalyRegionThresholdDisplay,TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-1]=TTemp[SP];
        T_tuple_or(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-2]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-2]=TTemp[SP];
        SP--;
        if(get_i(TTemp[SP-1],0))
        {
          /*Text[|Text|] := '---------------'*/
          copy_tuple(hv_Text,&TTemp[SP++]);
          T_tuple_length(TTemp[SP-1],&TTemp[SP]);
          destroy_tuple(TTemp[SP-1]);
          TTemp[SP-1]=TTemp[SP];
          create_tuple_s(&TTemp[SP++],"---------------");
          replace_elements(&hv_Text,&TTemp[SP-2],&TTemp[SP-1]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(TTemp[--SP]);
          /*Text[|Text|] := 'Thresholds '*/
          copy_tuple(hv_Text,&TTemp[SP++]);
          T_tuple_length(TTemp[SP-1],&TTemp[SP]);
          destroy_tuple(TTemp[SP-1]);
          TTemp[SP-1]=TTemp[SP];
          create_tuple_s(&TTemp[SP++],"Thresholds ");
          replace_elements(&hv_Text,&TTemp[SP-2],&TTemp[SP-1]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(TTemp[--SP]);
          /*Text[|Text|] := '---------------'*/
          copy_tuple(hv_Text,&TTemp[SP++]);
          T_tuple_length(TTemp[SP-1],&TTemp[SP]);
          destroy_tuple(TTemp[SP-1]);
          TTemp[SP-1]=TTemp[SP];
          create_tuple_s(&TTemp[SP++],"---------------");
          replace_elements(&hv_Text,&TTemp[SP-2],&TTemp[SP-1]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(TTemp[--SP]);
        }
        destroy_tuple(TTemp[--SP]);
        /*========== end if ==========*/
        /**/
        /*========== if (AnomalyClassThresholdDisplay != -1) ==========*/
        create_tuple_i(&TTemp[SP++],-1);
        T_tuple_not_equal(hv_AnomalyClassThresholdDisplay,TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-1]=TTemp[SP];
        if(get_i(TTemp[SP-1],0))
        {
          /*Text[|Text|] := 'Classification: ' + AnomalyClassThresholdDisplay$'.3f'*/
          copy_tuple(hv_Text,&TTemp[SP++]);
          T_tuple_length(TTemp[SP-1],&TTemp[SP]);
          destroy_tuple(TTemp[SP-1]);
          TTemp[SP-1]=TTemp[SP];
          create_tuple_s(&TTemp[SP++],"Classification: ");
          create_tuple_s(&TTemp[SP++],".3f");
          T_tuple_string(hv_AnomalyClassThresholdDisplay,TTemp[SP-1],&TTemp[SP]);
          destroy_tuple(TTemp[SP-1]);
          TTemp[SP-1]=TTemp[SP];
          T_tuple_add(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
          destroy_tuple(TTemp[SP-2]);
          destroy_tuple(TTemp[SP-1]);
          TTemp[SP-2]=TTemp[SP];
          SP--;
          replace_elements(&hv_Text,&TTemp[SP-2],&TTemp[SP-1]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(TTemp[--SP]);
          /*Text[|Text|] := ''*/
          copy_tuple(hv_Text,&TTemp[SP++]);
          T_tuple_length(TTemp[SP-1],&TTemp[SP]);
          destroy_tuple(TTemp[SP-1]);
          TTemp[SP-1]=TTemp[SP];
          create_tuple_s(&TTemp[SP++],"");
          replace_elements(&hv_Text,&TTemp[SP-2],&TTemp[SP-1]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(TTemp[--SP]);
        }
        destroy_tuple(TTemp[--SP]);
        /*========== end if ==========*/
        /*========== if (AnomalyRegionThresholdDisplay != -1) ==========*/
        create_tuple_i(&TTemp[SP++],-1);
        T_tuple_not_equal(hv_AnomalyRegionThresholdDisplay,TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-1]=TTemp[SP];
        if(get_i(TTemp[SP-1],0))
        {
          /*Text[|Text|] := 'Segmentation: ' + AnomalyRegionThresholdDisplay$'.3f'*/
          copy_tuple(hv_Text,&TTemp[SP++]);
          T_tuple_length(TTemp[SP-1],&TTemp[SP]);
          destroy_tuple(TTemp[SP-1]);
          TTemp[SP-1]=TTemp[SP];
          create_tuple_s(&TTemp[SP++],"Segmentation: ");
          create_tuple_s(&TTemp[SP++],".3f");
          T_tuple_string(hv_AnomalyRegionThresholdDisplay,TTemp[SP-1],&TTemp[SP]);
          destroy_tuple(TTemp[SP-1]);
          TTemp[SP-1]=TTemp[SP];
          T_tuple_add(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
          destroy_tuple(TTemp[SP-2]);
          destroy_tuple(TTemp[SP-1]);
          TTemp[SP-2]=TTemp[SP];
          SP--;
          replace_elements(&hv_Text,&TTemp[SP-2],&TTemp[SP-1]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(TTemp[--SP]);
          /*Text[|Text|] := ''*/
          copy_tuple(hv_Text,&TTemp[SP++]);
          T_tuple_length(TTemp[SP-1],&TTemp[SP]);
          destroy_tuple(TTemp[SP-1]);
          TTemp[SP-1]=TTemp[SP];
          create_tuple_s(&TTemp[SP++],"");
          replace_elements(&hv_Text,&TTemp[SP-2],&TTemp[SP-1]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(TTemp[--SP]);
        }
        destroy_tuple(TTemp[--SP]);
        /*========== end if ==========*/
        /*Get or open next child window*/
        /*get_child_window (HeightImage, __get_dict_tuple( Params, ['font']), __get_dict_tuple( Params, ['font_size']), Text, PrevWindowCoordinates, WindowHandleDict, WindowHandleName, WindowImageRatio, PrevWindowCoordinates)*/
        create_tuple_s(&TTemp[SP++],"font");
        T_get_dict_tuple(hv_Params,TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-1]=TTemp[SP];
        create_tuple_s(&TTemp[SP++],"font_size");
        T_get_dict_tuple(hv_Params,TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-1]=TTemp[SP];
        copy_tuple(hv_PrevWindowCoordinates,&TTemp[SP++]);
        destroy_tuple(hv_WindowImageRatio);
        destroy_tuple(hv_PrevWindowCoordinates);
        /***/get_child_window(hv_HeightImage, TTemp[SP-3], TTemp[SP-2], hv_Text, 
            TTemp[SP-1], hv_WindowHandleDict, hv_WindowHandleName, &hv_WindowImageRatio, 
            &hv_PrevWindowCoordinates);
        destroy_tuple(TTemp[--SP]);
        destroy_tuple(TTemp[--SP]);
        destroy_tuple(TTemp[--SP]);

        /*tuple_gen_const (|Text|, 'white', LineColors)*/
        T_tuple_length(hv_Text,&TTemp[SP++]);
        create_tuple_s(&TTemp[SP++],"white");
        destroy_tuple(hv_LineColors);
        /***/T_tuple_gen_const(TTemp[SP-2], TTemp[SP-1], &hv_LineColors);
        destroy_tuple(TTemp[--SP]);
        destroy_tuple(TTemp[--SP]);

        /*ResultColorOffset := 10*/
        reuse_tuple_i(&hv_ResultColorOffset,10);

        /*========== if (AnomalyRegionGroundTruthExists == 'false' and AnomalyLabelIDGroundTruth == 1 and __get_dict_tuple( Params, ['display_ground_truth_anomaly_regions'])) ==========*/
        create_tuple_s(&TTemp[SP++],"false");
        T_tuple_equal(hv_AnomalyRegionGroundTruthExists,TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-1]=TTemp[SP];
        create_tuple_i(&TTemp[SP++],1);
        T_tuple_equal(hv_AnomalyLabelIDGroundTruth,TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-1]=TTemp[SP];
        T_tuple_and(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-2]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-2]=TTemp[SP];
        SP--;
        create_tuple_s(&TTemp[SP++],"display_ground_truth_anomaly_regions");
        T_get_dict_tuple(hv_Params,TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-1]=TTemp[SP];
        T_tuple_and(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-2]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-2]=TTemp[SP];
        SP--;
        if(get_i(TTemp[SP-1],0))
        {
          /*ResultColorOffset := ResultColorOffset + 2*/
          create_tuple_i(&TTemp[SP++],2);
          T_tuple_add(hv_ResultColorOffset,TTemp[SP-1],&TTemp[SP]);
          destroy_tuple(hv_ResultColorOffset);
          hv_ResultColorOffset=TTemp[SP];
          destroy_tuple(TTemp[--SP]);

        }
        destroy_tuple(TTemp[--SP]);
        /*========== end if ==========*/
        /*LineColors[ResultColorOffset] := PredictionColor*/
        replace_elements(&hv_LineColors,&hv_ResultColorOffset,&hv_PredictionColor);
        if (hdev_window_stack_is_open())
        {
          Htuple active_win;
          create_tuple(&active_win,0);
          hdev_window_stack_get_active(&active_win);
          /*dev_disp_text (Text, 'window', 'top', 'left', LineColors, 'box', 'false')*/
          create_tuple_s(&TTemp[SP++],"window");
          create_tuple_s(&TTemp[SP++],"top");
          create_tuple_s(&TTemp[SP++],"left");
          create_tuple_s(&TTemp[SP++],"box");
          create_tuple_s(&TTemp[SP++],"false");
          /***/T_disp_text(active_win,hv_Text, TTemp[SP-5], TTemp[SP-4], TTemp[SP-3], 
              hv_LineColors, TTemp[SP-2], TTemp[SP-1]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(active_win);
        }
      }
      destroy_tuple(TTemp[--SP]);
      /*========== end if ==========*/
      /**/
    }
    else
    {
    destroy_tuple(TTemp[--SP]);
    /*========== elseif (KeysForDisplay[KeyIndex] == 'anomaly_ground_truth') ==========*/

    T_tuple_select(hv_KeysForDisplay_COPY_INP_TMP,hv_KeyIndex,&TTemp[SP++]);
    create_tuple_s(&TTemp[SP++],"anomaly_ground_truth");
    T_tuple_equal(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-2]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-2]=TTemp[SP];
    SP--;
    if(get_i(TTemp[SP-1],0))
    {
      /*Image.*/
      /*get_dl_sample_image (Image, SampleKeys, DLSample, 'image')*/
      create_tuple_s(&TTemp[SP++],"image");
      clear_obj(ho_Image);
      /***/get_dl_sample_image(&ho_Image, hv_SampleKeys, hv_DLSample, TTemp[SP-1]);
      destroy_tuple(TTemp[--SP]);

      /*get_anomaly_ground_truth_label (SampleKeys, DLSample, AnomalyLabelGroundTruth, AnomalyLabelIDGroundTruth)*/
      destroy_tuple(hv_AnomalyLabelGroundTruth);
      destroy_tuple(hv_AnomalyLabelIDGroundTruth);
      /***/get_anomaly_ground_truth_label(hv_SampleKeys, hv_DLSample, &hv_AnomalyLabelGroundTruth, 
          &hv_AnomalyLabelIDGroundTruth);

      /**/
      /*Get or open next window.*/
      /*get_image_size (Image, WidthImage, HeightImage)*/
      destroy_tuple(hv_WidthImage);
      destroy_tuple(hv_HeightImage);
      /***/T_get_image_size(ho_Image, &hv_WidthImage, &hv_HeightImage);

      /*get_next_window (__get_dict_tuple( Params, ['font']), __get_dict_tuple( Params, ['font_size']), __get_dict_tuple( Params, ['display_bottom_desc']), WidthImage, HeightImage, 0, __get_dict_tuple( Params, ['scale_windows']), __get_dict_tuple( Params, ['threshold_width']), PrevWindowCoordinates, WindowHandleDict, KeysForDisplay[KeyIndex], CurrentWindowHandle, WindowImageRatio, PrevWindowCoordinates)*/
      create_tuple_s(&TTemp[SP++],"font");
      T_get_dict_tuple(hv_Params,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      create_tuple_s(&TTemp[SP++],"font_size");
      T_get_dict_tuple(hv_Params,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      create_tuple_s(&TTemp[SP++],"display_bottom_desc");
      T_get_dict_tuple(hv_Params,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      create_tuple_i(&TTemp[SP++],0);
      create_tuple_s(&TTemp[SP++],"scale_windows");
      T_get_dict_tuple(hv_Params,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      create_tuple_s(&TTemp[SP++],"threshold_width");
      T_get_dict_tuple(hv_Params,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      copy_tuple(hv_PrevWindowCoordinates,&TTemp[SP++]);
      T_tuple_select(hv_KeysForDisplay_COPY_INP_TMP,hv_KeyIndex,&TTemp[SP++]);
      destroy_tuple(hv_CurrentWindowHandle);
      destroy_tuple(hv_WindowImageRatio);
      destroy_tuple(hv_PrevWindowCoordinates);
      /***/get_next_window(TTemp[SP-8], TTemp[SP-7], TTemp[SP-6], hv_WidthImage, 
          hv_HeightImage, TTemp[SP-5], TTemp[SP-4], TTemp[SP-3], TTemp[SP-2], hv_WindowHandleDict, 
          TTemp[SP-1], &hv_CurrentWindowHandle, &hv_WindowImageRatio, &hv_PrevWindowCoordinates);
      destroy_tuple(TTemp[--SP]);
      destroy_tuple(TTemp[--SP]);
      destroy_tuple(TTemp[--SP]);
      destroy_tuple(TTemp[--SP]);
      destroy_tuple(TTemp[--SP]);
      destroy_tuple(TTemp[--SP]);
      destroy_tuple(TTemp[--SP]);
      destroy_tuple(TTemp[--SP]);

      /**/
      /*Visualization.*/
      if (hdev_window_stack_is_open())
      {
        Htuple active_win;
        create_tuple(&active_win,0);
        hdev_window_stack_get_active(&active_win);
        /*dev_display (Image)*/
        /***/T_disp_obj(ho_Image, active_win);
        destroy_tuple(active_win);
      }
      /**/
      /*AnomalyRegionExists := 'false'*/
      reuse_tuple_s(&hv_AnomalyRegionExists,"false");
      /*========== if (__get_dict_tuple( Params, ['display_ground_truth_anomaly_regions'])) ==========*/
      create_tuple_s(&TTemp[SP++],"display_ground_truth_anomaly_regions");
      T_get_dict_tuple(hv_Params,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      if(get_i(TTemp[SP-1],0))
      {
        /*Show the ground truth region.*/
        /*dev_display_ground_truth_anomaly_regions (SampleKeys, DLSample, CurrentWindowHandle, __get_dict_tuple( Params, ['line_width']), __get_dict_tuple( Params, ['anomaly_region_label_color']), __get_dict_tuple( Params, ['anomaly_color_transparency']), AnomalyRegionExists)*/
        create_tuple_s(&TTemp[SP++],"line_width");
        T_get_dict_tuple(hv_Params,TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-1]=TTemp[SP];
        create_tuple_s(&TTemp[SP++],"anomaly_region_label_color");
        T_get_dict_tuple(hv_Params,TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-1]=TTemp[SP];
        create_tuple_s(&TTemp[SP++],"anomaly_color_transparency");
        T_get_dict_tuple(hv_Params,TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-1]=TTemp[SP];
        destroy_tuple(hv_AnomalyRegionExists);
        /***/dev_display_ground_truth_anomaly_regions(hv_SampleKeys, hv_DLSample, 
            hv_CurrentWindowHandle, TTemp[SP-3], TTemp[SP-2], TTemp[SP-1], &hv_AnomalyRegionExists);
        destroy_tuple(TTemp[--SP]);
        destroy_tuple(TTemp[--SP]);
        destroy_tuple(TTemp[--SP]);

      }
      destroy_tuple(TTemp[--SP]);
      /*========== end if ==========*/
      /**/
      /*Text := 'Ground truth anomalies ' + ImageIDStringBraces*/
      create_tuple_s(&TTemp[SP++],"Ground truth anomalies ");
      T_tuple_add(TTemp[SP-1],hv_ImageIDStringBraces,&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      destroy_tuple(hv_Text);
      hv_Text=TTemp[--SP];

      /*========== if (__get_dict_tuple( Params, ['display_bottom_desc'])) ==========*/
      create_tuple_s(&TTemp[SP++],"display_bottom_desc");
      T_get_dict_tuple(hv_Params,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      if(get_i(TTemp[SP-1],0))
      {
        if (hdev_window_stack_is_open())
        {
          Htuple active_win;
          create_tuple(&active_win,0);
          hdev_window_stack_get_active(&active_win);
          /*dev_disp_text (Text, 'window', 'bottom', 'left', 'white', 'box', 'false')*/
          create_tuple_s(&TTemp[SP++],"window");
          create_tuple_s(&TTemp[SP++],"bottom");
          create_tuple_s(&TTemp[SP++],"left");
          create_tuple_s(&TTemp[SP++],"white");
          create_tuple_s(&TTemp[SP++],"box");
          create_tuple_s(&TTemp[SP++],"false");
          /***/T_disp_text(active_win,hv_Text, TTemp[SP-6], TTemp[SP-5], TTemp[SP-4], 
              TTemp[SP-3], TTemp[SP-2], TTemp[SP-1]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(active_win);
        }
      }
      destroy_tuple(TTemp[--SP]);
      /*========== end if ==========*/
      /**/
      /*Display the legend.*/
      /*========== if (__get_dict_tuple( Params, ['display_legend'])) ==========*/
      create_tuple_s(&TTemp[SP++],"display_legend");
      T_get_dict_tuple(hv_Params,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      if(get_i(TTemp[SP-1],0))
      {
        /*Text[|Text|] := ''*/
        copy_tuple(hv_Text,&TTemp[SP++]);
        T_tuple_length(TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-1]=TTemp[SP];
        create_tuple_s(&TTemp[SP++],"");
        replace_elements(&hv_Text,&TTemp[SP-2],&TTemp[SP-1]);
        destroy_tuple(TTemp[--SP]);
        destroy_tuple(TTemp[--SP]);
        /*Text[|Text|] := AnomalyLabelIDGroundTruth + ' : \'' + AnomalyLabelGroundTruth + '\''*/
        copy_tuple(hv_Text,&TTemp[SP++]);
        T_tuple_length(TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-1]=TTemp[SP];
        create_tuple_s(&TTemp[SP++]," : '");
        T_tuple_add(hv_AnomalyLabelIDGroundTruth,TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-1]=TTemp[SP];
        T_tuple_add(TTemp[SP-1],hv_AnomalyLabelGroundTruth,&TTemp[SP]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-1]=TTemp[SP];
        create_tuple_s(&TTemp[SP++],"'");
        T_tuple_add(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-2]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-2]=TTemp[SP];
        SP--;
        replace_elements(&hv_Text,&TTemp[SP-2],&TTemp[SP-1]);
        destroy_tuple(TTemp[--SP]);
        destroy_tuple(TTemp[--SP]);
        /*========== if (AnomalyRegionExists == 'false' and AnomalyLabelIDGroundTruth == 1 and __get_dict_tuple( Params, ['display_ground_truth_anomaly_regions'])) ==========*/
        create_tuple_s(&TTemp[SP++],"false");
        T_tuple_equal(hv_AnomalyRegionExists,TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-1]=TTemp[SP];
        create_tuple_i(&TTemp[SP++],1);
        T_tuple_equal(hv_AnomalyLabelIDGroundTruth,TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-1]=TTemp[SP];
        T_tuple_and(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-2]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-2]=TTemp[SP];
        SP--;
        create_tuple_s(&TTemp[SP++],"display_ground_truth_anomaly_regions");
        T_get_dict_tuple(hv_Params,TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-1]=TTemp[SP];
        T_tuple_and(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-2]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-2]=TTemp[SP];
        SP--;
        if(get_i(TTemp[SP-1],0))
        {
          /*Text[|Text|] := ''*/
          copy_tuple(hv_Text,&TTemp[SP++]);
          T_tuple_length(TTemp[SP-1],&TTemp[SP]);
          destroy_tuple(TTemp[SP-1]);
          TTemp[SP-1]=TTemp[SP];
          create_tuple_s(&TTemp[SP++],"");
          replace_elements(&hv_Text,&TTemp[SP-2],&TTemp[SP-1]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(TTemp[--SP]);
          /*Text[|Text|] := 'No \'anomaly_ground_truth\' exists!'*/
          copy_tuple(hv_Text,&TTemp[SP++]);
          T_tuple_length(TTemp[SP-1],&TTemp[SP]);
          destroy_tuple(TTemp[SP-1]);
          TTemp[SP-1]=TTemp[SP];
          create_tuple_s(&TTemp[SP++],"No 'anomaly_ground_truth' exists!");
          replace_elements(&hv_Text,&TTemp[SP-2],&TTemp[SP-1]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(TTemp[--SP]);
        }
        destroy_tuple(TTemp[--SP]);
        /*========== end if ==========*/
        /**/
        /*Get or open next child window*/
        /*get_child_window (HeightImage, __get_dict_tuple( Params, ['font']), __get_dict_tuple( Params, ['font_size']), Text, PrevWindowCoordinates, WindowHandleDict, KeysForDisplay[KeyIndex], WindowImageRatio, PrevWindowCoordinates)*/
        create_tuple_s(&TTemp[SP++],"font");
        T_get_dict_tuple(hv_Params,TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-1]=TTemp[SP];
        create_tuple_s(&TTemp[SP++],"font_size");
        T_get_dict_tuple(hv_Params,TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-1]=TTemp[SP];
        copy_tuple(hv_PrevWindowCoordinates,&TTemp[SP++]);
        T_tuple_select(hv_KeysForDisplay_COPY_INP_TMP,hv_KeyIndex,&TTemp[SP++]);
        destroy_tuple(hv_WindowImageRatio);
        destroy_tuple(hv_PrevWindowCoordinates);
        /***/get_child_window(hv_HeightImage, TTemp[SP-4], TTemp[SP-3], hv_Text, 
            TTemp[SP-2], hv_WindowHandleDict, TTemp[SP-1], &hv_WindowImageRatio, 
            &hv_PrevWindowCoordinates);
        destroy_tuple(TTemp[--SP]);
        destroy_tuple(TTemp[--SP]);
        destroy_tuple(TTemp[--SP]);
        destroy_tuple(TTemp[--SP]);

        if (hdev_window_stack_is_open())
        {
          Htuple active_win;
          create_tuple(&active_win,0);
          hdev_window_stack_get_active(&active_win);
          /*dev_disp_text (Text, 'window', 'top', 'left', 'white', 'box', 'false')*/
          create_tuple_s(&TTemp[SP++],"window");
          create_tuple_s(&TTemp[SP++],"top");
          create_tuple_s(&TTemp[SP++],"left");
          create_tuple_s(&TTemp[SP++],"white");
          create_tuple_s(&TTemp[SP++],"box");
          create_tuple_s(&TTemp[SP++],"false");
          /***/T_disp_text(active_win,hv_Text, TTemp[SP-6], TTemp[SP-5], TTemp[SP-4], 
              TTemp[SP-3], TTemp[SP-2], TTemp[SP-1]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(active_win);
        }
      }
      destroy_tuple(TTemp[--SP]);
      /*========== end if ==========*/
    }
    else
    {
    destroy_tuple(TTemp[--SP]);
    /*========== elseif (KeysForDisplay[KeyIndex] == 'anomaly_image' or KeysForDisplay[KeyIndex] == 'anomaly_image_local' or KeysForDisplay[KeyIndex] == 'anomaly_image_global') ==========*/

    T_tuple_select(hv_KeysForDisplay_COPY_INP_TMP,hv_KeyIndex,&TTemp[SP++]);
    create_tuple_s(&TTemp[SP++],"anomaly_image");
    T_tuple_equal(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-2]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-2]=TTemp[SP];
    SP--;
    T_tuple_select(hv_KeysForDisplay_COPY_INP_TMP,hv_KeyIndex,&TTemp[SP++]);
    create_tuple_s(&TTemp[SP++],"anomaly_image_local");
    T_tuple_equal(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-2]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-2]=TTemp[SP];
    SP--;
    T_tuple_or(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-2]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-2]=TTemp[SP];
    SP--;
    T_tuple_select(hv_KeysForDisplay_COPY_INP_TMP,hv_KeyIndex,&TTemp[SP++]);
    create_tuple_s(&TTemp[SP++],"anomaly_image_global");
    T_tuple_equal(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-2]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-2]=TTemp[SP];
    SP--;
    T_tuple_or(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-2]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-2]=TTemp[SP];
    SP--;
    if(get_i(TTemp[SP-1],0))
    {
      /**/
      /*Image.*/
      /*get_dl_sample_image (Image, SampleKeys, DLSample, 'image')*/
      create_tuple_s(&TTemp[SP++],"image");
      clear_obj(ho_Image);
      /***/get_dl_sample_image(&ho_Image, hv_SampleKeys, hv_DLSample, TTemp[SP-1]);
      destroy_tuple(TTemp[--SP]);

      /**/
      /*Get the anomaly results either by applying the specified thresholds or out of DLResult.*/
      /*AnomalyImageKey := KeysForDisplay[KeyIndex]*/
      T_tuple_select(hv_KeysForDisplay_COPY_INP_TMP,hv_KeyIndex,&TTemp[SP++]);
      destroy_tuple(hv_AnomalyImageKey);
      hv_AnomalyImageKey=TTemp[--SP];

      /*tuple_regexp_match (AnomalyImageKey, 'anomaly_image(.*)', AnomalyResultPostfix)*/
      create_tuple_s(&TTemp[SP++],"anomaly_image(.*)");
      destroy_tuple(hv_AnomalyResultPostfix);
      /***/T_tuple_regexp_match(hv_AnomalyImageKey, TTemp[SP-1], &hv_AnomalyResultPostfix);
      destroy_tuple(TTemp[--SP]);

      /*get_anomaly_result (AnomalyImage, AnomalyRegion, DLResult, __get_dict_tuple( Params, ['anomaly_classification_threshold']), __get_dict_tuple( Params, ['anomaly_region_threshold']), AnomalyResultPostfix, AnomalyScore, AnomalyClassID, AnomalyClassThresholdDisplay, AnomalyRegionThresholdDisplay)*/
      create_tuple_s(&TTemp[SP++],"anomaly_classification_threshold");
      T_get_dict_tuple(hv_Params,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      create_tuple_s(&TTemp[SP++],"anomaly_region_threshold");
      T_get_dict_tuple(hv_Params,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      clear_obj(ho_AnomalyImage);
      clear_obj(ho_AnomalyRegion);
      destroy_tuple(hv_AnomalyScore);
      destroy_tuple(hv_AnomalyClassID);
      destroy_tuple(hv_AnomalyClassThresholdDisplay);
      destroy_tuple(hv_AnomalyRegionThresholdDisplay);
      /***/get_anomaly_result(&ho_AnomalyImage, &ho_AnomalyRegion, hv_DLResult_COPY_INP_TMP, 
          TTemp[SP-2], TTemp[SP-1], hv_AnomalyResultPostfix, &hv_AnomalyScore, &hv_AnomalyClassID, 
          &hv_AnomalyClassThresholdDisplay, &hv_AnomalyRegionThresholdDisplay);
      destroy_tuple(TTemp[--SP]);
      destroy_tuple(TTemp[--SP]);

      /**/
      /*Read in input image.*/
      /*get_dict_object (Image, DLSample, 'image')*/
      create_tuple_s(&TTemp[SP++],"image");
      clear_obj(ho_Image);
      /***/T_get_dict_object(&ho_Image, hv_DLSample, TTemp[SP-1]);
      destroy_tuple(TTemp[--SP]);

      /*Add the anomaly image to the input image.*/
      /*add_colormap_to_image (AnomalyImage, Image, AnomalyImage, __get_dict_tuple( Params, ['heatmap_color_scheme']))*/
      create_tuple_s(&TTemp[SP++],"heatmap_color_scheme");
      T_get_dict_tuple(hv_Params,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      /***/add_colormap_to_image(ho_AnomalyImage, ho_Image, &(OTemp[SPO]), TTemp[SP-1]);
      SPO++;
      clear_obj(ho_AnomalyImage);
      ho_AnomalyImage = OTemp[--SPO];
      destroy_tuple(TTemp[--SP]);

      /**/
      /*Get or open next window.*/
      /*get_image_size (Image, WidthImage, HeightImage)*/
      destroy_tuple(hv_WidthImage);
      destroy_tuple(hv_HeightImage);
      /***/T_get_image_size(ho_Image, &hv_WidthImage, &hv_HeightImage);

      /*get_next_window (__get_dict_tuple( Params, ['font']), __get_dict_tuple( Params, ['font_size']), __get_dict_tuple( Params, ['display_bottom_desc']), WidthImage, HeightImage, 0, __get_dict_tuple( Params, ['scale_windows']), __get_dict_tuple( Params, ['threshold_width']), PrevWindowCoordinates, WindowHandleDict, KeysForDisplay[KeyIndex], CurrentWindowHandle, WindowImageRatio, PrevWindowCoordinates)*/
      create_tuple_s(&TTemp[SP++],"font");
      T_get_dict_tuple(hv_Params,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      create_tuple_s(&TTemp[SP++],"font_size");
      T_get_dict_tuple(hv_Params,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      create_tuple_s(&TTemp[SP++],"display_bottom_desc");
      T_get_dict_tuple(hv_Params,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      create_tuple_i(&TTemp[SP++],0);
      create_tuple_s(&TTemp[SP++],"scale_windows");
      T_get_dict_tuple(hv_Params,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      create_tuple_s(&TTemp[SP++],"threshold_width");
      T_get_dict_tuple(hv_Params,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      copy_tuple(hv_PrevWindowCoordinates,&TTemp[SP++]);
      T_tuple_select(hv_KeysForDisplay_COPY_INP_TMP,hv_KeyIndex,&TTemp[SP++]);
      destroy_tuple(hv_CurrentWindowHandle);
      destroy_tuple(hv_WindowImageRatio);
      destroy_tuple(hv_PrevWindowCoordinates);
      /***/get_next_window(TTemp[SP-8], TTemp[SP-7], TTemp[SP-6], hv_WidthImage, 
          hv_HeightImage, TTemp[SP-5], TTemp[SP-4], TTemp[SP-3], TTemp[SP-2], hv_WindowHandleDict, 
          TTemp[SP-1], &hv_CurrentWindowHandle, &hv_WindowImageRatio, &hv_PrevWindowCoordinates);
      destroy_tuple(TTemp[--SP]);
      destroy_tuple(TTemp[--SP]);
      destroy_tuple(TTemp[--SP]);
      destroy_tuple(TTemp[--SP]);
      destroy_tuple(TTemp[--SP]);
      destroy_tuple(TTemp[--SP]);
      destroy_tuple(TTemp[--SP]);
      destroy_tuple(TTemp[--SP]);

      /**/
      if (hdev_window_stack_is_open())
      {
        Htuple active_win;
        create_tuple(&active_win,0);
        hdev_window_stack_get_active(&active_win);
        /*dev_display (AnomalyImage)*/
        /***/T_disp_obj(ho_AnomalyImage, active_win);
        destroy_tuple(active_win);
      }
      /*Text := AnomalyImageKey*/
      destroy_tuple(hv_Text);
      copy_tuple(hv_AnomalyImageKey,&hv_Text);

      /*========== if (__get_dict_tuple( Params, ['display_bottom_desc'])) ==========*/
      create_tuple_s(&TTemp[SP++],"display_bottom_desc");
      T_get_dict_tuple(hv_Params,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      if(get_i(TTemp[SP-1],0))
      {
        if (hdev_window_stack_is_open())
        {
          Htuple active_win;
          create_tuple(&active_win,0);
          hdev_window_stack_get_active(&active_win);
          /*dev_disp_text (Text, 'window', 'bottom', 'left', 'white', 'box', 'false')*/
          create_tuple_s(&TTemp[SP++],"window");
          create_tuple_s(&TTemp[SP++],"bottom");
          create_tuple_s(&TTemp[SP++],"left");
          create_tuple_s(&TTemp[SP++],"white");
          create_tuple_s(&TTemp[SP++],"box");
          create_tuple_s(&TTemp[SP++],"false");
          /***/T_disp_text(active_win,hv_Text, TTemp[SP-6], TTemp[SP-5], TTemp[SP-4], 
              TTemp[SP-3], TTemp[SP-2], TTemp[SP-1]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(active_win);
        }
      }
      destroy_tuple(TTemp[--SP]);
      /*========== end if ==========*/
      /**/
      /*tuple_regexp_replace (AnomalyImageKey, 'image', 'score', AnomalyScoreKey)*/
      create_tuple_s(&TTemp[SP++],"image");
      create_tuple_s(&TTemp[SP++],"score");
      destroy_tuple(hv_AnomalyScoreKey);
      /***/T_tuple_regexp_replace(hv_AnomalyImageKey, TTemp[SP-2], TTemp[SP-1], &hv_AnomalyScoreKey);
      destroy_tuple(TTemp[--SP]);
      destroy_tuple(TTemp[--SP]);

      /**/
      /*Display the legend.*/
      /*========== if (__get_dict_tuple( Params, ['display_legend'])) ==========*/
      create_tuple_s(&TTemp[SP++],"display_legend");
      T_get_dict_tuple(hv_Params,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      if(get_i(TTemp[SP-1],0))
      {
        /*Text[|Text|] := ''*/
        copy_tuple(hv_Text,&TTemp[SP++]);
        T_tuple_length(TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-1]=TTemp[SP];
        create_tuple_s(&TTemp[SP++],"");
        replace_elements(&hv_Text,&TTemp[SP-2],&TTemp[SP-1]);
        destroy_tuple(TTemp[--SP]);
        destroy_tuple(TTemp[--SP]);
        /*========== if (AnomalyClassID == 1) ==========*/
        create_tuple_i(&TTemp[SP++],1);
        T_tuple_equal(hv_AnomalyClassID,TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-1]=TTemp[SP];
        if(get_i(TTemp[SP-1],0))
        {
          /*Text[|Text|] := AnomalyClassID + ' : \'nok\''*/
          copy_tuple(hv_Text,&TTemp[SP++]);
          T_tuple_length(TTemp[SP-1],&TTemp[SP]);
          destroy_tuple(TTemp[SP-1]);
          TTemp[SP-1]=TTemp[SP];
          create_tuple_s(&TTemp[SP++]," : 'nok'");
          T_tuple_add(hv_AnomalyClassID,TTemp[SP-1],&TTemp[SP]);
          destroy_tuple(TTemp[SP-1]);
          TTemp[SP-1]=TTemp[SP];
          replace_elements(&hv_Text,&TTemp[SP-2],&TTemp[SP-1]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(TTemp[--SP]);
        }
        else
        {
        destroy_tuple(TTemp[--SP]);
        /*========== elseif (AnomalyClassID == 0) ==========*/

        create_tuple_i(&TTemp[SP++],0);
        T_tuple_equal(hv_AnomalyClassID,TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-1]=TTemp[SP];
        if(get_i(TTemp[SP-1],0))
        {
          /*Text[|Text|] := AnomalyClassID + ' : \'ok\''*/
          copy_tuple(hv_Text,&TTemp[SP++]);
          T_tuple_length(TTemp[SP-1],&TTemp[SP]);
          destroy_tuple(TTemp[SP-1]);
          TTemp[SP-1]=TTemp[SP];
          create_tuple_s(&TTemp[SP++]," : 'ok'");
          T_tuple_add(hv_AnomalyClassID,TTemp[SP-1],&TTemp[SP]);
          destroy_tuple(TTemp[SP-1]);
          TTemp[SP-1]=TTemp[SP];
          replace_elements(&hv_Text,&TTemp[SP-2],&TTemp[SP-1]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(TTemp[--SP]);
        }
        else
        {
          /*Text[|Text|] := 'No classification result found'*/
          copy_tuple(hv_Text,&TTemp[SP++]);
          T_tuple_length(TTemp[SP-1],&TTemp[SP]);
          destroy_tuple(TTemp[SP-1]);
          TTemp[SP-1]=TTemp[SP];
          create_tuple_s(&TTemp[SP++],"No classification result found");
          replace_elements(&hv_Text,&TTemp[SP-2],&TTemp[SP-1]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(TTemp[--SP]);
        }
        }
        destroy_tuple(TTemp[--SP]);
        /*========== end if ==========*/
        /*Text[|Text|] := ''*/
        copy_tuple(hv_Text,&TTemp[SP++]);
        T_tuple_length(TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-1]=TTemp[SP];
        create_tuple_s(&TTemp[SP++],"");
        replace_elements(&hv_Text,&TTemp[SP-2],&TTemp[SP-1]);
        destroy_tuple(TTemp[--SP]);
        destroy_tuple(TTemp[--SP]);
        /*Text[|Text|] := AnomalyScoreKey + ': ' + AnomalyScore$'.3f'*/
        copy_tuple(hv_Text,&TTemp[SP++]);
        T_tuple_length(TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-1]=TTemp[SP];
        create_tuple_s(&TTemp[SP++],": ");
        T_tuple_add(hv_AnomalyScoreKey,TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-1]=TTemp[SP];
        create_tuple_s(&TTemp[SP++],".3f");
        T_tuple_string(hv_AnomalyScore,TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-1]=TTemp[SP];
        T_tuple_add(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-2]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-2]=TTemp[SP];
        SP--;
        replace_elements(&hv_Text,&TTemp[SP-2],&TTemp[SP-1]);
        destroy_tuple(TTemp[--SP]);
        destroy_tuple(TTemp[--SP]);
        /*Get or open next child window*/
        /*get_child_window (HeightImage, __get_dict_tuple( Params, ['font']), __get_dict_tuple( Params, ['font_size']), Text, PrevWindowCoordinates, WindowHandleDict, KeysForDisplay[KeyIndex], WindowImageRatio, PrevWindowCoordinates)*/
        create_tuple_s(&TTemp[SP++],"font");
        T_get_dict_tuple(hv_Params,TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-1]=TTemp[SP];
        create_tuple_s(&TTemp[SP++],"font_size");
        T_get_dict_tuple(hv_Params,TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-1]=TTemp[SP];
        copy_tuple(hv_PrevWindowCoordinates,&TTemp[SP++]);
        T_tuple_select(hv_KeysForDisplay_COPY_INP_TMP,hv_KeyIndex,&TTemp[SP++]);
        destroy_tuple(hv_WindowImageRatio);
        destroy_tuple(hv_PrevWindowCoordinates);
        /***/get_child_window(hv_HeightImage, TTemp[SP-4], TTemp[SP-3], hv_Text, 
            TTemp[SP-2], hv_WindowHandleDict, TTemp[SP-1], &hv_WindowImageRatio, 
            &hv_PrevWindowCoordinates);
        destroy_tuple(TTemp[--SP]);
        destroy_tuple(TTemp[--SP]);
        destroy_tuple(TTemp[--SP]);
        destroy_tuple(TTemp[--SP]);

        if (hdev_window_stack_is_open())
        {
          Htuple active_win;
          create_tuple(&active_win,0);
          hdev_window_stack_get_active(&active_win);
          /*dev_disp_text (Text, 'window', 'top', 'left', 'white', 'box', 'false')*/
          create_tuple_s(&TTemp[SP++],"window");
          create_tuple_s(&TTemp[SP++],"top");
          create_tuple_s(&TTemp[SP++],"left");
          create_tuple_s(&TTemp[SP++],"white");
          create_tuple_s(&TTemp[SP++],"box");
          create_tuple_s(&TTemp[SP++],"false");
          /***/T_disp_text(active_win,hv_Text, TTemp[SP-6], TTemp[SP-5], TTemp[SP-4], 
              TTemp[SP-3], TTemp[SP-2], TTemp[SP-1]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(active_win);
        }
      }
      destroy_tuple(TTemp[--SP]);
      /*========== end if ==========*/
    }
    else
    {
    destroy_tuple(TTemp[--SP]);
    /*========== elseif (KeysForDisplay[KeyIndex] == 'anomaly_result' or KeysForDisplay[KeyIndex] == 'anomaly_result_local' or KeysForDisplay[KeyIndex] == 'anomaly_result_global') ==========*/

    T_tuple_select(hv_KeysForDisplay_COPY_INP_TMP,hv_KeyIndex,&TTemp[SP++]);
    create_tuple_s(&TTemp[SP++],"anomaly_result");
    T_tuple_equal(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-2]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-2]=TTemp[SP];
    SP--;
    T_tuple_select(hv_KeysForDisplay_COPY_INP_TMP,hv_KeyIndex,&TTemp[SP++]);
    create_tuple_s(&TTemp[SP++],"anomaly_result_local");
    T_tuple_equal(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-2]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-2]=TTemp[SP];
    SP--;
    T_tuple_or(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-2]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-2]=TTemp[SP];
    SP--;
    T_tuple_select(hv_KeysForDisplay_COPY_INP_TMP,hv_KeyIndex,&TTemp[SP++]);
    create_tuple_s(&TTemp[SP++],"anomaly_result_global");
    T_tuple_equal(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-2]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-2]=TTemp[SP];
    SP--;
    T_tuple_or(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-2]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-2]=TTemp[SP];
    SP--;
    if(get_i(TTemp[SP-1],0))
    {
      /**/
      /*Get image.*/
      /*get_dl_sample_image (Image, SampleKeys, DLSample, 'image')*/
      create_tuple_s(&TTemp[SP++],"image");
      clear_obj(ho_Image);
      /***/get_dl_sample_image(&ho_Image, hv_SampleKeys, hv_DLSample, TTemp[SP-1]);
      destroy_tuple(TTemp[--SP]);

      /**/
      /*Get the anomaly results either by applying the specified thresholds or out of DLResult.*/
      /*AnomalyResultKey := KeysForDisplay[KeyIndex]*/
      T_tuple_select(hv_KeysForDisplay_COPY_INP_TMP,hv_KeyIndex,&TTemp[SP++]);
      destroy_tuple(hv_AnomalyResultKey);
      hv_AnomalyResultKey=TTemp[--SP];

      /*tuple_regexp_match (AnomalyResultKey, 'anomaly_result(.*)', AnomalyResultPostfix)*/
      create_tuple_s(&TTemp[SP++],"anomaly_result(.*)");
      destroy_tuple(hv_AnomalyResultPostfix);
      /***/T_tuple_regexp_match(hv_AnomalyResultKey, TTemp[SP-1], &hv_AnomalyResultPostfix);
      destroy_tuple(TTemp[--SP]);

      /*get_anomaly_result (AnomalyImage, AnomalyRegion, DLResult, __get_dict_tuple( Params, ['anomaly_classification_threshold']), __get_dict_tuple( Params, ['anomaly_region_threshold']), AnomalyResultPostfix, AnomalyScore, AnomalyClassID, AnomalyClassThresholdDisplay, AnomalyRegionThresholdDisplay)*/
      create_tuple_s(&TTemp[SP++],"anomaly_classification_threshold");
      T_get_dict_tuple(hv_Params,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      create_tuple_s(&TTemp[SP++],"anomaly_region_threshold");
      T_get_dict_tuple(hv_Params,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      clear_obj(ho_AnomalyImage);
      clear_obj(ho_AnomalyRegion);
      destroy_tuple(hv_AnomalyScore);
      destroy_tuple(hv_AnomalyClassID);
      destroy_tuple(hv_AnomalyClassThresholdDisplay);
      destroy_tuple(hv_AnomalyRegionThresholdDisplay);
      /***/get_anomaly_result(&ho_AnomalyImage, &ho_AnomalyRegion, hv_DLResult_COPY_INP_TMP, 
          TTemp[SP-2], TTemp[SP-1], hv_AnomalyResultPostfix, &hv_AnomalyScore, &hv_AnomalyClassID, 
          &hv_AnomalyClassThresholdDisplay, &hv_AnomalyRegionThresholdDisplay);
      destroy_tuple(TTemp[--SP]);
      destroy_tuple(TTemp[--SP]);

      /**/
      /*Get or open next window.*/
      /*get_image_size (Image, WidthImage, HeightImage)*/
      destroy_tuple(hv_WidthImage);
      destroy_tuple(hv_HeightImage);
      /***/T_get_image_size(ho_Image, &hv_WidthImage, &hv_HeightImage);

      /*get_next_window (__get_dict_tuple( Params, ['font']), __get_dict_tuple( Params, ['font_size']), __get_dict_tuple( Params, ['display_bottom_desc']), WidthImage, HeightImage, 0, __get_dict_tuple( Params, ['scale_windows']), __get_dict_tuple( Params, ['threshold_width']), PrevWindowCoordinates, WindowHandleDict, KeysForDisplay[KeyIndex], CurrentWindowHandle, WindowImageRatio, PrevWindowCoordinates)*/
      create_tuple_s(&TTemp[SP++],"font");
      T_get_dict_tuple(hv_Params,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      create_tuple_s(&TTemp[SP++],"font_size");
      T_get_dict_tuple(hv_Params,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      create_tuple_s(&TTemp[SP++],"display_bottom_desc");
      T_get_dict_tuple(hv_Params,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      create_tuple_i(&TTemp[SP++],0);
      create_tuple_s(&TTemp[SP++],"scale_windows");
      T_get_dict_tuple(hv_Params,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      create_tuple_s(&TTemp[SP++],"threshold_width");
      T_get_dict_tuple(hv_Params,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      copy_tuple(hv_PrevWindowCoordinates,&TTemp[SP++]);
      T_tuple_select(hv_KeysForDisplay_COPY_INP_TMP,hv_KeyIndex,&TTemp[SP++]);
      destroy_tuple(hv_CurrentWindowHandle);
      destroy_tuple(hv_WindowImageRatio);
      destroy_tuple(hv_PrevWindowCoordinates);
      /***/get_next_window(TTemp[SP-8], TTemp[SP-7], TTemp[SP-6], hv_WidthImage, 
          hv_HeightImage, TTemp[SP-5], TTemp[SP-4], TTemp[SP-3], TTemp[SP-2], hv_WindowHandleDict, 
          TTemp[SP-1], &hv_CurrentWindowHandle, &hv_WindowImageRatio, &hv_PrevWindowCoordinates);
      destroy_tuple(TTemp[--SP]);
      destroy_tuple(TTemp[--SP]);
      destroy_tuple(TTemp[--SP]);
      destroy_tuple(TTemp[--SP]);
      destroy_tuple(TTemp[--SP]);
      destroy_tuple(TTemp[--SP]);
      destroy_tuple(TTemp[--SP]);
      destroy_tuple(TTemp[--SP]);

      /**/
      /*Visualization.*/
      if (hdev_window_stack_is_open())
      {
        Htuple active_win;
        create_tuple(&active_win,0);
        hdev_window_stack_get_active(&active_win);
        /*dev_display (Image)*/
        /***/T_disp_obj(ho_Image, active_win);
        destroy_tuple(active_win);
      }
      /**/
      /*Display anomaly regions defined by the specified threshold or out of DLResult.*/
      /*tuple_regexp_replace (AnomalyResultKey, 'result', 'region', AnomalyRegionKey)*/
      create_tuple_s(&TTemp[SP++],"result");
      create_tuple_s(&TTemp[SP++],"region");
      destroy_tuple(hv_AnomalyRegionKey);
      /***/T_tuple_regexp_replace(hv_AnomalyResultKey, TTemp[SP-2], TTemp[SP-1], 
          &hv_AnomalyRegionKey);
      destroy_tuple(TTemp[--SP]);
      destroy_tuple(TTemp[--SP]);

      /*create_dict (__Tmp_Ctrl_Dict_Init_5)*/
      destroy_tuple(hv___Tmp_Ctrl_Dict_Init_5);
      /***/T_create_dict(&hv___Tmp_Ctrl_Dict_Init_5);

      /*set_dict_tuple (__Tmp_Ctrl_Dict_Init_5, ['comp'], -1)*/
      create_tuple_s(&TTemp[SP++],"comp");
      create_tuple_i(&TTemp[SP++],-1);
      /***/T_set_dict_tuple(hv___Tmp_Ctrl_Dict_Init_5, TTemp[SP-2], TTemp[SP-1]);
      destroy_tuple(TTemp[--SP]);
      destroy_tuple(TTemp[--SP]);

      /*========== if (not __test_equal_dict_item([Params, __Tmp_Ctrl_Dict_Init_5], ['anomaly_region_threshold'], 'comp') or find(ResultKeys,AnomalyRegionKey) != -1) ==========*/
      T_tuple_concat(hv_Params,hv___Tmp_Ctrl_Dict_Init_5,&TTemp[SP++]);
      create_tuple_s(&TTemp[SP++],"anomaly_region_threshold");
      create_tuple_s(&TTemp[SP++],"comp");
      T_test_equal_dict_item(TTemp[SP-3],TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-3]);
      destroy_tuple(TTemp[SP-2]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-3]=TTemp[SP];
      SP=SP-2;
      T_tuple_not(TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      T_tuple_find(hv_ResultKeys,hv_AnomalyRegionKey,&TTemp[SP++]);
      create_tuple_i(&TTemp[SP++],-1);
      T_tuple_not_equal(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-2]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-2]=TTemp[SP];
      SP--;
      T_tuple_or(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-2]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-2]=TTemp[SP];
      SP--;
      if(get_i(TTemp[SP-1],0))
      {
        /*dev_display_result_anomaly_regions (AnomalyRegion, CurrentWindowHandle, __get_dict_tuple( Params, ['line_width']), __get_dict_tuple( Params, ['anomaly_region_result_color']))*/
        create_tuple_s(&TTemp[SP++],"line_width");
        T_get_dict_tuple(hv_Params,TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-1]=TTemp[SP];
        create_tuple_s(&TTemp[SP++],"anomaly_region_result_color");
        T_get_dict_tuple(hv_Params,TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-1]=TTemp[SP];
        /***/dev_display_result_anomaly_regions(ho_AnomalyRegion, hv_CurrentWindowHandle, 
            TTemp[SP-2], TTemp[SP-1]);
        destroy_tuple(TTemp[--SP]);
        destroy_tuple(TTemp[--SP]);

      }
      destroy_tuple(TTemp[--SP]);
      /*========== end if ==========*/
      /*__Tmp_Ctrl_Dict_Init_5 := constant('HNULL')*/
      create_tuple_s(&TTemp[SP++],"HNULL");
      T_tuple_constant(TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      destroy_tuple(hv___Tmp_Ctrl_Dict_Init_5);
      hv___Tmp_Ctrl_Dict_Init_5=TTemp[--SP];

      /**/
      /*tuple_regexp_replace (AnomalyResultKey, 'result', 'score', AnomalyScoreKey)*/
      create_tuple_s(&TTemp[SP++],"result");
      create_tuple_s(&TTemp[SP++],"score");
      destroy_tuple(hv_AnomalyScoreKey);
      /***/T_tuple_regexp_replace(hv_AnomalyResultKey, TTemp[SP-2], TTemp[SP-1], 
          &hv_AnomalyScoreKey);
      destroy_tuple(TTemp[--SP]);
      destroy_tuple(TTemp[--SP]);

      /**/
      /*Text := 'Detected anomalies ' + ImageIDStringBraces*/
      create_tuple_s(&TTemp[SP++],"Detected anomalies ");
      T_tuple_add(TTemp[SP-1],hv_ImageIDStringBraces,&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      destroy_tuple(hv_Text);
      hv_Text=TTemp[--SP];

      /*========== if (__get_dict_tuple( Params, ['display_bottom_desc'])) ==========*/
      create_tuple_s(&TTemp[SP++],"display_bottom_desc");
      T_get_dict_tuple(hv_Params,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      if(get_i(TTemp[SP-1],0))
      {
        if (hdev_window_stack_is_open())
        {
          Htuple active_win;
          create_tuple(&active_win,0);
          hdev_window_stack_get_active(&active_win);
          /*dev_disp_text (Text, 'window', 'bottom', 'left', 'white', 'box', 'false')*/
          create_tuple_s(&TTemp[SP++],"window");
          create_tuple_s(&TTemp[SP++],"bottom");
          create_tuple_s(&TTemp[SP++],"left");
          create_tuple_s(&TTemp[SP++],"white");
          create_tuple_s(&TTemp[SP++],"box");
          create_tuple_s(&TTemp[SP++],"false");
          /***/T_disp_text(active_win,hv_Text, TTemp[SP-6], TTemp[SP-5], TTemp[SP-4], 
              TTemp[SP-3], TTemp[SP-2], TTemp[SP-1]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(active_win);
        }
      }
      destroy_tuple(TTemp[--SP]);
      /*========== end if ==========*/
      /**/
      /*Display the legend.*/
      /*========== if (__get_dict_tuple( Params, ['display_legend'])) ==========*/
      create_tuple_s(&TTemp[SP++],"display_legend");
      T_get_dict_tuple(hv_Params,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      if(get_i(TTemp[SP-1],0))
      {
        /*Text[|Text|] := ''*/
        copy_tuple(hv_Text,&TTemp[SP++]);
        T_tuple_length(TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-1]=TTemp[SP];
        create_tuple_s(&TTemp[SP++],"");
        replace_elements(&hv_Text,&TTemp[SP-2],&TTemp[SP-1]);
        destroy_tuple(TTemp[--SP]);
        destroy_tuple(TTemp[--SP]);
        /*Text[|Text|] := '---------------'*/
        copy_tuple(hv_Text,&TTemp[SP++]);
        T_tuple_length(TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-1]=TTemp[SP];
        create_tuple_s(&TTemp[SP++],"---------------");
        replace_elements(&hv_Text,&TTemp[SP-2],&TTemp[SP-1]);
        destroy_tuple(TTemp[--SP]);
        destroy_tuple(TTemp[--SP]);
        /*Text[|Text|] := 'Results '*/
        copy_tuple(hv_Text,&TTemp[SP++]);
        T_tuple_length(TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-1]=TTemp[SP];
        create_tuple_s(&TTemp[SP++],"Results ");
        replace_elements(&hv_Text,&TTemp[SP-2],&TTemp[SP-1]);
        destroy_tuple(TTemp[--SP]);
        destroy_tuple(TTemp[--SP]);
        /*Text[|Text|] := '---------------'*/
        copy_tuple(hv_Text,&TTemp[SP++]);
        T_tuple_length(TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-1]=TTemp[SP];
        create_tuple_s(&TTemp[SP++],"---------------");
        replace_elements(&hv_Text,&TTemp[SP-2],&TTemp[SP-1]);
        destroy_tuple(TTemp[--SP]);
        destroy_tuple(TTemp[--SP]);
        /*========== if (AnomalyClassID == 1) ==========*/
        create_tuple_i(&TTemp[SP++],1);
        T_tuple_equal(hv_AnomalyClassID,TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-1]=TTemp[SP];
        if(get_i(TTemp[SP-1],0))
        {
          /*Text[|Text|] := AnomalyClassID + ' : \'nok\''*/
          copy_tuple(hv_Text,&TTemp[SP++]);
          T_tuple_length(TTemp[SP-1],&TTemp[SP]);
          destroy_tuple(TTemp[SP-1]);
          TTemp[SP-1]=TTemp[SP];
          create_tuple_s(&TTemp[SP++]," : 'nok'");
          T_tuple_add(hv_AnomalyClassID,TTemp[SP-1],&TTemp[SP]);
          destroy_tuple(TTemp[SP-1]);
          TTemp[SP-1]=TTemp[SP];
          replace_elements(&hv_Text,&TTemp[SP-2],&TTemp[SP-1]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(TTemp[--SP]);
        }
        else
        {
        destroy_tuple(TTemp[--SP]);
        /*========== elseif (AnomalyClassID == 0) ==========*/

        create_tuple_i(&TTemp[SP++],0);
        T_tuple_equal(hv_AnomalyClassID,TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-1]=TTemp[SP];
        if(get_i(TTemp[SP-1],0))
        {
          /*Text[|Text|] := AnomalyClassID + ' : \'ok\''*/
          copy_tuple(hv_Text,&TTemp[SP++]);
          T_tuple_length(TTemp[SP-1],&TTemp[SP]);
          destroy_tuple(TTemp[SP-1]);
          TTemp[SP-1]=TTemp[SP];
          create_tuple_s(&TTemp[SP++]," : 'ok'");
          T_tuple_add(hv_AnomalyClassID,TTemp[SP-1],&TTemp[SP]);
          destroy_tuple(TTemp[SP-1]);
          TTemp[SP-1]=TTemp[SP];
          replace_elements(&hv_Text,&TTemp[SP-2],&TTemp[SP-1]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(TTemp[--SP]);
        }
        else
        {
          /*Text[|Text|] := 'No classification result found'*/
          copy_tuple(hv_Text,&TTemp[SP++]);
          T_tuple_length(TTemp[SP-1],&TTemp[SP]);
          destroy_tuple(TTemp[SP-1]);
          TTemp[SP-1]=TTemp[SP];
          create_tuple_s(&TTemp[SP++],"No classification result found");
          replace_elements(&hv_Text,&TTemp[SP-2],&TTemp[SP-1]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(TTemp[--SP]);
        }
        }
        destroy_tuple(TTemp[--SP]);
        /*========== end if ==========*/
        /*create_dict (__Tmp_Ctrl_Dict_Init_6)*/
        destroy_tuple(hv___Tmp_Ctrl_Dict_Init_6);
        /***/T_create_dict(&hv___Tmp_Ctrl_Dict_Init_6);

        /*set_dict_tuple (__Tmp_Ctrl_Dict_Init_6, ['comp'], -1)*/
        create_tuple_s(&TTemp[SP++],"comp");
        create_tuple_i(&TTemp[SP++],-1);
        /***/T_set_dict_tuple(hv___Tmp_Ctrl_Dict_Init_6, TTemp[SP-2], TTemp[SP-1]);
        destroy_tuple(TTemp[--SP]);
        destroy_tuple(TTemp[--SP]);

        /*========== if (__test_equal_dict_item([Params, __Tmp_Ctrl_Dict_Init_6], ['anomaly_region_threshold'], 'comp') and find(ResultKeys,AnomalyRegionKey) == -1) ==========*/
        T_tuple_concat(hv_Params,hv___Tmp_Ctrl_Dict_Init_6,&TTemp[SP++]);
        create_tuple_s(&TTemp[SP++],"anomaly_region_threshold");
        create_tuple_s(&TTemp[SP++],"comp");
        T_test_equal_dict_item(TTemp[SP-3],TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-3]);
        destroy_tuple(TTemp[SP-2]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-3]=TTemp[SP];
        SP=SP-2;
        T_tuple_find(hv_ResultKeys,hv_AnomalyRegionKey,&TTemp[SP++]);
        create_tuple_i(&TTemp[SP++],-1);
        T_tuple_equal(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-2]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-2]=TTemp[SP];
        SP--;
        T_tuple_and(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-2]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-2]=TTemp[SP];
        SP--;
        if(get_i(TTemp[SP-1],0))
        {
          /*Text[|Text|] := ''*/
          copy_tuple(hv_Text,&TTemp[SP++]);
          T_tuple_length(TTemp[SP-1],&TTemp[SP]);
          destroy_tuple(TTemp[SP-1]);
          TTemp[SP-1]=TTemp[SP];
          create_tuple_s(&TTemp[SP++],"");
          replace_elements(&hv_Text,&TTemp[SP-2],&TTemp[SP-1]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(TTemp[--SP]);
          /*Text[|Text|] := 'No segmentation result found'*/
          copy_tuple(hv_Text,&TTemp[SP++]);
          T_tuple_length(TTemp[SP-1],&TTemp[SP]);
          destroy_tuple(TTemp[SP-1]);
          TTemp[SP-1]=TTemp[SP];
          create_tuple_s(&TTemp[SP++],"No segmentation result found");
          replace_elements(&hv_Text,&TTemp[SP-2],&TTemp[SP-1]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(TTemp[--SP]);
        }
        destroy_tuple(TTemp[--SP]);
        /*========== end if ==========*/
        /*__Tmp_Ctrl_Dict_Init_6 := constant('HNULL')*/
        create_tuple_s(&TTemp[SP++],"HNULL");
        T_tuple_constant(TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-1]=TTemp[SP];
        destroy_tuple(hv___Tmp_Ctrl_Dict_Init_6);
        hv___Tmp_Ctrl_Dict_Init_6=TTemp[--SP];

        /*Text[|Text|] := ''*/
        copy_tuple(hv_Text,&TTemp[SP++]);
        T_tuple_length(TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-1]=TTemp[SP];
        create_tuple_s(&TTemp[SP++],"");
        replace_elements(&hv_Text,&TTemp[SP-2],&TTemp[SP-1]);
        destroy_tuple(TTemp[--SP]);
        destroy_tuple(TTemp[--SP]);
        /*Text[|Text|] := AnomalyScoreKey + ': ' + AnomalyScore$'.3f'*/
        copy_tuple(hv_Text,&TTemp[SP++]);
        T_tuple_length(TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-1]=TTemp[SP];
        create_tuple_s(&TTemp[SP++],": ");
        T_tuple_add(hv_AnomalyScoreKey,TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-1]=TTemp[SP];
        create_tuple_s(&TTemp[SP++],".3f");
        T_tuple_string(hv_AnomalyScore,TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-1]=TTemp[SP];
        T_tuple_add(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-2]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-2]=TTemp[SP];
        SP--;
        replace_elements(&hv_Text,&TTemp[SP-2],&TTemp[SP-1]);
        destroy_tuple(TTemp[--SP]);
        destroy_tuple(TTemp[--SP]);
        /*Text[|Text|] := ''*/
        copy_tuple(hv_Text,&TTemp[SP++]);
        T_tuple_length(TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-1]=TTemp[SP];
        create_tuple_s(&TTemp[SP++],"");
        replace_elements(&hv_Text,&TTemp[SP-2],&TTemp[SP-1]);
        destroy_tuple(TTemp[--SP]);
        destroy_tuple(TTemp[--SP]);
        /*========== if (AnomalyClassThresholdDisplay != -1 or AnomalyRegionThresholdDisplay != -1) ==========*/
        create_tuple_i(&TTemp[SP++],-1);
        T_tuple_not_equal(hv_AnomalyClassThresholdDisplay,TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-1]=TTemp[SP];
        create_tuple_i(&TTemp[SP++],-1);
        T_tuple_not_equal(hv_AnomalyRegionThresholdDisplay,TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-1]=TTemp[SP];
        T_tuple_or(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-2]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-2]=TTemp[SP];
        SP--;
        if(get_i(TTemp[SP-1],0))
        {
          /*Text[|Text|] := '---------------'*/
          copy_tuple(hv_Text,&TTemp[SP++]);
          T_tuple_length(TTemp[SP-1],&TTemp[SP]);
          destroy_tuple(TTemp[SP-1]);
          TTemp[SP-1]=TTemp[SP];
          create_tuple_s(&TTemp[SP++],"---------------");
          replace_elements(&hv_Text,&TTemp[SP-2],&TTemp[SP-1]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(TTemp[--SP]);
          /*Text[|Text|] := 'Thresholds '*/
          copy_tuple(hv_Text,&TTemp[SP++]);
          T_tuple_length(TTemp[SP-1],&TTemp[SP]);
          destroy_tuple(TTemp[SP-1]);
          TTemp[SP-1]=TTemp[SP];
          create_tuple_s(&TTemp[SP++],"Thresholds ");
          replace_elements(&hv_Text,&TTemp[SP-2],&TTemp[SP-1]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(TTemp[--SP]);
          /*Text[|Text|] := '---------------'*/
          copy_tuple(hv_Text,&TTemp[SP++]);
          T_tuple_length(TTemp[SP-1],&TTemp[SP]);
          destroy_tuple(TTemp[SP-1]);
          TTemp[SP-1]=TTemp[SP];
          create_tuple_s(&TTemp[SP++],"---------------");
          replace_elements(&hv_Text,&TTemp[SP-2],&TTemp[SP-1]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(TTemp[--SP]);
        }
        destroy_tuple(TTemp[--SP]);
        /*========== end if ==========*/
        /**/
        /*========== if (AnomalyClassThresholdDisplay != -1) ==========*/
        create_tuple_i(&TTemp[SP++],-1);
        T_tuple_not_equal(hv_AnomalyClassThresholdDisplay,TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-1]=TTemp[SP];
        if(get_i(TTemp[SP-1],0))
        {
          /*Text[|Text|] := 'Classification: ' + AnomalyClassThresholdDisplay$'.3f'*/
          copy_tuple(hv_Text,&TTemp[SP++]);
          T_tuple_length(TTemp[SP-1],&TTemp[SP]);
          destroy_tuple(TTemp[SP-1]);
          TTemp[SP-1]=TTemp[SP];
          create_tuple_s(&TTemp[SP++],"Classification: ");
          create_tuple_s(&TTemp[SP++],".3f");
          T_tuple_string(hv_AnomalyClassThresholdDisplay,TTemp[SP-1],&TTemp[SP]);
          destroy_tuple(TTemp[SP-1]);
          TTemp[SP-1]=TTemp[SP];
          T_tuple_add(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
          destroy_tuple(TTemp[SP-2]);
          destroy_tuple(TTemp[SP-1]);
          TTemp[SP-2]=TTemp[SP];
          SP--;
          replace_elements(&hv_Text,&TTemp[SP-2],&TTemp[SP-1]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(TTemp[--SP]);
          /*Text[|Text|] := ''*/
          copy_tuple(hv_Text,&TTemp[SP++]);
          T_tuple_length(TTemp[SP-1],&TTemp[SP]);
          destroy_tuple(TTemp[SP-1]);
          TTemp[SP-1]=TTemp[SP];
          create_tuple_s(&TTemp[SP++],"");
          replace_elements(&hv_Text,&TTemp[SP-2],&TTemp[SP-1]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(TTemp[--SP]);
        }
        destroy_tuple(TTemp[--SP]);
        /*========== end if ==========*/
        /*========== if (AnomalyRegionThresholdDisplay != -1) ==========*/
        create_tuple_i(&TTemp[SP++],-1);
        T_tuple_not_equal(hv_AnomalyRegionThresholdDisplay,TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-1]=TTemp[SP];
        if(get_i(TTemp[SP-1],0))
        {
          /*Text[|Text|] := 'Segmentation: ' + AnomalyRegionThresholdDisplay$'.3f'*/
          copy_tuple(hv_Text,&TTemp[SP++]);
          T_tuple_length(TTemp[SP-1],&TTemp[SP]);
          destroy_tuple(TTemp[SP-1]);
          TTemp[SP-1]=TTemp[SP];
          create_tuple_s(&TTemp[SP++],"Segmentation: ");
          create_tuple_s(&TTemp[SP++],".3f");
          T_tuple_string(hv_AnomalyRegionThresholdDisplay,TTemp[SP-1],&TTemp[SP]);
          destroy_tuple(TTemp[SP-1]);
          TTemp[SP-1]=TTemp[SP];
          T_tuple_add(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
          destroy_tuple(TTemp[SP-2]);
          destroy_tuple(TTemp[SP-1]);
          TTemp[SP-2]=TTemp[SP];
          SP--;
          replace_elements(&hv_Text,&TTemp[SP-2],&TTemp[SP-1]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(TTemp[--SP]);
          /*Text[|Text|] := ''*/
          copy_tuple(hv_Text,&TTemp[SP++]);
          T_tuple_length(TTemp[SP-1],&TTemp[SP]);
          destroy_tuple(TTemp[SP-1]);
          TTemp[SP-1]=TTemp[SP];
          create_tuple_s(&TTemp[SP++],"");
          replace_elements(&hv_Text,&TTemp[SP-2],&TTemp[SP-1]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(TTemp[--SP]);
        }
        destroy_tuple(TTemp[--SP]);
        /*========== end if ==========*/
        /**/
        /*Get or open next child window*/
        /*get_child_window (HeightImage, __get_dict_tuple( Params, ['font']), __get_dict_tuple( Params, ['font_size']), Text, PrevWindowCoordinates, WindowHandleDict, KeysForDisplay[KeyIndex], WindowImageRatio, PrevWindowCoordinates)*/
        create_tuple_s(&TTemp[SP++],"font");
        T_get_dict_tuple(hv_Params,TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-1]=TTemp[SP];
        create_tuple_s(&TTemp[SP++],"font_size");
        T_get_dict_tuple(hv_Params,TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-1]=TTemp[SP];
        copy_tuple(hv_PrevWindowCoordinates,&TTemp[SP++]);
        T_tuple_select(hv_KeysForDisplay_COPY_INP_TMP,hv_KeyIndex,&TTemp[SP++]);
        destroy_tuple(hv_WindowImageRatio);
        destroy_tuple(hv_PrevWindowCoordinates);
        /***/get_child_window(hv_HeightImage, TTemp[SP-4], TTemp[SP-3], hv_Text, 
            TTemp[SP-2], hv_WindowHandleDict, TTemp[SP-1], &hv_WindowImageRatio, 
            &hv_PrevWindowCoordinates);
        destroy_tuple(TTemp[--SP]);
        destroy_tuple(TTemp[--SP]);
        destroy_tuple(TTemp[--SP]);
        destroy_tuple(TTemp[--SP]);

        if (hdev_window_stack_is_open())
        {
          Htuple active_win;
          create_tuple(&active_win,0);
          hdev_window_stack_get_active(&active_win);
          /*dev_disp_text (Text, 'window', 'top', 'left', 'white', 'box', 'false')*/
          create_tuple_s(&TTemp[SP++],"window");
          create_tuple_s(&TTemp[SP++],"top");
          create_tuple_s(&TTemp[SP++],"left");
          create_tuple_s(&TTemp[SP++],"white");
          create_tuple_s(&TTemp[SP++],"box");
          create_tuple_s(&TTemp[SP++],"false");
          /***/T_disp_text(active_win,hv_Text, TTemp[SP-6], TTemp[SP-5], TTemp[SP-4], 
              TTemp[SP-3], TTemp[SP-2], TTemp[SP-1]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(active_win);
        }
      }
      destroy_tuple(TTemp[--SP]);
      /*========== end if ==========*/
      /**/
    }
    else
    {
    destroy_tuple(TTemp[--SP]);
    /*========== elseif (KeysForDisplay[KeyIndex] == 'gripping_heatmap') ==========*/

    T_tuple_select(hv_KeysForDisplay_COPY_INP_TMP,hv_KeyIndex,&TTemp[SP++]);
    create_tuple_s(&TTemp[SP++],"gripping_heatmap");
    T_tuple_equal(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-2]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-2]=TTemp[SP];
    SP--;
    if(get_i(TTemp[SP-1],0))
    {
      /**/
      /*Image.*/
      /*get_dl_sample_image (Image, SampleKeys, DLSample, 'image')*/
      create_tuple_s(&TTemp[SP++],"image");
      clear_obj(ho_Image);
      /***/get_dl_sample_image(&ho_Image, hv_SampleKeys, hv_DLSample, TTemp[SP-1]);
      destroy_tuple(TTemp[--SP]);

      /**/
      /*Get gripping points*/
      /*get_gripping_points_from_dict (DLResult, Rows, Columns)*/
      destroy_tuple(hv_Rows);
      destroy_tuple(hv_Columns);
      /***/get_gripping_points_from_dict(hv_DLResult_COPY_INP_TMP, &hv_Rows, &hv_Columns);

      /**/
      /*Confidence image.*/
      /*========== if (find(ResultKeys,'gripping_confidence') != -1) ==========*/
      create_tuple_s(&TTemp[SP++],"gripping_confidence");
      T_tuple_find(hv_ResultKeys,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      create_tuple_i(&TTemp[SP++],-1);
      T_tuple_not_equal(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-2]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-2]=TTemp[SP];
      SP--;
      if(get_i(TTemp[SP-1],0))
      {
        /*get_dict_object (ConfidenceImage, DLResult, 'gripping_confidence')*/
        create_tuple_s(&TTemp[SP++],"gripping_confidence");
        clear_obj(ho_ConfidenceImage);
        /***/T_get_dict_object(&ho_ConfidenceImage, hv_DLResult_COPY_INP_TMP, TTemp[SP-1]);
        destroy_tuple(TTemp[--SP]);

      }
      else
      {
        /* throw(...); only in hdevelop*/
      }
      destroy_tuple(TTemp[--SP]);
      /*========== end if ==========*/
      /*add_colormap_to_image (ConfidenceImage, Image, HeatmapScene, __get_dict_tuple( Params, ['heatmap_color_scheme']))*/
      create_tuple_s(&TTemp[SP++],"heatmap_color_scheme");
      T_get_dict_tuple(hv_Params,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      clear_obj(ho_HeatmapScene);
      /***/add_colormap_to_image(ho_ConfidenceImage, ho_Image, &ho_HeatmapScene, 
          TTemp[SP-1]);
      destroy_tuple(TTemp[--SP]);

      /**/
      /*Get or open next window.*/
      /*get_image_size (Image, WidthImage, HeightImage)*/
      destroy_tuple(hv_WidthImage);
      destroy_tuple(hv_HeightImage);
      /***/T_get_image_size(ho_Image, &hv_WidthImage, &hv_HeightImage);

      /*get_next_window (__get_dict_tuple( Params, ['font']), __get_dict_tuple( Params, ['font_size']), __get_dict_tuple( Params, ['display_bottom_desc']), WidthImage, HeightImage, 0, __get_dict_tuple( Params, ['scale_windows']), __get_dict_tuple( Params, ['threshold_width']), PrevWindowCoordinates, WindowHandleDict, KeysForDisplay[KeyIndex], CurrentWindowHandle, WindowImageRatio, PrevWindowCoordinates)*/
      create_tuple_s(&TTemp[SP++],"font");
      T_get_dict_tuple(hv_Params,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      create_tuple_s(&TTemp[SP++],"font_size");
      T_get_dict_tuple(hv_Params,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      create_tuple_s(&TTemp[SP++],"display_bottom_desc");
      T_get_dict_tuple(hv_Params,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      create_tuple_i(&TTemp[SP++],0);
      create_tuple_s(&TTemp[SP++],"scale_windows");
      T_get_dict_tuple(hv_Params,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      create_tuple_s(&TTemp[SP++],"threshold_width");
      T_get_dict_tuple(hv_Params,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      copy_tuple(hv_PrevWindowCoordinates,&TTemp[SP++]);
      T_tuple_select(hv_KeysForDisplay_COPY_INP_TMP,hv_KeyIndex,&TTemp[SP++]);
      destroy_tuple(hv_CurrentWindowHandle);
      destroy_tuple(hv_WindowImageRatio);
      destroy_tuple(hv_PrevWindowCoordinates);
      /***/get_next_window(TTemp[SP-8], TTemp[SP-7], TTemp[SP-6], hv_WidthImage, 
          hv_HeightImage, TTemp[SP-5], TTemp[SP-4], TTemp[SP-3], TTemp[SP-2], hv_WindowHandleDict, 
          TTemp[SP-1], &hv_CurrentWindowHandle, &hv_WindowImageRatio, &hv_PrevWindowCoordinates);
      destroy_tuple(TTemp[--SP]);
      destroy_tuple(TTemp[--SP]);
      destroy_tuple(TTemp[--SP]);
      destroy_tuple(TTemp[--SP]);
      destroy_tuple(TTemp[--SP]);
      destroy_tuple(TTemp[--SP]);
      destroy_tuple(TTemp[--SP]);
      destroy_tuple(TTemp[--SP]);

      /**/
      if (hdev_window_stack_is_open())
      {
        Htuple active_win;
        create_tuple(&active_win,0);
        hdev_window_stack_get_active(&active_win);
        /*dev_display (HeatmapScene)*/
        /***/T_disp_obj(ho_HeatmapScene, active_win);
        destroy_tuple(active_win);
      }
      /*========== if (__get_dict_tuple( Params, ['display_bottom_desc'])) ==========*/
      create_tuple_s(&TTemp[SP++],"display_bottom_desc");
      T_get_dict_tuple(hv_Params,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      if(get_i(TTemp[SP-1],0))
      {
        if (hdev_window_stack_is_open())
        {
          Htuple active_win;
          create_tuple(&active_win,0);
          hdev_window_stack_get_active(&active_win);
          /*dev_disp_text (ImageIDStringCapital, 'window', 'bottom', 'left', 'white', 'box', 'false')*/
          create_tuple_s(&TTemp[SP++],"window");
          create_tuple_s(&TTemp[SP++],"bottom");
          create_tuple_s(&TTemp[SP++],"left");
          create_tuple_s(&TTemp[SP++],"white");
          create_tuple_s(&TTemp[SP++],"box");
          create_tuple_s(&TTemp[SP++],"false");
          /***/T_disp_text(active_win,hv_ImageIDStringCapital, TTemp[SP-6], TTemp[SP-5], 
              TTemp[SP-4], TTemp[SP-3], TTemp[SP-2], TTemp[SP-1]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(active_win);
        }
      }
      destroy_tuple(TTemp[--SP]);
      /*========== end if ==========*/
      if (hdev_window_stack_is_open())
      {
        Htuple active_win;
        create_tuple(&active_win,0);
        hdev_window_stack_get_active(&active_win);
        /*dev_disp_text ('Gripping heatmap', 'window', 'top', 'left', 'black', 'box', 'true')*/
        create_tuple_s(&TTemp[SP++],"Gripping heatmap");
        create_tuple_s(&TTemp[SP++],"window");
        create_tuple_s(&TTemp[SP++],"top");
        create_tuple_s(&TTemp[SP++],"left");
        create_tuple_s(&TTemp[SP++],"black");
        create_tuple_s(&TTemp[SP++],"box");
        create_tuple_s(&TTemp[SP++],"true");
        /***/T_disp_text(active_win,TTemp[SP-7], TTemp[SP-6], TTemp[SP-5], TTemp[SP-4], 
            TTemp[SP-3], TTemp[SP-2], TTemp[SP-1]);
        destroy_tuple(TTemp[--SP]);
        destroy_tuple(TTemp[--SP]);
        destroy_tuple(TTemp[--SP]);
        destroy_tuple(TTemp[--SP]);
        destroy_tuple(TTemp[--SP]);
        destroy_tuple(TTemp[--SP]);
        destroy_tuple(TTemp[--SP]);
        destroy_tuple(active_win);
      }
      /**/
      /*gen_cross_contour_xld (Cross, Rows, Columns, __get_dict_tuple( Params, ['gripping_point_size']), 0.785398)*/
      create_tuple_s(&TTemp[SP++],"gripping_point_size");
      T_get_dict_tuple(hv_Params,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      create_tuple_d(&TTemp[SP++],0.785398);
      clear_obj(ho_Cross);
      /***/T_gen_cross_contour_xld(&ho_Cross, hv_Rows, hv_Columns, TTemp[SP-2], TTemp[SP-1]);
      destroy_tuple(TTemp[--SP]);
      destroy_tuple(TTemp[--SP]);

      if (hdev_window_stack_is_open())
      {
        Htuple active_win;
        create_tuple(&active_win,0);
        hdev_window_stack_get_active(&active_win);
        /*dev_set_line_width (__get_dict_tuple( Params, ['line_width']))*/
        create_tuple_s(&TTemp[SP++],"line_width");
        T_get_dict_tuple(hv_Params,TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-1]=TTemp[SP];
        /***/T_set_line_width(active_win,TTemp[SP-1]);
        destroy_tuple(TTemp[--SP]);
        destroy_tuple(active_win);
      }
      if (hdev_window_stack_is_open())
      {
        Htuple active_win;
        create_tuple(&active_win,0);
        hdev_window_stack_get_active(&active_win);
        /*dev_set_color (__get_dict_tuple( Params, ['gripping_point_color']))*/
        create_tuple_s(&TTemp[SP++],"gripping_point_color");
        T_get_dict_tuple(hv_Params,TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-1]=TTemp[SP];
        /***/T_set_color(active_win,TTemp[SP-1]);
        destroy_tuple(TTemp[--SP]);
        destroy_tuple(active_win);
      }
      if (hdev_window_stack_is_open())
      {
        Htuple active_win;
        create_tuple(&active_win,0);
        hdev_window_stack_get_active(&active_win);
        /*dev_display (Cross)*/
        /***/T_disp_obj(ho_Cross, active_win);
        destroy_tuple(active_win);
      }
      /**/
    }
    else
    {
    destroy_tuple(TTemp[--SP]);
    /*========== elseif (KeysForDisplay[KeyIndex] == 'gripping_points') ==========*/

    T_tuple_select(hv_KeysForDisplay_COPY_INP_TMP,hv_KeyIndex,&TTemp[SP++]);
    create_tuple_s(&TTemp[SP++],"gripping_points");
    T_tuple_equal(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-2]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-2]=TTemp[SP];
    SP--;
    if(get_i(TTemp[SP-1],0))
    {
      /**/
      /*Image.*/
      /*get_dl_sample_image (Image, SampleKeys, DLSample, 'image')*/
      create_tuple_s(&TTemp[SP++],"image");
      clear_obj(ho_Image);
      /***/get_dl_sample_image(&ho_Image, hv_SampleKeys, hv_DLSample, TTemp[SP-1]);
      destroy_tuple(TTemp[--SP]);

      /**/
      /*Get gripping points*/
      /*get_gripping_points_from_dict (DLResult, Rows, Columns)*/
      destroy_tuple(hv_Rows);
      destroy_tuple(hv_Columns);
      /***/get_gripping_points_from_dict(hv_DLResult_COPY_INP_TMP, &hv_Rows, &hv_Columns);

      /**/
      /*Get or open next window.*/
      /*get_image_size (Image, WidthImage, HeightImage)*/
      destroy_tuple(hv_WidthImage);
      destroy_tuple(hv_HeightImage);
      /***/T_get_image_size(ho_Image, &hv_WidthImage, &hv_HeightImage);

      /*get_next_window (__get_dict_tuple( Params, ['font']), __get_dict_tuple( Params, ['font_size']), __get_dict_tuple( Params, ['display_bottom_desc']), WidthImage, HeightImage, 0, __get_dict_tuple( Params, ['scale_windows']), __get_dict_tuple( Params, ['threshold_width']), PrevWindowCoordinates, WindowHandleDict, KeysForDisplay[KeyIndex], CurrentWindowHandle, WindowImageRatio, PrevWindowCoordinates)*/
      create_tuple_s(&TTemp[SP++],"font");
      T_get_dict_tuple(hv_Params,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      create_tuple_s(&TTemp[SP++],"font_size");
      T_get_dict_tuple(hv_Params,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      create_tuple_s(&TTemp[SP++],"display_bottom_desc");
      T_get_dict_tuple(hv_Params,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      create_tuple_i(&TTemp[SP++],0);
      create_tuple_s(&TTemp[SP++],"scale_windows");
      T_get_dict_tuple(hv_Params,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      create_tuple_s(&TTemp[SP++],"threshold_width");
      T_get_dict_tuple(hv_Params,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      copy_tuple(hv_PrevWindowCoordinates,&TTemp[SP++]);
      T_tuple_select(hv_KeysForDisplay_COPY_INP_TMP,hv_KeyIndex,&TTemp[SP++]);
      destroy_tuple(hv_CurrentWindowHandle);
      destroy_tuple(hv_WindowImageRatio);
      destroy_tuple(hv_PrevWindowCoordinates);
      /***/get_next_window(TTemp[SP-8], TTemp[SP-7], TTemp[SP-6], hv_WidthImage, 
          hv_HeightImage, TTemp[SP-5], TTemp[SP-4], TTemp[SP-3], TTemp[SP-2], hv_WindowHandleDict, 
          TTemp[SP-1], &hv_CurrentWindowHandle, &hv_WindowImageRatio, &hv_PrevWindowCoordinates);
      destroy_tuple(TTemp[--SP]);
      destroy_tuple(TTemp[--SP]);
      destroy_tuple(TTemp[--SP]);
      destroy_tuple(TTemp[--SP]);
      destroy_tuple(TTemp[--SP]);
      destroy_tuple(TTemp[--SP]);
      destroy_tuple(TTemp[--SP]);
      destroy_tuple(TTemp[--SP]);

      /**/
      /*full_domain (Image, Image)*/
      /***/full_domain(ho_Image, &(OTemp[SPO]));
      SPO++;
      clear_obj(ho_Image);
      ho_Image = OTemp[--SPO];

      if (hdev_window_stack_is_open())
      {
        Htuple active_win;
        create_tuple(&active_win,0);
        hdev_window_stack_get_active(&active_win);
        /*dev_display (Image)*/
        /***/T_disp_obj(ho_Image, active_win);
        destroy_tuple(active_win);
      }
      /*========== if (__get_dict_tuple( Params, ['display_bottom_desc'])) ==========*/
      create_tuple_s(&TTemp[SP++],"display_bottom_desc");
      T_get_dict_tuple(hv_Params,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      if(get_i(TTemp[SP-1],0))
      {
        if (hdev_window_stack_is_open())
        {
          Htuple active_win;
          create_tuple(&active_win,0);
          hdev_window_stack_get_active(&active_win);
          /*dev_disp_text (ImageIDStringCapital, 'window', 'bottom', 'left', 'white', 'box', 'false')*/
          create_tuple_s(&TTemp[SP++],"window");
          create_tuple_s(&TTemp[SP++],"bottom");
          create_tuple_s(&TTemp[SP++],"left");
          create_tuple_s(&TTemp[SP++],"white");
          create_tuple_s(&TTemp[SP++],"box");
          create_tuple_s(&TTemp[SP++],"false");
          /***/T_disp_text(active_win,hv_ImageIDStringCapital, TTemp[SP-6], TTemp[SP-5], 
              TTemp[SP-4], TTemp[SP-3], TTemp[SP-2], TTemp[SP-1]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(active_win);
        }
      }
      destroy_tuple(TTemp[--SP]);
      /*========== end if ==========*/
      if (hdev_window_stack_is_open())
      {
        Htuple active_win;
        create_tuple(&active_win,0);
        hdev_window_stack_get_active(&active_win);
        /*dev_disp_text ('Gripping points', 'window', 'top', 'left', 'black', 'box', 'true')*/
        create_tuple_s(&TTemp[SP++],"Gripping points");
        create_tuple_s(&TTemp[SP++],"window");
        create_tuple_s(&TTemp[SP++],"top");
        create_tuple_s(&TTemp[SP++],"left");
        create_tuple_s(&TTemp[SP++],"black");
        create_tuple_s(&TTemp[SP++],"box");
        create_tuple_s(&TTemp[SP++],"true");
        /***/T_disp_text(active_win,TTemp[SP-7], TTemp[SP-6], TTemp[SP-5], TTemp[SP-4], 
            TTemp[SP-3], TTemp[SP-2], TTemp[SP-1]);
        destroy_tuple(TTemp[--SP]);
        destroy_tuple(TTemp[--SP]);
        destroy_tuple(TTemp[--SP]);
        destroy_tuple(TTemp[--SP]);
        destroy_tuple(TTemp[--SP]);
        destroy_tuple(TTemp[--SP]);
        destroy_tuple(TTemp[--SP]);
        destroy_tuple(active_win);
      }
      /**/
      /*gen_cross_contour_xld (Cross, Rows, Columns, __get_dict_tuple( Params, ['gripping_point_size']), 0.785398)*/
      create_tuple_s(&TTemp[SP++],"gripping_point_size");
      T_get_dict_tuple(hv_Params,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      create_tuple_d(&TTemp[SP++],0.785398);
      clear_obj(ho_Cross);
      /***/T_gen_cross_contour_xld(&ho_Cross, hv_Rows, hv_Columns, TTemp[SP-2], TTemp[SP-1]);
      destroy_tuple(TTemp[--SP]);
      destroy_tuple(TTemp[--SP]);

      if (hdev_window_stack_is_open())
      {
        Htuple active_win;
        create_tuple(&active_win,0);
        hdev_window_stack_get_active(&active_win);
        /*dev_set_line_width (__get_dict_tuple( Params, ['line_width']))*/
        create_tuple_s(&TTemp[SP++],"line_width");
        T_get_dict_tuple(hv_Params,TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-1]=TTemp[SP];
        /***/T_set_line_width(active_win,TTemp[SP-1]);
        destroy_tuple(TTemp[--SP]);
        destroy_tuple(active_win);
      }
      if (hdev_window_stack_is_open())
      {
        Htuple active_win;
        create_tuple(&active_win,0);
        hdev_window_stack_get_active(&active_win);
        /*dev_set_color (__get_dict_tuple( Params, ['gripping_point_color']))*/
        create_tuple_s(&TTemp[SP++],"gripping_point_color");
        T_get_dict_tuple(hv_Params,TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-1]=TTemp[SP];
        /***/T_set_color(active_win,TTemp[SP-1]);
        destroy_tuple(TTemp[--SP]);
        destroy_tuple(active_win);
      }
      if (hdev_window_stack_is_open())
      {
        Htuple active_win;
        create_tuple(&active_win,0);
        hdev_window_stack_get_active(&active_win);
        /*dev_display (Cross)*/
        /***/T_disp_obj(ho_Cross, active_win);
        destroy_tuple(active_win);
      }
      /**/
    }
    else
    {
    destroy_tuple(TTemp[--SP]);
    /*========== elseif (KeysForDisplay[KeyIndex] == 'bbox_both' or KeysForDisplay[KeyIndex] == 'ocr_detection_both') ==========*/

    T_tuple_select(hv_KeysForDisplay_COPY_INP_TMP,hv_KeyIndex,&TTemp[SP++]);
    create_tuple_s(&TTemp[SP++],"bbox_both");
    T_tuple_equal(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-2]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-2]=TTemp[SP];
    SP--;
    T_tuple_select(hv_KeysForDisplay_COPY_INP_TMP,hv_KeyIndex,&TTemp[SP++]);
    create_tuple_s(&TTemp[SP++],"ocr_detection_both");
    T_tuple_equal(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-2]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-2]=TTemp[SP];
    SP--;
    T_tuple_or(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-2]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-2]=TTemp[SP];
    SP--;
    if(get_i(TTemp[SP-1],0))
    {
      /**/
      /*Ground truth and result bounding boxes on image.*/
      /*get_dl_sample_image (Image, SampleKeys, DLSample, 'image')*/
      create_tuple_s(&TTemp[SP++],"image");
      clear_obj(ho_Image);
      /***/get_dl_sample_image(&ho_Image, hv_SampleKeys, hv_DLSample, TTemp[SP-1]);
      destroy_tuple(TTemp[--SP]);

      /**/
      /*Get or open next window.*/
      /*get_image_size (Image, WidthImage, HeightImage)*/
      destroy_tuple(hv_WidthImage);
      destroy_tuple(hv_HeightImage);
      /***/T_get_image_size(ho_Image, &hv_WidthImage, &hv_HeightImage);

      /*get_next_window (__get_dict_tuple( Params, ['font']), __get_dict_tuple( Params, ['font_size']), __get_dict_tuple( Params, ['display_bottom_desc']), WidthImage, HeightImage, 0, __get_dict_tuple( Params, ['scale_windows']), __get_dict_tuple( Params, ['threshold_width']), PrevWindowCoordinates, WindowHandleDict, KeysForDisplay[KeyIndex], CurrentWindowHandle, WindowImageRatio, PrevWindowCoordinates)*/
      create_tuple_s(&TTemp[SP++],"font");
      T_get_dict_tuple(hv_Params,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      create_tuple_s(&TTemp[SP++],"font_size");
      T_get_dict_tuple(hv_Params,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      create_tuple_s(&TTemp[SP++],"display_bottom_desc");
      T_get_dict_tuple(hv_Params,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      create_tuple_i(&TTemp[SP++],0);
      create_tuple_s(&TTemp[SP++],"scale_windows");
      T_get_dict_tuple(hv_Params,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      create_tuple_s(&TTemp[SP++],"threshold_width");
      T_get_dict_tuple(hv_Params,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      copy_tuple(hv_PrevWindowCoordinates,&TTemp[SP++]);
      T_tuple_select(hv_KeysForDisplay_COPY_INP_TMP,hv_KeyIndex,&TTemp[SP++]);
      destroy_tuple(hv_CurrentWindowHandle);
      destroy_tuple(hv_WindowImageRatio);
      destroy_tuple(hv_PrevWindowCoordinates);
      /***/get_next_window(TTemp[SP-8], TTemp[SP-7], TTemp[SP-6], hv_WidthImage, 
          hv_HeightImage, TTemp[SP-5], TTemp[SP-4], TTemp[SP-3], TTemp[SP-2], hv_WindowHandleDict, 
          TTemp[SP-1], &hv_CurrentWindowHandle, &hv_WindowImageRatio, &hv_PrevWindowCoordinates);
      destroy_tuple(TTemp[--SP]);
      destroy_tuple(TTemp[--SP]);
      destroy_tuple(TTemp[--SP]);
      destroy_tuple(TTemp[--SP]);
      destroy_tuple(TTemp[--SP]);
      destroy_tuple(TTemp[--SP]);
      destroy_tuple(TTemp[--SP]);
      destroy_tuple(TTemp[--SP]);

      /**/
      /*========== if (IsOCRDetection) ==========*/
      copy_tuple(hv_IsOCRDetection,&TTemp[SP++]);
      if(get_i(TTemp[SP-1],0))
      {
        /*full_domain (Image, Image)*/
        /***/full_domain(ho_Image, &(OTemp[SPO]));
        SPO++;
        clear_obj(ho_Image);
        ho_Image = OTemp[--SPO];

      }
      destroy_tuple(TTemp[--SP]);
      /*========== end if ==========*/
      if (hdev_window_stack_is_open())
      {
        Htuple active_win;
        create_tuple(&active_win,0);
        hdev_window_stack_get_active(&active_win);
        /*dev_display (Image)*/
        /***/T_disp_obj(ho_Image, active_win);
        destroy_tuple(active_win);
      }
      /**/
      /*Visualization.*/
      /**/
      /*DisplayDirectionTemp := __get_dict_tuple( Params, ['display_direction'])*/
      create_tuple_s(&TTemp[SP++],"display_direction");
      T_get_dict_tuple(hv_Params,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      destroy_tuple(hv_DisplayDirectionTemp);
      hv_DisplayDirectionTemp=TTemp[--SP];

      /*========== if (__get_dict_tuple( Params, ['display_direction']) and IsOCRDetection) ==========*/
      create_tuple_s(&TTemp[SP++],"display_direction");
      T_get_dict_tuple(hv_Params,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      T_tuple_and(TTemp[SP-1],hv_IsOCRDetection,&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      if(get_i(TTemp[SP-1],0))
      {
        /*DisplayDirectionTemp := -1*/
        reuse_tuple_i(&hv_DisplayDirectionTemp,-1);

      }
      destroy_tuple(TTemp[--SP]);
      /*========== end if ==========*/
      /*dev_display_ground_truth_detection (DLSample, SampleKeys, __get_dict_tuple( Params, ['line_width']), ClassIDs, Colors, __get_dict_tuple( Params, ['bbox_label_color']), WindowImageRatio, __get_dict_tuple( Params, ['bbox_text_color']), __get_dict_tuple( Params, ['display_labels']), DisplayDirectionTemp, CurrentWindowHandle, BboxLabelIndex)*/
      create_tuple_s(&TTemp[SP++],"line_width");
      T_get_dict_tuple(hv_Params,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      create_tuple_s(&TTemp[SP++],"bbox_label_color");
      T_get_dict_tuple(hv_Params,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      create_tuple_s(&TTemp[SP++],"bbox_text_color");
      T_get_dict_tuple(hv_Params,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      create_tuple_s(&TTemp[SP++],"display_labels");
      T_get_dict_tuple(hv_Params,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      destroy_tuple(hv_BboxLabelIndex);
      /***/dev_display_ground_truth_detection(hv_DLSample, hv_SampleKeys, TTemp[SP-4], 
          hv_ClassIDs, hv_Colors, TTemp[SP-3], hv_WindowImageRatio, TTemp[SP-2], 
          TTemp[SP-1], hv_DisplayDirectionTemp, hv_CurrentWindowHandle, &hv_BboxLabelIndex);
      destroy_tuple(TTemp[--SP]);
      destroy_tuple(TTemp[--SP]);
      destroy_tuple(TTemp[--SP]);
      destroy_tuple(TTemp[--SP]);

      /*========== if (find(ResultKeys,'bbox_confidence') != -1) ==========*/
      create_tuple_s(&TTemp[SP++],"bbox_confidence");
      T_tuple_find(hv_ResultKeys,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      create_tuple_i(&TTemp[SP++],-1);
      T_tuple_not_equal(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-2]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-2]=TTemp[SP];
      SP--;
      if(get_i(TTemp[SP-1],0))
      {
        /*get_dict_tuple (DLResult, 'bbox_confidence', BboxConfidences)*/
        create_tuple_s(&TTemp[SP++],"bbox_confidence");
        destroy_tuple(hv_BboxConfidences);
        /***/T_get_dict_tuple(hv_DLResult_COPY_INP_TMP, TTemp[SP-1], &hv_BboxConfidences);
        destroy_tuple(TTemp[--SP]);

      }
      else
      {
        /* throw(...); only in hdevelop*/
      }
      destroy_tuple(TTemp[--SP]);
      /*========== end if ==========*/
      /*========== if (__get_dict_tuple( Params, ['bbox_display_confidence'])) ==========*/
      create_tuple_s(&TTemp[SP++],"bbox_display_confidence");
      T_get_dict_tuple(hv_Params,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      if(get_i(TTemp[SP-1],0))
      {
        /*TextConf := ' (' + BboxConfidences$'.2f' + ')'*/
        create_tuple_s(&TTemp[SP++]," (");
        create_tuple_s(&TTemp[SP++],".2f");
        T_tuple_string(hv_BboxConfidences,TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-1]=TTemp[SP];
        T_tuple_add(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-2]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-2]=TTemp[SP];
        SP--;
        create_tuple_s(&TTemp[SP++],")");
        T_tuple_add(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-2]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-2]=TTemp[SP];
        SP--;
        destroy_tuple(hv_TextConf);
        hv_TextConf=TTemp[--SP];

      }
      else
      {
        /*TextConf := gen_tuple_const(|BboxConfidences|,'')*/
        T_tuple_length(hv_BboxConfidences,&TTemp[SP++]);
        create_tuple_s(&TTemp[SP++],"");
        T_tuple_gen_const(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-2]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-2]=TTemp[SP];
        SP--;
        destroy_tuple(hv_TextConf);
        hv_TextConf=TTemp[--SP];

      }
      destroy_tuple(TTemp[--SP]);
      /*========== end if ==========*/
      /*dev_display_result_detection (DLResult, ResultKeys, __get_dict_tuple( Params, ['line_width']), ClassIDs, TextConf, Colors, __get_dict_tuple( Params, ['bbox_label_color']), WindowImageRatio, 'bottom', __get_dict_tuple( Params, ['bbox_text_color']), __get_dict_tuple( Params, ['display_labels']), DisplayDirectionTemp, CurrentWindowHandle, BboxClassIndex)*/
      create_tuple_s(&TTemp[SP++],"line_width");
      T_get_dict_tuple(hv_Params,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      create_tuple_s(&TTemp[SP++],"bbox_label_color");
      T_get_dict_tuple(hv_Params,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      create_tuple_s(&TTemp[SP++],"bottom");
      create_tuple_s(&TTemp[SP++],"bbox_text_color");
      T_get_dict_tuple(hv_Params,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      create_tuple_s(&TTemp[SP++],"display_labels");
      T_get_dict_tuple(hv_Params,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      destroy_tuple(hv_BboxClassIndex);
      /***/dev_display_result_detection(hv_DLResult_COPY_INP_TMP, hv_ResultKeys, 
          TTemp[SP-5], hv_ClassIDs, hv_TextConf, hv_Colors, TTemp[SP-4], hv_WindowImageRatio, 
          TTemp[SP-3], TTemp[SP-2], TTemp[SP-1], hv_DisplayDirectionTemp, hv_CurrentWindowHandle, 
          &hv_BboxClassIndex);
      destroy_tuple(TTemp[--SP]);
      destroy_tuple(TTemp[--SP]);
      destroy_tuple(TTemp[--SP]);
      destroy_tuple(TTemp[--SP]);
      destroy_tuple(TTemp[--SP]);

      /*Text := 'Ground truth and results ' + ImageIDStringBraces*/
      create_tuple_s(&TTemp[SP++],"Ground truth and results ");
      T_tuple_add(TTemp[SP-1],hv_ImageIDStringBraces,&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      destroy_tuple(hv_Text);
      hv_Text=TTemp[--SP];

      /*========== if (__get_dict_tuple( Params, ['display_bottom_desc'])) ==========*/
      create_tuple_s(&TTemp[SP++],"display_bottom_desc");
      T_get_dict_tuple(hv_Params,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      if(get_i(TTemp[SP-1],0))
      {
        if (hdev_window_stack_is_open())
        {
          Htuple active_win;
          create_tuple(&active_win,0);
          hdev_window_stack_get_active(&active_win);
          /*dev_disp_text (Text, 'window', 'bottom', 'left', 'white', 'box', 'false')*/
          create_tuple_s(&TTemp[SP++],"window");
          create_tuple_s(&TTemp[SP++],"bottom");
          create_tuple_s(&TTemp[SP++],"left");
          create_tuple_s(&TTemp[SP++],"white");
          create_tuple_s(&TTemp[SP++],"box");
          create_tuple_s(&TTemp[SP++],"false");
          /***/T_disp_text(active_win,hv_Text, TTemp[SP-6], TTemp[SP-5], TTemp[SP-4], 
              TTemp[SP-3], TTemp[SP-2], TTemp[SP-1]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(active_win);
        }
      }
      destroy_tuple(TTemp[--SP]);
      /*========== end if ==========*/
      /*Text := 'Ground truth and'*/
      reuse_tuple_s(&hv_Text,"Ground truth and");
      /*Text[|Text|] := 'results ' + ImageIDStringBraces*/
      copy_tuple(hv_Text,&TTemp[SP++]);
      T_tuple_length(TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      create_tuple_s(&TTemp[SP++],"results ");
      T_tuple_add(TTemp[SP-1],hv_ImageIDStringBraces,&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      replace_elements(&hv_Text,&TTemp[SP-2],&TTemp[SP-1]);
      destroy_tuple(TTemp[--SP]);
      destroy_tuple(TTemp[--SP]);
      /**/
      /*Display the legend.*/
      /*========== if (__get_dict_tuple( Params, ['display_legend'])) ==========*/
      create_tuple_s(&TTemp[SP++],"display_legend");
      T_get_dict_tuple(hv_Params,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      if(get_i(TTemp[SP-1],0))
      {
        /*BboxColorsBoth := ['white', 'white']*/
        create_tuple(&TTemp[SP++],2);
        set_s(TTemp[SP-1],"white",0);
        set_s(TTemp[SP-1],"white",1);
        destroy_tuple(hv_BboxColorsBoth);
        hv_BboxColorsBoth=TTemp[--SP];

        /*========== if (|BboxClassIndex| + |BboxLabelIndex| > 0) ==========*/
        T_tuple_length(hv_BboxClassIndex,&TTemp[SP++]);
        T_tuple_length(hv_BboxLabelIndex,&TTemp[SP++]);
        T_tuple_add(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-2]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-2]=TTemp[SP];
        SP--;
        create_tuple_i(&TTemp[SP++],0);
        T_tuple_greater(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-2]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-2]=TTemp[SP];
        SP--;
        if(get_i(TTemp[SP-1],0))
        {
          /*BboxClassLabelIndexUniq := uniq(sort([BboxClassIndex,BboxLabelIndex]))*/
          T_tuple_concat(hv_BboxClassIndex,hv_BboxLabelIndex,&TTemp[SP++]);
          T_tuple_sort(TTemp[SP-1],&TTemp[SP]);
          destroy_tuple(TTemp[SP-1]);
          TTemp[SP-1]=TTemp[SP];
          T_tuple_uniq(TTemp[SP-1],&TTemp[SP]);
          destroy_tuple(TTemp[SP-1]);
          TTemp[SP-1]=TTemp[SP];
          destroy_tuple(hv_BboxClassLabelIndexUniq);
          hv_BboxClassLabelIndexUniq=TTemp[--SP];

          /*Text := [Text,ClassesLegend[BboxClassLabelIndexUniq]]*/
          copy_tuple(hv_Text,&TTemp[SP++]);
          T_tuple_select(hv_ClassesLegend,hv_BboxClassLabelIndexUniq,&TTemp[SP++]);
          T_tuple_concat(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
          destroy_tuple(TTemp[SP-2]);
          destroy_tuple(TTemp[SP-1]);
          TTemp[SP-2]=TTemp[SP];
          SP--;
          destroy_tuple(hv_Text);
          hv_Text=TTemp[--SP];

          /*BboxColorsBoth := [BboxColorsBoth,Colors[BboxClassLabelIndexUniq]]*/
          copy_tuple(hv_BboxColorsBoth,&TTemp[SP++]);
          T_tuple_select(hv_Colors,hv_BboxClassLabelIndexUniq,&TTemp[SP++]);
          T_tuple_concat(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
          destroy_tuple(TTemp[SP-2]);
          destroy_tuple(TTemp[SP-1]);
          TTemp[SP-2]=TTemp[SP];
          SP--;
          destroy_tuple(hv_BboxColorsBoth);
          hv_BboxColorsBoth=TTemp[--SP];

        }
        else
        {
          /*Text := [Text,'No ground truth nor results present.']*/
          copy_tuple(hv_Text,&TTemp[SP++]);
          create_tuple_s(&TTemp[SP++],"No ground truth nor results present.");
          T_tuple_concat(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
          destroy_tuple(TTemp[SP-2]);
          destroy_tuple(TTemp[SP-1]);
          TTemp[SP-2]=TTemp[SP];
          SP--;
          destroy_tuple(hv_Text);
          hv_Text=TTemp[--SP];

        }
        destroy_tuple(TTemp[--SP]);
        /*========== end if ==========*/
        /**/
        /*Get or open next child window.*/
        /*get_child_window (HeightImage, __get_dict_tuple( Params, ['font']), __get_dict_tuple( Params, ['font_size']), Text, PrevWindowCoordinates, WindowHandleDict, KeysForDisplay[KeyIndex], WindowImageRatio, PrevWindowCoordinates)*/
        create_tuple_s(&TTemp[SP++],"font");
        T_get_dict_tuple(hv_Params,TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-1]=TTemp[SP];
        create_tuple_s(&TTemp[SP++],"font_size");
        T_get_dict_tuple(hv_Params,TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-1]=TTemp[SP];
        copy_tuple(hv_PrevWindowCoordinates,&TTemp[SP++]);
        T_tuple_select(hv_KeysForDisplay_COPY_INP_TMP,hv_KeyIndex,&TTemp[SP++]);
        destroy_tuple(hv_WindowImageRatio);
        destroy_tuple(hv_PrevWindowCoordinates);
        /***/get_child_window(hv_HeightImage, TTemp[SP-4], TTemp[SP-3], hv_Text, 
            TTemp[SP-2], hv_WindowHandleDict, TTemp[SP-1], &hv_WindowImageRatio, 
            &hv_PrevWindowCoordinates);
        destroy_tuple(TTemp[--SP]);
        destroy_tuple(TTemp[--SP]);
        destroy_tuple(TTemp[--SP]);
        destroy_tuple(TTemp[--SP]);

        if (hdev_window_stack_is_open())
        {
          Htuple active_win;
          create_tuple(&active_win,0);
          hdev_window_stack_get_active(&active_win);
          /*dev_disp_text (Text, 'window', 'top', 'left', BboxColorsBoth, 'box', 'false')*/
          create_tuple_s(&TTemp[SP++],"window");
          create_tuple_s(&TTemp[SP++],"top");
          create_tuple_s(&TTemp[SP++],"left");
          create_tuple_s(&TTemp[SP++],"box");
          create_tuple_s(&TTemp[SP++],"false");
          /***/T_disp_text(active_win,hv_Text, TTemp[SP-5], TTemp[SP-4], TTemp[SP-3], 
              hv_BboxColorsBoth, TTemp[SP-2], TTemp[SP-1]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(active_win);
        }
      }
      destroy_tuple(TTemp[--SP]);
      /*========== end if ==========*/
    }
    else
    {
    destroy_tuple(TTemp[--SP]);
    /*========== elseif (KeysForDisplay[KeyIndex] == 'bbox_ground_truth' or KeysForDisplay[KeyIndex] == 'ocr_detection_ground_truth') ==========*/

    T_tuple_select(hv_KeysForDisplay_COPY_INP_TMP,hv_KeyIndex,&TTemp[SP++]);
    create_tuple_s(&TTemp[SP++],"bbox_ground_truth");
    T_tuple_equal(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-2]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-2]=TTemp[SP];
    SP--;
    T_tuple_select(hv_KeysForDisplay_COPY_INP_TMP,hv_KeyIndex,&TTemp[SP++]);
    create_tuple_s(&TTemp[SP++],"ocr_detection_ground_truth");
    T_tuple_equal(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-2]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-2]=TTemp[SP];
    SP--;
    T_tuple_or(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-2]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-2]=TTemp[SP];
    SP--;
    if(get_i(TTemp[SP-1],0))
    {
      /**/
      /*Sample bounding boxes on image.*/
      /*get_dl_sample_image (Image, SampleKeys, DLSample, 'image')*/
      create_tuple_s(&TTemp[SP++],"image");
      clear_obj(ho_Image);
      /***/get_dl_sample_image(&ho_Image, hv_SampleKeys, hv_DLSample, TTemp[SP-1]);
      destroy_tuple(TTemp[--SP]);

      /**/
      /*Get or open next window.*/
      /*get_image_size (Image, WidthImage, HeightImage)*/
      destroy_tuple(hv_WidthImage);
      destroy_tuple(hv_HeightImage);
      /***/T_get_image_size(ho_Image, &hv_WidthImage, &hv_HeightImage);

      /*get_next_window (__get_dict_tuple( Params, ['font']), __get_dict_tuple( Params, ['font_size']), __get_dict_tuple( Params, ['display_bottom_desc']), WidthImage, HeightImage, 0, __get_dict_tuple( Params, ['scale_windows']), __get_dict_tuple( Params, ['threshold_width']), PrevWindowCoordinates, WindowHandleDict, KeysForDisplay[KeyIndex], CurrentWindowHandle, WindowImageRatio, PrevWindowCoordinates)*/
      create_tuple_s(&TTemp[SP++],"font");
      T_get_dict_tuple(hv_Params,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      create_tuple_s(&TTemp[SP++],"font_size");
      T_get_dict_tuple(hv_Params,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      create_tuple_s(&TTemp[SP++],"display_bottom_desc");
      T_get_dict_tuple(hv_Params,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      create_tuple_i(&TTemp[SP++],0);
      create_tuple_s(&TTemp[SP++],"scale_windows");
      T_get_dict_tuple(hv_Params,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      create_tuple_s(&TTemp[SP++],"threshold_width");
      T_get_dict_tuple(hv_Params,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      copy_tuple(hv_PrevWindowCoordinates,&TTemp[SP++]);
      T_tuple_select(hv_KeysForDisplay_COPY_INP_TMP,hv_KeyIndex,&TTemp[SP++]);
      destroy_tuple(hv_CurrentWindowHandle);
      destroy_tuple(hv_WindowImageRatio);
      destroy_tuple(hv_PrevWindowCoordinates);
      /***/get_next_window(TTemp[SP-8], TTemp[SP-7], TTemp[SP-6], hv_WidthImage, 
          hv_HeightImage, TTemp[SP-5], TTemp[SP-4], TTemp[SP-3], TTemp[SP-2], hv_WindowHandleDict, 
          TTemp[SP-1], &hv_CurrentWindowHandle, &hv_WindowImageRatio, &hv_PrevWindowCoordinates);
      destroy_tuple(TTemp[--SP]);
      destroy_tuple(TTemp[--SP]);
      destroy_tuple(TTemp[--SP]);
      destroy_tuple(TTemp[--SP]);
      destroy_tuple(TTemp[--SP]);
      destroy_tuple(TTemp[--SP]);
      destroy_tuple(TTemp[--SP]);
      destroy_tuple(TTemp[--SP]);

      /**/
      /*Visualization.*/
      /*========== if (IsOCRDetection) ==========*/
      copy_tuple(hv_IsOCRDetection,&TTemp[SP++]);
      if(get_i(TTemp[SP-1],0))
      {
        /*full_domain (Image, Image)*/
        /***/full_domain(ho_Image, &(OTemp[SPO]));
        SPO++;
        clear_obj(ho_Image);
        ho_Image = OTemp[--SPO];

      }
      destroy_tuple(TTemp[--SP]);
      /*========== end if ==========*/
      if (hdev_window_stack_is_open())
      {
        Htuple active_win;
        create_tuple(&active_win,0);
        hdev_window_stack_get_active(&active_win);
        /*dev_display (Image)*/
        /***/T_disp_obj(ho_Image, active_win);
        destroy_tuple(active_win);
      }
      /**/
      /*Display smaller arrow for ocr_detection*/
      /*DisplayDirectionTemp := __get_dict_tuple( Params, ['display_direction'])*/
      create_tuple_s(&TTemp[SP++],"display_direction");
      T_get_dict_tuple(hv_Params,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      destroy_tuple(hv_DisplayDirectionTemp);
      hv_DisplayDirectionTemp=TTemp[--SP];

      /*========== if (__get_dict_tuple( Params, ['display_direction']) and IsOCRDetection) ==========*/
      create_tuple_s(&TTemp[SP++],"display_direction");
      T_get_dict_tuple(hv_Params,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      T_tuple_and(TTemp[SP-1],hv_IsOCRDetection,&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      if(get_i(TTemp[SP-1],0))
      {
        /*DisplayDirectionTemp := -1*/
        reuse_tuple_i(&hv_DisplayDirectionTemp,-1);

      }
      destroy_tuple(TTemp[--SP]);
      /*========== end if ==========*/
      /**/
      /*dev_display_ground_truth_detection (DLSample, SampleKeys, __get_dict_tuple( Params, ['line_width']), ClassIDs, Colors, __get_dict_tuple( Params, ['bbox_label_color']), WindowImageRatio, __get_dict_tuple( Params, ['bbox_text_color']), __get_dict_tuple( Params, ['display_labels']), DisplayDirectionTemp, CurrentWindowHandle, BboxIDs)*/
      create_tuple_s(&TTemp[SP++],"line_width");
      T_get_dict_tuple(hv_Params,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      create_tuple_s(&TTemp[SP++],"bbox_label_color");
      T_get_dict_tuple(hv_Params,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      create_tuple_s(&TTemp[SP++],"bbox_text_color");
      T_get_dict_tuple(hv_Params,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      create_tuple_s(&TTemp[SP++],"display_labels");
      T_get_dict_tuple(hv_Params,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      destroy_tuple(hv_BboxIDs);
      /***/dev_display_ground_truth_detection(hv_DLSample, hv_SampleKeys, TTemp[SP-4], 
          hv_ClassIDs, hv_Colors, TTemp[SP-3], hv_WindowImageRatio, TTemp[SP-2], 
          TTemp[SP-1], hv_DisplayDirectionTemp, hv_CurrentWindowHandle, &hv_BboxIDs);
      destroy_tuple(TTemp[--SP]);
      destroy_tuple(TTemp[--SP]);
      destroy_tuple(TTemp[--SP]);
      destroy_tuple(TTemp[--SP]);

      /*Text := 'Ground truth ' + ImageIDStringBraces*/
      create_tuple_s(&TTemp[SP++],"Ground truth ");
      T_tuple_add(TTemp[SP-1],hv_ImageIDStringBraces,&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      destroy_tuple(hv_Text);
      hv_Text=TTemp[--SP];

      /*========== if (__get_dict_tuple( Params, ['display_bottom_desc'])) ==========*/
      create_tuple_s(&TTemp[SP++],"display_bottom_desc");
      T_get_dict_tuple(hv_Params,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      if(get_i(TTemp[SP-1],0))
      {
        if (hdev_window_stack_is_open())
        {
          Htuple active_win;
          create_tuple(&active_win,0);
          hdev_window_stack_get_active(&active_win);
          /*dev_disp_text (Text, 'window', 'bottom', 'left', 'white', 'box', 'false')*/
          create_tuple_s(&TTemp[SP++],"window");
          create_tuple_s(&TTemp[SP++],"bottom");
          create_tuple_s(&TTemp[SP++],"left");
          create_tuple_s(&TTemp[SP++],"white");
          create_tuple_s(&TTemp[SP++],"box");
          create_tuple_s(&TTemp[SP++],"false");
          /***/T_disp_text(active_win,hv_Text, TTemp[SP-6], TTemp[SP-5], TTemp[SP-4], 
              TTemp[SP-3], TTemp[SP-2], TTemp[SP-1]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(active_win);
        }
      }
      destroy_tuple(TTemp[--SP]);
      /*========== end if ==========*/
      /**/
      /*Display the legend.*/
      /**/
      /*========== if (__get_dict_tuple( Params, ['display_legend'])) ==========*/
      create_tuple_s(&TTemp[SP++],"display_legend");
      T_get_dict_tuple(hv_Params,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      if(get_i(TTemp[SP-1],0))
      {
        /*BboxColors := 'white'*/
        reuse_tuple_s(&hv_BboxColors,"white");
        /*========== if (|BboxIDs|) ==========*/
        T_tuple_length(hv_BboxIDs,&TTemp[SP++]);
        if(get_i(TTemp[SP-1],0))
        {
          /*BboxIDsUniq := uniq(sort(BboxIDs))*/
          T_tuple_sort(hv_BboxIDs,&TTemp[SP++]);
          T_tuple_uniq(TTemp[SP-1],&TTemp[SP]);
          destroy_tuple(TTemp[SP-1]);
          TTemp[SP-1]=TTemp[SP];
          destroy_tuple(hv_BboxIDsUniq);
          hv_BboxIDsUniq=TTemp[--SP];

          /*Text := [Text,ClassesLegend[BboxIDsUniq]]*/
          copy_tuple(hv_Text,&TTemp[SP++]);
          T_tuple_select(hv_ClassesLegend,hv_BboxIDsUniq,&TTemp[SP++]);
          T_tuple_concat(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
          destroy_tuple(TTemp[SP-2]);
          destroy_tuple(TTemp[SP-1]);
          TTemp[SP-2]=TTemp[SP];
          SP--;
          destroy_tuple(hv_Text);
          hv_Text=TTemp[--SP];

          /*BboxColors := [BboxColors,Colors[BboxIDsUniq]]*/
          copy_tuple(hv_BboxColors,&TTemp[SP++]);
          T_tuple_select(hv_Colors,hv_BboxIDsUniq,&TTemp[SP++]);
          T_tuple_concat(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
          destroy_tuple(TTemp[SP-2]);
          destroy_tuple(TTemp[SP-1]);
          TTemp[SP-2]=TTemp[SP];
          SP--;
          destroy_tuple(hv_BboxColors);
          hv_BboxColors=TTemp[--SP];

        }
        else
        {
          /*Text := [Text,'No ground truth present.']*/
          copy_tuple(hv_Text,&TTemp[SP++]);
          create_tuple_s(&TTemp[SP++],"No ground truth present.");
          T_tuple_concat(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
          destroy_tuple(TTemp[SP-2]);
          destroy_tuple(TTemp[SP-1]);
          TTemp[SP-2]=TTemp[SP];
          SP--;
          destroy_tuple(hv_Text);
          hv_Text=TTemp[--SP];

        }
        destroy_tuple(TTemp[--SP]);
        /*========== end if ==========*/
        /**/
        /*Get or open next child window.*/
        /*get_child_window (HeightImage, __get_dict_tuple( Params, ['font']), __get_dict_tuple( Params, ['font_size']), Text, PrevWindowCoordinates, WindowHandleDict, KeysForDisplay[KeyIndex], WindowImageRatio, PrevWindowCoordinates)*/
        create_tuple_s(&TTemp[SP++],"font");
        T_get_dict_tuple(hv_Params,TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-1]=TTemp[SP];
        create_tuple_s(&TTemp[SP++],"font_size");
        T_get_dict_tuple(hv_Params,TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-1]=TTemp[SP];
        copy_tuple(hv_PrevWindowCoordinates,&TTemp[SP++]);
        T_tuple_select(hv_KeysForDisplay_COPY_INP_TMP,hv_KeyIndex,&TTemp[SP++]);
        destroy_tuple(hv_WindowImageRatio);
        destroy_tuple(hv_PrevWindowCoordinates);
        /***/get_child_window(hv_HeightImage, TTemp[SP-4], TTemp[SP-3], hv_Text, 
            TTemp[SP-2], hv_WindowHandleDict, TTemp[SP-1], &hv_WindowImageRatio, 
            &hv_PrevWindowCoordinates);
        destroy_tuple(TTemp[--SP]);
        destroy_tuple(TTemp[--SP]);
        destroy_tuple(TTemp[--SP]);
        destroy_tuple(TTemp[--SP]);

        if (hdev_window_stack_is_open())
        {
          Htuple active_win;
          create_tuple(&active_win,0);
          hdev_window_stack_get_active(&active_win);
          /*dev_disp_text (Text, 'window', 'top', 'left', BboxColors, 'box', 'false')*/
          create_tuple_s(&TTemp[SP++],"window");
          create_tuple_s(&TTemp[SP++],"top");
          create_tuple_s(&TTemp[SP++],"left");
          create_tuple_s(&TTemp[SP++],"box");
          create_tuple_s(&TTemp[SP++],"false");
          /***/T_disp_text(active_win,hv_Text, TTemp[SP-5], TTemp[SP-4], TTemp[SP-3], 
              hv_BboxColors, TTemp[SP-2], TTemp[SP-1]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(active_win);
        }
      }
      destroy_tuple(TTemp[--SP]);
      /*========== end if ==========*/
    }
    else
    {
    destroy_tuple(TTemp[--SP]);
    /*========== elseif (KeysForDisplay[KeyIndex] == 'bbox_result' or KeysForDisplay[KeyIndex] == 'ocr_detection_result') ==========*/

    T_tuple_select(hv_KeysForDisplay_COPY_INP_TMP,hv_KeyIndex,&TTemp[SP++]);
    create_tuple_s(&TTemp[SP++],"bbox_result");
    T_tuple_equal(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-2]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-2]=TTemp[SP];
    SP--;
    T_tuple_select(hv_KeysForDisplay_COPY_INP_TMP,hv_KeyIndex,&TTemp[SP++]);
    create_tuple_s(&TTemp[SP++],"ocr_detection_result");
    T_tuple_equal(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-2]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-2]=TTemp[SP];
    SP--;
    T_tuple_or(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-2]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-2]=TTemp[SP];
    SP--;
    if(get_i(TTemp[SP-1],0))
    {
      /**/
      /*Result bounding boxes on image.*/
      /*get_dl_sample_image (Image, SampleKeys, DLSample, 'image')*/
      create_tuple_s(&TTemp[SP++],"image");
      clear_obj(ho_Image);
      /***/get_dl_sample_image(&ho_Image, hv_SampleKeys, hv_DLSample, TTemp[SP-1]);
      destroy_tuple(TTemp[--SP]);

      /**/
      /*Get or open next window.*/
      /*get_image_size (Image, WidthImage, HeightImage)*/
      destroy_tuple(hv_WidthImage);
      destroy_tuple(hv_HeightImage);
      /***/T_get_image_size(ho_Image, &hv_WidthImage, &hv_HeightImage);

      /*get_next_window (__get_dict_tuple( Params, ['font']), __get_dict_tuple( Params, ['font_size']), __get_dict_tuple( Params, ['display_bottom_desc']), WidthImage, HeightImage, 0, __get_dict_tuple( Params, ['scale_windows']), __get_dict_tuple( Params, ['threshold_width']), PrevWindowCoordinates, WindowHandleDict, KeysForDisplay[KeyIndex], CurrentWindowHandle, WindowImageRatio, PrevWindowCoordinates)*/
      create_tuple_s(&TTemp[SP++],"font");
      T_get_dict_tuple(hv_Params,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      create_tuple_s(&TTemp[SP++],"font_size");
      T_get_dict_tuple(hv_Params,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      create_tuple_s(&TTemp[SP++],"display_bottom_desc");
      T_get_dict_tuple(hv_Params,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      create_tuple_i(&TTemp[SP++],0);
      create_tuple_s(&TTemp[SP++],"scale_windows");
      T_get_dict_tuple(hv_Params,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      create_tuple_s(&TTemp[SP++],"threshold_width");
      T_get_dict_tuple(hv_Params,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      copy_tuple(hv_PrevWindowCoordinates,&TTemp[SP++]);
      T_tuple_select(hv_KeysForDisplay_COPY_INP_TMP,hv_KeyIndex,&TTemp[SP++]);
      destroy_tuple(hv_CurrentWindowHandle);
      destroy_tuple(hv_WindowImageRatio);
      destroy_tuple(hv_PrevWindowCoordinates);
      /***/get_next_window(TTemp[SP-8], TTemp[SP-7], TTemp[SP-6], hv_WidthImage, 
          hv_HeightImage, TTemp[SP-5], TTemp[SP-4], TTemp[SP-3], TTemp[SP-2], hv_WindowHandleDict, 
          TTemp[SP-1], &hv_CurrentWindowHandle, &hv_WindowImageRatio, &hv_PrevWindowCoordinates);
      destroy_tuple(TTemp[--SP]);
      destroy_tuple(TTemp[--SP]);
      destroy_tuple(TTemp[--SP]);
      destroy_tuple(TTemp[--SP]);
      destroy_tuple(TTemp[--SP]);
      destroy_tuple(TTemp[--SP]);
      destroy_tuple(TTemp[--SP]);
      destroy_tuple(TTemp[--SP]);

      /**/
      /*Visualization.*/
      /*========== if (IsOCRDetection) ==========*/
      copy_tuple(hv_IsOCRDetection,&TTemp[SP++]);
      if(get_i(TTemp[SP-1],0))
      {
        /*full_domain (Image, Image)*/
        /***/full_domain(ho_Image, &(OTemp[SPO]));
        SPO++;
        clear_obj(ho_Image);
        ho_Image = OTemp[--SPO];

      }
      destroy_tuple(TTemp[--SP]);
      /*========== end if ==========*/
      if (hdev_window_stack_is_open())
      {
        Htuple active_win;
        create_tuple(&active_win,0);
        hdev_window_stack_get_active(&active_win);
        /*dev_display (Image)*/
        /***/T_disp_obj(ho_Image, active_win);
        destroy_tuple(active_win);
      }
      /**/
      /*Display smaller arrow for ocr_detection*/
      /*DisplayDirectionTemp := __get_dict_tuple( Params, ['display_direction'])*/
      create_tuple_s(&TTemp[SP++],"display_direction");
      T_get_dict_tuple(hv_Params,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      destroy_tuple(hv_DisplayDirectionTemp);
      hv_DisplayDirectionTemp=TTemp[--SP];

      /*========== if (__get_dict_tuple( Params, ['display_direction']) and IsOCRDetection) ==========*/
      create_tuple_s(&TTemp[SP++],"display_direction");
      T_get_dict_tuple(hv_Params,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      T_tuple_and(TTemp[SP-1],hv_IsOCRDetection,&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      if(get_i(TTemp[SP-1],0))
      {
        /*DisplayDirectionTemp := -1*/
        reuse_tuple_i(&hv_DisplayDirectionTemp,-1);

      }
      destroy_tuple(TTemp[--SP]);
      /*========== end if ==========*/
      /**/
      /*========== if (find(ResultKeys,'bbox_confidence') != -1) ==========*/
      create_tuple_s(&TTemp[SP++],"bbox_confidence");
      T_tuple_find(hv_ResultKeys,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      create_tuple_i(&TTemp[SP++],-1);
      T_tuple_not_equal(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-2]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-2]=TTemp[SP];
      SP--;
      if(get_i(TTemp[SP-1],0))
      {
        /*get_dict_tuple (DLResult, 'bbox_confidence', BboxConfidences)*/
        create_tuple_s(&TTemp[SP++],"bbox_confidence");
        destroy_tuple(hv_BboxConfidences);
        /***/T_get_dict_tuple(hv_DLResult_COPY_INP_TMP, TTemp[SP-1], &hv_BboxConfidences);
        destroy_tuple(TTemp[--SP]);

      }
      else
      {
        /* throw(...); only in hdevelop*/
      }
      destroy_tuple(TTemp[--SP]);
      /*========== end if ==========*/
      /*========== if (__get_dict_tuple( Params, ['bbox_display_confidence'])) ==========*/
      create_tuple_s(&TTemp[SP++],"bbox_display_confidence");
      T_get_dict_tuple(hv_Params,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      if(get_i(TTemp[SP-1],0))
      {
        /*TextConf := ' (' + BboxConfidences$'.2f' + ')'*/
        create_tuple_s(&TTemp[SP++]," (");
        create_tuple_s(&TTemp[SP++],".2f");
        T_tuple_string(hv_BboxConfidences,TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-1]=TTemp[SP];
        T_tuple_add(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-2]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-2]=TTemp[SP];
        SP--;
        create_tuple_s(&TTemp[SP++],")");
        T_tuple_add(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-2]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-2]=TTemp[SP];
        SP--;
        destroy_tuple(hv_TextConf);
        hv_TextConf=TTemp[--SP];

      }
      else
      {
        /*TextConf := gen_tuple_const(|BboxConfidences|,'')*/
        T_tuple_length(hv_BboxConfidences,&TTemp[SP++]);
        create_tuple_s(&TTemp[SP++],"");
        T_tuple_gen_const(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-2]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-2]=TTemp[SP];
        SP--;
        destroy_tuple(hv_TextConf);
        hv_TextConf=TTemp[--SP];

      }
      destroy_tuple(TTemp[--SP]);
      /*========== end if ==========*/
      /*dev_display_result_detection (DLResult, ResultKeys, __get_dict_tuple( Params, ['line_width']), ClassIDs, TextConf, Colors, __get_dict_tuple( Params, ['bbox_label_color']), WindowImageRatio, 'top', __get_dict_tuple( Params, ['bbox_text_color']), __get_dict_tuple( Params, ['display_labels']), DisplayDirectionTemp, CurrentWindowHandle, BboxClassIndex)*/
      create_tuple_s(&TTemp[SP++],"line_width");
      T_get_dict_tuple(hv_Params,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      create_tuple_s(&TTemp[SP++],"bbox_label_color");
      T_get_dict_tuple(hv_Params,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      create_tuple_s(&TTemp[SP++],"top");
      create_tuple_s(&TTemp[SP++],"bbox_text_color");
      T_get_dict_tuple(hv_Params,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      create_tuple_s(&TTemp[SP++],"display_labels");
      T_get_dict_tuple(hv_Params,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      destroy_tuple(hv_BboxClassIndex);
      /***/dev_display_result_detection(hv_DLResult_COPY_INP_TMP, hv_ResultKeys, 
          TTemp[SP-5], hv_ClassIDs, hv_TextConf, hv_Colors, TTemp[SP-4], hv_WindowImageRatio, 
          TTemp[SP-3], TTemp[SP-2], TTemp[SP-1], hv_DisplayDirectionTemp, hv_CurrentWindowHandle, 
          &hv_BboxClassIndex);
      destroy_tuple(TTemp[--SP]);
      destroy_tuple(TTemp[--SP]);
      destroy_tuple(TTemp[--SP]);
      destroy_tuple(TTemp[--SP]);
      destroy_tuple(TTemp[--SP]);

      /*Text := 'Result ' + ImageIDStringBraces*/
      create_tuple_s(&TTemp[SP++],"Result ");
      T_tuple_add(TTemp[SP-1],hv_ImageIDStringBraces,&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      destroy_tuple(hv_Text);
      hv_Text=TTemp[--SP];

      /*========== if (__get_dict_tuple( Params, ['display_bottom_desc'])) ==========*/
      create_tuple_s(&TTemp[SP++],"display_bottom_desc");
      T_get_dict_tuple(hv_Params,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      if(get_i(TTemp[SP-1],0))
      {
        if (hdev_window_stack_is_open())
        {
          Htuple active_win;
          create_tuple(&active_win,0);
          hdev_window_stack_get_active(&active_win);
          /*dev_disp_text (Text, 'window', 'bottom', 'left', 'white', 'box', 'false')*/
          create_tuple_s(&TTemp[SP++],"window");
          create_tuple_s(&TTemp[SP++],"bottom");
          create_tuple_s(&TTemp[SP++],"left");
          create_tuple_s(&TTemp[SP++],"white");
          create_tuple_s(&TTemp[SP++],"box");
          create_tuple_s(&TTemp[SP++],"false");
          /***/T_disp_text(active_win,hv_Text, TTemp[SP-6], TTemp[SP-5], TTemp[SP-4], 
              TTemp[SP-3], TTemp[SP-2], TTemp[SP-1]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(active_win);
        }
      }
      destroy_tuple(TTemp[--SP]);
      /*========== end if ==========*/
      /**/
      /*Display the legend.*/
      /*========== if (__get_dict_tuple( Params, ['display_legend'])) ==========*/
      create_tuple_s(&TTemp[SP++],"display_legend");
      T_get_dict_tuple(hv_Params,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      if(get_i(TTemp[SP-1],0))
      {
        /*BboxColorsResults := 'white'*/
        reuse_tuple_s(&hv_BboxColorsResults,"white");
        /*========== if (|BboxClassIndex| > 0) ==========*/
        T_tuple_length(hv_BboxClassIndex,&TTemp[SP++]);
        create_tuple_i(&TTemp[SP++],0);
        T_tuple_greater(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-2]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-2]=TTemp[SP];
        SP--;
        if(get_i(TTemp[SP-1],0))
        {
          /*BboxClassIndexUniq := uniq(sort(BboxClassIndex))*/
          T_tuple_sort(hv_BboxClassIndex,&TTemp[SP++]);
          T_tuple_uniq(TTemp[SP-1],&TTemp[SP]);
          destroy_tuple(TTemp[SP-1]);
          TTemp[SP-1]=TTemp[SP];
          destroy_tuple(hv_BboxClassIndexUniq);
          hv_BboxClassIndexUniq=TTemp[--SP];

          /*Text := [Text,ClassesLegend[BboxClassIndexUniq]]*/
          copy_tuple(hv_Text,&TTemp[SP++]);
          T_tuple_select(hv_ClassesLegend,hv_BboxClassIndexUniq,&TTemp[SP++]);
          T_tuple_concat(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
          destroy_tuple(TTemp[SP-2]);
          destroy_tuple(TTemp[SP-1]);
          TTemp[SP-2]=TTemp[SP];
          SP--;
          destroy_tuple(hv_Text);
          hv_Text=TTemp[--SP];

          /*BboxColorsResults := [BboxColorsResults,Colors[BboxClassIndexUniq]]*/
          copy_tuple(hv_BboxColorsResults,&TTemp[SP++]);
          T_tuple_select(hv_Colors,hv_BboxClassIndexUniq,&TTemp[SP++]);
          T_tuple_concat(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
          destroy_tuple(TTemp[SP-2]);
          destroy_tuple(TTemp[SP-1]);
          TTemp[SP-2]=TTemp[SP];
          SP--;
          destroy_tuple(hv_BboxColorsResults);
          hv_BboxColorsResults=TTemp[--SP];

        }
        else
        {
          /*Text := [Text,'No results present.']*/
          copy_tuple(hv_Text,&TTemp[SP++]);
          create_tuple_s(&TTemp[SP++],"No results present.");
          T_tuple_concat(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
          destroy_tuple(TTemp[SP-2]);
          destroy_tuple(TTemp[SP-1]);
          TTemp[SP-2]=TTemp[SP];
          SP--;
          destroy_tuple(hv_Text);
          hv_Text=TTemp[--SP];

        }
        destroy_tuple(TTemp[--SP]);
        /*========== end if ==========*/
        /**/
        /*Get or open next child window.*/
        /*get_child_window (HeightImage, __get_dict_tuple( Params, ['font']), __get_dict_tuple( Params, ['font_size']), Text, PrevWindowCoordinates, WindowHandleDict, KeysForDisplay[KeyIndex], WindowImageRatio, PrevWindowCoordinates)*/
        create_tuple_s(&TTemp[SP++],"font");
        T_get_dict_tuple(hv_Params,TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-1]=TTemp[SP];
        create_tuple_s(&TTemp[SP++],"font_size");
        T_get_dict_tuple(hv_Params,TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-1]=TTemp[SP];
        copy_tuple(hv_PrevWindowCoordinates,&TTemp[SP++]);
        T_tuple_select(hv_KeysForDisplay_COPY_INP_TMP,hv_KeyIndex,&TTemp[SP++]);
        destroy_tuple(hv_WindowImageRatio);
        destroy_tuple(hv_PrevWindowCoordinates);
        /***/get_child_window(hv_HeightImage, TTemp[SP-4], TTemp[SP-3], hv_Text, 
            TTemp[SP-2], hv_WindowHandleDict, TTemp[SP-1], &hv_WindowImageRatio, 
            &hv_PrevWindowCoordinates);
        destroy_tuple(TTemp[--SP]);
        destroy_tuple(TTemp[--SP]);
        destroy_tuple(TTemp[--SP]);
        destroy_tuple(TTemp[--SP]);

        if (hdev_window_stack_is_open())
        {
          Htuple active_win;
          create_tuple(&active_win,0);
          hdev_window_stack_get_active(&active_win);
          /*dev_disp_text (Text, 'window', 'top', 'left', BboxColorsResults, 'box', 'false')*/
          create_tuple_s(&TTemp[SP++],"window");
          create_tuple_s(&TTemp[SP++],"top");
          create_tuple_s(&TTemp[SP++],"left");
          create_tuple_s(&TTemp[SP++],"box");
          create_tuple_s(&TTemp[SP++],"false");
          /***/T_disp_text(active_win,hv_Text, TTemp[SP-5], TTemp[SP-4], TTemp[SP-3], 
              hv_BboxColorsResults, TTemp[SP-2], TTemp[SP-1]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(active_win);
        }
      }
      destroy_tuple(TTemp[--SP]);
      /*========== end if ==========*/
    }
    else
    {
    destroy_tuple(TTemp[--SP]);
    /*========== elseif (KeysForDisplay[KeyIndex] == 'ocr_detection_score_map_character' or KeysForDisplay[KeyIndex] == 'ocr_detection_score_map_link' or KeysForDisplay[KeyIndex] == 'ocr_detection_score_map_orientation') ==========*/

    T_tuple_select(hv_KeysForDisplay_COPY_INP_TMP,hv_KeyIndex,&TTemp[SP++]);
    create_tuple_s(&TTemp[SP++],"ocr_detection_score_map_character");
    T_tuple_equal(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-2]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-2]=TTemp[SP];
    SP--;
    T_tuple_select(hv_KeysForDisplay_COPY_INP_TMP,hv_KeyIndex,&TTemp[SP++]);
    create_tuple_s(&TTemp[SP++],"ocr_detection_score_map_link");
    T_tuple_equal(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-2]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-2]=TTemp[SP];
    SP--;
    T_tuple_or(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-2]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-2]=TTemp[SP];
    SP--;
    T_tuple_select(hv_KeysForDisplay_COPY_INP_TMP,hv_KeyIndex,&TTemp[SP++]);
    create_tuple_s(&TTemp[SP++],"ocr_detection_score_map_orientation");
    T_tuple_equal(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-2]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-2]=TTemp[SP];
    SP--;
    T_tuple_or(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-2]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-2]=TTemp[SP];
    SP--;
    if(get_i(TTemp[SP-1],0))
    {
      /**/
      /*Extract score maps*/
      /*ScoreMaps := __get_dict_object( OcrResult, 'score_maps')*/
      create_tuple_s(&TTemp[SP++],"score_maps");
      T_get_dict_object(&OTemp[SPO++],hv_OcrResult,TTemp[SP-1]);
      destroy_tuple(TTemp[SP-1]);
      SP--;
      clear_obj(ho_ScoreMaps);
      ho_ScoreMaps=OTemp[--SPO];

      /*decompose4 (ScoreMaps, CharacterScoreMap, LinkScoreMap, OrientationSinScoreMap, OrientationCosScoreMap)*/
      clear_obj(ho_CharacterScoreMap);
      clear_obj(ho_LinkScoreMap);
      clear_obj(ho_OrientationSinScoreMap);
      clear_obj(ho_OrientationCosScoreMap);
      /***/decompose4(ho_ScoreMaps, &ho_CharacterScoreMap, &ho_LinkScoreMap, &ho_OrientationSinScoreMap, 
          &ho_OrientationCosScoreMap);

      /**/
      /*Select score map to display*/
      /*========== if (KeysForDisplay[KeyIndex] == 'ocr_detection_score_map_character') ==========*/
      T_tuple_select(hv_KeysForDisplay_COPY_INP_TMP,hv_KeyIndex,&TTemp[SP++]);
      create_tuple_s(&TTemp[SP++],"ocr_detection_score_map_character");
      T_tuple_equal(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-2]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-2]=TTemp[SP];
      SP--;
      if(get_i(TTemp[SP-1],0))
      {
        /*ScoreMap := CharacterScoreMap*/
        clear_obj(ho_ScoreMap);
        copy_obj(ho_CharacterScoreMap,&ho_ScoreMap,1,-1);

        /*Text := 'Character score ' + ImageIDStringBraces*/
        create_tuple_s(&TTemp[SP++],"Character score ");
        T_tuple_add(TTemp[SP-1],hv_ImageIDStringBraces,&TTemp[SP]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-1]=TTemp[SP];
        destroy_tuple(hv_Text);
        hv_Text=TTemp[--SP];

      }
      else
      {
      destroy_tuple(TTemp[--SP]);
      /*========== elseif (KeysForDisplay[KeyIndex] == 'ocr_detection_score_map_link') ==========*/

      T_tuple_select(hv_KeysForDisplay_COPY_INP_TMP,hv_KeyIndex,&TTemp[SP++]);
      create_tuple_s(&TTemp[SP++],"ocr_detection_score_map_link");
      T_tuple_equal(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-2]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-2]=TTemp[SP];
      SP--;
      if(get_i(TTemp[SP-1],0))
      {
        /*ScoreMap := LinkScoreMap*/
        clear_obj(ho_ScoreMap);
        copy_obj(ho_LinkScoreMap,&ho_ScoreMap,1,-1);

        /*Text := 'Link score ' + ImageIDStringBraces*/
        create_tuple_s(&TTemp[SP++],"Link score ");
        T_tuple_add(TTemp[SP-1],hv_ImageIDStringBraces,&TTemp[SP]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-1]=TTemp[SP];
        destroy_tuple(hv_Text);
        hv_Text=TTemp[--SP];

      }
      else
      {
      destroy_tuple(TTemp[--SP]);
      /*========== elseif (KeysForDisplay[KeyIndex] == 'ocr_detection_score_map_orientation') ==========*/

      T_tuple_select(hv_KeysForDisplay_COPY_INP_TMP,hv_KeyIndex,&TTemp[SP++]);
      create_tuple_s(&TTemp[SP++],"ocr_detection_score_map_orientation");
      T_tuple_equal(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-2]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-2]=TTemp[SP];
      SP--;
      if(get_i(TTemp[SP-1],0))
      {
        /*compose2 (OrientationSinScoreMap, OrientationCosScoreMap, OrientationScoreMap)*/
        clear_obj(ho_OrientationScoreMap);
        /***/compose2(ho_OrientationSinScoreMap, ho_OrientationCosScoreMap, &ho_OrientationScoreMap
            );

        /*ScoreMap := OrientationScoreMap*/
        clear_obj(ho_ScoreMap);
        copy_obj(ho_OrientationScoreMap,&ho_ScoreMap,1,-1);

        /*Text := 'Orientation (sin,cos) ' + ImageIDStringBraces*/
        create_tuple_s(&TTemp[SP++],"Orientation (sin,cos) ");
        T_tuple_add(TTemp[SP-1],hv_ImageIDStringBraces,&TTemp[SP]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-1]=TTemp[SP];
        destroy_tuple(hv_Text);
        hv_Text=TTemp[--SP];

      }
      }
      }
      destroy_tuple(TTemp[--SP]);
      /*========== end if ==========*/
      /*Get or open next window.*/
      /*get_image_size (ScoreMap, WidthImage, HeightImage)*/
      destroy_tuple(hv_WidthImage);
      destroy_tuple(hv_HeightImage);
      /***/T_get_image_size(ho_ScoreMap, &hv_WidthImage, &hv_HeightImage);

      /*get_next_window (__get_dict_tuple( Params, ['font']), __get_dict_tuple( Params, ['font_size']), __get_dict_tuple( Params, ['display_bottom_desc']), WidthImage, HeightImage, 0, __get_dict_tuple( Params, ['scale_windows']), __get_dict_tuple( Params, ['threshold_width']), PrevWindowCoordinates, WindowHandleDict, KeysForDisplay[KeyIndex], CurrentWindowHandle, WindowImageRatio, PrevWindowCoordinates)*/
      create_tuple_s(&TTemp[SP++],"font");
      T_get_dict_tuple(hv_Params,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      create_tuple_s(&TTemp[SP++],"font_size");
      T_get_dict_tuple(hv_Params,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      create_tuple_s(&TTemp[SP++],"display_bottom_desc");
      T_get_dict_tuple(hv_Params,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      create_tuple_i(&TTemp[SP++],0);
      create_tuple_s(&TTemp[SP++],"scale_windows");
      T_get_dict_tuple(hv_Params,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      create_tuple_s(&TTemp[SP++],"threshold_width");
      T_get_dict_tuple(hv_Params,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      copy_tuple(hv_PrevWindowCoordinates,&TTemp[SP++]);
      T_tuple_select(hv_KeysForDisplay_COPY_INP_TMP,hv_KeyIndex,&TTemp[SP++]);
      destroy_tuple(hv_CurrentWindowHandle);
      destroy_tuple(hv_WindowImageRatio);
      destroy_tuple(hv_PrevWindowCoordinates);
      /***/get_next_window(TTemp[SP-8], TTemp[SP-7], TTemp[SP-6], hv_WidthImage, 
          hv_HeightImage, TTemp[SP-5], TTemp[SP-4], TTemp[SP-3], TTemp[SP-2], hv_WindowHandleDict, 
          TTemp[SP-1], &hv_CurrentWindowHandle, &hv_WindowImageRatio, &hv_PrevWindowCoordinates);
      destroy_tuple(TTemp[--SP]);
      destroy_tuple(TTemp[--SP]);
      destroy_tuple(TTemp[--SP]);
      destroy_tuple(TTemp[--SP]);
      destroy_tuple(TTemp[--SP]);
      destroy_tuple(TTemp[--SP]);
      destroy_tuple(TTemp[--SP]);
      destroy_tuple(TTemp[--SP]);

      /**/
      /*Display the score maps using the 'jet' color map.*/
      /*set_lut (CurrentWindowHandle, ['jet', 0, 1])*/
      create_tuple(&TTemp[SP++],3);
      set_s(TTemp[SP-1],"jet",0);
      set_i(TTemp[SP-1],0      ,1);
      set_i(TTemp[SP-1],1      ,2);
      /***/T_set_lut(hv_CurrentWindowHandle, TTemp[SP-1]);
      destroy_tuple(TTemp[--SP]);

      if (hdev_window_stack_is_open())
      {
        Htuple active_win;
        create_tuple(&active_win,0);
        hdev_window_stack_get_active(&active_win);
        /*dev_display (ScoreMap)*/
        /***/T_disp_obj(ho_ScoreMap, active_win);
        destroy_tuple(active_win);
      }
      /**/
      /*Display text*/
      /*========== if (__get_dict_tuple( Params, ['display_bottom_desc'])) ==========*/
      create_tuple_s(&TTemp[SP++],"display_bottom_desc");
      T_get_dict_tuple(hv_Params,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      if(get_i(TTemp[SP-1],0))
      {
        if (hdev_window_stack_is_open())
        {
          Htuple active_win;
          create_tuple(&active_win,0);
          hdev_window_stack_get_active(&active_win);
          /*dev_disp_text (Text, 'window', 'bottom', 'left', 'white', 'box', 'false')*/
          create_tuple_s(&TTemp[SP++],"window");
          create_tuple_s(&TTemp[SP++],"bottom");
          create_tuple_s(&TTemp[SP++],"left");
          create_tuple_s(&TTemp[SP++],"white");
          create_tuple_s(&TTemp[SP++],"box");
          create_tuple_s(&TTemp[SP++],"false");
          /***/T_disp_text(active_win,hv_Text, TTemp[SP-6], TTemp[SP-5], TTemp[SP-4], 
              TTemp[SP-3], TTemp[SP-2], TTemp[SP-1]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(active_win);
        }
      }
      destroy_tuple(TTemp[--SP]);
      /*========== end if ==========*/
    }
    else
    {
    destroy_tuple(TTemp[--SP]);
    /*========== elseif (KeysForDisplay[KeyIndex] == 'classification_both' or KeysForDisplay[KeyIndex] == 'multi_label_classification_both') ==========*/

    T_tuple_select(hv_KeysForDisplay_COPY_INP_TMP,hv_KeyIndex,&TTemp[SP++]);
    create_tuple_s(&TTemp[SP++],"classification_both");
    T_tuple_equal(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-2]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-2]=TTemp[SP];
    SP--;
    T_tuple_select(hv_KeysForDisplay_COPY_INP_TMP,hv_KeyIndex,&TTemp[SP++]);
    create_tuple_s(&TTemp[SP++],"multi_label_classification_both");
    T_tuple_equal(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-2]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-2]=TTemp[SP];
    SP--;
    T_tuple_or(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-2]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-2]=TTemp[SP];
    SP--;
    if(get_i(TTemp[SP-1],0))
    {
      /**/
      /*Ground truth and result classification image.*/
      /*get_dl_sample_image (Image, SampleKeys, DLSample, 'image')*/
      create_tuple_s(&TTemp[SP++],"image");
      clear_obj(ho_Image);
      /***/get_dl_sample_image(&ho_Image, hv_SampleKeys, hv_DLSample, TTemp[SP-1]);
      destroy_tuple(TTemp[--SP]);

      /**/
      /*get_classification_ground_truth (SampleKeys, DLSample, ClassificationLabelIDGroundTruth)*/
      destroy_tuple(hv_ClassificationLabelIDGroundTruth);
      /***/get_classification_ground_truth(hv_SampleKeys, hv_DLSample, &hv_ClassificationLabelIDGroundTruth);

      /*get_classification_result (ResultKeys, DLResult, ClassificationLabelIDResult)*/
      destroy_tuple(hv_ClassificationLabelIDResult);
      /***/get_classification_result(hv_ResultKeys, hv_DLResult_COPY_INP_TMP, &hv_ClassificationLabelIDResult);

      /**/
      /*Get or open next window.*/
      /*get_image_size (Image, WidthImage, HeightImage)*/
      destroy_tuple(hv_WidthImage);
      destroy_tuple(hv_HeightImage);
      /***/T_get_image_size(ho_Image, &hv_WidthImage, &hv_HeightImage);

      /*get_next_window (__get_dict_tuple( Params, ['font']), __get_dict_tuple( Params, ['font_size']), __get_dict_tuple( Params, ['display_bottom_desc']), WidthImage, HeightImage, 0, __get_dict_tuple( Params, ['scale_windows']), __get_dict_tuple( Params, ['threshold_width']), PrevWindowCoordinates, WindowHandleDict, KeysForDisplay[KeyIndex], CurrentWindowHandle, WindowImageRatio, PrevWindowCoordinates)*/
      create_tuple_s(&TTemp[SP++],"font");
      T_get_dict_tuple(hv_Params,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      create_tuple_s(&TTemp[SP++],"font_size");
      T_get_dict_tuple(hv_Params,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      create_tuple_s(&TTemp[SP++],"display_bottom_desc");
      T_get_dict_tuple(hv_Params,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      create_tuple_i(&TTemp[SP++],0);
      create_tuple_s(&TTemp[SP++],"scale_windows");
      T_get_dict_tuple(hv_Params,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      create_tuple_s(&TTemp[SP++],"threshold_width");
      T_get_dict_tuple(hv_Params,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      copy_tuple(hv_PrevWindowCoordinates,&TTemp[SP++]);
      T_tuple_select(hv_KeysForDisplay_COPY_INP_TMP,hv_KeyIndex,&TTemp[SP++]);
      destroy_tuple(hv_CurrentWindowHandle);
      destroy_tuple(hv_WindowImageRatio);
      destroy_tuple(hv_PrevWindowCoordinates);
      /***/get_next_window(TTemp[SP-8], TTemp[SP-7], TTemp[SP-6], hv_WidthImage, 
          hv_HeightImage, TTemp[SP-5], TTemp[SP-4], TTemp[SP-3], TTemp[SP-2], hv_WindowHandleDict, 
          TTemp[SP-1], &hv_CurrentWindowHandle, &hv_WindowImageRatio, &hv_PrevWindowCoordinates);
      destroy_tuple(TTemp[--SP]);
      destroy_tuple(TTemp[--SP]);
      destroy_tuple(TTemp[--SP]);
      destroy_tuple(TTemp[--SP]);
      destroy_tuple(TTemp[--SP]);
      destroy_tuple(TTemp[--SP]);
      destroy_tuple(TTemp[--SP]);
      destroy_tuple(TTemp[--SP]);

      /**/
      /*Get prediction color.*/
      /*PredictionColor := 'white'*/
      reuse_tuple_s(&hv_PredictionColor,"white");
      /*========== if (sort(ClassificationLabelIDGroundTruth) == sort(ClassificationLabelIDResult)) ==========*/
      T_tuple_sort(hv_ClassificationLabelIDGroundTruth,&TTemp[SP++]);
      T_tuple_sort(hv_ClassificationLabelIDResult,&TTemp[SP++]);
      T_tuple_equal(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-2]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-2]=TTemp[SP];
      SP--;
      if(get_i(TTemp[SP-1],0))
      {
        /*PredictionText := 'Correct'*/
        reuse_tuple_s(&hv_PredictionText,"Correct");
        /*PredictionColor := 'green'*/
        reuse_tuple_s(&hv_PredictionColor,"green");
      }
      else
      {
        /*PredictionText := 'Wrong'*/
        reuse_tuple_s(&hv_PredictionText,"Wrong");
        /*PredictionColor := 'red'*/
        reuse_tuple_s(&hv_PredictionColor,"red");
      }
      destroy_tuple(TTemp[--SP]);
      /*========== end if ==========*/
      /**/
      /*Generate prediction color frame and show image.*/
      /*========== if (__get_dict_tuple( Params, ['display_classification_color_frame'])) ==========*/
      create_tuple_s(&TTemp[SP++],"display_classification_color_frame");
      T_get_dict_tuple(hv_Params,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      if(get_i(TTemp[SP-1],0))
      {
        /*Create a frame with line width 7 that is completely displayed in the window.*/
        /*BoarderOffset := 7 / 2.*/
        create_tuple_i(&TTemp[SP++],7);
        create_tuple_d(&TTemp[SP++],2.);
        T_tuple_div(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-2]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-2]=TTemp[SP];
        SP--;
        destroy_tuple(hv_BoarderOffset);
        hv_BoarderOffset=TTemp[--SP];

        /*get_dict_tuple (WindowHandleDict, 'meta_information', MetaInfo)*/
        create_tuple_s(&TTemp[SP++],"meta_information");
        destroy_tuple(hv_MetaInfo);
        /***/T_get_dict_tuple(hv_WindowHandleDict, TTemp[SP-1], &hv_MetaInfo);
        destroy_tuple(TTemp[--SP]);

        /*get_dict_tuple (MetaInfo, KeysForDisplay[KeyIndex] + '_window_image_ratio_height', WindowImageRatioHeight)*/
        T_tuple_select(hv_KeysForDisplay_COPY_INP_TMP,hv_KeyIndex,&TTemp[SP++]);
        create_tuple_s(&TTemp[SP++],"_window_image_ratio_height");
        T_tuple_add(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-2]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-2]=TTemp[SP];
        SP--;
        destroy_tuple(hv_WindowImageRatioHeight);
        /***/T_get_dict_tuple(hv_MetaInfo, TTemp[SP-1], &hv_WindowImageRatioHeight);
        destroy_tuple(TTemp[--SP]);

        /*get_dict_tuple (MetaInfo, KeysForDisplay[KeyIndex] + '_window_image_ratio_width', WindowImageRatioWidth)*/
        T_tuple_select(hv_KeysForDisplay_COPY_INP_TMP,hv_KeyIndex,&TTemp[SP++]);
        create_tuple_s(&TTemp[SP++],"_window_image_ratio_width");
        T_tuple_add(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-2]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-2]=TTemp[SP];
        SP--;
        destroy_tuple(hv_WindowImageRatioWidth);
        /***/T_get_dict_tuple(hv_MetaInfo, TTemp[SP-1], &hv_WindowImageRatioWidth);
        destroy_tuple(TTemp[--SP]);

        /*BoarderOffsetRow := BoarderOffset / WindowImageRatioHeight*/
        T_tuple_div(hv_BoarderOffset,hv_WindowImageRatioHeight,&TTemp[SP++]);
        destroy_tuple(hv_BoarderOffsetRow);
        hv_BoarderOffsetRow=TTemp[--SP];

        /*BoarderOffsetCol := BoarderOffset / WindowImageRatioWidth*/
        T_tuple_div(hv_BoarderOffset,hv_WindowImageRatioWidth,&TTemp[SP++]);
        destroy_tuple(hv_BoarderOffsetCol);
        hv_BoarderOffsetCol=TTemp[--SP];

        /*gen_contour_polygon_xld (PredictionColorFrame, [BoarderOffsetRow - 0.5,BoarderOffsetRow - 0.5,HeightImage + 0.5 - BoarderOffsetRow,HeightImage + 0.5 - BoarderOffsetRow,BoarderOffsetRow - 0.5], [BoarderOffsetCol - 0.5,WidthImage + 0.5 - BoarderOffsetCol,WidthImage + 0.5 - BoarderOffsetCol,BoarderOffsetCol - 0.5,BoarderOffsetCol - 0.5])*/
        create_tuple_d(&TTemp[SP++],0.5);
        T_tuple_sub(hv_BoarderOffsetRow,TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-1]=TTemp[SP];
        create_tuple_d(&TTemp[SP++],0.5);
        T_tuple_sub(hv_BoarderOffsetRow,TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-1]=TTemp[SP];
        T_tuple_concat(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-2]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-2]=TTemp[SP];
        SP--;
        create_tuple_d(&TTemp[SP++],0.5);
        T_tuple_add(hv_HeightImage,TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-1]=TTemp[SP];
        T_tuple_sub(TTemp[SP-1],hv_BoarderOffsetRow,&TTemp[SP]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-1]=TTemp[SP];
        T_tuple_concat(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-2]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-2]=TTemp[SP];
        SP--;
        create_tuple_d(&TTemp[SP++],0.5);
        T_tuple_add(hv_HeightImage,TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-1]=TTemp[SP];
        T_tuple_sub(TTemp[SP-1],hv_BoarderOffsetRow,&TTemp[SP]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-1]=TTemp[SP];
        T_tuple_concat(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-2]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-2]=TTemp[SP];
        SP--;
        create_tuple_d(&TTemp[SP++],0.5);
        T_tuple_sub(hv_BoarderOffsetRow,TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-1]=TTemp[SP];
        T_tuple_concat(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-2]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-2]=TTemp[SP];
        SP--;
        create_tuple_d(&TTemp[SP++],0.5);
        T_tuple_sub(hv_BoarderOffsetCol,TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-1]=TTemp[SP];
        create_tuple_d(&TTemp[SP++],0.5);
        T_tuple_add(hv_WidthImage,TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-1]=TTemp[SP];
        T_tuple_sub(TTemp[SP-1],hv_BoarderOffsetCol,&TTemp[SP]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-1]=TTemp[SP];
        T_tuple_concat(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-2]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-2]=TTemp[SP];
        SP--;
        create_tuple_d(&TTemp[SP++],0.5);
        T_tuple_add(hv_WidthImage,TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-1]=TTemp[SP];
        T_tuple_sub(TTemp[SP-1],hv_BoarderOffsetCol,&TTemp[SP]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-1]=TTemp[SP];
        T_tuple_concat(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-2]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-2]=TTemp[SP];
        SP--;
        create_tuple_d(&TTemp[SP++],0.5);
        T_tuple_sub(hv_BoarderOffsetCol,TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-1]=TTemp[SP];
        T_tuple_concat(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-2]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-2]=TTemp[SP];
        SP--;
        create_tuple_d(&TTemp[SP++],0.5);
        T_tuple_sub(hv_BoarderOffsetCol,TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-1]=TTemp[SP];
        T_tuple_concat(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-2]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-2]=TTemp[SP];
        SP--;
        clear_obj(ho_PredictionColorFrame);
        /***/T_gen_contour_polygon_xld(&ho_PredictionColorFrame, TTemp[SP-2], TTemp[SP-1]);
        destroy_tuple(TTemp[--SP]);
        destroy_tuple(TTemp[--SP]);

        if (hdev_window_stack_is_open())
        {
          Htuple active_win;
          create_tuple(&active_win,0);
          hdev_window_stack_get_active(&active_win);
          /*dev_set_line_width (7)*/
          create_tuple_i(&TTemp[SP++],7);
          /***/T_set_line_width(active_win,TTemp[SP-1]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(active_win);
        }
        if (hdev_window_stack_is_open())
        {
          Htuple active_win;
          create_tuple(&active_win,0);
          hdev_window_stack_get_active(&active_win);
          /*dev_set_color (PredictionColor)*/
          /***/T_set_color(active_win,hv_PredictionColor);
          destroy_tuple(active_win);
        }
        if (hdev_window_stack_is_open())
        {
          Htuple active_win;
          create_tuple(&active_win,0);
          hdev_window_stack_get_active(&active_win);
          /*dev_display (Image)*/
          /***/T_disp_obj(ho_Image, active_win);
          destroy_tuple(active_win);
        }
        if (hdev_window_stack_is_open())
        {
          Htuple active_win;
          create_tuple(&active_win,0);
          hdev_window_stack_get_active(&active_win);
          /*dev_display (PredictionColorFrame)*/
          /***/T_disp_obj(ho_PredictionColorFrame, active_win);
          destroy_tuple(active_win);
        }
      }
      else
      {
        if (hdev_window_stack_is_open())
        {
          Htuple active_win;
          create_tuple(&active_win,0);
          hdev_window_stack_get_active(&active_win);
          /*dev_display (Image)*/
          /***/T_disp_obj(ho_Image, active_win);
          destroy_tuple(active_win);
        }
      }
      destroy_tuple(TTemp[--SP]);
      /*========== end if ==========*/
      /**/
      /*========== if (__get_dict_tuple( Params, ['display_classification_ids'])) ==========*/
      create_tuple_s(&TTemp[SP++],"display_classification_ids");
      T_get_dict_tuple(hv_Params,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      if(get_i(TTemp[SP-1],0))
      {
        /*get_dict_tuple (WindowHandleDict, 'meta_information', MetaInfo)*/
        create_tuple_s(&TTemp[SP++],"meta_information");
        destroy_tuple(hv_MetaInfo);
        /***/T_get_dict_tuple(hv_WindowHandleDict, TTemp[SP-1], &hv_MetaInfo);
        destroy_tuple(TTemp[--SP]);

        /*get_dict_tuple (MetaInfo, KeysForDisplay[KeyIndex] + '_margin_bottom', MarginBottom)*/
        T_tuple_select(hv_KeysForDisplay_COPY_INP_TMP,hv_KeyIndex,&TTemp[SP++]);
        create_tuple_s(&TTemp[SP++],"_margin_bottom");
        T_tuple_add(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-2]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-2]=TTemp[SP];
        SP--;
        destroy_tuple(hv_MarginBottom);
        /***/T_get_dict_tuple(hv_MetaInfo, TTemp[SP-1], &hv_MarginBottom);
        destroy_tuple(TTemp[--SP]);

        /*get_dict_tuple (MetaInfo, KeysForDisplay[KeyIndex] + '_window_coordinates', WindowCoordinates)*/
        T_tuple_select(hv_KeysForDisplay_COPY_INP_TMP,hv_KeyIndex,&TTemp[SP++]);
        create_tuple_s(&TTemp[SP++],"_window_coordinates");
        T_tuple_add(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-2]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-2]=TTemp[SP];
        SP--;
        destroy_tuple(hv_WindowCoordinates);
        /***/T_get_dict_tuple(hv_MetaInfo, TTemp[SP-1], &hv_WindowCoordinates);
        destroy_tuple(TTemp[--SP]);

        /*CurrentWindowHeight := WindowCoordinates[3] - WindowCoordinates[0]*/
        create_tuple_i(&TTemp[SP++],3);
        T_tuple_select(hv_WindowCoordinates,TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-1]=TTemp[SP];
        create_tuple_i(&TTemp[SP++],0);
        T_tuple_select(hv_WindowCoordinates,TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-1]=TTemp[SP];
        T_tuple_sub(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-2]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-2]=TTemp[SP];
        SP--;
        destroy_tuple(hv_CurrentWindowHeight);
        hv_CurrentWindowHeight=TTemp[--SP];

        /*get_font_extents (CurrentWindowHandle, _, _, _, MaxHeight)*/
        destroy_tuple(hv__);
        destroy_tuple(hv_MaxHeight);
        /***/T_get_font_extents(hv_CurrentWindowHandle, &hv__, &(CExpDummyOCvar[0]), 
            &(CExpDummyOCvar[1]), &hv_MaxHeight);
        destroy_tuple(CExpDummyOCvar[0]);
        destroy_tuple(CExpDummyOCvar[1]);

        /*========== if (|ClassificationLabelIDGroundTruth| > 1) ==========*/
        T_tuple_length(hv_ClassificationLabelIDGroundTruth,&TTemp[SP++]);
        create_tuple_i(&TTemp[SP++],1);
        T_tuple_greater(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-2]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-2]=TTemp[SP];
        SP--;
        if(get_i(TTemp[SP-1],0))
        {
          /*PluralPostfix := 's'*/
          reuse_tuple_s(&hv_PluralPostfix,"s");
          /*ClassificationLabelIDGroundTruth := sort(ClassificationLabelIDGroundTruth)*/
          copy_tuple(hv_ClassificationLabelIDGroundTruth,&TTemp[SP++]);
          T_tuple_sort(TTemp[SP-1],&TTemp[SP]);
          destroy_tuple(TTemp[SP-1]);
          TTemp[SP-1]=TTemp[SP];
          destroy_tuple(hv_ClassificationLabelIDGroundTruth);
          hv_ClassificationLabelIDGroundTruth=TTemp[--SP];

        }
        else
        {
          /*PluralPostfix := ''*/
          reuse_tuple_s(&hv_PluralPostfix,"");
        }
        destroy_tuple(TTemp[--SP]);
        /*========== end if ==========*/
        /*ClassificationLabelIDGroundTruthList := ''*/
        reuse_tuple_s(&hv_ClassificationLabelIDGroundTruthList,"");
        /*========== for C := 0 to |ClassificationLabelIDGroundTruth| - 1 by 1 ==========*/
        T_tuple_length(hv_ClassificationLabelIDGroundTruth,&TTemp[SP++]);
        create_tuple_i(&TTemp[SP++],1);
        T_tuple_sub(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-2]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-2]=TTemp[SP];
        SP--;
        create_tuple_i(&TTemp[SP++],1);
        create_tuple_i(&TTemp[SP++],0);
        T_tuple_greater(TTemp[SP-1],TTemp[SP-3],&TTemp[SP]);
        SP++;
        T_tuple_equal(TTemp[SP-2],TTemp[SP-4],&TTemp[SP]);
        if(get_i(TTemp[SP],0) ||
           (!((( get_i(TTemp[SP-1],0)) && (get_d(TTemp[SP-3],0)>0)) ||
              ((!get_i(TTemp[SP-1],0)) && (get_d(TTemp[SP-3],0)<0)))))
        {
         destroy_tuple(TTemp[SP--]);
         destroy_tuple(TTemp[SP]);
         T_tuple_sub(TTemp[SP-1],TTemp[SP-2],&TTemp[SP]);
         destroy_tuple(hv_C);
         copy_tuple(TTemp[SP],&hv_C);
         destroy_tuple(TTemp[SP--]);
         destroy_tuple(TTemp[SP]);
         for(;;)
         {
         T_tuple_add(hv_C,TTemp[SP-1],&TTemp[SP]);
         destroy_tuple(hv_C);
         copy_tuple(TTemp[SP],&hv_C);
         destroy_tuple(TTemp[SP]);
         if(get_d(TTemp[SP-1],0)<0)
          T_tuple_less(hv_C,TTemp[SP-2],&TTemp[SP]);
         else
          T_tuple_greater(hv_C,TTemp[SP-2],&TTemp[SP]);
         if(get_i(TTemp[SP],0)) break;
         destroy_tuple(TTemp[SP]);
         /*========== for ==========*/

          /*ClassificationLabelIDGroundTruthList := ClassificationLabelIDGroundTruthList + ClassificationLabelIDGroundTruth[C]*/
          T_tuple_select(hv_ClassificationLabelIDGroundTruth,hv_C,&TTemp[SP++]);
          T_tuple_add(hv_ClassificationLabelIDGroundTruthList,TTemp[SP-1],&TTemp[SP]);
          destroy_tuple(hv_ClassificationLabelIDGroundTruthList);
          hv_ClassificationLabelIDGroundTruthList=TTemp[SP];
          destroy_tuple(TTemp[--SP]);

          /*========== if (C < |ClassificationLabelIDGroundTruth| - 1) ==========*/
          T_tuple_length(hv_ClassificationLabelIDGroundTruth,&TTemp[SP++]);
          create_tuple_i(&TTemp[SP++],1);
          T_tuple_sub(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
          destroy_tuple(TTemp[SP-2]);
          destroy_tuple(TTemp[SP-1]);
          TTemp[SP-2]=TTemp[SP];
          SP--;
          T_tuple_less(hv_C,TTemp[SP-1],&TTemp[SP]);
          destroy_tuple(TTemp[SP-1]);
          TTemp[SP-1]=TTemp[SP];
          if(get_i(TTemp[SP-1],0))
          {
            /*ClassificationLabelIDGroundTruthList := ClassificationLabelIDGroundTruthList + ', '*/
            create_tuple_s(&TTemp[SP++],", ");
            T_tuple_add(hv_ClassificationLabelIDGroundTruthList,TTemp[SP-1],&TTemp[SP]);
            destroy_tuple(hv_ClassificationLabelIDGroundTruthList);
            hv_ClassificationLabelIDGroundTruthList=TTemp[SP];
            destroy_tuple(TTemp[--SP]);

          }
          destroy_tuple(TTemp[--SP]);
          /*========== end if ==========*/
         }
         destroy_tuple(TTemp[SP--]);
         destroy_tuple(TTemp[SP--]);
         destroy_tuple(TTemp[SP]);
        }
        else
        {
         destroy_tuple(TTemp[SP--]);
         destroy_tuple(TTemp[SP--]);
         destroy_tuple(TTemp[SP--]);
         destroy_tuple(TTemp[SP--]);
         destroy_tuple(TTemp[SP]);
        }/*========== end for ========*/


        /*Text := 'GT label ID' + PluralPostfix + ': ' + ClassificationLabelIDGroundTruthList*/
        create_tuple_s(&TTemp[SP++],"GT label ID");
        T_tuple_add(TTemp[SP-1],hv_PluralPostfix,&TTemp[SP]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-1]=TTemp[SP];
        create_tuple_s(&TTemp[SP++],": ");
        T_tuple_add(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-2]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-2]=TTemp[SP];
        SP--;
        T_tuple_add(TTemp[SP-1],hv_ClassificationLabelIDGroundTruthList,&TTemp[SP]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-1]=TTemp[SP];
        destroy_tuple(hv_Text);
        hv_Text=TTemp[--SP];

        if (hdev_window_stack_is_open())
        {
          Htuple active_win;
          create_tuple(&active_win,0);
          hdev_window_stack_get_active(&active_win);
          /*dev_disp_text (Text, 'window', 'top', 'left', 'white', 'box', 'false')*/
          create_tuple_s(&TTemp[SP++],"window");
          create_tuple_s(&TTemp[SP++],"top");
          create_tuple_s(&TTemp[SP++],"left");
          create_tuple_s(&TTemp[SP++],"white");
          create_tuple_s(&TTemp[SP++],"box");
          create_tuple_s(&TTemp[SP++],"false");
          /***/T_disp_text(active_win,hv_Text, TTemp[SP-6], TTemp[SP-5], TTemp[SP-4], 
              TTemp[SP-3], TTemp[SP-2], TTemp[SP-1]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(active_win);
        }

        /*========== if (|ClassificationLabelIDResult| > 1) ==========*/
        T_tuple_length(hv_ClassificationLabelIDResult,&TTemp[SP++]);
        create_tuple_i(&TTemp[SP++],1);
        T_tuple_greater(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-2]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-2]=TTemp[SP];
        SP--;
        if(get_i(TTemp[SP-1],0))
        {
          /*PluralPostfix := 's'*/
          reuse_tuple_s(&hv_PluralPostfix,"s");
          /*ClassificationLabelIDResult := sort(ClassificationLabelIDResult)*/
          copy_tuple(hv_ClassificationLabelIDResult,&TTemp[SP++]);
          T_tuple_sort(TTemp[SP-1],&TTemp[SP]);
          destroy_tuple(TTemp[SP-1]);
          TTemp[SP-1]=TTemp[SP];
          destroy_tuple(hv_ClassificationLabelIDResult);
          hv_ClassificationLabelIDResult=TTemp[--SP];

        }
        else
        {
          /*PluralPostfix := ''*/
          reuse_tuple_s(&hv_PluralPostfix,"");
        }
        destroy_tuple(TTemp[--SP]);
        /*========== end if ==========*/
        /*ClassificationLabelIDResultList := ''*/
        reuse_tuple_s(&hv_ClassificationLabelIDResultList,"");
        /*========== for C := 0 to |ClassificationLabelIDResult| - 1 by 1 ==========*/
        T_tuple_length(hv_ClassificationLabelIDResult,&TTemp[SP++]);
        create_tuple_i(&TTemp[SP++],1);
        T_tuple_sub(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-2]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-2]=TTemp[SP];
        SP--;
        create_tuple_i(&TTemp[SP++],1);
        create_tuple_i(&TTemp[SP++],0);
        T_tuple_greater(TTemp[SP-1],TTemp[SP-3],&TTemp[SP]);
        SP++;
        T_tuple_equal(TTemp[SP-2],TTemp[SP-4],&TTemp[SP]);
        if(get_i(TTemp[SP],0) ||
           (!((( get_i(TTemp[SP-1],0)) && (get_d(TTemp[SP-3],0)>0)) ||
              ((!get_i(TTemp[SP-1],0)) && (get_d(TTemp[SP-3],0)<0)))))
        {
         destroy_tuple(TTemp[SP--]);
         destroy_tuple(TTemp[SP]);
         T_tuple_sub(TTemp[SP-1],TTemp[SP-2],&TTemp[SP]);
         destroy_tuple(hv_C);
         copy_tuple(TTemp[SP],&hv_C);
         destroy_tuple(TTemp[SP--]);
         destroy_tuple(TTemp[SP]);
         for(;;)
         {
         T_tuple_add(hv_C,TTemp[SP-1],&TTemp[SP]);
         destroy_tuple(hv_C);
         copy_tuple(TTemp[SP],&hv_C);
         destroy_tuple(TTemp[SP]);
         if(get_d(TTemp[SP-1],0)<0)
          T_tuple_less(hv_C,TTemp[SP-2],&TTemp[SP]);
         else
          T_tuple_greater(hv_C,TTemp[SP-2],&TTemp[SP]);
         if(get_i(TTemp[SP],0)) break;
         destroy_tuple(TTemp[SP]);
         /*========== for ==========*/

          /*ClassificationLabelIDResultList := ClassificationLabelIDResultList + ClassificationLabelIDResult[C]*/
          T_tuple_select(hv_ClassificationLabelIDResult,hv_C,&TTemp[SP++]);
          T_tuple_add(hv_ClassificationLabelIDResultList,TTemp[SP-1],&TTemp[SP]);
          destroy_tuple(hv_ClassificationLabelIDResultList);
          hv_ClassificationLabelIDResultList=TTemp[SP];
          destroy_tuple(TTemp[--SP]);

          /*========== if (C < |ClassificationLabelIDResult| - 1) ==========*/
          T_tuple_length(hv_ClassificationLabelIDResult,&TTemp[SP++]);
          create_tuple_i(&TTemp[SP++],1);
          T_tuple_sub(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
          destroy_tuple(TTemp[SP-2]);
          destroy_tuple(TTemp[SP-1]);
          TTemp[SP-2]=TTemp[SP];
          SP--;
          T_tuple_less(hv_C,TTemp[SP-1],&TTemp[SP]);
          destroy_tuple(TTemp[SP-1]);
          TTemp[SP-1]=TTemp[SP];
          if(get_i(TTemp[SP-1],0))
          {
            /*ClassificationLabelIDResultList := ClassificationLabelIDResultList + ', '*/
            create_tuple_s(&TTemp[SP++],", ");
            T_tuple_add(hv_ClassificationLabelIDResultList,TTemp[SP-1],&TTemp[SP]);
            destroy_tuple(hv_ClassificationLabelIDResultList);
            hv_ClassificationLabelIDResultList=TTemp[SP];
            destroy_tuple(TTemp[--SP]);

          }
          destroy_tuple(TTemp[--SP]);
          /*========== end if ==========*/
         }
         destroy_tuple(TTemp[SP--]);
         destroy_tuple(TTemp[SP--]);
         destroy_tuple(TTemp[SP]);
        }
        else
        {
         destroy_tuple(TTemp[SP--]);
         destroy_tuple(TTemp[SP--]);
         destroy_tuple(TTemp[SP--]);
         destroy_tuple(TTemp[SP--]);
         destroy_tuple(TTemp[SP]);
        }/*========== end for ========*/

        /*Text := 'Result class ID' + PluralPostfix + ': ' + ClassificationLabelIDResultList*/
        create_tuple_s(&TTemp[SP++],"Result class ID");
        T_tuple_add(TTemp[SP-1],hv_PluralPostfix,&TTemp[SP]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-1]=TTemp[SP];
        create_tuple_s(&TTemp[SP++],": ");
        T_tuple_add(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-2]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-2]=TTemp[SP];
        SP--;
        T_tuple_add(TTemp[SP-1],hv_ClassificationLabelIDResultList,&TTemp[SP]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-1]=TTemp[SP];
        destroy_tuple(hv_Text);
        hv_Text=TTemp[--SP];

        /*========== if (__get_dict_tuple( Params, ['display_bottom_desc'])) ==========*/
        create_tuple_s(&TTemp[SP++],"display_bottom_desc");
        T_get_dict_tuple(hv_Params,TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-1]=TTemp[SP];
        if(get_i(TTemp[SP-1],0))
        {
          if (hdev_window_stack_is_open())
          {
            Htuple active_win;
            create_tuple(&active_win,0);
            hdev_window_stack_get_active(&active_win);
            /*dev_disp_text (Text, 'window', CurrentWindowHeight - (MarginBottom + MaxHeight + 10), 'left', 'white', 'box', 'false')*/
            create_tuple_s(&TTemp[SP++],"window");
            T_tuple_add(hv_MarginBottom,hv_MaxHeight,&TTemp[SP++]);
            create_tuple_i(&TTemp[SP++],10);
            T_tuple_add(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
            destroy_tuple(TTemp[SP-2]);
            destroy_tuple(TTemp[SP-1]);
            TTemp[SP-2]=TTemp[SP];
            SP--;
            T_tuple_sub(hv_CurrentWindowHeight,TTemp[SP-1],&TTemp[SP]);
            destroy_tuple(TTemp[SP-1]);
            TTemp[SP-1]=TTemp[SP];
            create_tuple_s(&TTemp[SP++],"left");
            create_tuple_s(&TTemp[SP++],"white");
            create_tuple_s(&TTemp[SP++],"box");
            create_tuple_s(&TTemp[SP++],"false");
            /***/T_disp_text(active_win,hv_Text, TTemp[SP-6], TTemp[SP-5], TTemp[SP-4], 
                TTemp[SP-3], TTemp[SP-2], TTemp[SP-1]);
            destroy_tuple(TTemp[--SP]);
            destroy_tuple(TTemp[--SP]);
            destroy_tuple(TTemp[--SP]);
            destroy_tuple(TTemp[--SP]);
            destroy_tuple(TTemp[--SP]);
            destroy_tuple(TTemp[--SP]);
            destroy_tuple(active_win);
          }
        }
        else
        {
          if (hdev_window_stack_is_open())
          {
            Htuple active_win;
            create_tuple(&active_win,0);
            hdev_window_stack_get_active(&active_win);
            /*dev_disp_text (Text, 'window', 'bottom', 'left', 'white', 'box', 'false')*/
            create_tuple_s(&TTemp[SP++],"window");
            create_tuple_s(&TTemp[SP++],"bottom");
            create_tuple_s(&TTemp[SP++],"left");
            create_tuple_s(&TTemp[SP++],"white");
            create_tuple_s(&TTemp[SP++],"box");
            create_tuple_s(&TTemp[SP++],"false");
            /***/T_disp_text(active_win,hv_Text, TTemp[SP-6], TTemp[SP-5], TTemp[SP-4], 
                TTemp[SP-3], TTemp[SP-2], TTemp[SP-1]);
            destroy_tuple(TTemp[--SP]);
            destroy_tuple(TTemp[--SP]);
            destroy_tuple(TTemp[--SP]);
            destroy_tuple(TTemp[--SP]);
            destroy_tuple(TTemp[--SP]);
            destroy_tuple(TTemp[--SP]);
            destroy_tuple(active_win);
          }
        }
        destroy_tuple(TTemp[--SP]);
        /*========== end if ==========*/
      }
      destroy_tuple(TTemp[--SP]);
      /*========== end if ==========*/
      /**/
      /*========== if (__get_dict_tuple( Params, ['display_bottom_desc'])) ==========*/
      create_tuple_s(&TTemp[SP++],"display_bottom_desc");
      T_get_dict_tuple(hv_Params,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      if(get_i(TTemp[SP-1],0))
      {
        /*Text := 'Result/GT classification ' + ImageIDStringBraces*/
        create_tuple_s(&TTemp[SP++],"Result/GT classification ");
        T_tuple_add(TTemp[SP-1],hv_ImageIDStringBraces,&TTemp[SP]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-1]=TTemp[SP];
        destroy_tuple(hv_Text);
        hv_Text=TTemp[--SP];

        if (hdev_window_stack_is_open())
        {
          Htuple active_win;
          create_tuple(&active_win,0);
          hdev_window_stack_get_active(&active_win);
          /*dev_disp_text (Text, 'window', 'bottom', 'left', 'white', 'box', 'false')*/
          create_tuple_s(&TTemp[SP++],"window");
          create_tuple_s(&TTemp[SP++],"bottom");
          create_tuple_s(&TTemp[SP++],"left");
          create_tuple_s(&TTemp[SP++],"white");
          create_tuple_s(&TTemp[SP++],"box");
          create_tuple_s(&TTemp[SP++],"false");
          /***/T_disp_text(active_win,hv_Text, TTemp[SP-6], TTemp[SP-5], TTemp[SP-4], 
              TTemp[SP-3], TTemp[SP-2], TTemp[SP-1]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(active_win);
        }
      }
      destroy_tuple(TTemp[--SP]);
      /*========== end if ==========*/
      /**/
      /*Display the legend.*/
      /*========== if (__get_dict_tuple( Params, ['display_legend'])) ==========*/
      create_tuple_s(&TTemp[SP++],"display_legend");
      T_get_dict_tuple(hv_Params,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      if(get_i(TTemp[SP-1],0))
      {
        /*========== if (|ClassificationLabelIDGroundTruth| > 1) ==========*/
        T_tuple_length(hv_ClassificationLabelIDGroundTruth,&TTemp[SP++]);
        create_tuple_i(&TTemp[SP++],1);
        T_tuple_greater(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-2]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-2]=TTemp[SP];
        SP--;
        if(get_i(TTemp[SP-1],0))
        {
          /*PluralPostfix := 's'*/
          reuse_tuple_s(&hv_PluralPostfix,"s");
        }
        else
        {
          /*PluralPostfix := ''*/
          reuse_tuple_s(&hv_PluralPostfix,"");
        }
        destroy_tuple(TTemp[--SP]);
        /*========== end if ==========*/
        /*Text := 'Ground truth class ID' + PluralPostfix + ' ' + ImageIDStringBraces*/
        create_tuple_s(&TTemp[SP++],"Ground truth class ID");
        T_tuple_add(TTemp[SP-1],hv_PluralPostfix,&TTemp[SP]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-1]=TTemp[SP];
        create_tuple_s(&TTemp[SP++]," ");
        T_tuple_add(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-2]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-2]=TTemp[SP];
        SP--;
        T_tuple_add(TTemp[SP-1],hv_ImageIDStringBraces,&TTemp[SP]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-1]=TTemp[SP];
        destroy_tuple(hv_Text);
        hv_Text=TTemp[--SP];

        /*Text := [Text,ClassesLegend[__get_dict_tuple( ClassIDstoIndex, ClassificationLabelIDGroundTruth)]]*/
        copy_tuple(hv_Text,&TTemp[SP++]);
        T_get_dict_tuple(hv_ClassIDstoIndex,hv_ClassificationLabelIDGroundTruth,&TTemp[SP++]);
        T_tuple_select(hv_ClassesLegend,TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-1]=TTemp[SP];
        T_tuple_concat(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-2]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-2]=TTemp[SP];
        SP--;
        destroy_tuple(hv_Text);
        hv_Text=TTemp[--SP];

        /*Text[|Text|] := ''*/
        copy_tuple(hv_Text,&TTemp[SP++]);
        T_tuple_length(TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-1]=TTemp[SP];
        create_tuple_s(&TTemp[SP++],"");
        replace_elements(&hv_Text,&TTemp[SP-2],&TTemp[SP-1]);
        destroy_tuple(TTemp[--SP]);
        destroy_tuple(TTemp[--SP]);
        /*Text[|Text|] := ''*/
        copy_tuple(hv_Text,&TTemp[SP++]);
        T_tuple_length(TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-1]=TTemp[SP];
        create_tuple_s(&TTemp[SP++],"");
        replace_elements(&hv_Text,&TTemp[SP-2],&TTemp[SP-1]);
        destroy_tuple(TTemp[--SP]);
        destroy_tuple(TTemp[--SP]);
        /*========== if (|ClassificationLabelIDResult| > 1) ==========*/
        T_tuple_length(hv_ClassificationLabelIDResult,&TTemp[SP++]);
        create_tuple_i(&TTemp[SP++],1);
        T_tuple_greater(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-2]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-2]=TTemp[SP];
        SP--;
        if(get_i(TTemp[SP-1],0))
        {
          /*PluralPostfix := 's'*/
          reuse_tuple_s(&hv_PluralPostfix,"s");
        }
        else
        {
          /*PluralPostfix := ''*/
          reuse_tuple_s(&hv_PluralPostfix,"");
        }
        destroy_tuple(TTemp[--SP]);
        /*========== end if ==========*/
        /*Text[|Text|] := 'Result class ID' + PluralPostfix*/
        copy_tuple(hv_Text,&TTemp[SP++]);
        T_tuple_length(TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-1]=TTemp[SP];
        create_tuple_s(&TTemp[SP++],"Result class ID");
        T_tuple_add(TTemp[SP-1],hv_PluralPostfix,&TTemp[SP]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-1]=TTemp[SP];
        replace_elements(&hv_Text,&TTemp[SP-2],&TTemp[SP-1]);
        destroy_tuple(TTemp[--SP]);
        destroy_tuple(TTemp[--SP]);
        /*========== if (ClassificationLabelIDResult == []) ==========*/
        create_tuple(&TTemp[SP++],0);
        T_tuple_equal(hv_ClassificationLabelIDResult,TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-1]=TTemp[SP];
        if(get_i(TTemp[SP-1],0))
        {
          /*Text[|Text|] := 'No classification result is given!'*/
          copy_tuple(hv_Text,&TTemp[SP++]);
          T_tuple_length(TTemp[SP-1],&TTemp[SP]);
          destroy_tuple(TTemp[SP-1]);
          TTemp[SP-1]=TTemp[SP];
          create_tuple_s(&TTemp[SP++],"No classification result is given!");
          replace_elements(&hv_Text,&TTemp[SP-2],&TTemp[SP-1]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(TTemp[--SP]);
        }
        destroy_tuple(TTemp[--SP]);
        /*========== end if ==========*/
        /*get_dict_param (DLResult, 'key_exists', 'selected_confidences', HasConfidences)*/
        create_tuple_s(&TTemp[SP++],"key_exists");
        create_tuple_s(&TTemp[SP++],"selected_confidences");
        destroy_tuple(hv_HasConfidences);
        /***/T_get_dict_param(hv_DLResult_COPY_INP_TMP, TTemp[SP-2], TTemp[SP-1], 
            &hv_HasConfidences);
        destroy_tuple(TTemp[--SP]);
        destroy_tuple(TTemp[--SP]);

        /*========== if (HasConfidences) ==========*/
        copy_tuple(hv_HasConfidences,&TTemp[SP++]);
        if(get_i(TTemp[SP-1],0))
        {
          /*TPIndices := []*/
          create_tuple(&TTemp[SP++],0);
          destroy_tuple(hv_TPIndices);
          hv_TPIndices=TTemp[--SP];

          /*========== for RIdx := 0 to |__get_dict_tuple( DLResult, ['selected_class_ids'])| - 1 by 1 ==========*/
          create_tuple_s(&TTemp[SP++],"selected_class_ids");
          T_get_dict_tuple(hv_DLResult_COPY_INP_TMP,TTemp[SP-1],&TTemp[SP]);
          destroy_tuple(TTemp[SP-1]);
          TTemp[SP-1]=TTemp[SP];
          T_tuple_length(TTemp[SP-1],&TTemp[SP]);
          destroy_tuple(TTemp[SP-1]);
          TTemp[SP-1]=TTemp[SP];
          create_tuple_i(&TTemp[SP++],1);
          T_tuple_sub(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
          destroy_tuple(TTemp[SP-2]);
          destroy_tuple(TTemp[SP-1]);
          TTemp[SP-2]=TTemp[SP];
          SP--;
          create_tuple_i(&TTemp[SP++],1);
          create_tuple_i(&TTemp[SP++],0);
          T_tuple_greater(TTemp[SP-1],TTemp[SP-3],&TTemp[SP]);
          SP++;
          T_tuple_equal(TTemp[SP-2],TTemp[SP-4],&TTemp[SP]);
          if(get_i(TTemp[SP],0) ||
             (!((( get_i(TTemp[SP-1],0)) && (get_d(TTemp[SP-3],0)>0)) ||
                ((!get_i(TTemp[SP-1],0)) && (get_d(TTemp[SP-3],0)<0)))))
          {
           destroy_tuple(TTemp[SP--]);
           destroy_tuple(TTemp[SP]);
           T_tuple_sub(TTemp[SP-1],TTemp[SP-2],&TTemp[SP]);
           destroy_tuple(hv_RIdx);
           copy_tuple(TTemp[SP],&hv_RIdx);
           destroy_tuple(TTemp[SP--]);
           destroy_tuple(TTemp[SP]);
           for(;;)
           {
           T_tuple_add(hv_RIdx,TTemp[SP-1],&TTemp[SP]);
           destroy_tuple(hv_RIdx);
           copy_tuple(TTemp[SP],&hv_RIdx);
           destroy_tuple(TTemp[SP]);
           if(get_d(TTemp[SP-1],0)<0)
            T_tuple_less(hv_RIdx,TTemp[SP-2],&TTemp[SP]);
           else
            T_tuple_greater(hv_RIdx,TTemp[SP-2],&TTemp[SP]);
           if(get_i(TTemp[SP],0)) break;
           destroy_tuple(TTemp[SP]);
           /*========== for ==========*/

            /*ResultLine := __get_dict_tuple( DLResult, ['selected_class_ids'])[RIdx]*/
            create_tuple_s(&TTemp[SP++],"selected_class_ids");
            T_get_dict_tuple(hv_DLResult_COPY_INP_TMP,TTemp[SP-1],&TTemp[SP]);
            destroy_tuple(TTemp[SP-1]);
            TTemp[SP-1]=TTemp[SP];
            T_tuple_select(TTemp[SP-1],hv_RIdx,&TTemp[SP]);
            destroy_tuple(TTemp[SP-1]);
            TTemp[SP-1]=TTemp[SP];
            destroy_tuple(hv_ResultLine);
            hv_ResultLine=TTemp[--SP];

            /*ResultLine := ResultLine + ' (' + (__get_dict_tuple( DLResult, ['selected_confidences'])[RIdx]$'.2f') + ') : '*/
            copy_tuple(hv_ResultLine,&TTemp[SP++]);
            create_tuple_s(&TTemp[SP++]," (");
            T_tuple_add(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
            destroy_tuple(TTemp[SP-2]);
            destroy_tuple(TTemp[SP-1]);
            TTemp[SP-2]=TTemp[SP];
            SP--;
            create_tuple_s(&TTemp[SP++],"selected_confidences");
            T_get_dict_tuple(hv_DLResult_COPY_INP_TMP,TTemp[SP-1],&TTemp[SP]);
            destroy_tuple(TTemp[SP-1]);
            TTemp[SP-1]=TTemp[SP];
            T_tuple_select(TTemp[SP-1],hv_RIdx,&TTemp[SP]);
            destroy_tuple(TTemp[SP-1]);
            TTemp[SP-1]=TTemp[SP];
            create_tuple_s(&TTemp[SP++],".2f");
            T_tuple_string(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
            destroy_tuple(TTemp[SP-2]);
            destroy_tuple(TTemp[SP-1]);
            TTemp[SP-2]=TTemp[SP];
            SP--;
            T_tuple_add(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
            destroy_tuple(TTemp[SP-2]);
            destroy_tuple(TTemp[SP-1]);
            TTemp[SP-2]=TTemp[SP];
            SP--;
            create_tuple_s(&TTemp[SP++],") : ");
            T_tuple_add(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
            destroy_tuple(TTemp[SP-2]);
            destroy_tuple(TTemp[SP-1]);
            TTemp[SP-2]=TTemp[SP];
            SP--;
            destroy_tuple(hv_ResultLine);
            hv_ResultLine=TTemp[--SP];

            /*ResultLine := ResultLine + __get_dict_tuple( DLResult, ['selected_class_names'])[RIdx]*/
            create_tuple_s(&TTemp[SP++],"selected_class_names");
            T_get_dict_tuple(hv_DLResult_COPY_INP_TMP,TTemp[SP-1],&TTemp[SP]);
            destroy_tuple(TTemp[SP-1]);
            TTemp[SP-1]=TTemp[SP];
            T_tuple_select(TTemp[SP-1],hv_RIdx,&TTemp[SP]);
            destroy_tuple(TTemp[SP-1]);
            TTemp[SP-1]=TTemp[SP];
            T_tuple_add(hv_ResultLine,TTemp[SP-1],&TTemp[SP]);
            destroy_tuple(hv_ResultLine);
            hv_ResultLine=TTemp[SP];
            destroy_tuple(TTemp[--SP]);

            /*Text := [Text,ResultLine]*/
            copy_tuple(hv_Text,&TTemp[SP++]);
            T_tuple_concat(TTemp[SP-1],hv_ResultLine,&TTemp[SP]);
            destroy_tuple(TTemp[SP-1]);
            TTemp[SP-1]=TTemp[SP];
            destroy_tuple(hv_Text);
            hv_Text=TTemp[--SP];

            /*========== if (-1 != find(ClassificationLabelIDGroundTruth,__get_dict_tuple( DLResult, ['selected_class_ids'])[RIdx])) ==========*/
            create_tuple_i(&TTemp[SP++],-1);
            create_tuple_s(&TTemp[SP++],"selected_class_ids");
            T_get_dict_tuple(hv_DLResult_COPY_INP_TMP,TTemp[SP-1],&TTemp[SP]);
            destroy_tuple(TTemp[SP-1]);
            TTemp[SP-1]=TTemp[SP];
            T_tuple_select(TTemp[SP-1],hv_RIdx,&TTemp[SP]);
            destroy_tuple(TTemp[SP-1]);
            TTemp[SP-1]=TTemp[SP];
            T_tuple_find(hv_ClassificationLabelIDGroundTruth,TTemp[SP-1],&TTemp[SP]);
            destroy_tuple(TTemp[SP-1]);
            TTemp[SP-1]=TTemp[SP];
            T_tuple_not_equal(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
            destroy_tuple(TTemp[SP-2]);
            destroy_tuple(TTemp[SP-1]);
            TTemp[SP-2]=TTemp[SP];
            SP--;
            if(get_i(TTemp[SP-1],0))
            {
              /*TPIndices := [TPIndices,RIdx]*/
              copy_tuple(hv_TPIndices,&TTemp[SP++]);
              T_tuple_concat(TTemp[SP-1],hv_RIdx,&TTemp[SP]);
              destroy_tuple(TTemp[SP-1]);
              TTemp[SP-1]=TTemp[SP];
              destroy_tuple(hv_TPIndices);
              hv_TPIndices=TTemp[--SP];

            }
            destroy_tuple(TTemp[--SP]);
            /*========== end if ==========*/
           }
           destroy_tuple(TTemp[SP--]);
           destroy_tuple(TTemp[SP--]);
           destroy_tuple(TTemp[SP]);
          }
          else
          {
           destroy_tuple(TTemp[SP--]);
           destroy_tuple(TTemp[SP--]);
           destroy_tuple(TTemp[SP--]);
           destroy_tuple(TTemp[SP--]);
           destroy_tuple(TTemp[SP]);
          }/*========== end for ========*/

          /*Check for false negatives and add those to the legend (only multi-label classification)*/
          /*HasFalseNegatives := |difference(ClassificationLabelIDGroundTruth,__get_dict_tuple( DLResult, ['selected_class_ids']))| > 0*/
          create_tuple_s(&TTemp[SP++],"selected_class_ids");
          T_get_dict_tuple(hv_DLResult_COPY_INP_TMP,TTemp[SP-1],&TTemp[SP]);
          destroy_tuple(TTemp[SP-1]);
          TTemp[SP-1]=TTemp[SP];
          T_tuple_difference(hv_ClassificationLabelIDGroundTruth,TTemp[SP-1],&TTemp[SP]);
          destroy_tuple(TTemp[SP-1]);
          TTemp[SP-1]=TTemp[SP];
          T_tuple_length(TTemp[SP-1],&TTemp[SP]);
          destroy_tuple(TTemp[SP-1]);
          TTemp[SP-1]=TTemp[SP];
          create_tuple_i(&TTemp[SP++],0);
          T_tuple_greater(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
          destroy_tuple(TTemp[SP-2]);
          destroy_tuple(TTemp[SP-1]);
          TTemp[SP-2]=TTemp[SP];
          SP--;
          destroy_tuple(hv_HasFalseNegatives);
          hv_HasFalseNegatives=TTemp[--SP];

          /*========== if (HasFalseNegatives) ==========*/
          copy_tuple(hv_HasFalseNegatives,&TTemp[SP++]);
          if(get_i(TTemp[SP-1],0))
          {
            /*FalseNegativeClassIDs := difference(ClassificationLabelIDGroundTruth,__get_dict_tuple( DLResult, ['selected_class_ids']))*/
            create_tuple_s(&TTemp[SP++],"selected_class_ids");
            T_get_dict_tuple(hv_DLResult_COPY_INP_TMP,TTemp[SP-1],&TTemp[SP]);
            destroy_tuple(TTemp[SP-1]);
            TTemp[SP-1]=TTemp[SP];
            T_tuple_difference(hv_ClassificationLabelIDGroundTruth,TTemp[SP-1],&TTemp[SP]);
            destroy_tuple(TTemp[SP-1]);
            TTemp[SP-1]=TTemp[SP];
            destroy_tuple(hv_FalseNegativeClassIDs);
            hv_FalseNegativeClassIDs=TTemp[--SP];

            /*========== if (|FalseNegativeClassIDs| > 1) ==========*/
            T_tuple_length(hv_FalseNegativeClassIDs,&TTemp[SP++]);
            create_tuple_i(&TTemp[SP++],1);
            T_tuple_greater(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
            destroy_tuple(TTemp[SP-2]);
            destroy_tuple(TTemp[SP-1]);
            TTemp[SP-2]=TTemp[SP];
            SP--;
            if(get_i(TTemp[SP-1],0))
            {
              /*PluralPostfix := 's'*/
              reuse_tuple_s(&hv_PluralPostfix,"s");
            }
            else
            {
              /*PluralPostfix := ''*/
              reuse_tuple_s(&hv_PluralPostfix,"");
            }
            destroy_tuple(TTemp[--SP]);
            /*========== end if ==========*/
            /*Text := [Text,'']*/
            copy_tuple(hv_Text,&TTemp[SP++]);
            create_tuple_s(&TTemp[SP++],"");
            T_tuple_concat(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
            destroy_tuple(TTemp[SP-2]);
            destroy_tuple(TTemp[SP-1]);
            TTemp[SP-2]=TTemp[SP];
            SP--;
            destroy_tuple(hv_Text);
            hv_Text=TTemp[--SP];

            /*Text := [Text,'False negative class ID' + PluralPostfix]*/
            copy_tuple(hv_Text,&TTemp[SP++]);
            create_tuple_s(&TTemp[SP++],"False negative class ID");
            T_tuple_add(TTemp[SP-1],hv_PluralPostfix,&TTemp[SP]);
            destroy_tuple(TTemp[SP-1]);
            TTemp[SP-1]=TTemp[SP];
            T_tuple_concat(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
            destroy_tuple(TTemp[SP-2]);
            destroy_tuple(TTemp[SP-1]);
            TTemp[SP-2]=TTemp[SP];
            SP--;
            destroy_tuple(hv_Text);
            hv_Text=TTemp[--SP];

            /*========== for FNIdx := 0 to |FalseNegativeClassIDs| - 1 by 1 ==========*/
            T_tuple_length(hv_FalseNegativeClassIDs,&TTemp[SP++]);
            create_tuple_i(&TTemp[SP++],1);
            T_tuple_sub(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
            destroy_tuple(TTemp[SP-2]);
            destroy_tuple(TTemp[SP-1]);
            TTemp[SP-2]=TTemp[SP];
            SP--;
            create_tuple_i(&TTemp[SP++],1);
            create_tuple_i(&TTemp[SP++],0);
            T_tuple_greater(TTemp[SP-1],TTemp[SP-3],&TTemp[SP]);
            SP++;
            T_tuple_equal(TTemp[SP-2],TTemp[SP-4],&TTemp[SP]);
            if(get_i(TTemp[SP],0) ||
               (!((( get_i(TTemp[SP-1],0)) && (get_d(TTemp[SP-3],0)>0)) ||
                  ((!get_i(TTemp[SP-1],0)) && (get_d(TTemp[SP-3],0)<0)))))
            {
             destroy_tuple(TTemp[SP--]);
             destroy_tuple(TTemp[SP]);
             T_tuple_sub(TTemp[SP-1],TTemp[SP-2],&TTemp[SP]);
             destroy_tuple(hv_FNIdx);
             copy_tuple(TTemp[SP],&hv_FNIdx);
             destroy_tuple(TTemp[SP--]);
             destroy_tuple(TTemp[SP]);
             for(;;)
             {
             T_tuple_add(hv_FNIdx,TTemp[SP-1],&TTemp[SP]);
             destroy_tuple(hv_FNIdx);
             copy_tuple(TTemp[SP],&hv_FNIdx);
             destroy_tuple(TTemp[SP]);
             if(get_d(TTemp[SP-1],0)<0)
              T_tuple_less(hv_FNIdx,TTemp[SP-2],&TTemp[SP]);
             else
              T_tuple_greater(hv_FNIdx,TTemp[SP-2],&TTemp[SP]);
             if(get_i(TTemp[SP],0)) break;
             destroy_tuple(TTemp[SP]);
             /*========== for ==========*/

              /*FNClassIdx := __get_dict_tuple( ClassIDstoIndex, FalseNegativeClassIDs[FNIdx])*/
              T_tuple_select(hv_FalseNegativeClassIDs,hv_FNIdx,&TTemp[SP++]);
              T_get_dict_tuple(hv_ClassIDstoIndex,TTemp[SP-1],&TTemp[SP]);
              destroy_tuple(TTemp[SP-1]);
              TTemp[SP-1]=TTemp[SP];
              destroy_tuple(hv_FNClassIdx);
              hv_FNClassIdx=TTemp[--SP];

              /*FNLine := __get_dict_tuple( DLResult, ['class_ids'])[FNClassIdx]*/
              create_tuple_s(&TTemp[SP++],"class_ids");
              T_get_dict_tuple(hv_DLResult_COPY_INP_TMP,TTemp[SP-1],&TTemp[SP]);
              destroy_tuple(TTemp[SP-1]);
              TTemp[SP-1]=TTemp[SP];
              T_tuple_select(TTemp[SP-1],hv_FNClassIdx,&TTemp[SP]);
              destroy_tuple(TTemp[SP-1]);
              TTemp[SP-1]=TTemp[SP];
              destroy_tuple(hv_FNLine);
              hv_FNLine=TTemp[--SP];

              /*FNLine := FNLine + ' (' + (__get_dict_tuple( DLResult, ['confidences'])[FNClassIdx]$'f'){0:3} + ') : '*/
              copy_tuple(hv_FNLine,&TTemp[SP++]);
              create_tuple_s(&TTemp[SP++]," (");
              T_tuple_add(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
              destroy_tuple(TTemp[SP-2]);
              destroy_tuple(TTemp[SP-1]);
              TTemp[SP-2]=TTemp[SP];
              SP--;
              create_tuple_s(&TTemp[SP++],"confidences");
              T_get_dict_tuple(hv_DLResult_COPY_INP_TMP,TTemp[SP-1],&TTemp[SP]);
              destroy_tuple(TTemp[SP-1]);
              TTemp[SP-1]=TTemp[SP];
              T_tuple_select(TTemp[SP-1],hv_FNClassIdx,&TTemp[SP]);
              destroy_tuple(TTemp[SP-1]);
              TTemp[SP-1]=TTemp[SP];
              create_tuple_s(&TTemp[SP++],"f");
              T_tuple_string(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
              destroy_tuple(TTemp[SP-2]);
              destroy_tuple(TTemp[SP-1]);
              TTemp[SP-2]=TTemp[SP];
              SP--;
              create_tuple_i(&TTemp[SP++],0);
              create_tuple_i(&TTemp[SP++],3);
              T_tuple_substr(TTemp[SP-3],TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
              destroy_tuple(TTemp[SP-3]);
              destroy_tuple(TTemp[SP-2]);
              destroy_tuple(TTemp[SP-1]);
              TTemp[SP-3]=TTemp[SP];
              SP=SP-2;
              T_tuple_add(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
              destroy_tuple(TTemp[SP-2]);
              destroy_tuple(TTemp[SP-1]);
              TTemp[SP-2]=TTemp[SP];
              SP--;
              create_tuple_s(&TTemp[SP++],") : ");
              T_tuple_add(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
              destroy_tuple(TTemp[SP-2]);
              destroy_tuple(TTemp[SP-1]);
              TTemp[SP-2]=TTemp[SP];
              SP--;
              destroy_tuple(hv_FNLine);
              hv_FNLine=TTemp[--SP];

              /*FNLine := FNLine + __get_dict_tuple( DLResult, ['class_names'])[FNClassIdx]*/
              create_tuple_s(&TTemp[SP++],"class_names");
              T_get_dict_tuple(hv_DLResult_COPY_INP_TMP,TTemp[SP-1],&TTemp[SP]);
              destroy_tuple(TTemp[SP-1]);
              TTemp[SP-1]=TTemp[SP];
              T_tuple_select(TTemp[SP-1],hv_FNClassIdx,&TTemp[SP]);
              destroy_tuple(TTemp[SP-1]);
              TTemp[SP-1]=TTemp[SP];
              T_tuple_add(hv_FNLine,TTemp[SP-1],&TTemp[SP]);
              destroy_tuple(hv_FNLine);
              hv_FNLine=TTemp[SP];
              destroy_tuple(TTemp[--SP]);

              /*Text := [Text,FNLine]*/
              copy_tuple(hv_Text,&TTemp[SP++]);
              T_tuple_concat(TTemp[SP-1],hv_FNLine,&TTemp[SP]);
              destroy_tuple(TTemp[SP-1]);
              TTemp[SP-1]=TTemp[SP];
              destroy_tuple(hv_Text);
              hv_Text=TTemp[--SP];

             }
             destroy_tuple(TTemp[SP--]);
             destroy_tuple(TTemp[SP--]);
             destroy_tuple(TTemp[SP]);
            }
            else
            {
             destroy_tuple(TTemp[SP--]);
             destroy_tuple(TTemp[SP--]);
             destroy_tuple(TTemp[SP--]);
             destroy_tuple(TTemp[SP--]);
             destroy_tuple(TTemp[SP]);
            }/*========== end for ========*/

            /*NumFNLines := FNIdx*/
            destroy_tuple(hv_NumFNLines);
            copy_tuple(hv_FNIdx,&hv_NumFNLines);

          }
          destroy_tuple(TTemp[--SP]);
          /*========== end if ==========*/
        }
        else
        {
          /*Text := [Text,ClassesLegend[__get_dict_tuple( ClassIDstoIndex, ClassificationLabelIDResult)]]*/
          copy_tuple(hv_Text,&TTemp[SP++]);
          T_get_dict_tuple(hv_ClassIDstoIndex,hv_ClassificationLabelIDResult,&TTemp[SP++]);
          T_tuple_select(hv_ClassesLegend,TTemp[SP-1],&TTemp[SP]);
          destroy_tuple(TTemp[SP-1]);
          TTemp[SP-1]=TTemp[SP];
          T_tuple_concat(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
          destroy_tuple(TTemp[SP-2]);
          destroy_tuple(TTemp[SP-1]);
          TTemp[SP-2]=TTemp[SP];
          SP--;
          destroy_tuple(hv_Text);
          hv_Text=TTemp[--SP];

        }
        destroy_tuple(TTemp[--SP]);
        /*========== end if ==========*/
        /*Text[|Text|] := ''*/
        copy_tuple(hv_Text,&TTemp[SP++]);
        T_tuple_length(TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-1]=TTemp[SP];
        create_tuple_s(&TTemp[SP++],"");
        replace_elements(&hv_Text,&TTemp[SP-2],&TTemp[SP-1]);
        destroy_tuple(TTemp[--SP]);
        destroy_tuple(TTemp[--SP]);
        /*Text[|Text|] := ''*/
        copy_tuple(hv_Text,&TTemp[SP++]);
        T_tuple_length(TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-1]=TTemp[SP];
        create_tuple_s(&TTemp[SP++],"");
        replace_elements(&hv_Text,&TTemp[SP-2],&TTemp[SP-1]);
        destroy_tuple(TTemp[--SP]);
        destroy_tuple(TTemp[--SP]);
        /*Text[|Text|] := 'Prediction '*/
        copy_tuple(hv_Text,&TTemp[SP++]);
        T_tuple_length(TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-1]=TTemp[SP];
        create_tuple_s(&TTemp[SP++],"Prediction ");
        replace_elements(&hv_Text,&TTemp[SP-2],&TTemp[SP-1]);
        destroy_tuple(TTemp[--SP]);
        destroy_tuple(TTemp[--SP]);
        /*Text[|Text|] := PredictionText*/
        copy_tuple(hv_Text,&TTemp[SP++]);
        T_tuple_length(TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-1]=TTemp[SP];
        replace_elements(&hv_Text,&TTemp[SP-1],&hv_PredictionText);
        destroy_tuple(TTemp[--SP]);
        /**/
        /*Get or open next child window.*/
        /*get_child_window (HeightImage, __get_dict_tuple( Params, ['font']), __get_dict_tuple( Params, ['font_size']), Text, PrevWindowCoordinates, WindowHandleDict, KeysForDisplay[KeyIndex], WindowImageRatio, PrevWindowCoordinates)*/
        create_tuple_s(&TTemp[SP++],"font");
        T_get_dict_tuple(hv_Params,TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-1]=TTemp[SP];
        create_tuple_s(&TTemp[SP++],"font_size");
        T_get_dict_tuple(hv_Params,TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-1]=TTemp[SP];
        copy_tuple(hv_PrevWindowCoordinates,&TTemp[SP++]);
        T_tuple_select(hv_KeysForDisplay_COPY_INP_TMP,hv_KeyIndex,&TTemp[SP++]);
        destroy_tuple(hv_WindowImageRatio);
        destroy_tuple(hv_PrevWindowCoordinates);
        /***/get_child_window(hv_HeightImage, TTemp[SP-4], TTemp[SP-3], hv_Text, 
            TTemp[SP-2], hv_WindowHandleDict, TTemp[SP-1], &hv_WindowImageRatio, 
            &hv_PrevWindowCoordinates);
        destroy_tuple(TTemp[--SP]);
        destroy_tuple(TTemp[--SP]);
        destroy_tuple(TTemp[--SP]);
        destroy_tuple(TTemp[--SP]);

        /*tuple_gen_const (|Text|, 'white', LineColors)*/
        T_tuple_length(hv_Text,&TTemp[SP++]);
        create_tuple_s(&TTemp[SP++],"white");
        destroy_tuple(hv_LineColors);
        /***/T_tuple_gen_const(TTemp[SP-2], TTemp[SP-1], &hv_LineColors);
        destroy_tuple(TTemp[--SP]);
        destroy_tuple(TTemp[--SP]);

        /*get_dict_param (DLSample, 'key_exists', 'image_label_ids', IsMLC)*/
        create_tuple_s(&TTemp[SP++],"key_exists");
        create_tuple_s(&TTemp[SP++],"image_label_ids");
        destroy_tuple(hv_IsMLC);
        /***/T_get_dict_param(hv_DLSample, TTemp[SP-2], TTemp[SP-1], &hv_IsMLC);
        destroy_tuple(TTemp[--SP]);
        destroy_tuple(TTemp[--SP]);

        /*========== if (IsMLC) ==========*/
        copy_tuple(hv_IsMLC,&TTemp[SP++]);
        if(get_i(TTemp[SP-1],0))
        {
          /*tuple_gen_const (|Colors|, 'light gray', Colors)*/
          copy_tuple(hv_Colors,&TTemp[SP++]);
          T_tuple_length(TTemp[SP-1],&TTemp[SP]);
          destroy_tuple(TTemp[SP-1]);
          TTemp[SP-1]=TTemp[SP];
          create_tuple_s(&TTemp[SP++],"light gray");
          destroy_tuple(hv_Colors);
          /***/T_tuple_gen_const(TTemp[SP-2], TTemp[SP-1], &hv_Colors);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(TTemp[--SP]);

          /*tuple_gen_const (|__get_dict_tuple( DLResult, ['selected_class_ids'])|, 'red', ResultColors)*/
          create_tuple_s(&TTemp[SP++],"selected_class_ids");
          T_get_dict_tuple(hv_DLResult_COPY_INP_TMP,TTemp[SP-1],&TTemp[SP]);
          destroy_tuple(TTemp[SP-1]);
          TTemp[SP-1]=TTemp[SP];
          T_tuple_length(TTemp[SP-1],&TTemp[SP]);
          destroy_tuple(TTemp[SP-1]);
          TTemp[SP-1]=TTemp[SP];
          create_tuple_s(&TTemp[SP++],"red");
          destroy_tuple(hv_ResultColors);
          /***/T_tuple_gen_const(TTemp[SP-2], TTemp[SP-1], &hv_ResultColors);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(TTemp[--SP]);

        }
        destroy_tuple(TTemp[--SP]);
        /*========== end if ==========*/
        /*LineColors[1:|ClassificationLabelIDGroundTruth|] := Colors[__get_dict_tuple( ClassIDstoIndex, ClassificationLabelIDGroundTruth)]*/
        create_tuple_i(&TTemp[SP++],1);
        T_tuple_length(hv_ClassificationLabelIDGroundTruth,&TTemp[SP++]);
        create_tuple_i(&TTemp[SP++],1);
        T_tuple_gen_sequence(TTemp[SP-3],TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-1]);
        destroy_tuple(TTemp[SP-2]);
        destroy_tuple(TTemp[SP-3]);
        TTemp[SP-3]=TTemp[SP];
        SP=SP-2;
        T_get_dict_tuple(hv_ClassIDstoIndex,hv_ClassificationLabelIDGroundTruth,&TTemp[SP++]);
        T_tuple_select(hv_Colors,TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-1]=TTemp[SP];
        replace_elements(&hv_LineColors,&TTemp[SP-2],&TTemp[SP-1]);
        destroy_tuple(TTemp[--SP]);
        destroy_tuple(TTemp[--SP]);
        /*========== if (ClassificationLabelIDResult != []) ==========*/
        create_tuple(&TTemp[SP++],0);
        T_tuple_not_equal(hv_ClassificationLabelIDResult,TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-1]=TTemp[SP];
        if(get_i(TTemp[SP-1],0))
        {
          /*========== if (IsMLC) ==========*/
          copy_tuple(hv_IsMLC,&TTemp[SP++]);
          if(get_i(TTemp[SP-1],0))
          {
            /*ResultColors[TPIndices] := 'green'*/
            create_tuple_s(&TTemp[SP++],"green");
            replace_elements(&hv_ResultColors,&hv_TPIndices,&TTemp[SP-1]);
            destroy_tuple(TTemp[--SP]);
            /*LineColors[5 + |ClassificationLabelIDGroundTruth| - 1:5 + |ClassificationLabelIDGroundTruth| - 1 + |ClassificationLabelIDResult| - 1] := ResultColors*/
            create_tuple_i(&TTemp[SP++],5);
            T_tuple_length(hv_ClassificationLabelIDGroundTruth,&TTemp[SP++]);
            T_tuple_add(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
            destroy_tuple(TTemp[SP-2]);
            destroy_tuple(TTemp[SP-1]);
            TTemp[SP-2]=TTemp[SP];
            SP--;
            create_tuple_i(&TTemp[SP++],1);
            T_tuple_sub(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
            destroy_tuple(TTemp[SP-2]);
            destroy_tuple(TTemp[SP-1]);
            TTemp[SP-2]=TTemp[SP];
            SP--;
            create_tuple_i(&TTemp[SP++],5);
            T_tuple_length(hv_ClassificationLabelIDGroundTruth,&TTemp[SP++]);
            T_tuple_add(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
            destroy_tuple(TTemp[SP-2]);
            destroy_tuple(TTemp[SP-1]);
            TTemp[SP-2]=TTemp[SP];
            SP--;
            create_tuple_i(&TTemp[SP++],1);
            T_tuple_sub(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
            destroy_tuple(TTemp[SP-2]);
            destroy_tuple(TTemp[SP-1]);
            TTemp[SP-2]=TTemp[SP];
            SP--;
            T_tuple_length(hv_ClassificationLabelIDResult,&TTemp[SP++]);
            T_tuple_add(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
            destroy_tuple(TTemp[SP-2]);
            destroy_tuple(TTemp[SP-1]);
            TTemp[SP-2]=TTemp[SP];
            SP--;
            create_tuple_i(&TTemp[SP++],1);
            T_tuple_sub(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
            destroy_tuple(TTemp[SP-2]);
            destroy_tuple(TTemp[SP-1]);
            TTemp[SP-2]=TTemp[SP];
            SP--;
            create_tuple_i(&TTemp[SP++],1);
            T_tuple_gen_sequence(TTemp[SP-3],TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
            destroy_tuple(TTemp[SP-1]);
            destroy_tuple(TTemp[SP-2]);
            destroy_tuple(TTemp[SP-3]);
            TTemp[SP-3]=TTemp[SP];
            SP=SP-2;
            replace_elements(&hv_LineColors,&TTemp[SP-1],&hv_ResultColors);
            destroy_tuple(TTemp[--SP]);
          }
          else
          {
            /*LineColors[5 + |ClassificationLabelIDGroundTruth| - 1:5 + |ClassificationLabelIDGroundTruth| - 1 + |ClassificationLabelIDResult| - 1] := Colors[__get_dict_tuple( ClassIDstoIndex, ClassificationLabelIDResult)]*/
            create_tuple_i(&TTemp[SP++],5);
            T_tuple_length(hv_ClassificationLabelIDGroundTruth,&TTemp[SP++]);
            T_tuple_add(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
            destroy_tuple(TTemp[SP-2]);
            destroy_tuple(TTemp[SP-1]);
            TTemp[SP-2]=TTemp[SP];
            SP--;
            create_tuple_i(&TTemp[SP++],1);
            T_tuple_sub(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
            destroy_tuple(TTemp[SP-2]);
            destroy_tuple(TTemp[SP-1]);
            TTemp[SP-2]=TTemp[SP];
            SP--;
            create_tuple_i(&TTemp[SP++],5);
            T_tuple_length(hv_ClassificationLabelIDGroundTruth,&TTemp[SP++]);
            T_tuple_add(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
            destroy_tuple(TTemp[SP-2]);
            destroy_tuple(TTemp[SP-1]);
            TTemp[SP-2]=TTemp[SP];
            SP--;
            create_tuple_i(&TTemp[SP++],1);
            T_tuple_sub(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
            destroy_tuple(TTemp[SP-2]);
            destroy_tuple(TTemp[SP-1]);
            TTemp[SP-2]=TTemp[SP];
            SP--;
            T_tuple_length(hv_ClassificationLabelIDResult,&TTemp[SP++]);
            T_tuple_add(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
            destroy_tuple(TTemp[SP-2]);
            destroy_tuple(TTemp[SP-1]);
            TTemp[SP-2]=TTemp[SP];
            SP--;
            create_tuple_i(&TTemp[SP++],1);
            T_tuple_sub(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
            destroy_tuple(TTemp[SP-2]);
            destroy_tuple(TTemp[SP-1]);
            TTemp[SP-2]=TTemp[SP];
            SP--;
            create_tuple_i(&TTemp[SP++],1);
            T_tuple_gen_sequence(TTemp[SP-3],TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
            destroy_tuple(TTemp[SP-1]);
            destroy_tuple(TTemp[SP-2]);
            destroy_tuple(TTemp[SP-3]);
            TTemp[SP-3]=TTemp[SP];
            SP=SP-2;
            T_get_dict_tuple(hv_ClassIDstoIndex,hv_ClassificationLabelIDResult,&TTemp[SP++]);
            T_tuple_select(hv_Colors,TTemp[SP-1],&TTemp[SP]);
            destroy_tuple(TTemp[SP-1]);
            TTemp[SP-1]=TTemp[SP];
            replace_elements(&hv_LineColors,&TTemp[SP-2],&TTemp[SP-1]);
            destroy_tuple(TTemp[--SP]);
            destroy_tuple(TTemp[--SP]);
          }
          destroy_tuple(TTemp[--SP]);
          /*========== end if ==========*/
        }
        else
        {
          /*LineColors[5 + |ClassificationLabelIDGroundTruth| - 1] := 'red'*/
          create_tuple_i(&TTemp[SP++],5);
          T_tuple_length(hv_ClassificationLabelIDGroundTruth,&TTemp[SP++]);
          T_tuple_add(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
          destroy_tuple(TTemp[SP-2]);
          destroy_tuple(TTemp[SP-1]);
          TTemp[SP-2]=TTemp[SP];
          SP--;
          create_tuple_i(&TTemp[SP++],1);
          T_tuple_sub(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
          destroy_tuple(TTemp[SP-2]);
          destroy_tuple(TTemp[SP-1]);
          TTemp[SP-2]=TTemp[SP];
          SP--;
          create_tuple_s(&TTemp[SP++],"red");
          replace_elements(&hv_LineColors,&TTemp[SP-2],&TTemp[SP-1]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(TTemp[--SP]);
        }
        destroy_tuple(TTemp[--SP]);
        /*========== end if ==========*/
        /*LineColors[|LineColors| - 1] := PredictionColor*/
        copy_tuple(hv_LineColors,&TTemp[SP++]);
        T_tuple_length(TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-1]=TTemp[SP];
        create_tuple_i(&TTemp[SP++],1);
        T_tuple_sub(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-2]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-2]=TTemp[SP];
        SP--;
        replace_elements(&hv_LineColors,&TTemp[SP-1],&hv_PredictionColor);
        destroy_tuple(TTemp[--SP]);
        /*get_dict_param (DLResult, 'key_exists', 'selected_confidences', HasConfidences)*/
        create_tuple_s(&TTemp[SP++],"key_exists");
        create_tuple_s(&TTemp[SP++],"selected_confidences");
        destroy_tuple(hv_HasConfidences);
        /***/T_get_dict_param(hv_DLResult_COPY_INP_TMP, TTemp[SP-2], TTemp[SP-1], 
            &hv_HasConfidences);
        destroy_tuple(TTemp[--SP]);
        destroy_tuple(TTemp[--SP]);

        /*========== if (HasConfidences) ==========*/
        copy_tuple(hv_HasConfidences,&TTemp[SP++]);
        if(get_i(TTemp[SP-1],0))
        {
          /*HasFalseNegatives := |difference(ClassificationLabelIDGroundTruth,__get_dict_tuple( DLResult, ['selected_class_ids']))| > 0*/
          create_tuple_s(&TTemp[SP++],"selected_class_ids");
          T_get_dict_tuple(hv_DLResult_COPY_INP_TMP,TTemp[SP-1],&TTemp[SP]);
          destroy_tuple(TTemp[SP-1]);
          TTemp[SP-1]=TTemp[SP];
          T_tuple_difference(hv_ClassificationLabelIDGroundTruth,TTemp[SP-1],&TTemp[SP]);
          destroy_tuple(TTemp[SP-1]);
          TTemp[SP-1]=TTemp[SP];
          T_tuple_length(TTemp[SP-1],&TTemp[SP]);
          destroy_tuple(TTemp[SP-1]);
          TTemp[SP-1]=TTemp[SP];
          create_tuple_i(&TTemp[SP++],0);
          T_tuple_greater(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
          destroy_tuple(TTemp[SP-2]);
          destroy_tuple(TTemp[SP-1]);
          TTemp[SP-2]=TTemp[SP];
          SP--;
          destroy_tuple(hv_HasFalseNegatives);
          hv_HasFalseNegatives=TTemp[--SP];

          /*========== if (HasFalseNegatives) ==========*/
          copy_tuple(hv_HasFalseNegatives,&TTemp[SP++]);
          if(get_i(TTemp[SP-1],0))
          {
            /*LineColors[|LineColors| - 4 - NumFNLines:|LineColors| - 4] := 'red'*/
            copy_tuple(hv_LineColors,&TTemp[SP++]);
            T_tuple_length(TTemp[SP-1],&TTemp[SP]);
            destroy_tuple(TTemp[SP-1]);
            TTemp[SP-1]=TTemp[SP];
            create_tuple_i(&TTemp[SP++],4);
            T_tuple_sub(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
            destroy_tuple(TTemp[SP-2]);
            destroy_tuple(TTemp[SP-1]);
            TTemp[SP-2]=TTemp[SP];
            SP--;
            T_tuple_sub(TTemp[SP-1],hv_NumFNLines,&TTemp[SP]);
            destroy_tuple(TTemp[SP-1]);
            TTemp[SP-1]=TTemp[SP];
            copy_tuple(hv_LineColors,&TTemp[SP++]);
            T_tuple_length(TTemp[SP-1],&TTemp[SP]);
            destroy_tuple(TTemp[SP-1]);
            TTemp[SP-1]=TTemp[SP];
            create_tuple_i(&TTemp[SP++],4);
            T_tuple_sub(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
            destroy_tuple(TTemp[SP-2]);
            destroy_tuple(TTemp[SP-1]);
            TTemp[SP-2]=TTemp[SP];
            SP--;
            create_tuple_i(&TTemp[SP++],1);
            T_tuple_gen_sequence(TTemp[SP-3],TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
            destroy_tuple(TTemp[SP-1]);
            destroy_tuple(TTemp[SP-2]);
            destroy_tuple(TTemp[SP-3]);
            TTemp[SP-3]=TTemp[SP];
            SP=SP-2;
            create_tuple_s(&TTemp[SP++],"red");
            replace_elements(&hv_LineColors,&TTemp[SP-2],&TTemp[SP-1]);
            destroy_tuple(TTemp[--SP]);
            destroy_tuple(TTemp[--SP]);
          }
          destroy_tuple(TTemp[--SP]);
          /*========== end if ==========*/
        }
        destroy_tuple(TTemp[--SP]);
        /*========== end if ==========*/
        if (hdev_window_stack_is_open())
        {
          Htuple active_win;
          create_tuple(&active_win,0);
          hdev_window_stack_get_active(&active_win);
          /*dev_disp_text (Text, 'window', 'top', 'left', LineColors, 'box', 'false')*/
          create_tuple_s(&TTemp[SP++],"window");
          create_tuple_s(&TTemp[SP++],"top");
          create_tuple_s(&TTemp[SP++],"left");
          create_tuple_s(&TTemp[SP++],"box");
          create_tuple_s(&TTemp[SP++],"false");
          /***/T_disp_text(active_win,hv_Text, TTemp[SP-5], TTemp[SP-4], TTemp[SP-3], 
              hv_LineColors, TTemp[SP-2], TTemp[SP-1]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(active_win);
        }
      }
      destroy_tuple(TTemp[--SP]);
      /*========== end if ==========*/
    }
    else
    {
    destroy_tuple(TTemp[--SP]);
    /*========== elseif (KeysForDisplay[KeyIndex] == 'classification_ground_truth' or KeysForDisplay[KeyIndex] == 'multi_label_classification_ground_truth') ==========*/

    T_tuple_select(hv_KeysForDisplay_COPY_INP_TMP,hv_KeyIndex,&TTemp[SP++]);
    create_tuple_s(&TTemp[SP++],"classification_ground_truth");
    T_tuple_equal(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-2]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-2]=TTemp[SP];
    SP--;
    T_tuple_select(hv_KeysForDisplay_COPY_INP_TMP,hv_KeyIndex,&TTemp[SP++]);
    create_tuple_s(&TTemp[SP++],"multi_label_classification_ground_truth");
    T_tuple_equal(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-2]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-2]=TTemp[SP];
    SP--;
    T_tuple_or(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-2]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-2]=TTemp[SP];
    SP--;
    if(get_i(TTemp[SP-1],0))
    {
      /**/
      /*Ground truth classification image and class label.*/
      /*get_dl_sample_image (Image, SampleKeys, DLSample, 'image')*/
      create_tuple_s(&TTemp[SP++],"image");
      clear_obj(ho_Image);
      /***/get_dl_sample_image(&ho_Image, hv_SampleKeys, hv_DLSample, TTemp[SP-1]);
      destroy_tuple(TTemp[--SP]);

      /**/
      /*get_classification_ground_truth (SampleKeys, DLSample, ClassificationLabelIDGroundTruth)*/
      destroy_tuple(hv_ClassificationLabelIDGroundTruth);
      /***/get_classification_ground_truth(hv_SampleKeys, hv_DLSample, &hv_ClassificationLabelIDGroundTruth);

      /**/
      /*Get or open next window.*/
      /*get_image_size (Image, WidthImage, HeightImage)*/
      destroy_tuple(hv_WidthImage);
      destroy_tuple(hv_HeightImage);
      /***/T_get_image_size(ho_Image, &hv_WidthImage, &hv_HeightImage);

      /*get_next_window (__get_dict_tuple( Params, ['font']), __get_dict_tuple( Params, ['font_size']), __get_dict_tuple( Params, ['display_bottom_desc']), WidthImage, HeightImage, 0, __get_dict_tuple( Params, ['scale_windows']), __get_dict_tuple( Params, ['threshold_width']), PrevWindowCoordinates, WindowHandleDict, KeysForDisplay[KeyIndex], CurrentWindowHandle, WindowImageRatio, PrevWindowCoordinates)*/
      create_tuple_s(&TTemp[SP++],"font");
      T_get_dict_tuple(hv_Params,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      create_tuple_s(&TTemp[SP++],"font_size");
      T_get_dict_tuple(hv_Params,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      create_tuple_s(&TTemp[SP++],"display_bottom_desc");
      T_get_dict_tuple(hv_Params,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      create_tuple_i(&TTemp[SP++],0);
      create_tuple_s(&TTemp[SP++],"scale_windows");
      T_get_dict_tuple(hv_Params,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      create_tuple_s(&TTemp[SP++],"threshold_width");
      T_get_dict_tuple(hv_Params,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      copy_tuple(hv_PrevWindowCoordinates,&TTemp[SP++]);
      T_tuple_select(hv_KeysForDisplay_COPY_INP_TMP,hv_KeyIndex,&TTemp[SP++]);
      destroy_tuple(hv_CurrentWindowHandle);
      destroy_tuple(hv_WindowImageRatio);
      destroy_tuple(hv_PrevWindowCoordinates);
      /***/get_next_window(TTemp[SP-8], TTemp[SP-7], TTemp[SP-6], hv_WidthImage, 
          hv_HeightImage, TTemp[SP-5], TTemp[SP-4], TTemp[SP-3], TTemp[SP-2], hv_WindowHandleDict, 
          TTemp[SP-1], &hv_CurrentWindowHandle, &hv_WindowImageRatio, &hv_PrevWindowCoordinates);
      destroy_tuple(TTemp[--SP]);
      destroy_tuple(TTemp[--SP]);
      destroy_tuple(TTemp[--SP]);
      destroy_tuple(TTemp[--SP]);
      destroy_tuple(TTemp[--SP]);
      destroy_tuple(TTemp[--SP]);
      destroy_tuple(TTemp[--SP]);
      destroy_tuple(TTemp[--SP]);

      /**/
      /*Visualization.*/
      if (hdev_window_stack_is_open())
      {
        Htuple active_win;
        create_tuple(&active_win,0);
        hdev_window_stack_get_active(&active_win);
        /*dev_display (Image)*/
        /***/T_disp_obj(ho_Image, active_win);
        destroy_tuple(active_win);
      }
      /**/
      /*========== if (|ClassificationLabelIDGroundTruth| > 1) ==========*/
      T_tuple_length(hv_ClassificationLabelIDGroundTruth,&TTemp[SP++]);
      create_tuple_i(&TTemp[SP++],1);
      T_tuple_greater(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-2]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-2]=TTemp[SP];
      SP--;
      if(get_i(TTemp[SP-1],0))
      {
        /*PluralPostfix := 's'*/
        reuse_tuple_s(&hv_PluralPostfix,"s");
        /*ClassificationLabelIDGroundTruth := sort(ClassificationLabelIDGroundTruth)*/
        copy_tuple(hv_ClassificationLabelIDGroundTruth,&TTemp[SP++]);
        T_tuple_sort(TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-1]=TTemp[SP];
        destroy_tuple(hv_ClassificationLabelIDGroundTruth);
        hv_ClassificationLabelIDGroundTruth=TTemp[--SP];

      }
      else
      {
        /*PluralPostfix := ''*/
        reuse_tuple_s(&hv_PluralPostfix,"");
      }
      destroy_tuple(TTemp[--SP]);
      /*========== end if ==========*/
      /**/
      /*========== if (__get_dict_tuple( Params, ['display_classification_ids'])) ==========*/
      create_tuple_s(&TTemp[SP++],"display_classification_ids");
      T_get_dict_tuple(hv_Params,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      if(get_i(TTemp[SP-1],0))
      {
        /*ClassificationLabelIDGroundTruthList := ''*/
        reuse_tuple_s(&hv_ClassificationLabelIDGroundTruthList,"");
        /*========== for C := 0 to |ClassificationLabelIDGroundTruth| - 1 by 1 ==========*/
        T_tuple_length(hv_ClassificationLabelIDGroundTruth,&TTemp[SP++]);
        create_tuple_i(&TTemp[SP++],1);
        T_tuple_sub(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-2]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-2]=TTemp[SP];
        SP--;
        create_tuple_i(&TTemp[SP++],1);
        create_tuple_i(&TTemp[SP++],0);
        T_tuple_greater(TTemp[SP-1],TTemp[SP-3],&TTemp[SP]);
        SP++;
        T_tuple_equal(TTemp[SP-2],TTemp[SP-4],&TTemp[SP]);
        if(get_i(TTemp[SP],0) ||
           (!((( get_i(TTemp[SP-1],0)) && (get_d(TTemp[SP-3],0)>0)) ||
              ((!get_i(TTemp[SP-1],0)) && (get_d(TTemp[SP-3],0)<0)))))
        {
         destroy_tuple(TTemp[SP--]);
         destroy_tuple(TTemp[SP]);
         T_tuple_sub(TTemp[SP-1],TTemp[SP-2],&TTemp[SP]);
         destroy_tuple(hv_C);
         copy_tuple(TTemp[SP],&hv_C);
         destroy_tuple(TTemp[SP--]);
         destroy_tuple(TTemp[SP]);
         for(;;)
         {
         T_tuple_add(hv_C,TTemp[SP-1],&TTemp[SP]);
         destroy_tuple(hv_C);
         copy_tuple(TTemp[SP],&hv_C);
         destroy_tuple(TTemp[SP]);
         if(get_d(TTemp[SP-1],0)<0)
          T_tuple_less(hv_C,TTemp[SP-2],&TTemp[SP]);
         else
          T_tuple_greater(hv_C,TTemp[SP-2],&TTemp[SP]);
         if(get_i(TTemp[SP],0)) break;
         destroy_tuple(TTemp[SP]);
         /*========== for ==========*/

          /*ClassificationLabelIDGroundTruthList := ClassificationLabelIDGroundTruthList + ClassificationLabelIDGroundTruth[C]*/
          T_tuple_select(hv_ClassificationLabelIDGroundTruth,hv_C,&TTemp[SP++]);
          T_tuple_add(hv_ClassificationLabelIDGroundTruthList,TTemp[SP-1],&TTemp[SP]);
          destroy_tuple(hv_ClassificationLabelIDGroundTruthList);
          hv_ClassificationLabelIDGroundTruthList=TTemp[SP];
          destroy_tuple(TTemp[--SP]);

          /*========== if (C < |ClassificationLabelIDGroundTruth| - 1) ==========*/
          T_tuple_length(hv_ClassificationLabelIDGroundTruth,&TTemp[SP++]);
          create_tuple_i(&TTemp[SP++],1);
          T_tuple_sub(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
          destroy_tuple(TTemp[SP-2]);
          destroy_tuple(TTemp[SP-1]);
          TTemp[SP-2]=TTemp[SP];
          SP--;
          T_tuple_less(hv_C,TTemp[SP-1],&TTemp[SP]);
          destroy_tuple(TTemp[SP-1]);
          TTemp[SP-1]=TTemp[SP];
          if(get_i(TTemp[SP-1],0))
          {
            /*ClassificationLabelIDGroundTruthList := ClassificationLabelIDGroundTruthList + ', '*/
            create_tuple_s(&TTemp[SP++],", ");
            T_tuple_add(hv_ClassificationLabelIDGroundTruthList,TTemp[SP-1],&TTemp[SP]);
            destroy_tuple(hv_ClassificationLabelIDGroundTruthList);
            hv_ClassificationLabelIDGroundTruthList=TTemp[SP];
            destroy_tuple(TTemp[--SP]);

          }
          destroy_tuple(TTemp[--SP]);
          /*========== end if ==========*/
         }
         destroy_tuple(TTemp[SP--]);
         destroy_tuple(TTemp[SP--]);
         destroy_tuple(TTemp[SP]);
        }
        else
        {
         destroy_tuple(TTemp[SP--]);
         destroy_tuple(TTemp[SP--]);
         destroy_tuple(TTemp[SP--]);
         destroy_tuple(TTemp[SP--]);
         destroy_tuple(TTemp[SP]);
        }/*========== end for ========*/

        /*Text := 'GT label ID' + PluralPostfix + ': ' + ClassificationLabelIDGroundTruthList*/
        create_tuple_s(&TTemp[SP++],"GT label ID");
        T_tuple_add(TTemp[SP-1],hv_PluralPostfix,&TTemp[SP]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-1]=TTemp[SP];
        create_tuple_s(&TTemp[SP++],": ");
        T_tuple_add(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-2]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-2]=TTemp[SP];
        SP--;
        T_tuple_add(TTemp[SP-1],hv_ClassificationLabelIDGroundTruthList,&TTemp[SP]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-1]=TTemp[SP];
        destroy_tuple(hv_Text);
        hv_Text=TTemp[--SP];

        if (hdev_window_stack_is_open())
        {
          Htuple active_win;
          create_tuple(&active_win,0);
          hdev_window_stack_get_active(&active_win);
          /*dev_disp_text (Text, 'window', 'top', 'left', 'white', 'box', 'false')*/
          create_tuple_s(&TTemp[SP++],"window");
          create_tuple_s(&TTemp[SP++],"top");
          create_tuple_s(&TTemp[SP++],"left");
          create_tuple_s(&TTemp[SP++],"white");
          create_tuple_s(&TTemp[SP++],"box");
          create_tuple_s(&TTemp[SP++],"false");
          /***/T_disp_text(active_win,hv_Text, TTemp[SP-6], TTemp[SP-5], TTemp[SP-4], 
              TTemp[SP-3], TTemp[SP-2], TTemp[SP-1]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(active_win);
        }
      }
      destroy_tuple(TTemp[--SP]);
      /*========== end if ==========*/
      /**/
      /*========== if (__get_dict_tuple( Params, ['display_bottom_desc'])) ==========*/
      create_tuple_s(&TTemp[SP++],"display_bottom_desc");
      T_get_dict_tuple(hv_Params,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      if(get_i(TTemp[SP-1],0))
      {
        /*Text := 'Ground truth classification ' + ImageIDStringBraces*/
        create_tuple_s(&TTemp[SP++],"Ground truth classification ");
        T_tuple_add(TTemp[SP-1],hv_ImageIDStringBraces,&TTemp[SP]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-1]=TTemp[SP];
        destroy_tuple(hv_Text);
        hv_Text=TTemp[--SP];

        if (hdev_window_stack_is_open())
        {
          Htuple active_win;
          create_tuple(&active_win,0);
          hdev_window_stack_get_active(&active_win);
          /*dev_disp_text (Text, 'window', 'bottom', 'left', 'white', 'box', 'false')*/
          create_tuple_s(&TTemp[SP++],"window");
          create_tuple_s(&TTemp[SP++],"bottom");
          create_tuple_s(&TTemp[SP++],"left");
          create_tuple_s(&TTemp[SP++],"white");
          create_tuple_s(&TTemp[SP++],"box");
          create_tuple_s(&TTemp[SP++],"false");
          /***/T_disp_text(active_win,hv_Text, TTemp[SP-6], TTemp[SP-5], TTemp[SP-4], 
              TTemp[SP-3], TTemp[SP-2], TTemp[SP-1]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(active_win);
        }
      }
      destroy_tuple(TTemp[--SP]);
      /*========== end if ==========*/
      /**/
      /*Display the legend.*/
      /*========== if (__get_dict_tuple( Params, ['display_legend'])) ==========*/
      create_tuple_s(&TTemp[SP++],"display_legend");
      T_get_dict_tuple(hv_Params,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      if(get_i(TTemp[SP-1],0))
      {
        /*Text := 'Ground truth class ID' + PluralPostfix + ' ' + ImageIDStringBraces*/
        create_tuple_s(&TTemp[SP++],"Ground truth class ID");
        T_tuple_add(TTemp[SP-1],hv_PluralPostfix,&TTemp[SP]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-1]=TTemp[SP];
        create_tuple_s(&TTemp[SP++]," ");
        T_tuple_add(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-2]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-2]=TTemp[SP];
        SP--;
        T_tuple_add(TTemp[SP-1],hv_ImageIDStringBraces,&TTemp[SP]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-1]=TTemp[SP];
        destroy_tuple(hv_Text);
        hv_Text=TTemp[--SP];

        /*Text := [Text,ClassesLegend[__get_dict_tuple( ClassIDstoIndex, ClassificationLabelIDGroundTruth)]]*/
        copy_tuple(hv_Text,&TTemp[SP++]);
        T_get_dict_tuple(hv_ClassIDstoIndex,hv_ClassificationLabelIDGroundTruth,&TTemp[SP++]);
        T_tuple_select(hv_ClassesLegend,TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-1]=TTemp[SP];
        T_tuple_concat(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-2]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-2]=TTemp[SP];
        SP--;
        destroy_tuple(hv_Text);
        hv_Text=TTemp[--SP];

        /**/
        /*Get or open next child window*/
        /*get_child_window (HeightImage, __get_dict_tuple( Params, ['font']), __get_dict_tuple( Params, ['font_size']), Text, PrevWindowCoordinates, WindowHandleDict, KeysForDisplay[KeyIndex], WindowImageRatio, PrevWindowCoordinates)*/
        create_tuple_s(&TTemp[SP++],"font");
        T_get_dict_tuple(hv_Params,TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-1]=TTemp[SP];
        create_tuple_s(&TTemp[SP++],"font_size");
        T_get_dict_tuple(hv_Params,TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-1]=TTemp[SP];
        copy_tuple(hv_PrevWindowCoordinates,&TTemp[SP++]);
        T_tuple_select(hv_KeysForDisplay_COPY_INP_TMP,hv_KeyIndex,&TTemp[SP++]);
        destroy_tuple(hv_WindowImageRatio);
        destroy_tuple(hv_PrevWindowCoordinates);
        /***/get_child_window(hv_HeightImage, TTemp[SP-4], TTemp[SP-3], hv_Text, 
            TTemp[SP-2], hv_WindowHandleDict, TTemp[SP-1], &hv_WindowImageRatio, 
            &hv_PrevWindowCoordinates);
        destroy_tuple(TTemp[--SP]);
        destroy_tuple(TTemp[--SP]);
        destroy_tuple(TTemp[--SP]);
        destroy_tuple(TTemp[--SP]);

        /*get_dict_param (DLSample, 'key_exists', 'image_label_ids', IsMLC)*/
        create_tuple_s(&TTemp[SP++],"key_exists");
        create_tuple_s(&TTemp[SP++],"image_label_ids");
        destroy_tuple(hv_IsMLC);
        /***/T_get_dict_param(hv_DLSample, TTemp[SP-2], TTemp[SP-1], &hv_IsMLC);
        destroy_tuple(TTemp[--SP]);
        destroy_tuple(TTemp[--SP]);

        /*========== if (IsMLC) ==========*/
        copy_tuple(hv_IsMLC,&TTemp[SP++]);
        if(get_i(TTemp[SP-1],0))
        {
          /*tuple_gen_const (|Colors|, 'light gray', Colors)*/
          copy_tuple(hv_Colors,&TTemp[SP++]);
          T_tuple_length(TTemp[SP-1],&TTemp[SP]);
          destroy_tuple(TTemp[SP-1]);
          TTemp[SP-1]=TTemp[SP];
          create_tuple_s(&TTemp[SP++],"light gray");
          destroy_tuple(hv_Colors);
          /***/T_tuple_gen_const(TTemp[SP-2], TTemp[SP-1], &hv_Colors);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(TTemp[--SP]);

        }
        destroy_tuple(TTemp[--SP]);
        /*========== end if ==========*/
        if (hdev_window_stack_is_open())
        {
          Htuple active_win;
          create_tuple(&active_win,0);
          hdev_window_stack_get_active(&active_win);
          /*dev_disp_text (Text, 'window', 'top', 'left', ['white',Colors[__get_dict_tuple( ClassIDstoIndex, ClassificationLabelIDGroundTruth)]], 'box', 'false')*/
          create_tuple_s(&TTemp[SP++],"window");
          create_tuple_s(&TTemp[SP++],"top");
          create_tuple_s(&TTemp[SP++],"left");
          create_tuple_s(&TTemp[SP++],"white");
          T_get_dict_tuple(hv_ClassIDstoIndex,hv_ClassificationLabelIDGroundTruth,&TTemp[SP++]);
          T_tuple_select(hv_Colors,TTemp[SP-1],&TTemp[SP]);
          destroy_tuple(TTemp[SP-1]);
          TTemp[SP-1]=TTemp[SP];
          T_tuple_concat(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
          destroy_tuple(TTemp[SP-2]);
          destroy_tuple(TTemp[SP-1]);
          TTemp[SP-2]=TTemp[SP];
          SP--;
          create_tuple_s(&TTemp[SP++],"box");
          create_tuple_s(&TTemp[SP++],"false");
          /***/T_disp_text(active_win,hv_Text, TTemp[SP-6], TTemp[SP-5], TTemp[SP-4], 
              TTemp[SP-3], TTemp[SP-2], TTemp[SP-1]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(active_win);
        }
      }
      destroy_tuple(TTemp[--SP]);
      /*========== end if ==========*/
    }
    else
    {
    destroy_tuple(TTemp[--SP]);
    /*========== elseif (KeysForDisplay[KeyIndex] == 'classification_result' or KeysForDisplay[KeyIndex] == 'multi_label_classification_result') ==========*/

    T_tuple_select(hv_KeysForDisplay_COPY_INP_TMP,hv_KeyIndex,&TTemp[SP++]);
    create_tuple_s(&TTemp[SP++],"classification_result");
    T_tuple_equal(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-2]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-2]=TTemp[SP];
    SP--;
    T_tuple_select(hv_KeysForDisplay_COPY_INP_TMP,hv_KeyIndex,&TTemp[SP++]);
    create_tuple_s(&TTemp[SP++],"multi_label_classification_result");
    T_tuple_equal(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-2]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-2]=TTemp[SP];
    SP--;
    T_tuple_or(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-2]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-2]=TTemp[SP];
    SP--;
    if(get_i(TTemp[SP-1],0))
    {
      /**/
      /*Ground truth classification image.*/
      /*get_dl_sample_image (Image, SampleKeys, DLSample, 'image')*/
      create_tuple_s(&TTemp[SP++],"image");
      clear_obj(ho_Image);
      /***/get_dl_sample_image(&ho_Image, hv_SampleKeys, hv_DLSample, TTemp[SP-1]);
      destroy_tuple(TTemp[--SP]);

      /**/
      /*get_classification_result (ResultKeys, DLResult, ClassificationLabelIDResult)*/
      destroy_tuple(hv_ClassificationLabelIDResult);
      /***/get_classification_result(hv_ResultKeys, hv_DLResult_COPY_INP_TMP, &hv_ClassificationLabelIDResult);

      /**/
      /*Get or open next window.*/
      /*get_image_size (Image, WidthImage, HeightImage)*/
      destroy_tuple(hv_WidthImage);
      destroy_tuple(hv_HeightImage);
      /***/T_get_image_size(ho_Image, &hv_WidthImage, &hv_HeightImage);

      /*get_next_window (__get_dict_tuple( Params, ['font']), __get_dict_tuple( Params, ['font_size']), __get_dict_tuple( Params, ['display_bottom_desc']), WidthImage, HeightImage, 0, __get_dict_tuple( Params, ['scale_windows']), __get_dict_tuple( Params, ['threshold_width']), PrevWindowCoordinates, WindowHandleDict, KeysForDisplay[KeyIndex], CurrentWindowHandle, WindowImageRatio, PrevWindowCoordinates)*/
      create_tuple_s(&TTemp[SP++],"font");
      T_get_dict_tuple(hv_Params,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      create_tuple_s(&TTemp[SP++],"font_size");
      T_get_dict_tuple(hv_Params,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      create_tuple_s(&TTemp[SP++],"display_bottom_desc");
      T_get_dict_tuple(hv_Params,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      create_tuple_i(&TTemp[SP++],0);
      create_tuple_s(&TTemp[SP++],"scale_windows");
      T_get_dict_tuple(hv_Params,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      create_tuple_s(&TTemp[SP++],"threshold_width");
      T_get_dict_tuple(hv_Params,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      copy_tuple(hv_PrevWindowCoordinates,&TTemp[SP++]);
      T_tuple_select(hv_KeysForDisplay_COPY_INP_TMP,hv_KeyIndex,&TTemp[SP++]);
      destroy_tuple(hv_CurrentWindowHandle);
      destroy_tuple(hv_WindowImageRatio);
      destroy_tuple(hv_PrevWindowCoordinates);
      /***/get_next_window(TTemp[SP-8], TTemp[SP-7], TTemp[SP-6], hv_WidthImage, 
          hv_HeightImage, TTemp[SP-5], TTemp[SP-4], TTemp[SP-3], TTemp[SP-2], hv_WindowHandleDict, 
          TTemp[SP-1], &hv_CurrentWindowHandle, &hv_WindowImageRatio, &hv_PrevWindowCoordinates);
      destroy_tuple(TTemp[--SP]);
      destroy_tuple(TTemp[--SP]);
      destroy_tuple(TTemp[--SP]);
      destroy_tuple(TTemp[--SP]);
      destroy_tuple(TTemp[--SP]);
      destroy_tuple(TTemp[--SP]);
      destroy_tuple(TTemp[--SP]);
      destroy_tuple(TTemp[--SP]);

      /**/
      /*Visualization.*/
      if (hdev_window_stack_is_open())
      {
        Htuple active_win;
        create_tuple(&active_win,0);
        hdev_window_stack_get_active(&active_win);
        /*dev_display (Image)*/
        /***/T_disp_obj(ho_Image, active_win);
        destroy_tuple(active_win);
      }
      /**/
      /*========== if (|ClassificationLabelIDResult| > 1) ==========*/
      T_tuple_length(hv_ClassificationLabelIDResult,&TTemp[SP++]);
      create_tuple_i(&TTemp[SP++],1);
      T_tuple_greater(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-2]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-2]=TTemp[SP];
      SP--;
      if(get_i(TTemp[SP-1],0))
      {
        /*PluralPostfix := 's'*/
        reuse_tuple_s(&hv_PluralPostfix,"s");
        /*ClassificationLabelIDResult := sort(ClassificationLabelIDResult)*/
        copy_tuple(hv_ClassificationLabelIDResult,&TTemp[SP++]);
        T_tuple_sort(TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-1]=TTemp[SP];
        destroy_tuple(hv_ClassificationLabelIDResult);
        hv_ClassificationLabelIDResult=TTemp[--SP];

      }
      else
      {
        /*PluralPostfix := ''*/
        reuse_tuple_s(&hv_PluralPostfix,"");
      }
      destroy_tuple(TTemp[--SP]);
      /*========== end if ==========*/
      /**/
      /*Display the class IDs.*/
      /*========== if (__get_dict_tuple( Params, ['display_classification_ids'])) ==========*/
      create_tuple_s(&TTemp[SP++],"display_classification_ids");
      T_get_dict_tuple(hv_Params,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      if(get_i(TTemp[SP-1],0))
      {
        /*get_dict_tuple (WindowHandleDict, 'meta_information', MetaInfo)*/
        create_tuple_s(&TTemp[SP++],"meta_information");
        destroy_tuple(hv_MetaInfo);
        /***/T_get_dict_tuple(hv_WindowHandleDict, TTemp[SP-1], &hv_MetaInfo);
        destroy_tuple(TTemp[--SP]);

        /*get_dict_tuple (MetaInfo, 'classification_result_margin_bottom', MarginBottom)*/
        create_tuple_s(&TTemp[SP++],"classification_result_margin_bottom");
        destroy_tuple(hv_MarginBottom);
        /***/T_get_dict_tuple(hv_MetaInfo, TTemp[SP-1], &hv_MarginBottom);
        destroy_tuple(TTemp[--SP]);

        /*get_dict_tuple (MetaInfo, 'classification_result_window_coordinates', WindowCoordinates)*/
        create_tuple_s(&TTemp[SP++],"classification_result_window_coordinates");
        destroy_tuple(hv_WindowCoordinates);
        /***/T_get_dict_tuple(hv_MetaInfo, TTemp[SP-1], &hv_WindowCoordinates);
        destroy_tuple(TTemp[--SP]);

        /*CurrentWindowHeight := WindowCoordinates[3] - WindowCoordinates[0]*/
        create_tuple_i(&TTemp[SP++],3);
        T_tuple_select(hv_WindowCoordinates,TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-1]=TTemp[SP];
        create_tuple_i(&TTemp[SP++],0);
        T_tuple_select(hv_WindowCoordinates,TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-1]=TTemp[SP];
        T_tuple_sub(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-2]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-2]=TTemp[SP];
        SP--;
        destroy_tuple(hv_CurrentWindowHeight);
        hv_CurrentWindowHeight=TTemp[--SP];

        /*get_font_extents (CurrentWindowHandle, _, _, _, MaxHeight)*/
        destroy_tuple(hv__);
        destroy_tuple(hv_MaxHeight);
        /***/T_get_font_extents(hv_CurrentWindowHandle, &hv__, &(CExpDummyOCvar[0]), 
            &(CExpDummyOCvar[1]), &hv_MaxHeight);
        destroy_tuple(CExpDummyOCvar[0]);
        destroy_tuple(CExpDummyOCvar[1]);

        /*ClassificationLabelIDResultList := ''*/
        reuse_tuple_s(&hv_ClassificationLabelIDResultList,"");
        /*========== for C := 0 to |ClassificationLabelIDResult| - 1 by 1 ==========*/
        T_tuple_length(hv_ClassificationLabelIDResult,&TTemp[SP++]);
        create_tuple_i(&TTemp[SP++],1);
        T_tuple_sub(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-2]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-2]=TTemp[SP];
        SP--;
        create_tuple_i(&TTemp[SP++],1);
        create_tuple_i(&TTemp[SP++],0);
        T_tuple_greater(TTemp[SP-1],TTemp[SP-3],&TTemp[SP]);
        SP++;
        T_tuple_equal(TTemp[SP-2],TTemp[SP-4],&TTemp[SP]);
        if(get_i(TTemp[SP],0) ||
           (!((( get_i(TTemp[SP-1],0)) && (get_d(TTemp[SP-3],0)>0)) ||
              ((!get_i(TTemp[SP-1],0)) && (get_d(TTemp[SP-3],0)<0)))))
        {
         destroy_tuple(TTemp[SP--]);
         destroy_tuple(TTemp[SP]);
         T_tuple_sub(TTemp[SP-1],TTemp[SP-2],&TTemp[SP]);
         destroy_tuple(hv_C);
         copy_tuple(TTemp[SP],&hv_C);
         destroy_tuple(TTemp[SP--]);
         destroy_tuple(TTemp[SP]);
         for(;;)
         {
         T_tuple_add(hv_C,TTemp[SP-1],&TTemp[SP]);
         destroy_tuple(hv_C);
         copy_tuple(TTemp[SP],&hv_C);
         destroy_tuple(TTemp[SP]);
         if(get_d(TTemp[SP-1],0)<0)
          T_tuple_less(hv_C,TTemp[SP-2],&TTemp[SP]);
         else
          T_tuple_greater(hv_C,TTemp[SP-2],&TTemp[SP]);
         if(get_i(TTemp[SP],0)) break;
         destroy_tuple(TTemp[SP]);
         /*========== for ==========*/

          /*ClassificationLabelIDResultList := ClassificationLabelIDResultList + ClassificationLabelIDResult[C]*/
          T_tuple_select(hv_ClassificationLabelIDResult,hv_C,&TTemp[SP++]);
          T_tuple_add(hv_ClassificationLabelIDResultList,TTemp[SP-1],&TTemp[SP]);
          destroy_tuple(hv_ClassificationLabelIDResultList);
          hv_ClassificationLabelIDResultList=TTemp[SP];
          destroy_tuple(TTemp[--SP]);

          /*========== if (C < |ClassificationLabelIDResult| - 1) ==========*/
          T_tuple_length(hv_ClassificationLabelIDResult,&TTemp[SP++]);
          create_tuple_i(&TTemp[SP++],1);
          T_tuple_sub(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
          destroy_tuple(TTemp[SP-2]);
          destroy_tuple(TTemp[SP-1]);
          TTemp[SP-2]=TTemp[SP];
          SP--;
          T_tuple_less(hv_C,TTemp[SP-1],&TTemp[SP]);
          destroy_tuple(TTemp[SP-1]);
          TTemp[SP-1]=TTemp[SP];
          if(get_i(TTemp[SP-1],0))
          {
            /*ClassificationLabelIDResultList := ClassificationLabelIDResultList + ', '*/
            create_tuple_s(&TTemp[SP++],", ");
            T_tuple_add(hv_ClassificationLabelIDResultList,TTemp[SP-1],&TTemp[SP]);
            destroy_tuple(hv_ClassificationLabelIDResultList);
            hv_ClassificationLabelIDResultList=TTemp[SP];
            destroy_tuple(TTemp[--SP]);

          }
          destroy_tuple(TTemp[--SP]);
          /*========== end if ==========*/
         }
         destroy_tuple(TTemp[SP--]);
         destroy_tuple(TTemp[SP--]);
         destroy_tuple(TTemp[SP]);
        }
        else
        {
         destroy_tuple(TTemp[SP--]);
         destroy_tuple(TTemp[SP--]);
         destroy_tuple(TTemp[SP--]);
         destroy_tuple(TTemp[SP--]);
         destroy_tuple(TTemp[SP]);
        }/*========== end for ========*/

        /*Text := 'Result class ID' + PluralPostfix + ': ' + ClassificationLabelIDResultList*/
        create_tuple_s(&TTemp[SP++],"Result class ID");
        T_tuple_add(TTemp[SP-1],hv_PluralPostfix,&TTemp[SP]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-1]=TTemp[SP];
        create_tuple_s(&TTemp[SP++],": ");
        T_tuple_add(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-2]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-2]=TTemp[SP];
        SP--;
        T_tuple_add(TTemp[SP-1],hv_ClassificationLabelIDResultList,&TTemp[SP]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-1]=TTemp[SP];
        destroy_tuple(hv_Text);
        hv_Text=TTemp[--SP];

        /*========== if (__get_dict_tuple( Params, ['display_bottom_desc'])) ==========*/
        create_tuple_s(&TTemp[SP++],"display_bottom_desc");
        T_get_dict_tuple(hv_Params,TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-1]=TTemp[SP];
        if(get_i(TTemp[SP-1],0))
        {
          if (hdev_window_stack_is_open())
          {
            Htuple active_win;
            create_tuple(&active_win,0);
            hdev_window_stack_get_active(&active_win);
            /*dev_disp_text (Text, 'window', CurrentWindowHeight - (MarginBottom + MaxHeight + 10), 'left', 'white', 'box', 'false')*/
            create_tuple_s(&TTemp[SP++],"window");
            T_tuple_add(hv_MarginBottom,hv_MaxHeight,&TTemp[SP++]);
            create_tuple_i(&TTemp[SP++],10);
            T_tuple_add(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
            destroy_tuple(TTemp[SP-2]);
            destroy_tuple(TTemp[SP-1]);
            TTemp[SP-2]=TTemp[SP];
            SP--;
            T_tuple_sub(hv_CurrentWindowHeight,TTemp[SP-1],&TTemp[SP]);
            destroy_tuple(TTemp[SP-1]);
            TTemp[SP-1]=TTemp[SP];
            create_tuple_s(&TTemp[SP++],"left");
            create_tuple_s(&TTemp[SP++],"white");
            create_tuple_s(&TTemp[SP++],"box");
            create_tuple_s(&TTemp[SP++],"false");
            /***/T_disp_text(active_win,hv_Text, TTemp[SP-6], TTemp[SP-5], TTemp[SP-4], 
                TTemp[SP-3], TTemp[SP-2], TTemp[SP-1]);
            destroy_tuple(TTemp[--SP]);
            destroy_tuple(TTemp[--SP]);
            destroy_tuple(TTemp[--SP]);
            destroy_tuple(TTemp[--SP]);
            destroy_tuple(TTemp[--SP]);
            destroy_tuple(TTemp[--SP]);
            destroy_tuple(active_win);
          }
        }
        else
        {
          if (hdev_window_stack_is_open())
          {
            Htuple active_win;
            create_tuple(&active_win,0);
            hdev_window_stack_get_active(&active_win);
            /*dev_disp_text (Text, 'window', 'bottom', 'left', 'white', 'box', 'false')*/
            create_tuple_s(&TTemp[SP++],"window");
            create_tuple_s(&TTemp[SP++],"bottom");
            create_tuple_s(&TTemp[SP++],"left");
            create_tuple_s(&TTemp[SP++],"white");
            create_tuple_s(&TTemp[SP++],"box");
            create_tuple_s(&TTemp[SP++],"false");
            /***/T_disp_text(active_win,hv_Text, TTemp[SP-6], TTemp[SP-5], TTemp[SP-4], 
                TTemp[SP-3], TTemp[SP-2], TTemp[SP-1]);
            destroy_tuple(TTemp[--SP]);
            destroy_tuple(TTemp[--SP]);
            destroy_tuple(TTemp[--SP]);
            destroy_tuple(TTemp[--SP]);
            destroy_tuple(TTemp[--SP]);
            destroy_tuple(TTemp[--SP]);
            destroy_tuple(active_win);
          }
        }
        destroy_tuple(TTemp[--SP]);
        /*========== end if ==========*/
      }
      destroy_tuple(TTemp[--SP]);
      /*========== end if ==========*/
      /**/
      /*========== if (__get_dict_tuple( Params, ['display_bottom_desc'])) ==========*/
      create_tuple_s(&TTemp[SP++],"display_bottom_desc");
      T_get_dict_tuple(hv_Params,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      if(get_i(TTemp[SP-1],0))
      {
        /*Text := 'Result classification ' + ImageIDStringBraces*/
        create_tuple_s(&TTemp[SP++],"Result classification ");
        T_tuple_add(TTemp[SP-1],hv_ImageIDStringBraces,&TTemp[SP]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-1]=TTemp[SP];
        destroy_tuple(hv_Text);
        hv_Text=TTemp[--SP];

        if (hdev_window_stack_is_open())
        {
          Htuple active_win;
          create_tuple(&active_win,0);
          hdev_window_stack_get_active(&active_win);
          /*dev_disp_text (Text, 'window', 'bottom', 'left', 'white', 'box', 'false')*/
          create_tuple_s(&TTemp[SP++],"window");
          create_tuple_s(&TTemp[SP++],"bottom");
          create_tuple_s(&TTemp[SP++],"left");
          create_tuple_s(&TTemp[SP++],"white");
          create_tuple_s(&TTemp[SP++],"box");
          create_tuple_s(&TTemp[SP++],"false");
          /***/T_disp_text(active_win,hv_Text, TTemp[SP-6], TTemp[SP-5], TTemp[SP-4], 
              TTemp[SP-3], TTemp[SP-2], TTemp[SP-1]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(active_win);
        }
      }
      destroy_tuple(TTemp[--SP]);
      /*========== end if ==========*/
      /**/
      /*Display the legend.*/
      /*========== if (__get_dict_tuple( Params, ['display_legend'])) ==========*/
      create_tuple_s(&TTemp[SP++],"display_legend");
      T_get_dict_tuple(hv_Params,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      if(get_i(TTemp[SP-1],0))
      {
        /*Text := 'Result class ID' + PluralPostfix + ' ' + ImageIDStringBraces*/
        create_tuple_s(&TTemp[SP++],"Result class ID");
        T_tuple_add(TTemp[SP-1],hv_PluralPostfix,&TTemp[SP]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-1]=TTemp[SP];
        create_tuple_s(&TTemp[SP++]," ");
        T_tuple_add(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-2]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-2]=TTemp[SP];
        SP--;
        T_tuple_add(TTemp[SP-1],hv_ImageIDStringBraces,&TTemp[SP]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-1]=TTemp[SP];
        destroy_tuple(hv_Text);
        hv_Text=TTemp[--SP];

        /*========== if (ClassificationLabelIDResult == []) ==========*/
        create_tuple(&TTemp[SP++],0);
        T_tuple_equal(hv_ClassificationLabelIDResult,TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-1]=TTemp[SP];
        if(get_i(TTemp[SP-1],0))
        {
          /*Text[|Text|] := 'No classification result is given!'*/
          copy_tuple(hv_Text,&TTemp[SP++]);
          T_tuple_length(TTemp[SP-1],&TTemp[SP]);
          destroy_tuple(TTemp[SP-1]);
          TTemp[SP-1]=TTemp[SP];
          create_tuple_s(&TTemp[SP++],"No classification result is given!");
          replace_elements(&hv_Text,&TTemp[SP-2],&TTemp[SP-1]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(TTemp[--SP]);
        }
        else
        {
          /*get_dict_param (DLResult, 'key_exists', 'selected_class_ids', IsMLC)*/
          create_tuple_s(&TTemp[SP++],"key_exists");
          create_tuple_s(&TTemp[SP++],"selected_class_ids");
          destroy_tuple(hv_IsMLC);
          /***/T_get_dict_param(hv_DLResult_COPY_INP_TMP, TTemp[SP-2], TTemp[SP-1], 
              &hv_IsMLC);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(TTemp[--SP]);

          /*========== if (IsMLC) ==========*/
          copy_tuple(hv_IsMLC,&TTemp[SP++]);
          if(get_i(TTemp[SP-1],0))
          {
            /*tuple_gen_const (|Colors|, 'light gray', Colors)*/
            copy_tuple(hv_Colors,&TTemp[SP++]);
            T_tuple_length(TTemp[SP-1],&TTemp[SP]);
            destroy_tuple(TTemp[SP-1]);
            TTemp[SP-1]=TTemp[SP];
            create_tuple_s(&TTemp[SP++],"light gray");
            destroy_tuple(hv_Colors);
            /***/T_tuple_gen_const(TTemp[SP-2], TTemp[SP-1], &hv_Colors);
            destroy_tuple(TTemp[--SP]);
            destroy_tuple(TTemp[--SP]);

          }
          destroy_tuple(TTemp[--SP]);
          /*========== end if ==========*/
          /*Text := [Text,ClassesLegend[__get_dict_tuple( ClassIDstoIndex, ClassificationLabelIDResult)]]*/
          copy_tuple(hv_Text,&TTemp[SP++]);
          T_get_dict_tuple(hv_ClassIDstoIndex,hv_ClassificationLabelIDResult,&TTemp[SP++]);
          T_tuple_select(hv_ClassesLegend,TTemp[SP-1],&TTemp[SP]);
          destroy_tuple(TTemp[SP-1]);
          TTemp[SP-1]=TTemp[SP];
          T_tuple_concat(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
          destroy_tuple(TTemp[SP-2]);
          destroy_tuple(TTemp[SP-1]);
          TTemp[SP-2]=TTemp[SP];
          SP--;
          destroy_tuple(hv_Text);
          hv_Text=TTemp[--SP];

        }
        destroy_tuple(TTemp[--SP]);
        /*========== end if ==========*/
        /**/
        /*Get or open next child window*/
        /*get_child_window (HeightImage, __get_dict_tuple( Params, ['font']), __get_dict_tuple( Params, ['font_size']), Text, PrevWindowCoordinates, WindowHandleDict, KeysForDisplay[KeyIndex], WindowImageRatio, PrevWindowCoordinates)*/
        create_tuple_s(&TTemp[SP++],"font");
        T_get_dict_tuple(hv_Params,TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-1]=TTemp[SP];
        create_tuple_s(&TTemp[SP++],"font_size");
        T_get_dict_tuple(hv_Params,TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-1]=TTemp[SP];
        copy_tuple(hv_PrevWindowCoordinates,&TTemp[SP++]);
        T_tuple_select(hv_KeysForDisplay_COPY_INP_TMP,hv_KeyIndex,&TTemp[SP++]);
        destroy_tuple(hv_WindowImageRatio);
        destroy_tuple(hv_PrevWindowCoordinates);
        /***/get_child_window(hv_HeightImage, TTemp[SP-4], TTemp[SP-3], hv_Text, 
            TTemp[SP-2], hv_WindowHandleDict, TTemp[SP-1], &hv_WindowImageRatio, 
            &hv_PrevWindowCoordinates);
        destroy_tuple(TTemp[--SP]);
        destroy_tuple(TTemp[--SP]);
        destroy_tuple(TTemp[--SP]);
        destroy_tuple(TTemp[--SP]);

        if (hdev_window_stack_is_open())
        {
          Htuple active_win;
          create_tuple(&active_win,0);
          hdev_window_stack_get_active(&active_win);
          /*dev_disp_text (Text, 'window', 'top', 'left', ['white',Colors[__get_dict_tuple( ClassIDstoIndex, ClassificationLabelIDResult)]], 'box', 'false')*/
          create_tuple_s(&TTemp[SP++],"window");
          create_tuple_s(&TTemp[SP++],"top");
          create_tuple_s(&TTemp[SP++],"left");
          create_tuple_s(&TTemp[SP++],"white");
          T_get_dict_tuple(hv_ClassIDstoIndex,hv_ClassificationLabelIDResult,&TTemp[SP++]);
          T_tuple_select(hv_Colors,TTemp[SP-1],&TTemp[SP]);
          destroy_tuple(TTemp[SP-1]);
          TTemp[SP-1]=TTemp[SP];
          T_tuple_concat(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
          destroy_tuple(TTemp[SP-2]);
          destroy_tuple(TTemp[SP-1]);
          TTemp[SP-2]=TTemp[SP];
          SP--;
          create_tuple_s(&TTemp[SP++],"box");
          create_tuple_s(&TTemp[SP++],"false");
          /***/T_disp_text(active_win,hv_Text, TTemp[SP-6], TTemp[SP-5], TTemp[SP-4], 
              TTemp[SP-3], TTemp[SP-2], TTemp[SP-1]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(active_win);
        }
      }
      destroy_tuple(TTemp[--SP]);
      /*========== end if ==========*/
    }
    else
    {
    destroy_tuple(TTemp[--SP]);
    /*========== elseif (KeysForDisplay[KeyIndex] == 'heatmap_grad_cam' or KeysForDisplay[KeyIndex] == 'heatmap_guided_grad_cam' or KeysForDisplay[KeyIndex] == 'heatmap_confidence_based') ==========*/

    T_tuple_select(hv_KeysForDisplay_COPY_INP_TMP,hv_KeyIndex,&TTemp[SP++]);
    create_tuple_s(&TTemp[SP++],"heatmap_grad_cam");
    T_tuple_equal(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-2]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-2]=TTemp[SP];
    SP--;
    T_tuple_select(hv_KeysForDisplay_COPY_INP_TMP,hv_KeyIndex,&TTemp[SP++]);
    create_tuple_s(&TTemp[SP++],"heatmap_guided_grad_cam");
    T_tuple_equal(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-2]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-2]=TTemp[SP];
    SP--;
    T_tuple_or(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-2]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-2]=TTemp[SP];
    SP--;
    T_tuple_select(hv_KeysForDisplay_COPY_INP_TMP,hv_KeyIndex,&TTemp[SP++]);
    create_tuple_s(&TTemp[SP++],"heatmap_confidence_based");
    T_tuple_equal(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-2]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-2]=TTemp[SP];
    SP--;
    T_tuple_or(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-2]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-2]=TTemp[SP];
    SP--;
    if(get_i(TTemp[SP-1],0))
    {
      /**/
      /*Display the heatmap image (method 'heatmap_grad_cam', 'heatmap_guided_grad_cam',*/
      /*or 'heatmap_confidence_based') in the selected color scheme.*/
      /*Retrieve heatmap image, inferred image, and inference results.*/
      /*SelectedHeatmapMethod := KeysForDisplay[KeyIndex]*/
      T_tuple_select(hv_KeysForDisplay_COPY_INP_TMP,hv_KeyIndex,&TTemp[SP++]);
      destroy_tuple(hv_SelectedHeatmapMethod);
      hv_SelectedHeatmapMethod=TTemp[--SP];

      /*========== if ((find(ResultKeys,'heatmap_grad_cam') != -1) or (find(ResultKeys,'heatmap_guided_grad_cam') != -1) or (find(ResultKeys,'heatmap_confidence_based') != -1)) ==========*/
      create_tuple_s(&TTemp[SP++],"heatmap_grad_cam");
      T_tuple_find(hv_ResultKeys,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      create_tuple_i(&TTemp[SP++],-1);
      T_tuple_not_equal(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-2]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-2]=TTemp[SP];
      SP--;
      create_tuple_s(&TTemp[SP++],"heatmap_guided_grad_cam");
      T_tuple_find(hv_ResultKeys,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      create_tuple_i(&TTemp[SP++],-1);
      T_tuple_not_equal(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-2]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-2]=TTemp[SP];
      SP--;
      T_tuple_or(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-2]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-2]=TTemp[SP];
      SP--;
      create_tuple_s(&TTemp[SP++],"heatmap_confidence_based");
      T_tuple_find(hv_ResultKeys,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      create_tuple_i(&TTemp[SP++],-1);
      T_tuple_not_equal(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-2]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-2]=TTemp[SP];
      SP--;
      T_tuple_or(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-2]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-2]=TTemp[SP];
      SP--;
      if(get_i(TTemp[SP-1],0))
      {
        /*========== if (SelectedHeatmapMethod == 'heatmap_grad_cam') ==========*/
        create_tuple_s(&TTemp[SP++],"heatmap_grad_cam");
        T_tuple_equal(hv_SelectedHeatmapMethod,TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-1]=TTemp[SP];
        if(get_i(TTemp[SP-1],0))
        {
          /*get_dict_tuple (DLResult, 'heatmap_grad_cam', DictHeatmap)*/
          create_tuple_s(&TTemp[SP++],"heatmap_grad_cam");
          destroy_tuple(hv_DictHeatmap);
          /***/T_get_dict_tuple(hv_DLResult_COPY_INP_TMP, TTemp[SP-1], &hv_DictHeatmap);
          destroy_tuple(TTemp[--SP]);

          /*MethodName := 'Grad-CAM'*/
          reuse_tuple_s(&hv_MethodName,"Grad-CAM");
        }
        else
        {
        destroy_tuple(TTemp[--SP]);
        /*========== elseif (SelectedHeatmapMethod == 'heatmap_guided_grad_cam') ==========*/

        create_tuple_s(&TTemp[SP++],"heatmap_guided_grad_cam");
        T_tuple_equal(hv_SelectedHeatmapMethod,TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-1]=TTemp[SP];
        if(get_i(TTemp[SP-1],0))
        {
          /*get_dict_tuple (DLResult, 'heatmap_guided_grad_cam', DictHeatmap)*/
          create_tuple_s(&TTemp[SP++],"heatmap_guided_grad_cam");
          destroy_tuple(hv_DictHeatmap);
          /***/T_get_dict_tuple(hv_DLResult_COPY_INP_TMP, TTemp[SP-1], &hv_DictHeatmap);
          destroy_tuple(TTemp[--SP]);

          /*MethodName := 'Guided-Grad-CAM'*/
          reuse_tuple_s(&hv_MethodName,"Guided-Grad-CAM");
        }
        else
        {
          /*get_dict_tuple (DLResult, 'heatmap_confidence_based', DictHeatmap)*/
          create_tuple_s(&TTemp[SP++],"heatmap_confidence_based");
          destroy_tuple(hv_DictHeatmap);
          /***/T_get_dict_tuple(hv_DLResult_COPY_INP_TMP, TTemp[SP-1], &hv_DictHeatmap);
          destroy_tuple(TTemp[--SP]);

          /*MethodName := 'Confidence based'*/
          reuse_tuple_s(&hv_MethodName,"Confidence based");
        }
        }
        destroy_tuple(TTemp[--SP]);
        /*========== end if ==========*/
        /*get_dict_param (DictHeatmap, 'keys', [], HeatmapKeys)*/
        create_tuple_s(&TTemp[SP++],"keys");
        create_tuple(&TTemp[SP++],0);
        destroy_tuple(hv_HeatmapKeys);
        /***/T_get_dict_param(hv_DictHeatmap, TTemp[SP-2], TTemp[SP-1], &hv_HeatmapKeys);
        destroy_tuple(TTemp[--SP]);
        destroy_tuple(TTemp[--SP]);

        /**/
        /*========== if (SelectedHeatmapMethod == 'heatmap_guided_grad_cam') ==========*/
        create_tuple_s(&TTemp[SP++],"heatmap_guided_grad_cam");
        T_tuple_equal(hv_SelectedHeatmapMethod,TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-1]=TTemp[SP];
        if(get_i(TTemp[SP-1],0))
        {
          /*HeatmapImageName := regexp_select(HeatmapKeys,'guided_grad_cam_image_class_[0-9]*')*/
          create_tuple_s(&TTemp[SP++],"guided_grad_cam_image_class_[0-9]*");
          T_tuple_regexp_select(hv_HeatmapKeys,TTemp[SP-1],&TTemp[SP]);
          destroy_tuple(TTemp[SP-1]);
          TTemp[SP-1]=TTemp[SP];
          destroy_tuple(hv_HeatmapImageName);
          hv_HeatmapImageName=TTemp[--SP];

          /*TargetClassID := regexp_match(HeatmapImageName,'guided_grad_cam_image_class_([0-9]+)$')*/
          create_tuple_s(&TTemp[SP++],"guided_grad_cam_image_class_([0-9]+)$");
          T_tuple_regexp_match(hv_HeatmapImageName,TTemp[SP-1],&TTemp[SP]);
          destroy_tuple(TTemp[SP-1]);
          TTemp[SP-1]=TTemp[SP];
          destroy_tuple(hv_TargetClassID);
          hv_TargetClassID=TTemp[--SP];

        }
        else
        {
          /*HeatmapImageName := regexp_select(HeatmapKeys,'heatmap_image_class_[0-9]*')*/
          create_tuple_s(&TTemp[SP++],"heatmap_image_class_[0-9]*");
          T_tuple_regexp_select(hv_HeatmapKeys,TTemp[SP-1],&TTemp[SP]);
          destroy_tuple(TTemp[SP-1]);
          TTemp[SP-1]=TTemp[SP];
          destroy_tuple(hv_HeatmapImageName);
          hv_HeatmapImageName=TTemp[--SP];

          /*TargetClassID := regexp_match(HeatmapImageName,'heatmap_image_class_([0-9]+)$')*/
          create_tuple_s(&TTemp[SP++],"heatmap_image_class_([0-9]+)$");
          T_tuple_regexp_match(hv_HeatmapImageName,TTemp[SP-1],&TTemp[SP]);
          destroy_tuple(TTemp[SP-1]);
          TTemp[SP-1]=TTemp[SP];
          destroy_tuple(hv_TargetClassID);
          hv_TargetClassID=TTemp[--SP];

        }
        destroy_tuple(TTemp[--SP]);
        /*========== end if ==========*/
        /*get_dict_object (ImageHeatmap, DictHeatmap, HeatmapImageName)*/
        clear_obj(ho_ImageHeatmap);
        /***/T_get_dict_object(&ho_ImageHeatmap, hv_DictHeatmap, hv_HeatmapImageName);

      }
      else
      {
        /* throw(...); only in hdevelop*/
      }
      destroy_tuple(TTemp[--SP]);
      /*========== end if ==========*/
      /**/
      /*Only for the Grad-Cam heatmap the input image is shown.*/
      /*========== if (SelectedHeatmapMethod == 'heatmap_grad_cam') ==========*/
      create_tuple_s(&TTemp[SP++],"heatmap_grad_cam");
      T_tuple_equal(hv_SelectedHeatmapMethod,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      if(get_i(TTemp[SP-1],0))
      {
        /*Read in input image.*/
        /*get_dict_object (Image, DLSample, 'image')*/
        create_tuple_s(&TTemp[SP++],"image");
        clear_obj(ho_Image);
        /***/T_get_dict_object(&ho_Image, hv_DLSample, TTemp[SP-1]);
        destroy_tuple(TTemp[--SP]);

        /*Add the heatmap to the input image.*/
        /*add_colormap_to_image (ImageHeatmap, Image, ImageHeatmap, __get_dict_tuple( Params, ['heatmap_color_scheme']))*/
        create_tuple_s(&TTemp[SP++],"heatmap_color_scheme");
        T_get_dict_tuple(hv_Params,TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-1]=TTemp[SP];
        /***/add_colormap_to_image(ho_ImageHeatmap, ho_Image, &(OTemp[SPO]), TTemp[SP-1]);
        SPO++;
        clear_obj(ho_ImageHeatmap);
        ho_ImageHeatmap = OTemp[--SPO];
        destroy_tuple(TTemp[--SP]);

      }
      destroy_tuple(TTemp[--SP]);
      /*========== end if ==========*/
      /**/
      /*Get or open next window.*/
      /*get_image_size (ImageHeatmap, WidthImage, HeightImage)*/
      destroy_tuple(hv_WidthImage);
      destroy_tuple(hv_HeightImage);
      /***/T_get_image_size(ho_ImageHeatmap, &hv_WidthImage, &hv_HeightImage);

      /*get_next_window (__get_dict_tuple( Params, ['font']), __get_dict_tuple( Params, ['font_size']), __get_dict_tuple( Params, ['display_bottom_desc']), WidthImage, HeightImage, 0, __get_dict_tuple( Params, ['scale_windows']), __get_dict_tuple( Params, ['threshold_width']), PrevWindowCoordinates, WindowHandleDict, KeysForDisplay[KeyIndex], CurrentWindowHandle, WindowImageRatio, PrevWindowCoordinates)*/
      create_tuple_s(&TTemp[SP++],"font");
      T_get_dict_tuple(hv_Params,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      create_tuple_s(&TTemp[SP++],"font_size");
      T_get_dict_tuple(hv_Params,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      create_tuple_s(&TTemp[SP++],"display_bottom_desc");
      T_get_dict_tuple(hv_Params,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      create_tuple_i(&TTemp[SP++],0);
      create_tuple_s(&TTemp[SP++],"scale_windows");
      T_get_dict_tuple(hv_Params,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      create_tuple_s(&TTemp[SP++],"threshold_width");
      T_get_dict_tuple(hv_Params,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      copy_tuple(hv_PrevWindowCoordinates,&TTemp[SP++]);
      T_tuple_select(hv_KeysForDisplay_COPY_INP_TMP,hv_KeyIndex,&TTemp[SP++]);
      destroy_tuple(hv_CurrentWindowHandle);
      destroy_tuple(hv_WindowImageRatio);
      destroy_tuple(hv_PrevWindowCoordinates);
      /***/get_next_window(TTemp[SP-8], TTemp[SP-7], TTemp[SP-6], hv_WidthImage, 
          hv_HeightImage, TTemp[SP-5], TTemp[SP-4], TTemp[SP-3], TTemp[SP-2], hv_WindowHandleDict, 
          TTemp[SP-1], &hv_CurrentWindowHandle, &hv_WindowImageRatio, &hv_PrevWindowCoordinates);
      destroy_tuple(TTemp[--SP]);
      destroy_tuple(TTemp[--SP]);
      destroy_tuple(TTemp[--SP]);
      destroy_tuple(TTemp[--SP]);
      destroy_tuple(TTemp[--SP]);
      destroy_tuple(TTemp[--SP]);
      destroy_tuple(TTemp[--SP]);
      destroy_tuple(TTemp[--SP]);

      /**/
      if (hdev_window_stack_is_open())
      {
        Htuple active_win;
        create_tuple(&active_win,0);
        hdev_window_stack_get_active(&active_win);
        /*dev_display (ImageHeatmap)*/
        /***/T_disp_obj(ho_ImageHeatmap, active_win);
        destroy_tuple(active_win);
      }
      /*========== if (__get_dict_tuple( Params, ['display_bottom_desc'])) ==========*/
      create_tuple_s(&TTemp[SP++],"display_bottom_desc");
      T_get_dict_tuple(hv_Params,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      if(get_i(TTemp[SP-1],0))
      {
        /*Text := 'Classification heatmap ' + ImageIDStringBraces*/
        create_tuple_s(&TTemp[SP++],"Classification heatmap ");
        T_tuple_add(TTemp[SP-1],hv_ImageIDStringBraces,&TTemp[SP]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-1]=TTemp[SP];
        destroy_tuple(hv_Text);
        hv_Text=TTemp[--SP];

        if (hdev_window_stack_is_open())
        {
          Htuple active_win;
          create_tuple(&active_win,0);
          hdev_window_stack_get_active(&active_win);
          /*dev_disp_text (Text, 'window', 'bottom', 'left', 'white', 'box', 'false')*/
          create_tuple_s(&TTemp[SP++],"window");
          create_tuple_s(&TTemp[SP++],"bottom");
          create_tuple_s(&TTemp[SP++],"left");
          create_tuple_s(&TTemp[SP++],"white");
          create_tuple_s(&TTemp[SP++],"box");
          create_tuple_s(&TTemp[SP++],"false");
          /***/T_disp_text(active_win,hv_Text, TTemp[SP-6], TTemp[SP-5], TTemp[SP-4], 
              TTemp[SP-3], TTemp[SP-2], TTemp[SP-1]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(active_win);
        }
      }
      destroy_tuple(TTemp[--SP]);
      /*========== end if ==========*/
      /**/
      /*Display the legend.*/
      /*========== if (__get_dict_tuple( Params, ['display_legend'])) ==========*/
      create_tuple_s(&TTemp[SP++],"display_legend");
      T_get_dict_tuple(hv_Params,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      if(get_i(TTemp[SP-1],0))
      {
        /*get_dict_tuple (DLResult, 'classification_class_names', ClassNames)*/
        create_tuple_s(&TTemp[SP++],"classification_class_names");
        destroy_tuple(hv_ClassNames);
        /***/T_get_dict_tuple(hv_DLResult_COPY_INP_TMP, TTemp[SP-1], &hv_ClassNames);
        destroy_tuple(TTemp[--SP]);

        /*get_dict_tuple (DLResult, 'classification_class_ids', ClassIDs)*/
        create_tuple_s(&TTemp[SP++],"classification_class_ids");
        destroy_tuple(hv_ClassIDs);
        /***/T_get_dict_tuple(hv_DLResult_COPY_INP_TMP, TTemp[SP-1], &hv_ClassIDs);
        destroy_tuple(TTemp[--SP]);

        /*get_dict_tuple (DLResult, 'classification_confidences', Confidences)*/
        create_tuple_s(&TTemp[SP++],"classification_confidences");
        destroy_tuple(hv_Confidences);
        /***/T_get_dict_tuple(hv_DLResult_COPY_INP_TMP, TTemp[SP-1], &hv_Confidences);
        destroy_tuple(TTemp[--SP]);

        /*========== if (SelectedHeatmapMethod == 'heatmap_confidence_based') ==========*/
        create_tuple_s(&TTemp[SP++],"heatmap_confidence_based");
        T_tuple_equal(hv_SelectedHeatmapMethod,TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-1]=TTemp[SP];
        if(get_i(TTemp[SP-1],0))
        {
          /*get_dict_tuple (DictHeatmap, 'classification_heatmap_maxdeviation', MaxDeviation)*/
          create_tuple_s(&TTemp[SP++],"classification_heatmap_maxdeviation");
          destroy_tuple(hv_MaxDeviation);
          /***/T_get_dict_tuple(hv_DictHeatmap, TTemp[SP-1], &hv_MaxDeviation);
          destroy_tuple(TTemp[--SP]);

        }
        destroy_tuple(TTemp[--SP]);
        /*========== end if ==========*/
        /*ClassificationLabelNameResult := ClassNames[0]*/
        create_tuple_i(&TTemp[SP++],0);
        T_tuple_select(hv_ClassNames,TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-1]=TTemp[SP];
        destroy_tuple(hv_ClassificationLabelNameResult);
        hv_ClassificationLabelNameResult=TTemp[--SP];

        /*ClassificationLabelIDResult := ClassIDs[0]*/
        create_tuple_i(&TTemp[SP++],0);
        T_tuple_select(hv_ClassIDs,TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-1]=TTemp[SP];
        destroy_tuple(hv_ClassificationLabelIDResult);
        hv_ClassificationLabelIDResult=TTemp[--SP];

        /*TargetClassConfidence := Confidences[find(ClassIDs,number(TargetClassID))]*/
        T_tuple_number(hv_TargetClassID,&TTemp[SP++]);
        T_tuple_find(hv_ClassIDs,TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-1]=TTemp[SP];
        T_tuple_select(hv_Confidences,TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-1]=TTemp[SP];
        destroy_tuple(hv_TargetClassConfidence);
        hv_TargetClassConfidence=TTemp[--SP];

        /*Text := '--------- '*/
        reuse_tuple_s(&hv_Text,"--------- ");
        /*Text[|Text|] := 'Image '*/
        copy_tuple(hv_Text,&TTemp[SP++]);
        T_tuple_length(TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-1]=TTemp[SP];
        create_tuple_s(&TTemp[SP++],"Image ");
        replace_elements(&hv_Text,&TTemp[SP-2],&TTemp[SP-1]);
        destroy_tuple(TTemp[--SP]);
        destroy_tuple(TTemp[--SP]);
        /*Text[|Text|] := '--------- '*/
        copy_tuple(hv_Text,&TTemp[SP++]);
        T_tuple_length(TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-1]=TTemp[SP];
        create_tuple_s(&TTemp[SP++],"--------- ");
        replace_elements(&hv_Text,&TTemp[SP-2],&TTemp[SP-1]);
        destroy_tuple(TTemp[--SP]);
        destroy_tuple(TTemp[--SP]);
        /*Text[|Text|] := ''*/
        copy_tuple(hv_Text,&TTemp[SP++]);
        T_tuple_length(TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-1]=TTemp[SP];
        create_tuple_s(&TTemp[SP++],"");
        replace_elements(&hv_Text,&TTemp[SP-2],&TTemp[SP-1]);
        destroy_tuple(TTemp[--SP]);
        destroy_tuple(TTemp[--SP]);
        /*========== if (find(SampleKeys,'image_label_id') != -1) ==========*/
        create_tuple_s(&TTemp[SP++],"image_label_id");
        T_tuple_find(hv_SampleKeys,TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-1]=TTemp[SP];
        create_tuple_i(&TTemp[SP++],-1);
        T_tuple_not_equal(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-2]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-2]=TTemp[SP];
        SP--;
        if(get_i(TTemp[SP-1],0))
        {
          /*get_dict_tuple (DLSample, 'image_label_id', ClassificationLabelIDGroundTruth)*/
          create_tuple_s(&TTemp[SP++],"image_label_id");
          destroy_tuple(hv_ClassificationLabelIDGroundTruth);
          /***/T_get_dict_tuple(hv_DLSample, TTemp[SP-1], &hv_ClassificationLabelIDGroundTruth);
          destroy_tuple(TTemp[--SP]);

          /*get_dict_tuple (DLDatasetInfo, 'class_names', ClassificationLabelNamesGroundTruth)*/
          create_tuple_s(&TTemp[SP++],"class_names");
          destroy_tuple(hv_ClassificationLabelNamesGroundTruth);
          /***/T_get_dict_tuple(hv_DLDatasetInfo, TTemp[SP-1], &hv_ClassificationLabelNamesGroundTruth);
          destroy_tuple(TTemp[--SP]);

          /*Get prediction color.*/
          /*========== if (ClassificationLabelIDGroundTruth == ClassificationLabelIDResult) ==========*/
          T_tuple_equal(hv_ClassificationLabelIDGroundTruth,hv_ClassificationLabelIDResult,&TTemp[SP++]);
          if(get_i(TTemp[SP-1],0))
          {
            /*PredictionColor := 'green'*/
            reuse_tuple_s(&hv_PredictionColor,"green");
          }
          else
          {
            /*PredictionColor := 'red'*/
            reuse_tuple_s(&hv_PredictionColor,"red");
          }
          destroy_tuple(TTemp[--SP]);
          /*========== end if ==========*/
          /*Text[|Text|] := 'Ground truth class: '*/
          copy_tuple(hv_Text,&TTemp[SP++]);
          T_tuple_length(TTemp[SP-1],&TTemp[SP]);
          destroy_tuple(TTemp[SP-1]);
          TTemp[SP-1]=TTemp[SP];
          create_tuple_s(&TTemp[SP++],"Ground truth class: ");
          replace_elements(&hv_Text,&TTemp[SP-2],&TTemp[SP-1]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(TTemp[--SP]);
          /*Text[|Text|] := ClassificationLabelNamesGroundTruth[ClassificationLabelIDGroundTruth]*/
          copy_tuple(hv_Text,&TTemp[SP++]);
          T_tuple_length(TTemp[SP-1],&TTemp[SP]);
          destroy_tuple(TTemp[SP-1]);
          TTemp[SP-1]=TTemp[SP];
          T_tuple_select(hv_ClassificationLabelNamesGroundTruth,hv_ClassificationLabelIDGroundTruth,&TTemp[SP++]);
          replace_elements(&hv_Text,&TTemp[SP-2],&TTemp[SP-1]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(TTemp[--SP]);
          /*Text[|Text|] := ''*/
          copy_tuple(hv_Text,&TTemp[SP++]);
          T_tuple_length(TTemp[SP-1],&TTemp[SP]);
          destroy_tuple(TTemp[SP-1]);
          TTemp[SP-1]=TTemp[SP];
          create_tuple_s(&TTemp[SP++],"");
          replace_elements(&hv_Text,&TTemp[SP-2],&TTemp[SP-1]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(TTemp[--SP]);
        }
        destroy_tuple(TTemp[--SP]);
        /*========== end if ==========*/
        /*Text[|Text|] := 'Predicted class: '*/
        copy_tuple(hv_Text,&TTemp[SP++]);
        T_tuple_length(TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-1]=TTemp[SP];
        create_tuple_s(&TTemp[SP++],"Predicted class: ");
        replace_elements(&hv_Text,&TTemp[SP-2],&TTemp[SP-1]);
        destroy_tuple(TTemp[--SP]);
        destroy_tuple(TTemp[--SP]);
        /*Text[|Text|] := ClassificationLabelNameResult*/
        copy_tuple(hv_Text,&TTemp[SP++]);
        T_tuple_length(TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-1]=TTemp[SP];
        replace_elements(&hv_Text,&TTemp[SP-1],&hv_ClassificationLabelNameResult);
        destroy_tuple(TTemp[--SP]);
        /*Text[|Text|] := ''*/
        copy_tuple(hv_Text,&TTemp[SP++]);
        T_tuple_length(TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-1]=TTemp[SP];
        create_tuple_s(&TTemp[SP++],"");
        replace_elements(&hv_Text,&TTemp[SP-2],&TTemp[SP-1]);
        destroy_tuple(TTemp[--SP]);
        destroy_tuple(TTemp[--SP]);
        /*Text[|Text|] := 'Confidence: ' + Confidences[0]$'.2f'*/
        copy_tuple(hv_Text,&TTemp[SP++]);
        T_tuple_length(TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-1]=TTemp[SP];
        create_tuple_s(&TTemp[SP++],"Confidence: ");
        create_tuple_i(&TTemp[SP++],0);
        T_tuple_select(hv_Confidences,TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-1]=TTemp[SP];
        create_tuple_s(&TTemp[SP++],".2f");
        T_tuple_string(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-2]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-2]=TTemp[SP];
        SP--;
        T_tuple_add(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-2]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-2]=TTemp[SP];
        SP--;
        replace_elements(&hv_Text,&TTemp[SP-2],&TTemp[SP-1]);
        destroy_tuple(TTemp[--SP]);
        destroy_tuple(TTemp[--SP]);
        /*Text[|Text|] := ''*/
        copy_tuple(hv_Text,&TTemp[SP++]);
        T_tuple_length(TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-1]=TTemp[SP];
        create_tuple_s(&TTemp[SP++],"");
        replace_elements(&hv_Text,&TTemp[SP-2],&TTemp[SP-1]);
        destroy_tuple(TTemp[--SP]);
        destroy_tuple(TTemp[--SP]);
        /*Text[|Text|] := '--------- '*/
        copy_tuple(hv_Text,&TTemp[SP++]);
        T_tuple_length(TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-1]=TTemp[SP];
        create_tuple_s(&TTemp[SP++],"--------- ");
        replace_elements(&hv_Text,&TTemp[SP-2],&TTemp[SP-1]);
        destroy_tuple(TTemp[--SP]);
        destroy_tuple(TTemp[--SP]);
        /*Text[|Text|] := 'Heatmap '*/
        copy_tuple(hv_Text,&TTemp[SP++]);
        T_tuple_length(TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-1]=TTemp[SP];
        create_tuple_s(&TTemp[SP++],"Heatmap ");
        replace_elements(&hv_Text,&TTemp[SP-2],&TTemp[SP-1]);
        destroy_tuple(TTemp[--SP]);
        destroy_tuple(TTemp[--SP]);
        /*Text[|Text|] := '--------- '*/
        copy_tuple(hv_Text,&TTemp[SP++]);
        T_tuple_length(TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-1]=TTemp[SP];
        create_tuple_s(&TTemp[SP++],"--------- ");
        replace_elements(&hv_Text,&TTemp[SP-2],&TTemp[SP-1]);
        destroy_tuple(TTemp[--SP]);
        destroy_tuple(TTemp[--SP]);
        /*Text[|Text|] := ''*/
        copy_tuple(hv_Text,&TTemp[SP++]);
        T_tuple_length(TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-1]=TTemp[SP];
        create_tuple_s(&TTemp[SP++],"");
        replace_elements(&hv_Text,&TTemp[SP-2],&TTemp[SP-1]);
        destroy_tuple(TTemp[--SP]);
        destroy_tuple(TTemp[--SP]);
        /*Text[|Text|] := 'Method: ' + MethodName*/
        copy_tuple(hv_Text,&TTemp[SP++]);
        T_tuple_length(TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-1]=TTemp[SP];
        create_tuple_s(&TTemp[SP++],"Method: ");
        T_tuple_add(TTemp[SP-1],hv_MethodName,&TTemp[SP]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-1]=TTemp[SP];
        replace_elements(&hv_Text,&TTemp[SP-2],&TTemp[SP-1]);
        destroy_tuple(TTemp[--SP]);
        destroy_tuple(TTemp[--SP]);
        /*Text[|Text|] := 'Target class: ' + TargetClassID*/
        copy_tuple(hv_Text,&TTemp[SP++]);
        T_tuple_length(TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-1]=TTemp[SP];
        create_tuple_s(&TTemp[SP++],"Target class: ");
        T_tuple_add(TTemp[SP-1],hv_TargetClassID,&TTemp[SP]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-1]=TTemp[SP];
        replace_elements(&hv_Text,&TTemp[SP-2],&TTemp[SP-1]);
        destroy_tuple(TTemp[--SP]);
        destroy_tuple(TTemp[--SP]);
        /*Text[|Text|] := ''*/
        copy_tuple(hv_Text,&TTemp[SP++]);
        T_tuple_length(TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-1]=TTemp[SP];
        create_tuple_s(&TTemp[SP++],"");
        replace_elements(&hv_Text,&TTemp[SP-2],&TTemp[SP-1]);
        destroy_tuple(TTemp[--SP]);
        destroy_tuple(TTemp[--SP]);
        /*Text[|Text|] := 'Target class confidence: ' + TargetClassConfidence$'.2f'*/
        copy_tuple(hv_Text,&TTemp[SP++]);
        T_tuple_length(TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-1]=TTemp[SP];
        create_tuple_s(&TTemp[SP++],"Target class confidence: ");
        create_tuple_s(&TTemp[SP++],".2f");
        T_tuple_string(hv_TargetClassConfidence,TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-1]=TTemp[SP];
        T_tuple_add(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-2]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-2]=TTemp[SP];
        SP--;
        replace_elements(&hv_Text,&TTemp[SP-2],&TTemp[SP-1]);
        destroy_tuple(TTemp[--SP]);
        destroy_tuple(TTemp[--SP]);
        /*========== if (SelectedHeatmapMethod == 'heatmap_confidence_based') ==========*/
        create_tuple_s(&TTemp[SP++],"heatmap_confidence_based");
        T_tuple_equal(hv_SelectedHeatmapMethod,TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-1]=TTemp[SP];
        if(get_i(TTemp[SP-1],0))
        {
          /*Text[|Text|] := 'Maximum deviation: ' + MaxDeviation$'.2f'*/
          copy_tuple(hv_Text,&TTemp[SP++]);
          T_tuple_length(TTemp[SP-1],&TTemp[SP]);
          destroy_tuple(TTemp[SP-1]);
          TTemp[SP-1]=TTemp[SP];
          create_tuple_s(&TTemp[SP++],"Maximum deviation: ");
          create_tuple_s(&TTemp[SP++],".2f");
          T_tuple_string(hv_MaxDeviation,TTemp[SP-1],&TTemp[SP]);
          destroy_tuple(TTemp[SP-1]);
          TTemp[SP-1]=TTemp[SP];
          T_tuple_add(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
          destroy_tuple(TTemp[SP-2]);
          destroy_tuple(TTemp[SP-1]);
          TTemp[SP-2]=TTemp[SP];
          SP--;
          replace_elements(&hv_Text,&TTemp[SP-2],&TTemp[SP-1]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(TTemp[--SP]);
        }
        destroy_tuple(TTemp[--SP]);
        /*========== end if ==========*/
        /**/
        /*Get or open next child window*/
        /*get_child_window (HeightImage, __get_dict_tuple( Params, ['font']), __get_dict_tuple( Params, ['font_size']), Text, PrevWindowCoordinates, WindowHandleDict, KeysForDisplay[KeyIndex], WindowImageRatio, PrevWindowCoordinates)*/
        create_tuple_s(&TTemp[SP++],"font");
        T_get_dict_tuple(hv_Params,TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-1]=TTemp[SP];
        create_tuple_s(&TTemp[SP++],"font_size");
        T_get_dict_tuple(hv_Params,TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-1]=TTemp[SP];
        copy_tuple(hv_PrevWindowCoordinates,&TTemp[SP++]);
        T_tuple_select(hv_KeysForDisplay_COPY_INP_TMP,hv_KeyIndex,&TTemp[SP++]);
        destroy_tuple(hv_WindowImageRatio);
        destroy_tuple(hv_PrevWindowCoordinates);
        /***/get_child_window(hv_HeightImage, TTemp[SP-4], TTemp[SP-3], hv_Text, 
            TTemp[SP-2], hv_WindowHandleDict, TTemp[SP-1], &hv_WindowImageRatio, 
            &hv_PrevWindowCoordinates);
        destroy_tuple(TTemp[--SP]);
        destroy_tuple(TTemp[--SP]);
        destroy_tuple(TTemp[--SP]);
        destroy_tuple(TTemp[--SP]);

        /*tuple_gen_const (|Text|, 'white', LineColors)*/
        T_tuple_length(hv_Text,&TTemp[SP++]);
        create_tuple_s(&TTemp[SP++],"white");
        destroy_tuple(hv_LineColors);
        /***/T_tuple_gen_const(TTemp[SP-2], TTemp[SP-1], &hv_LineColors);
        destroy_tuple(TTemp[--SP]);
        destroy_tuple(TTemp[--SP]);

        /*========== if (find(SampleKeys,'image_label_id') != -1) ==========*/
        create_tuple_s(&TTemp[SP++],"image_label_id");
        T_tuple_find(hv_SampleKeys,TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-1]=TTemp[SP];
        create_tuple_i(&TTemp[SP++],-1);
        T_tuple_not_equal(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-2]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-2]=TTemp[SP];
        SP--;
        if(get_i(TTemp[SP-1],0))
        {
          /*LineColors[8] := PredictionColor*/
          create_tuple_i(&TTemp[SP++],8);
          replace_elements(&hv_LineColors,&TTemp[SP-1],&hv_PredictionColor);
          destroy_tuple(TTemp[--SP]);
        }
        destroy_tuple(TTemp[--SP]);
        /*========== end if ==========*/
        if (hdev_window_stack_is_open())
        {
          Htuple active_win;
          create_tuple(&active_win,0);
          hdev_window_stack_get_active(&active_win);
          /*dev_disp_text (Text, 'window', 'top', 'left', LineColors, 'box', 'false')*/
          create_tuple_s(&TTemp[SP++],"window");
          create_tuple_s(&TTemp[SP++],"top");
          create_tuple_s(&TTemp[SP++],"left");
          create_tuple_s(&TTemp[SP++],"box");
          create_tuple_s(&TTemp[SP++],"false");
          /***/T_disp_text(active_win,hv_Text, TTemp[SP-5], TTemp[SP-4], TTemp[SP-3], 
              hv_LineColors, TTemp[SP-2], TTemp[SP-1]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(active_win);
        }
      }
      destroy_tuple(TTemp[--SP]);
      /*========== end if ==========*/
    }
    else
    {
    destroy_tuple(TTemp[--SP]);
    /*========== elseif (KeysForDisplay[KeyIndex] == 'ocr_recognition_ground_truth' or KeysForDisplay[KeyIndex] == 'ocr_recognition_result' or KeysForDisplay[KeyIndex] == 'ocr_recognition_both') ==========*/

    T_tuple_select(hv_KeysForDisplay_COPY_INP_TMP,hv_KeyIndex,&TTemp[SP++]);
    create_tuple_s(&TTemp[SP++],"ocr_recognition_ground_truth");
    T_tuple_equal(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-2]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-2]=TTemp[SP];
    SP--;
    T_tuple_select(hv_KeysForDisplay_COPY_INP_TMP,hv_KeyIndex,&TTemp[SP++]);
    create_tuple_s(&TTemp[SP++],"ocr_recognition_result");
    T_tuple_equal(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-2]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-2]=TTemp[SP];
    SP--;
    T_tuple_or(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-2]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-2]=TTemp[SP];
    SP--;
    T_tuple_select(hv_KeysForDisplay_COPY_INP_TMP,hv_KeyIndex,&TTemp[SP++]);
    create_tuple_s(&TTemp[SP++],"ocr_recognition_both");
    T_tuple_equal(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-2]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-2]=TTemp[SP];
    SP--;
    T_tuple_or(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-2]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-2]=TTemp[SP];
    SP--;
    if(get_i(TTemp[SP-1],0))
    {
      /**/
      /*OCR Recognition.*/
      /*ShowGT := KeysForDisplay[KeyIndex] == 'ocr_recognition_both' or KeysForDisplay[KeyIndex] == 'ocr_recognition_ground_truth'*/
      T_tuple_select(hv_KeysForDisplay_COPY_INP_TMP,hv_KeyIndex,&TTemp[SP++]);
      create_tuple_s(&TTemp[SP++],"ocr_recognition_both");
      T_tuple_equal(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-2]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-2]=TTemp[SP];
      SP--;
      T_tuple_select(hv_KeysForDisplay_COPY_INP_TMP,hv_KeyIndex,&TTemp[SP++]);
      create_tuple_s(&TTemp[SP++],"ocr_recognition_ground_truth");
      T_tuple_equal(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-2]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-2]=TTemp[SP];
      SP--;
      T_tuple_or(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-2]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-2]=TTemp[SP];
      SP--;
      destroy_tuple(hv_ShowGT);
      hv_ShowGT=TTemp[--SP];

      /*ShowResult := KeysForDisplay[KeyIndex] == 'ocr_recognition_both' or KeysForDisplay[KeyIndex] == 'ocr_recognition_result'*/
      T_tuple_select(hv_KeysForDisplay_COPY_INP_TMP,hv_KeyIndex,&TTemp[SP++]);
      create_tuple_s(&TTemp[SP++],"ocr_recognition_both");
      T_tuple_equal(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-2]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-2]=TTemp[SP];
      SP--;
      T_tuple_select(hv_KeysForDisplay_COPY_INP_TMP,hv_KeyIndex,&TTemp[SP++]);
      create_tuple_s(&TTemp[SP++],"ocr_recognition_result");
      T_tuple_equal(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-2]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-2]=TTemp[SP];
      SP--;
      T_tuple_or(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-2]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-2]=TTemp[SP];
      SP--;
      destroy_tuple(hv_ShowResult);
      hv_ShowResult=TTemp[--SP];

      /*NumLines := ShowGT + ShowResult*/
      T_tuple_add(hv_ShowGT,hv_ShowResult,&TTemp[SP++]);
      destroy_tuple(hv_NumLines);
      hv_NumLines=TTemp[--SP];

      /*get_dl_sample_image (Image, SampleKeys, DLSample, 'image')*/
      create_tuple_s(&TTemp[SP++],"image");
      clear_obj(ho_Image);
      /***/get_dl_sample_image(&ho_Image, hv_SampleKeys, hv_DLSample, TTemp[SP-1]);
      destroy_tuple(TTemp[--SP]);

      /**/
      /*Get or open next window.*/
      /*get_image_size (Image, WidthImage, HeightImage)*/
      destroy_tuple(hv_WidthImage);
      destroy_tuple(hv_HeightImage);
      /***/T_get_image_size(ho_Image, &hv_WidthImage, &hv_HeightImage);

      /*get_next_window (__get_dict_tuple( Params, ['font']), __get_dict_tuple( Params, ['font_size']), NumLines * __get_dict_tuple( Params, ['display_bottom_desc']), WidthImage, HeightImage, 0, __get_dict_tuple( Params, ['scale_windows']), __get_dict_tuple( Params, ['threshold_width']), PrevWindowCoordinates, WindowHandleDict, KeysForDisplay[KeyIndex], CurrentWindowHandle, WindowImageRatio, PrevWindowCoordinates)*/
      create_tuple_s(&TTemp[SP++],"font");
      T_get_dict_tuple(hv_Params,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      create_tuple_s(&TTemp[SP++],"font_size");
      T_get_dict_tuple(hv_Params,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      create_tuple_s(&TTemp[SP++],"display_bottom_desc");
      T_get_dict_tuple(hv_Params,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      T_tuple_mult(hv_NumLines,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      create_tuple_i(&TTemp[SP++],0);
      create_tuple_s(&TTemp[SP++],"scale_windows");
      T_get_dict_tuple(hv_Params,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      create_tuple_s(&TTemp[SP++],"threshold_width");
      T_get_dict_tuple(hv_Params,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      copy_tuple(hv_PrevWindowCoordinates,&TTemp[SP++]);
      T_tuple_select(hv_KeysForDisplay_COPY_INP_TMP,hv_KeyIndex,&TTemp[SP++]);
      destroy_tuple(hv_CurrentWindowHandle);
      destroy_tuple(hv_WindowImageRatio);
      destroy_tuple(hv_PrevWindowCoordinates);
      /***/get_next_window(TTemp[SP-8], TTemp[SP-7], TTemp[SP-6], hv_WidthImage, 
          hv_HeightImage, TTemp[SP-5], TTemp[SP-4], TTemp[SP-3], TTemp[SP-2], hv_WindowHandleDict, 
          TTemp[SP-1], &hv_CurrentWindowHandle, &hv_WindowImageRatio, &hv_PrevWindowCoordinates);
      destroy_tuple(TTemp[--SP]);
      destroy_tuple(TTemp[--SP]);
      destroy_tuple(TTemp[--SP]);
      destroy_tuple(TTemp[--SP]);
      destroy_tuple(TTemp[--SP]);
      destroy_tuple(TTemp[--SP]);
      destroy_tuple(TTemp[--SP]);
      destroy_tuple(TTemp[--SP]);

      /**/
      /*Visualization.*/
      /*full_domain (Image, Image)*/
      /***/full_domain(ho_Image, &(OTemp[SPO]));
      SPO++;
      clear_obj(ho_Image);
      ho_Image = OTemp[--SPO];

      /*get_image_type (Image, Type)*/
      destroy_tuple(hv_Type);
      /***/T_get_image_type(ho_Image, &hv_Type);

      /*========== if (Type == 'real') ==========*/
      create_tuple_s(&TTemp[SP++],"real");
      T_tuple_equal(hv_Type,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      if(get_i(TTemp[SP-1],0))
      {
        /*We assume that real images have been preprocessed*/
        /*to the range -1,1 already. Hence, we need to rescale*/
        /*them back to a visible range in byte.*/
        /*scale_image (Image, Image, 255.0 / 2, 127)*/
        create_tuple_d(&TTemp[SP++],255.0);
        create_tuple_i(&TTemp[SP++],2);
        T_tuple_div(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-2]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-2]=TTemp[SP];
        SP--;
        create_tuple_i(&TTemp[SP++],127);
        /***/T_scale_image(ho_Image, &(OTemp[SPO]), TTemp[SP-2], TTemp[SP-1]);
        SPO++;
        clear_obj(ho_Image);
        ho_Image = OTemp[--SPO];
        destroy_tuple(TTemp[--SP]);
        destroy_tuple(TTemp[--SP]);

        /*convert_image_type (Image, Image, 'byte')*/
        /***/convert_image_type(ho_Image, &(OTemp[SPO]), "byte");
        SPO++;
        clear_obj(ho_Image);
        ho_Image = OTemp[--SPO];

      }
      destroy_tuple(TTemp[--SP]);
      /*========== end if ==========*/
      if (hdev_window_stack_is_open())
      {
        Htuple active_win;
        create_tuple(&active_win,0);
        hdev_window_stack_get_active(&active_win);
        /*dev_display (Image)*/
        /***/T_disp_obj(ho_Image, active_win);
        destroy_tuple(active_win);
      }
      /*========== if (__get_dict_tuple( Params, ['display_bottom_desc'])) ==========*/
      create_tuple_s(&TTemp[SP++],"display_bottom_desc");
      T_get_dict_tuple(hv_Params,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      if(get_i(TTemp[SP-1],0))
      {
        /*Text := []*/
        create_tuple(&TTemp[SP++],0);
        destroy_tuple(hv_Text);
        hv_Text=TTemp[--SP];

        /*Ground truth.*/
        /*========== if (ShowGT) ==========*/
        copy_tuple(hv_ShowGT,&TTemp[SP++]);
        if(get_i(TTemp[SP-1],0))
        {
          /*Text[|Text|] := 'Ground truth: "' + __get_dict_tuple( DLSample, ['word']) + '" ' + ImageIDStringBraces*/
          copy_tuple(hv_Text,&TTemp[SP++]);
          T_tuple_length(TTemp[SP-1],&TTemp[SP]);
          destroy_tuple(TTemp[SP-1]);
          TTemp[SP-1]=TTemp[SP];
          create_tuple_s(&TTemp[SP++],"Ground truth: \"");
          create_tuple_s(&TTemp[SP++],"word");
          T_get_dict_tuple(hv_DLSample,TTemp[SP-1],&TTemp[SP]);
          destroy_tuple(TTemp[SP-1]);
          TTemp[SP-1]=TTemp[SP];
          T_tuple_add(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
          destroy_tuple(TTemp[SP-2]);
          destroy_tuple(TTemp[SP-1]);
          TTemp[SP-2]=TTemp[SP];
          SP--;
          create_tuple_s(&TTemp[SP++],"\" ");
          T_tuple_add(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
          destroy_tuple(TTemp[SP-2]);
          destroy_tuple(TTemp[SP-1]);
          TTemp[SP-2]=TTemp[SP];
          SP--;
          T_tuple_add(TTemp[SP-1],hv_ImageIDStringBraces,&TTemp[SP]);
          destroy_tuple(TTemp[SP-1]);
          TTemp[SP-1]=TTemp[SP];
          replace_elements(&hv_Text,&TTemp[SP-2],&TTemp[SP-1]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(TTemp[--SP]);
        }
        destroy_tuple(TTemp[--SP]);
        /*========== end if ==========*/
        /*Result.*/
        /*========== if (ShowResult) ==========*/
        copy_tuple(hv_ShowResult,&TTemp[SP++]);
        if(get_i(TTemp[SP-1],0))
        {
          /*get_dict_param (DLSample, 'key_exists', 'word', GTWordKeyExists)*/
          create_tuple_s(&TTemp[SP++],"key_exists");
          create_tuple_s(&TTemp[SP++],"word");
          destroy_tuple(hv_GTWordKeyExists);
          /***/T_get_dict_param(hv_DLSample, TTemp[SP-2], TTemp[SP-1], &hv_GTWordKeyExists);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(TTemp[--SP]);

          /*========== if (GTWordKeyExists) ==========*/
          copy_tuple(hv_GTWordKeyExists,&TTemp[SP++]);
          if(get_i(TTemp[SP-1],0))
          {
            /*get_dict_tuple (WindowHandleDict, 'meta_information', MetaInfo)*/
            create_tuple_s(&TTemp[SP++],"meta_information");
            destroy_tuple(hv_MetaInfo);
            /***/T_get_dict_tuple(hv_WindowHandleDict, TTemp[SP-1], &hv_MetaInfo);
            destroy_tuple(TTemp[--SP]);

            /*get_dict_tuple (MetaInfo, KeysForDisplay[KeyIndex] + '_window_coordinates', WindowCoordinates)*/
            T_tuple_select(hv_KeysForDisplay_COPY_INP_TMP,hv_KeyIndex,&TTemp[SP++]);
            create_tuple_s(&TTemp[SP++],"_window_coordinates");
            T_tuple_add(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
            destroy_tuple(TTemp[SP-2]);
            destroy_tuple(TTemp[SP-1]);
            TTemp[SP-2]=TTemp[SP];
            SP--;
            destroy_tuple(hv_WindowCoordinates);
            /***/T_get_dict_tuple(hv_MetaInfo, TTemp[SP-1], &hv_WindowCoordinates);
            destroy_tuple(TTemp[--SP]);

            /*get_dict_tuple (MetaInfo, KeysForDisplay[KeyIndex] + '_margin_bottom', MarginBottom)*/
            T_tuple_select(hv_KeysForDisplay_COPY_INP_TMP,hv_KeyIndex,&TTemp[SP++]);
            create_tuple_s(&TTemp[SP++],"_margin_bottom");
            T_tuple_add(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
            destroy_tuple(TTemp[SP-2]);
            destroy_tuple(TTemp[SP-1]);
            TTemp[SP-2]=TTemp[SP];
            SP--;
            destroy_tuple(hv_MarginBottom);
            /***/T_get_dict_tuple(hv_MetaInfo, TTemp[SP-1], &hv_MarginBottom);
            destroy_tuple(TTemp[--SP]);

            /*HeightWindow := WindowCoordinates[3]*/
            create_tuple_i(&TTemp[SP++],3);
            T_tuple_select(hv_WindowCoordinates,TTemp[SP-1],&TTemp[SP]);
            destroy_tuple(TTemp[SP-1]);
            TTemp[SP-1]=TTemp[SP];
            destroy_tuple(hv_HeightWindow);
            hv_HeightWindow=TTemp[--SP];

            /*HeightMarginBottom := HeightImage * MarginBottom / (HeightWindow - MarginBottom)*/
            T_tuple_mult(hv_HeightImage,hv_MarginBottom,&TTemp[SP++]);
            T_tuple_sub(hv_HeightWindow,hv_MarginBottom,&TTemp[SP++]);
            T_tuple_div(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
            destroy_tuple(TTemp[SP-2]);
            destroy_tuple(TTemp[SP-1]);
            TTemp[SP-2]=TTemp[SP];
            SP--;
            destroy_tuple(hv_HeightMarginBottom);
            hv_HeightMarginBottom=TTemp[--SP];

            /*Size := HeightMarginBottom / 2*/
            create_tuple_i(&TTemp[SP++],2);
            T_tuple_div(hv_HeightMarginBottom,TTemp[SP-1],&TTemp[SP]);
            destroy_tuple(TTemp[SP-1]);
            TTemp[SP-1]=TTemp[SP];
            destroy_tuple(hv_Size);
            hv_Size=TTemp[--SP];

            /*Length := Size / 2*/
            create_tuple_i(&TTemp[SP++],2);
            T_tuple_div(hv_Size,TTemp[SP-1],&TTemp[SP]);
            destroy_tuple(TTemp[SP-1]);
            TTemp[SP-1]=TTemp[SP];
            destroy_tuple(hv_Length);
            hv_Length=TTemp[--SP];

            /*Row := HeightImage + HeightMarginBottom / 2*/
            create_tuple_i(&TTemp[SP++],2);
            T_tuple_div(hv_HeightMarginBottom,TTemp[SP-1],&TTemp[SP]);
            destroy_tuple(TTemp[SP-1]);
            TTemp[SP-1]=TTemp[SP];
            T_tuple_add(hv_HeightImage,TTemp[SP-1],&TTemp[SP]);
            destroy_tuple(TTemp[SP-1]);
            TTemp[SP-1]=TTemp[SP];
            destroy_tuple(hv_Row);
            hv_Row=TTemp[--SP];

            /*Column := WidthImage - 1.5 * Size*/
            create_tuple_d(&TTemp[SP++],1.5);
            T_tuple_mult(TTemp[SP-1],hv_Size,&TTemp[SP]);
            destroy_tuple(TTemp[SP-1]);
            TTemp[SP-1]=TTemp[SP];
            T_tuple_sub(hv_WidthImage,TTemp[SP-1],&TTemp[SP]);
            destroy_tuple(TTemp[SP-1]);
            TTemp[SP-1]=TTemp[SP];
            destroy_tuple(hv_Column);
            hv_Column=TTemp[--SP];

            /*hom_mat2d_identity (HomMat2DIdentity)*/
            destroy_tuple(hv_HomMat2DIdentity);
            /***/T_hom_mat2d_identity(&hv_HomMat2DIdentity);

            /*hom_mat2d_rotate (HomMat2DIdentity, rad(45), 0, 0, HomMat2DRotate)*/
            create_tuple_i(&TTemp[SP++],45);
            T_tuple_rad(TTemp[SP-1],&TTemp[SP]);
            destroy_tuple(TTemp[SP-1]);
            TTemp[SP-1]=TTemp[SP];
            create_tuple_i(&TTemp[SP++],0);
            create_tuple_i(&TTemp[SP++],0);
            destroy_tuple(hv_HomMat2DRotate);
            /***/T_hom_mat2d_rotate(hv_HomMat2DIdentity, TTemp[SP-3], TTemp[SP-2], 
                TTemp[SP-1], &hv_HomMat2DRotate);
            destroy_tuple(TTemp[--SP]);
            destroy_tuple(TTemp[--SP]);
            destroy_tuple(TTemp[--SP]);

            /*hom_mat2d_translate (HomMat2DRotate, Row, Column, HomMat2DCompose)*/
            destroy_tuple(hv_HomMat2DCompose);
            /***/T_hom_mat2d_translate(hv_HomMat2DRotate, hv_Row, hv_Column, &hv_HomMat2DCompose);

            /*========== if (__test_equal_dict_item([DLResult, DLSample], ['word'], ['word'])) ==========*/
            T_tuple_concat(hv_DLResult_COPY_INP_TMP,hv_DLSample,&TTemp[SP++]);
            create_tuple_s(&TTemp[SP++],"word");
            create_tuple_s(&TTemp[SP++],"word");
            T_test_equal_dict_item(TTemp[SP-3],TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
            destroy_tuple(TTemp[SP-3]);
            destroy_tuple(TTemp[SP-2]);
            destroy_tuple(TTemp[SP-1]);
            TTemp[SP-3]=TTemp[SP];
            SP=SP-2;
            if(get_i(TTemp[SP-1],0))
            {
              /*PredictionForegroundColor := 'green'*/
              reuse_tuple_s(&hv_PredictionForegroundColor,"green");
              /*PredictionBackgroundColor := '#008000'*/
              reuse_tuple_s(&hv_PredictionBackgroundColor,"#008000");
              /*gen_contour_polygon_xld (PredictionSymbol, [-0.75 * Length,0, 0], [-Length,-Length,Length])*/
              create_tuple_d(&TTemp[SP++],-0.75);
              T_tuple_mult(TTemp[SP-1],hv_Length,&TTemp[SP]);
              destroy_tuple(TTemp[SP-1]);
              TTemp[SP-1]=TTemp[SP];
              create_tuple(&TTemp[SP++],2);
              set_i(TTemp[SP-1],0              ,0);
              set_i(TTemp[SP-1],0              ,1);
              T_tuple_concat(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
              destroy_tuple(TTemp[SP-2]);
              destroy_tuple(TTemp[SP-1]);
              TTemp[SP-2]=TTemp[SP];
              SP--;
              T_tuple_neg(hv_Length,&TTemp[SP++]);
              T_tuple_neg(hv_Length,&TTemp[SP++]);
              T_tuple_concat(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
              destroy_tuple(TTemp[SP-2]);
              destroy_tuple(TTemp[SP-1]);
              TTemp[SP-2]=TTemp[SP];
              SP--;
              T_tuple_concat(TTemp[SP-1],hv_Length,&TTemp[SP]);
              destroy_tuple(TTemp[SP-1]);
              TTemp[SP-1]=TTemp[SP];
              clear_obj(ho_PredictionSymbol);
              /***/T_gen_contour_polygon_xld(&ho_PredictionSymbol, TTemp[SP-2], TTemp[SP-1]);
              destroy_tuple(TTemp[--SP]);
              destroy_tuple(TTemp[--SP]);

            }
            else
            {
              /*PredictionForegroundColor := 'red'*/
              reuse_tuple_s(&hv_PredictionForegroundColor,"red");
              /*PredictionBackgroundColor := '#800000'*/
              reuse_tuple_s(&hv_PredictionBackgroundColor,"#800000");
              /*gen_contour_polygon_xld (CrossLineH, [0, 0], [-Length,Length])*/
              create_tuple(&TTemp[SP++],2);
              set_i(TTemp[SP-1],0              ,0);
              set_i(TTemp[SP-1],0              ,1);
              T_tuple_neg(hv_Length,&TTemp[SP++]);
              T_tuple_concat(TTemp[SP-1],hv_Length,&TTemp[SP]);
              destroy_tuple(TTemp[SP-1]);
              TTemp[SP-1]=TTemp[SP];
              clear_obj(ho_CrossLineH);
              /***/T_gen_contour_polygon_xld(&ho_CrossLineH, TTemp[SP-2], TTemp[SP-1]);
              destroy_tuple(TTemp[--SP]);
              destroy_tuple(TTemp[--SP]);

              /*gen_contour_polygon_xld (CrossLineV, [-Length,Length], [0, 0])*/
              T_tuple_neg(hv_Length,&TTemp[SP++]);
              T_tuple_concat(TTemp[SP-1],hv_Length,&TTemp[SP]);
              destroy_tuple(TTemp[SP-1]);
              TTemp[SP-1]=TTemp[SP];
              create_tuple(&TTemp[SP++],2);
              set_i(TTemp[SP-1],0              ,0);
              set_i(TTemp[SP-1],0              ,1);
              clear_obj(ho_CrossLineV);
              /***/T_gen_contour_polygon_xld(&ho_CrossLineV, TTemp[SP-2], TTemp[SP-1]);
              destroy_tuple(TTemp[--SP]);
              destroy_tuple(TTemp[--SP]);

              /*concat_obj (CrossLineH, CrossLineV, PredictionSymbol)*/
              clear_obj(ho_PredictionSymbol);
              /***/concat_obj(ho_CrossLineH, ho_CrossLineV, &ho_PredictionSymbol);

            }
            destroy_tuple(TTemp[--SP]);
            /*========== end if ==========*/
            /*affine_trans_contour_xld (PredictionSymbol, PredictionSymbol, HomMat2DCompose)*/
            /***/T_affine_trans_contour_xld(ho_PredictionSymbol, &(OTemp[SPO]), hv_HomMat2DCompose);
            SPO++;
            clear_obj(ho_PredictionSymbol);
            ho_PredictionSymbol = OTemp[--SPO];

            /*set_window_param (CurrentWindowHandle, 'background_color', PredictionBackgroundColor)*/
            create_tuple_s(&TTemp[SP++],"background_color");
            /***/T_set_window_param(hv_CurrentWindowHandle, TTemp[SP-1], hv_PredictionBackgroundColor);
            destroy_tuple(TTemp[--SP]);

            if (hdev_window_stack_is_open())
            {
              Htuple active_win;
              create_tuple(&active_win,0);
              hdev_window_stack_get_active(&active_win);
              /*dev_clear_window ()*/
              /***/T_clear_window(active_win);
              destroy_tuple(active_win);
            }
            if (hdev_window_stack_is_open())
            {
              Htuple active_win;
              create_tuple(&active_win,0);
              hdev_window_stack_get_active(&active_win);
              /*dev_display (Image)*/
              /***/T_disp_obj(ho_Image, active_win);
              destroy_tuple(active_win);
            }
            if (hdev_window_stack_is_open())
            {
              Htuple active_win;
              create_tuple(&active_win,0);
              hdev_window_stack_get_active(&active_win);
              /*dev_set_line_width (5)*/
              create_tuple_i(&TTemp[SP++],5);
              /***/T_set_line_width(active_win,TTemp[SP-1]);
              destroy_tuple(TTemp[--SP]);
              destroy_tuple(active_win);
            }
            if (hdev_window_stack_is_open())
            {
              Htuple active_win;
              create_tuple(&active_win,0);
              hdev_window_stack_get_active(&active_win);
              /*dev_set_color (PredictionForegroundColor)*/
              /***/T_set_color(active_win,hv_PredictionForegroundColor);
              destroy_tuple(active_win);
            }
            if (hdev_window_stack_is_open())
            {
              Htuple active_win;
              create_tuple(&active_win,0);
              hdev_window_stack_get_active(&active_win);
              /*dev_display (PredictionSymbol)*/
              /***/T_disp_obj(ho_PredictionSymbol, active_win);
              destroy_tuple(active_win);
            }
          }
          else
          {
            /*PredictionForegroundColor := 'white'*/
            reuse_tuple_s(&hv_PredictionForegroundColor,"white");
          }
          destroy_tuple(TTemp[--SP]);
          /*========== end if ==========*/
          /*========== if (ShowGT) ==========*/
          copy_tuple(hv_ShowGT,&TTemp[SP++]);
          if(get_i(TTemp[SP-1],0))
          {
            /*Spaces := '    '*/
            reuse_tuple_s(&hv_Spaces,"    ");
          }
          else
          {
            /*Spaces := ''*/
            reuse_tuple_s(&hv_Spaces,"");
          }
          destroy_tuple(TTemp[--SP]);
          /*========== end if ==========*/
          /*Text[|Text|] := 'Deep OCR:' + Spaces + ' "' + __get_dict_tuple( DLResult, ['word']) + '"'*/
          copy_tuple(hv_Text,&TTemp[SP++]);
          T_tuple_length(TTemp[SP-1],&TTemp[SP]);
          destroy_tuple(TTemp[SP-1]);
          TTemp[SP-1]=TTemp[SP];
          create_tuple_s(&TTemp[SP++],"Deep OCR:");
          T_tuple_add(TTemp[SP-1],hv_Spaces,&TTemp[SP]);
          destroy_tuple(TTemp[SP-1]);
          TTemp[SP-1]=TTemp[SP];
          create_tuple_s(&TTemp[SP++]," \"");
          T_tuple_add(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
          destroy_tuple(TTemp[SP-2]);
          destroy_tuple(TTemp[SP-1]);
          TTemp[SP-2]=TTemp[SP];
          SP--;
          create_tuple_s(&TTemp[SP++],"word");
          T_get_dict_tuple(hv_DLResult_COPY_INP_TMP,TTemp[SP-1],&TTemp[SP]);
          destroy_tuple(TTemp[SP-1]);
          TTemp[SP-1]=TTemp[SP];
          T_tuple_add(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
          destroy_tuple(TTemp[SP-2]);
          destroy_tuple(TTemp[SP-1]);
          TTemp[SP-2]=TTemp[SP];
          SP--;
          create_tuple_s(&TTemp[SP++],"\"");
          T_tuple_add(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
          destroy_tuple(TTemp[SP-2]);
          destroy_tuple(TTemp[SP-1]);
          TTemp[SP-2]=TTemp[SP];
          SP--;
          replace_elements(&hv_Text,&TTemp[SP-2],&TTemp[SP-1]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(TTemp[--SP]);
        }
        destroy_tuple(TTemp[--SP]);
        /*========== end if ==========*/
        if (hdev_window_stack_is_open())
        {
          Htuple active_win;
          create_tuple(&active_win,0);
          hdev_window_stack_get_active(&active_win);
          /*dev_disp_text (Text, 'window', 'bottom', 'left', 'white', 'box', 'false')*/
          create_tuple_s(&TTemp[SP++],"window");
          create_tuple_s(&TTemp[SP++],"bottom");
          create_tuple_s(&TTemp[SP++],"left");
          create_tuple_s(&TTemp[SP++],"white");
          create_tuple_s(&TTemp[SP++],"box");
          create_tuple_s(&TTemp[SP++],"false");
          /***/T_disp_text(active_win,hv_Text, TTemp[SP-6], TTemp[SP-5], TTemp[SP-4], 
              TTemp[SP-3], TTemp[SP-2], TTemp[SP-1]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(active_win);
        }
      }
      destroy_tuple(TTemp[--SP]);
      /*========== end if ==========*/
    }
    else
    {
    destroy_tuple(TTemp[--SP]);
    /*========== elseif (KeysForDisplay[KeyIndex] == 'segmentation_confidence') ==========*/

    T_tuple_select(hv_KeysForDisplay_COPY_INP_TMP,hv_KeyIndex,&TTemp[SP++]);
    create_tuple_s(&TTemp[SP++],"segmentation_confidence");
    T_tuple_equal(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-2]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-2]=TTemp[SP];
    SP--;
    if(get_i(TTemp[SP-1],0))
    {
      /**/
      /*Segmentation confidences.*/
      /*get_confidence_image (ImageConfidence, ResultKeys, DLResult)*/
      clear_obj(ho_ImageConfidence);
      /***/get_confidence_image(&ho_ImageConfidence, hv_ResultKeys, hv_DLResult_COPY_INP_TMP);

      /**/
      /*Get or open next window.*/
      /*get_image_size (ImageConfidence, WidthImage, HeightImage)*/
      destroy_tuple(hv_WidthImage);
      destroy_tuple(hv_HeightImage);
      /***/T_get_image_size(ho_ImageConfidence, &hv_WidthImage, &hv_HeightImage);

      /*get_next_window (__get_dict_tuple( Params, ['font']), __get_dict_tuple( Params, ['font_size']), __get_dict_tuple( Params, ['display_bottom_desc']), WidthImage, HeightImage, 0, __get_dict_tuple( Params, ['scale_windows']), __get_dict_tuple( Params, ['threshold_width']), PrevWindowCoordinates, WindowHandleDict, KeysForDisplay[KeyIndex], CurrentWindowHandle, WindowImageRatio, PrevWindowCoordinates)*/
      create_tuple_s(&TTemp[SP++],"font");
      T_get_dict_tuple(hv_Params,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      create_tuple_s(&TTemp[SP++],"font_size");
      T_get_dict_tuple(hv_Params,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      create_tuple_s(&TTemp[SP++],"display_bottom_desc");
      T_get_dict_tuple(hv_Params,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      create_tuple_i(&TTemp[SP++],0);
      create_tuple_s(&TTemp[SP++],"scale_windows");
      T_get_dict_tuple(hv_Params,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      create_tuple_s(&TTemp[SP++],"threshold_width");
      T_get_dict_tuple(hv_Params,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      copy_tuple(hv_PrevWindowCoordinates,&TTemp[SP++]);
      T_tuple_select(hv_KeysForDisplay_COPY_INP_TMP,hv_KeyIndex,&TTemp[SP++]);
      destroy_tuple(hv_CurrentWindowHandle);
      destroy_tuple(hv_WindowImageRatio);
      destroy_tuple(hv_PrevWindowCoordinates);
      /***/get_next_window(TTemp[SP-8], TTemp[SP-7], TTemp[SP-6], hv_WidthImage, 
          hv_HeightImage, TTemp[SP-5], TTemp[SP-4], TTemp[SP-3], TTemp[SP-2], hv_WindowHandleDict, 
          TTemp[SP-1], &hv_CurrentWindowHandle, &hv_WindowImageRatio, &hv_PrevWindowCoordinates);
      destroy_tuple(TTemp[--SP]);
      destroy_tuple(TTemp[--SP]);
      destroy_tuple(TTemp[--SP]);
      destroy_tuple(TTemp[--SP]);
      destroy_tuple(TTemp[--SP]);
      destroy_tuple(TTemp[--SP]);
      destroy_tuple(TTemp[--SP]);
      destroy_tuple(TTemp[--SP]);

      /**/
      if (hdev_window_stack_is_open())
      {
        Htuple active_win;
        create_tuple(&active_win,0);
        hdev_window_stack_get_active(&active_win);
        /*dev_display (ImageConfidence)*/
        /***/T_disp_obj(ho_ImageConfidence, active_win);
        destroy_tuple(active_win);
      }
      /*========== if (__get_dict_tuple( Params, ['display_bottom_desc'])) ==========*/
      create_tuple_s(&TTemp[SP++],"display_bottom_desc");
      T_get_dict_tuple(hv_Params,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      if(get_i(TTemp[SP-1],0))
      {
        if (hdev_window_stack_is_open())
        {
          Htuple active_win;
          create_tuple(&active_win,0);
          hdev_window_stack_get_active(&active_win);
          /*dev_disp_text ('Confidence image ' + ImageIDStringBraces, 'window', 'bottom', 'left', 'white', 'box', 'false')*/
          create_tuple_s(&TTemp[SP++],"Confidence image ");
          T_tuple_add(TTemp[SP-1],hv_ImageIDStringBraces,&TTemp[SP]);
          destroy_tuple(TTemp[SP-1]);
          TTemp[SP-1]=TTemp[SP];
          create_tuple_s(&TTemp[SP++],"window");
          create_tuple_s(&TTemp[SP++],"bottom");
          create_tuple_s(&TTemp[SP++],"left");
          create_tuple_s(&TTemp[SP++],"white");
          create_tuple_s(&TTemp[SP++],"box");
          create_tuple_s(&TTemp[SP++],"false");
          /***/T_disp_text(active_win,TTemp[SP-7], TTemp[SP-6], TTemp[SP-5], TTemp[SP-4], 
              TTemp[SP-3], TTemp[SP-2], TTemp[SP-1]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(active_win);
        }
      }
      destroy_tuple(TTemp[--SP]);
      /*========== end if ==========*/
    }
    else
    {
    destroy_tuple(TTemp[--SP]);
    /*========== elseif (KeysForDisplay[KeyIndex] == 'segmentation_confidence_map') ==========*/

    T_tuple_select(hv_KeysForDisplay_COPY_INP_TMP,hv_KeyIndex,&TTemp[SP++]);
    create_tuple_s(&TTemp[SP++],"segmentation_confidence_map");
    T_tuple_equal(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-2]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-2]=TTemp[SP];
    SP--;
    if(get_i(TTemp[SP-1],0))
    {
      /**/
      /*Segmentation confidence map on image.*/
      /*get_dl_sample_image (Image, SampleKeys, DLSample, 'image')*/
      create_tuple_s(&TTemp[SP++],"image");
      clear_obj(ho_Image);
      /***/get_dl_sample_image(&ho_Image, hv_SampleKeys, hv_DLSample, TTemp[SP-1]);
      destroy_tuple(TTemp[--SP]);

      /*get_confidence_image (ImageConfidence, ResultKeys, DLResult)*/
      clear_obj(ho_ImageConfidence);
      /***/get_confidence_image(&ho_ImageConfidence, hv_ResultKeys, hv_DLResult_COPY_INP_TMP);

      /**/
      /*Get or open next window.*/
      /*get_image_size (Image, WidthImage, HeightImage)*/
      destroy_tuple(hv_WidthImage);
      destroy_tuple(hv_HeightImage);
      /***/T_get_image_size(ho_Image, &hv_WidthImage, &hv_HeightImage);

      /*get_next_window (__get_dict_tuple( Params, ['font']), __get_dict_tuple( Params, ['font_size']), __get_dict_tuple( Params, ['display_bottom_desc']), WidthImage, HeightImage, __get_dict_tuple( Params, ['map_color_bar_width']), __get_dict_tuple( Params, ['scale_windows']), __get_dict_tuple( Params, ['threshold_width']), PrevWindowCoordinates, WindowHandleDict, KeysForDisplay[KeyIndex], CurrentWindowHandle, WindowImageRatio, PrevWindowCoordinates)*/
      create_tuple_s(&TTemp[SP++],"font");
      T_get_dict_tuple(hv_Params,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      create_tuple_s(&TTemp[SP++],"font_size");
      T_get_dict_tuple(hv_Params,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      create_tuple_s(&TTemp[SP++],"display_bottom_desc");
      T_get_dict_tuple(hv_Params,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      create_tuple_s(&TTemp[SP++],"map_color_bar_width");
      T_get_dict_tuple(hv_Params,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      create_tuple_s(&TTemp[SP++],"scale_windows");
      T_get_dict_tuple(hv_Params,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      create_tuple_s(&TTemp[SP++],"threshold_width");
      T_get_dict_tuple(hv_Params,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      copy_tuple(hv_PrevWindowCoordinates,&TTemp[SP++]);
      T_tuple_select(hv_KeysForDisplay_COPY_INP_TMP,hv_KeyIndex,&TTemp[SP++]);
      destroy_tuple(hv_CurrentWindowHandle);
      destroy_tuple(hv_WindowImageRatio);
      destroy_tuple(hv_PrevWindowCoordinates);
      /***/get_next_window(TTemp[SP-8], TTemp[SP-7], TTemp[SP-6], hv_WidthImage, 
          hv_HeightImage, TTemp[SP-5], TTemp[SP-4], TTemp[SP-3], TTemp[SP-2], hv_WindowHandleDict, 
          TTemp[SP-1], &hv_CurrentWindowHandle, &hv_WindowImageRatio, &hv_PrevWindowCoordinates);
      destroy_tuple(TTemp[--SP]);
      destroy_tuple(TTemp[--SP]);
      destroy_tuple(TTemp[--SP]);
      destroy_tuple(TTemp[--SP]);
      destroy_tuple(TTemp[--SP]);
      destroy_tuple(TTemp[--SP]);
      destroy_tuple(TTemp[--SP]);
      destroy_tuple(TTemp[--SP]);

      /**/
      /*Visualization.*/
      if (hdev_window_stack_is_open())
      {
        Htuple active_win;
        create_tuple(&active_win,0);
        hdev_window_stack_get_active(&active_win);
        /*dev_display (Image)*/
        /***/T_disp_obj(ho_Image, active_win);
        destroy_tuple(active_win);
      }
      /*dev_display_confidence_regions (ImageConfidence, __get_dict_tuple( Params, ['map_transparency']), ConfidenceColors)*/
      create_tuple_s(&TTemp[SP++],"map_transparency");
      T_get_dict_tuple(hv_Params,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      destroy_tuple(hv_ConfidenceColors);
      /***/dev_display_confidence_regions(ho_ImageConfidence, TTemp[SP-1], &hv_ConfidenceColors);
      destroy_tuple(TTemp[--SP]);

      /*dev_display_map_color_bar (WidthImage, HeightImage, __get_dict_tuple( Params, ['map_color_bar_width']), ConfidenceColors, 1.0, WindowImageRatio, CurrentWindowHandle)*/
      create_tuple_s(&TTemp[SP++],"map_color_bar_width");
      T_get_dict_tuple(hv_Params,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      create_tuple_d(&TTemp[SP++],1.0);
      /***/dev_display_map_color_bar(hv_WidthImage, hv_HeightImage, TTemp[SP-2], 
          hv_ConfidenceColors, TTemp[SP-1], hv_WindowImageRatio, hv_CurrentWindowHandle);
      destroy_tuple(TTemp[--SP]);
      destroy_tuple(TTemp[--SP]);

      /*========== if (__get_dict_tuple( Params, ['display_bottom_desc'])) ==========*/
      create_tuple_s(&TTemp[SP++],"display_bottom_desc");
      T_get_dict_tuple(hv_Params,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      if(get_i(TTemp[SP-1],0))
      {
        if (hdev_window_stack_is_open())
        {
          Htuple active_win;
          create_tuple(&active_win,0);
          hdev_window_stack_get_active(&active_win);
          /*dev_disp_text ('Confidence map ' + ImageIDStringBraces, 'window', 'bottom', 'left', 'white', 'box', 'false')*/
          create_tuple_s(&TTemp[SP++],"Confidence map ");
          T_tuple_add(TTemp[SP-1],hv_ImageIDStringBraces,&TTemp[SP]);
          destroy_tuple(TTemp[SP-1]);
          TTemp[SP-1]=TTemp[SP];
          create_tuple_s(&TTemp[SP++],"window");
          create_tuple_s(&TTemp[SP++],"bottom");
          create_tuple_s(&TTemp[SP++],"left");
          create_tuple_s(&TTemp[SP++],"white");
          create_tuple_s(&TTemp[SP++],"box");
          create_tuple_s(&TTemp[SP++],"false");
          /***/T_disp_text(active_win,TTemp[SP-7], TTemp[SP-6], TTemp[SP-5], TTemp[SP-4], 
              TTemp[SP-3], TTemp[SP-2], TTemp[SP-1]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(active_win);
        }
      }
      destroy_tuple(TTemp[--SP]);
      /*========== end if ==========*/
      /**/
    }
    else
    {
    destroy_tuple(TTemp[--SP]);
    /*========== elseif (KeysForDisplay[KeyIndex] == 'segmentation_image_both') ==========*/

    T_tuple_select(hv_KeysForDisplay_COPY_INP_TMP,hv_KeyIndex,&TTemp[SP++]);
    create_tuple_s(&TTemp[SP++],"segmentation_image_both");
    T_tuple_equal(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-2]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-2]=TTemp[SP];
    SP--;
    if(get_i(TTemp[SP-1],0))
    {
      /**/
      /*Ground truth and result segmentation on image.*/
      /*get_dl_sample_image (Image, SampleKeys, DLSample, 'image')*/
      create_tuple_s(&TTemp[SP++],"image");
      clear_obj(ho_Image);
      /***/get_dl_sample_image(&ho_Image, hv_SampleKeys, hv_DLSample, TTemp[SP-1]);
      destroy_tuple(TTemp[--SP]);

      /*get_segmentation_image_ground_truth (SegmentationImagGroundTruth, SampleKeys, DLSample)*/
      clear_obj(ho_SegmentationImagGroundTruth);
      /***/get_segmentation_image_ground_truth(&ho_SegmentationImagGroundTruth, hv_SampleKeys, 
          hv_DLSample);

      /*get_segmentation_image_result (SegmentationImageResult, ResultKeys, DLResult)*/
      clear_obj(ho_SegmentationImageResult);
      /***/get_segmentation_image_result(&ho_SegmentationImageResult, hv_ResultKeys, 
          hv_DLResult_COPY_INP_TMP);

      /**/
      /*Get or open next window.*/
      /*get_image_size (Image, WidthImage, HeightImage)*/
      destroy_tuple(hv_WidthImage);
      destroy_tuple(hv_HeightImage);
      /***/T_get_image_size(ho_Image, &hv_WidthImage, &hv_HeightImage);

      /*get_next_window (__get_dict_tuple( Params, ['font']), __get_dict_tuple( Params, ['font_size']), __get_dict_tuple( Params, ['display_bottom_desc']), WidthImage, HeightImage, 0, __get_dict_tuple( Params, ['scale_windows']), __get_dict_tuple( Params, ['threshold_width']), PrevWindowCoordinates, WindowHandleDict, KeysForDisplay[KeyIndex], CurrentWindowHandle, WindowImageRatio, PrevWindowCoordinates)*/
      create_tuple_s(&TTemp[SP++],"font");
      T_get_dict_tuple(hv_Params,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      create_tuple_s(&TTemp[SP++],"font_size");
      T_get_dict_tuple(hv_Params,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      create_tuple_s(&TTemp[SP++],"display_bottom_desc");
      T_get_dict_tuple(hv_Params,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      create_tuple_i(&TTemp[SP++],0);
      create_tuple_s(&TTemp[SP++],"scale_windows");
      T_get_dict_tuple(hv_Params,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      create_tuple_s(&TTemp[SP++],"threshold_width");
      T_get_dict_tuple(hv_Params,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      copy_tuple(hv_PrevWindowCoordinates,&TTemp[SP++]);
      T_tuple_select(hv_KeysForDisplay_COPY_INP_TMP,hv_KeyIndex,&TTemp[SP++]);
      destroy_tuple(hv_CurrentWindowHandle);
      destroy_tuple(hv_WindowImageRatio);
      destroy_tuple(hv_PrevWindowCoordinates);
      /***/get_next_window(TTemp[SP-8], TTemp[SP-7], TTemp[SP-6], hv_WidthImage, 
          hv_HeightImage, TTemp[SP-5], TTemp[SP-4], TTemp[SP-3], TTemp[SP-2], hv_WindowHandleDict, 
          TTemp[SP-1], &hv_CurrentWindowHandle, &hv_WindowImageRatio, &hv_PrevWindowCoordinates);
      destroy_tuple(TTemp[--SP]);
      destroy_tuple(TTemp[--SP]);
      destroy_tuple(TTemp[--SP]);
      destroy_tuple(TTemp[--SP]);
      destroy_tuple(TTemp[--SP]);
      destroy_tuple(TTemp[--SP]);
      destroy_tuple(TTemp[--SP]);
      destroy_tuple(TTemp[--SP]);

      /**/
      /*Visualization.*/
      if (hdev_window_stack_is_open())
      {
        Htuple active_win;
        create_tuple(&active_win,0);
        hdev_window_stack_get_active(&active_win);
        /*dev_display (Image)*/
        /***/T_disp_obj(ho_Image, active_win);
        destroy_tuple(active_win);
      }
      /**/
      /*Display regions.*/
      /*ColorsResults := Colors + __get_dict_tuple( Params, ['segmentation_transparency'])*/
      create_tuple_s(&TTemp[SP++],"segmentation_transparency");
      T_get_dict_tuple(hv_Params,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      T_tuple_add(hv_Colors,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      destroy_tuple(hv_ColorsResults);
      hv_ColorsResults=TTemp[--SP];

      if (hdev_window_stack_is_open())
      {
        Htuple active_win;
        create_tuple(&active_win,0);
        hdev_window_stack_get_active(&active_win);
        /*dev_set_draw ('margin')*/
        create_tuple_s(&TTemp[SP++],"margin");
        /***/T_set_draw(active_win,TTemp[SP-1]);
        destroy_tuple(TTemp[--SP]);
        destroy_tuple(active_win);
      }
      if (hdev_window_stack_is_open())
      {
        Htuple active_win;
        create_tuple(&active_win,0);
        hdev_window_stack_get_active(&active_win);
        /*dev_set_line_width (2)*/
        create_tuple_i(&TTemp[SP++],2);
        /***/T_set_line_width(active_win,TTemp[SP-1]);
        destroy_tuple(TTemp[--SP]);
        destroy_tuple(active_win);
      }
      /*dev_display_segmentation_regions (SegmentationImagGroundTruth, ClassIDs, ColorsResults, __get_dict_tuple( Params, ['segmentation_exclude_class_ids']), GroundTruthIDs)*/
      create_tuple_s(&TTemp[SP++],"segmentation_exclude_class_ids");
      T_get_dict_tuple(hv_Params,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      destroy_tuple(hv_GroundTruthIDs);
      /***/dev_display_segmentation_regions(ho_SegmentationImagGroundTruth, hv_ClassIDs, 
          hv_ColorsResults, TTemp[SP-1], &hv_GroundTruthIDs);
      destroy_tuple(TTemp[--SP]);

      if (hdev_window_stack_is_open())
      {
        Htuple active_win;
        create_tuple(&active_win,0);
        hdev_window_stack_get_active(&active_win);
        /*dev_set_line_width (6)*/
        create_tuple_i(&TTemp[SP++],6);
        /***/T_set_line_width(active_win,TTemp[SP-1]);
        destroy_tuple(TTemp[--SP]);
        destroy_tuple(active_win);
      }
      /*dev_display_segmentation_regions (SegmentationImageResult, ClassIDs, ColorsResults, __get_dict_tuple( Params, ['segmentation_exclude_class_ids']), ResultIDs)*/
      create_tuple_s(&TTemp[SP++],"segmentation_exclude_class_ids");
      T_get_dict_tuple(hv_Params,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      destroy_tuple(hv_ResultIDs);
      /***/dev_display_segmentation_regions(ho_SegmentationImageResult, hv_ClassIDs, 
          hv_ColorsResults, TTemp[SP-1], &hv_ResultIDs);
      destroy_tuple(TTemp[--SP]);

      if (hdev_window_stack_is_open())
      {
        Htuple active_win;
        create_tuple(&active_win,0);
        hdev_window_stack_get_active(&active_win);
        /*dev_set_draw ('fill')*/
        create_tuple_s(&TTemp[SP++],"fill");
        /***/T_set_draw(active_win,TTemp[SP-1]);
        destroy_tuple(TTemp[--SP]);
        destroy_tuple(active_win);
      }
      /*Text := 'Ground truth and result segmentation ' + ImageIDStringBraces*/
      create_tuple_s(&TTemp[SP++],"Ground truth and result segmentation ");
      T_tuple_add(TTemp[SP-1],hv_ImageIDStringBraces,&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      destroy_tuple(hv_Text);
      hv_Text=TTemp[--SP];

      /*========== if (__get_dict_tuple( Params, ['display_bottom_desc'])) ==========*/
      create_tuple_s(&TTemp[SP++],"display_bottom_desc");
      T_get_dict_tuple(hv_Params,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      if(get_i(TTemp[SP-1],0))
      {
        if (hdev_window_stack_is_open())
        {
          Htuple active_win;
          create_tuple(&active_win,0);
          hdev_window_stack_get_active(&active_win);
          /*dev_disp_text (Text, 'window', 'bottom', 'left', 'white', 'box', 'false')*/
          create_tuple_s(&TTemp[SP++],"window");
          create_tuple_s(&TTemp[SP++],"bottom");
          create_tuple_s(&TTemp[SP++],"left");
          create_tuple_s(&TTemp[SP++],"white");
          create_tuple_s(&TTemp[SP++],"box");
          create_tuple_s(&TTemp[SP++],"false");
          /***/T_disp_text(active_win,hv_Text, TTemp[SP-6], TTemp[SP-5], TTemp[SP-4], 
              TTemp[SP-3], TTemp[SP-2], TTemp[SP-1]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(active_win);
        }
      }
      destroy_tuple(TTemp[--SP]);
      /*========== end if ==========*/
      /**/
      /*Display the legend.*/
      /*========== if (__get_dict_tuple( Params, ['display_legend'])) ==========*/
      create_tuple_s(&TTemp[SP++],"display_legend");
      T_get_dict_tuple(hv_Params,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      if(get_i(TTemp[SP-1],0))
      {
        /*ImageClassIDsUniq := uniq(sort([GroundTruthIDs,ResultIDs]))*/
        T_tuple_concat(hv_GroundTruthIDs,hv_ResultIDs,&TTemp[SP++]);
        T_tuple_sort(TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-1]=TTemp[SP];
        T_tuple_uniq(TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-1]=TTemp[SP];
        destroy_tuple(hv_ImageClassIDsUniq);
        hv_ImageClassIDsUniq=TTemp[--SP];

        /*Get Indices according to image class IDs.*/
        /*tuple_gen_const (|ImageClassIDsUniq|, 0, ImageClassIDsIndices)*/
        T_tuple_length(hv_ImageClassIDsUniq,&TTemp[SP++]);
        create_tuple_i(&TTemp[SP++],0);
        destroy_tuple(hv_ImageClassIDsIndices);
        /***/T_tuple_gen_const(TTemp[SP-2], TTemp[SP-1], &hv_ImageClassIDsIndices);
        destroy_tuple(TTemp[--SP]);
        destroy_tuple(TTemp[--SP]);

        /*========== for ImageClassIDsIndex := 0 to |ImageClassIDsUniq| - 1 by 1 ==========*/
        T_tuple_length(hv_ImageClassIDsUniq,&TTemp[SP++]);
        create_tuple_i(&TTemp[SP++],1);
        T_tuple_sub(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-2]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-2]=TTemp[SP];
        SP--;
        create_tuple_i(&TTemp[SP++],1);
        create_tuple_i(&TTemp[SP++],0);
        T_tuple_greater(TTemp[SP-1],TTemp[SP-3],&TTemp[SP]);
        SP++;
        T_tuple_equal(TTemp[SP-2],TTemp[SP-4],&TTemp[SP]);
        if(get_i(TTemp[SP],0) ||
           (!((( get_i(TTemp[SP-1],0)) && (get_d(TTemp[SP-3],0)>0)) ||
              ((!get_i(TTemp[SP-1],0)) && (get_d(TTemp[SP-3],0)<0)))))
        {
         destroy_tuple(TTemp[SP--]);
         destroy_tuple(TTemp[SP]);
         T_tuple_sub(TTemp[SP-1],TTemp[SP-2],&TTemp[SP]);
         destroy_tuple(hv_ImageClassIDsIndex);
         copy_tuple(TTemp[SP],&hv_ImageClassIDsIndex);
         destroy_tuple(TTemp[SP--]);
         destroy_tuple(TTemp[SP]);
         for(;;)
         {
         T_tuple_add(hv_ImageClassIDsIndex,TTemp[SP-1],&TTemp[SP]);
         destroy_tuple(hv_ImageClassIDsIndex);
         copy_tuple(TTemp[SP],&hv_ImageClassIDsIndex);
         destroy_tuple(TTemp[SP]);
         if(get_d(TTemp[SP-1],0)<0)
          T_tuple_less(hv_ImageClassIDsIndex,TTemp[SP-2],&TTemp[SP]);
         else
          T_tuple_greater(hv_ImageClassIDsIndex,TTemp[SP-2],&TTemp[SP]);
         if(get_i(TTemp[SP],0)) break;
         destroy_tuple(TTemp[SP]);
         /*========== for ==========*/

          /*ImageClassIDsIndices[ImageClassIDsIndex] := find_first(ClassIDs,ImageClassIDsUniq[ImageClassIDsIndex])*/
          T_tuple_select(hv_ImageClassIDsUniq,hv_ImageClassIDsIndex,&TTemp[SP++]);
          T_tuple_find_first(hv_ClassIDs,TTemp[SP-1],&TTemp[SP]);
          destroy_tuple(TTemp[SP-1]);
          TTemp[SP-1]=TTemp[SP];
          replace_elements(&hv_ImageClassIDsIndices,&hv_ImageClassIDsIndex,&TTemp[SP-1]);
          destroy_tuple(TTemp[--SP]);
         }
         destroy_tuple(TTemp[SP--]);
         destroy_tuple(TTemp[SP--]);
         destroy_tuple(TTemp[SP]);
        }
        else
        {
         destroy_tuple(TTemp[SP--]);
         destroy_tuple(TTemp[SP--]);
         destroy_tuple(TTemp[SP--]);
         destroy_tuple(TTemp[SP--]);
         destroy_tuple(TTemp[SP]);
        }/*========== end for ========*/

        /*Text := [Text,ClassesLegend[ImageClassIDsIndices]]*/
        copy_tuple(hv_Text,&TTemp[SP++]);
        T_tuple_select(hv_ClassesLegend,hv_ImageClassIDsIndices,&TTemp[SP++]);
        T_tuple_concat(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-2]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-2]=TTemp[SP];
        SP--;
        destroy_tuple(hv_Text);
        hv_Text=TTemp[--SP];

        /*Text[|Text| + 1] := '- thicker line: result, thinner lines: ground truth'*/
        copy_tuple(hv_Text,&TTemp[SP++]);
        T_tuple_length(TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-1]=TTemp[SP];
        create_tuple_i(&TTemp[SP++],1);
        T_tuple_add(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-2]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-2]=TTemp[SP];
        SP--;
        create_tuple_s(&TTemp[SP++],"- thicker line: result, thinner lines: ground truth");
        replace_elements(&hv_Text,&TTemp[SP-2],&TTemp[SP-1]);
        destroy_tuple(TTemp[--SP]);
        destroy_tuple(TTemp[--SP]);
        /*Text[|Text|] := '  (you may have to zoom in for a more detailed view)'*/
        copy_tuple(hv_Text,&TTemp[SP++]);
        T_tuple_length(TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-1]=TTemp[SP];
        create_tuple_s(&TTemp[SP++],"  (you may have to zoom in for a more detailed view)");
        replace_elements(&hv_Text,&TTemp[SP-2],&TTemp[SP-1]);
        destroy_tuple(TTemp[--SP]);
        destroy_tuple(TTemp[--SP]);
        /*StringSegExcludeClassIDs := ''*/
        reuse_tuple_s(&hv_StringSegExcludeClassIDs,"");
        /*========== for StringIndex := 0 to |__get_dict_tuple( Params, ['segmentation_exclude_class_ids'])| - 1 by 1 ==========*/
        create_tuple_s(&TTemp[SP++],"segmentation_exclude_class_ids");
        T_get_dict_tuple(hv_Params,TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-1]=TTemp[SP];
        T_tuple_length(TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-1]=TTemp[SP];
        create_tuple_i(&TTemp[SP++],1);
        T_tuple_sub(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-2]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-2]=TTemp[SP];
        SP--;
        create_tuple_i(&TTemp[SP++],1);
        create_tuple_i(&TTemp[SP++],0);
        T_tuple_greater(TTemp[SP-1],TTemp[SP-3],&TTemp[SP]);
        SP++;
        T_tuple_equal(TTemp[SP-2],TTemp[SP-4],&TTemp[SP]);
        if(get_i(TTemp[SP],0) ||
           (!((( get_i(TTemp[SP-1],0)) && (get_d(TTemp[SP-3],0)>0)) ||
              ((!get_i(TTemp[SP-1],0)) && (get_d(TTemp[SP-3],0)<0)))))
        {
         destroy_tuple(TTemp[SP--]);
         destroy_tuple(TTemp[SP]);
         T_tuple_sub(TTemp[SP-1],TTemp[SP-2],&TTemp[SP]);
         destroy_tuple(hv_StringIndex);
         copy_tuple(TTemp[SP],&hv_StringIndex);
         destroy_tuple(TTemp[SP--]);
         destroy_tuple(TTemp[SP]);
         for(;;)
         {
         T_tuple_add(hv_StringIndex,TTemp[SP-1],&TTemp[SP]);
         destroy_tuple(hv_StringIndex);
         copy_tuple(TTemp[SP],&hv_StringIndex);
         destroy_tuple(TTemp[SP]);
         if(get_d(TTemp[SP-1],0)<0)
          T_tuple_less(hv_StringIndex,TTemp[SP-2],&TTemp[SP]);
         else
          T_tuple_greater(hv_StringIndex,TTemp[SP-2],&TTemp[SP]);
         if(get_i(TTemp[SP],0)) break;
         destroy_tuple(TTemp[SP]);
         /*========== for ==========*/

          /*========== if (StringIndex == |__get_dict_tuple( Params, ['segmentation_exclude_class_ids'])| - 1) ==========*/
          create_tuple_s(&TTemp[SP++],"segmentation_exclude_class_ids");
          T_get_dict_tuple(hv_Params,TTemp[SP-1],&TTemp[SP]);
          destroy_tuple(TTemp[SP-1]);
          TTemp[SP-1]=TTemp[SP];
          T_tuple_length(TTemp[SP-1],&TTemp[SP]);
          destroy_tuple(TTemp[SP-1]);
          TTemp[SP-1]=TTemp[SP];
          create_tuple_i(&TTemp[SP++],1);
          T_tuple_sub(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
          destroy_tuple(TTemp[SP-2]);
          destroy_tuple(TTemp[SP-1]);
          TTemp[SP-2]=TTemp[SP];
          SP--;
          T_tuple_equal(hv_StringIndex,TTemp[SP-1],&TTemp[SP]);
          destroy_tuple(TTemp[SP-1]);
          TTemp[SP-1]=TTemp[SP];
          if(get_i(TTemp[SP-1],0))
          {
            /*StringSegExcludeClassIDs := StringSegExcludeClassIDs + __get_dict_tuple( Params, ['segmentation_exclude_class_ids'])[StringIndex]*/
            create_tuple_s(&TTemp[SP++],"segmentation_exclude_class_ids");
            T_get_dict_tuple(hv_Params,TTemp[SP-1],&TTemp[SP]);
            destroy_tuple(TTemp[SP-1]);
            TTemp[SP-1]=TTemp[SP];
            T_tuple_select(TTemp[SP-1],hv_StringIndex,&TTemp[SP]);
            destroy_tuple(TTemp[SP-1]);
            TTemp[SP-1]=TTemp[SP];
            T_tuple_add(hv_StringSegExcludeClassIDs,TTemp[SP-1],&TTemp[SP]);
            destroy_tuple(hv_StringSegExcludeClassIDs);
            hv_StringSegExcludeClassIDs=TTemp[SP];
            destroy_tuple(TTemp[--SP]);

          }
          else
          {
            /*StringSegExcludeClassIDs := StringSegExcludeClassIDs + __get_dict_tuple( Params, ['segmentation_exclude_class_ids'])[StringIndex] + ', '*/
            copy_tuple(hv_StringSegExcludeClassIDs,&TTemp[SP++]);
            create_tuple_s(&TTemp[SP++],"segmentation_exclude_class_ids");
            T_get_dict_tuple(hv_Params,TTemp[SP-1],&TTemp[SP]);
            destroy_tuple(TTemp[SP-1]);
            TTemp[SP-1]=TTemp[SP];
            T_tuple_select(TTemp[SP-1],hv_StringIndex,&TTemp[SP]);
            destroy_tuple(TTemp[SP-1]);
            TTemp[SP-1]=TTemp[SP];
            T_tuple_add(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
            destroy_tuple(TTemp[SP-2]);
            destroy_tuple(TTemp[SP-1]);
            TTemp[SP-2]=TTemp[SP];
            SP--;
            create_tuple_s(&TTemp[SP++],", ");
            T_tuple_add(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
            destroy_tuple(TTemp[SP-2]);
            destroy_tuple(TTemp[SP-1]);
            TTemp[SP-2]=TTemp[SP];
            SP--;
            destroy_tuple(hv_StringSegExcludeClassIDs);
            hv_StringSegExcludeClassIDs=TTemp[--SP];

          }
          destroy_tuple(TTemp[--SP]);
          /*========== end if ==========*/
         }
         destroy_tuple(TTemp[SP--]);
         destroy_tuple(TTemp[SP--]);
         destroy_tuple(TTemp[SP]);
        }
        else
        {
         destroy_tuple(TTemp[SP--]);
         destroy_tuple(TTemp[SP--]);
         destroy_tuple(TTemp[SP--]);
         destroy_tuple(TTemp[SP--]);
         destroy_tuple(TTemp[SP]);
        }/*========== end for ========*/

        /*create_dict (__Tmp_Ctrl_Dict_Init_7)*/
        destroy_tuple(hv___Tmp_Ctrl_Dict_Init_7);
        /***/T_create_dict(&hv___Tmp_Ctrl_Dict_Init_7);

        /*set_dict_tuple (__Tmp_Ctrl_Dict_Init_7, ['comp'], [])*/
        create_tuple_s(&TTemp[SP++],"comp");
        create_tuple(&TTemp[SP++],0);
        /***/T_set_dict_tuple(hv___Tmp_Ctrl_Dict_Init_7, TTemp[SP-2], TTemp[SP-1]);
        destroy_tuple(TTemp[--SP]);
        destroy_tuple(TTemp[--SP]);

        /*========== if (not __test_equal_dict_item([Params, __Tmp_Ctrl_Dict_Init_7], ['segmentation_exclude_class_ids'], 'comp')) ==========*/
        T_tuple_concat(hv_Params,hv___Tmp_Ctrl_Dict_Init_7,&TTemp[SP++]);
        create_tuple_s(&TTemp[SP++],"segmentation_exclude_class_ids");
        create_tuple_s(&TTemp[SP++],"comp");
        T_test_equal_dict_item(TTemp[SP-3],TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-3]);
        destroy_tuple(TTemp[SP-2]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-3]=TTemp[SP];
        SP=SP-2;
        T_tuple_not(TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-1]=TTemp[SP];
        if(get_i(TTemp[SP-1],0))
        {
          /*Text[|Text|] := '- (excluded classID(s) ' + StringSegExcludeClassIDs + ' from visualization)'*/
          copy_tuple(hv_Text,&TTemp[SP++]);
          T_tuple_length(TTemp[SP-1],&TTemp[SP]);
          destroy_tuple(TTemp[SP-1]);
          TTemp[SP-1]=TTemp[SP];
          create_tuple_s(&TTemp[SP++],"- (excluded classID(s) ");
          T_tuple_add(TTemp[SP-1],hv_StringSegExcludeClassIDs,&TTemp[SP]);
          destroy_tuple(TTemp[SP-1]);
          TTemp[SP-1]=TTemp[SP];
          create_tuple_s(&TTemp[SP++]," from visualization)");
          T_tuple_add(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
          destroy_tuple(TTemp[SP-2]);
          destroy_tuple(TTemp[SP-1]);
          TTemp[SP-2]=TTemp[SP];
          SP--;
          replace_elements(&hv_Text,&TTemp[SP-2],&TTemp[SP-1]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(TTemp[--SP]);
        }
        destroy_tuple(TTemp[--SP]);
        /*========== end if ==========*/
        /*__Tmp_Ctrl_Dict_Init_7 := constant('HNULL')*/
        create_tuple_s(&TTemp[SP++],"HNULL");
        T_tuple_constant(TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-1]=TTemp[SP];
        destroy_tuple(hv___Tmp_Ctrl_Dict_Init_7);
        hv___Tmp_Ctrl_Dict_Init_7=TTemp[--SP];

        /**/
        /*get_child_window (HeightImage, __get_dict_tuple( Params, ['font']), __get_dict_tuple( Params, ['font_size']), Text, PrevWindowCoordinates, WindowHandleDict, KeysForDisplay[KeyIndex], WindowImageRatio, PrevWindowCoordinates)*/
        create_tuple_s(&TTemp[SP++],"font");
        T_get_dict_tuple(hv_Params,TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-1]=TTemp[SP];
        create_tuple_s(&TTemp[SP++],"font_size");
        T_get_dict_tuple(hv_Params,TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-1]=TTemp[SP];
        copy_tuple(hv_PrevWindowCoordinates,&TTemp[SP++]);
        T_tuple_select(hv_KeysForDisplay_COPY_INP_TMP,hv_KeyIndex,&TTemp[SP++]);
        destroy_tuple(hv_WindowImageRatio);
        destroy_tuple(hv_PrevWindowCoordinates);
        /***/get_child_window(hv_HeightImage, TTemp[SP-4], TTemp[SP-3], hv_Text, 
            TTemp[SP-2], hv_WindowHandleDict, TTemp[SP-1], &hv_WindowImageRatio, 
            &hv_PrevWindowCoordinates);
        destroy_tuple(TTemp[--SP]);
        destroy_tuple(TTemp[--SP]);
        destroy_tuple(TTemp[--SP]);
        destroy_tuple(TTemp[--SP]);

        if (hdev_window_stack_is_open())
        {
          Htuple active_win;
          create_tuple(&active_win,0);
          hdev_window_stack_get_active(&active_win);
          /*dev_disp_text (Text, 'window', 'top', 'left', ['white',Colors[ImageClassIDsIndices],'white', 'white', 'white'], 'box', 'false')*/
          create_tuple_s(&TTemp[SP++],"window");
          create_tuple_s(&TTemp[SP++],"top");
          create_tuple_s(&TTemp[SP++],"left");
          create_tuple_s(&TTemp[SP++],"white");
          T_tuple_select(hv_Colors,hv_ImageClassIDsIndices,&TTemp[SP++]);
          T_tuple_concat(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
          destroy_tuple(TTemp[SP-2]);
          destroy_tuple(TTemp[SP-1]);
          TTemp[SP-2]=TTemp[SP];
          SP--;
          create_tuple(&TTemp[SP++],3);
          set_s(TTemp[SP-1],"white",0);
          set_s(TTemp[SP-1],"white",1);
          set_s(TTemp[SP-1],"white",2);
          T_tuple_concat(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
          destroy_tuple(TTemp[SP-2]);
          destroy_tuple(TTemp[SP-1]);
          TTemp[SP-2]=TTemp[SP];
          SP--;
          create_tuple_s(&TTemp[SP++],"box");
          create_tuple_s(&TTemp[SP++],"false");
          /***/T_disp_text(active_win,hv_Text, TTemp[SP-6], TTemp[SP-5], TTemp[SP-4], 
              TTemp[SP-3], TTemp[SP-2], TTemp[SP-1]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(active_win);
        }
      }
      destroy_tuple(TTemp[--SP]);
      /*========== end if ==========*/
    }
    else
    {
    destroy_tuple(TTemp[--SP]);
    /*========== elseif (KeysForDisplay[KeyIndex] == 'segmentation_image_diff') ==========*/

    T_tuple_select(hv_KeysForDisplay_COPY_INP_TMP,hv_KeyIndex,&TTemp[SP++]);
    create_tuple_s(&TTemp[SP++],"segmentation_image_diff");
    T_tuple_equal(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-2]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-2]=TTemp[SP];
    SP--;
    if(get_i(TTemp[SP-1],0))
    {
      /**/
      /*Difference of ground truth and result segmentation on image.*/
      /*get_dl_sample_image (Image, SampleKeys, DLSample, 'image')*/
      create_tuple_s(&TTemp[SP++],"image");
      clear_obj(ho_Image);
      /***/get_dl_sample_image(&ho_Image, hv_SampleKeys, hv_DLSample, TTemp[SP-1]);
      destroy_tuple(TTemp[--SP]);

      /*get_segmentation_image_ground_truth (SegmentationImagGroundTruth, SampleKeys, DLSample)*/
      clear_obj(ho_SegmentationImagGroundTruth);
      /***/get_segmentation_image_ground_truth(&ho_SegmentationImagGroundTruth, hv_SampleKeys, 
          hv_DLSample);

      /*get_segmentation_image_result (SegmentationImageResult, ResultKeys, DLResult)*/
      clear_obj(ho_SegmentationImageResult);
      /***/get_segmentation_image_result(&ho_SegmentationImageResult, hv_ResultKeys, 
          hv_DLResult_COPY_INP_TMP);

      /**/
      /*Get or open next window.*/
      /*get_image_size (Image, WidthImage, HeightImage)*/
      destroy_tuple(hv_WidthImage);
      destroy_tuple(hv_HeightImage);
      /***/T_get_image_size(ho_Image, &hv_WidthImage, &hv_HeightImage);

      /*get_next_window (__get_dict_tuple( Params, ['font']), __get_dict_tuple( Params, ['font_size']), __get_dict_tuple( Params, ['display_bottom_desc']), WidthImage, HeightImage, 0, __get_dict_tuple( Params, ['scale_windows']), __get_dict_tuple( Params, ['threshold_width']), PrevWindowCoordinates, WindowHandleDict, KeysForDisplay[KeyIndex], CurrentWindowHandle, WindowImageRatio, PrevWindowCoordinates)*/
      create_tuple_s(&TTemp[SP++],"font");
      T_get_dict_tuple(hv_Params,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      create_tuple_s(&TTemp[SP++],"font_size");
      T_get_dict_tuple(hv_Params,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      create_tuple_s(&TTemp[SP++],"display_bottom_desc");
      T_get_dict_tuple(hv_Params,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      create_tuple_i(&TTemp[SP++],0);
      create_tuple_s(&TTemp[SP++],"scale_windows");
      T_get_dict_tuple(hv_Params,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      create_tuple_s(&TTemp[SP++],"threshold_width");
      T_get_dict_tuple(hv_Params,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      copy_tuple(hv_PrevWindowCoordinates,&TTemp[SP++]);
      T_tuple_select(hv_KeysForDisplay_COPY_INP_TMP,hv_KeyIndex,&TTemp[SP++]);
      destroy_tuple(hv_CurrentWindowHandle);
      destroy_tuple(hv_WindowImageRatio);
      destroy_tuple(hv_PrevWindowCoordinates);
      /***/get_next_window(TTemp[SP-8], TTemp[SP-7], TTemp[SP-6], hv_WidthImage, 
          hv_HeightImage, TTemp[SP-5], TTemp[SP-4], TTemp[SP-3], TTemp[SP-2], hv_WindowHandleDict, 
          TTemp[SP-1], &hv_CurrentWindowHandle, &hv_WindowImageRatio, &hv_PrevWindowCoordinates);
      destroy_tuple(TTemp[--SP]);
      destroy_tuple(TTemp[--SP]);
      destroy_tuple(TTemp[--SP]);
      destroy_tuple(TTemp[--SP]);
      destroy_tuple(TTemp[--SP]);
      destroy_tuple(TTemp[--SP]);
      destroy_tuple(TTemp[--SP]);
      destroy_tuple(TTemp[--SP]);

      /**/
      /*Visualization.*/
      if (hdev_window_stack_is_open())
      {
        Htuple active_win;
        create_tuple(&active_win,0);
        hdev_window_stack_get_active(&active_win);
        /*dev_display (Image)*/
        /***/T_disp_obj(ho_Image, active_win);
        destroy_tuple(active_win);
      }
      /*abs_diff_image (SegmentationImagGroundTruth, SegmentationImageResult, ImageAbsDiff, 1)*/
      clear_obj(ho_ImageAbsDiff);
      /***/abs_diff_image(ho_SegmentationImagGroundTruth, ho_SegmentationImageResult, 
          &ho_ImageAbsDiff, 1);

      /*min_max_gray (SegmentationImageResult, ImageAbsDiff, 0, Min, Max, Range)*/
      create_tuple_i(&TTemp[SP++],0);
      destroy_tuple(hv_Min);
      destroy_tuple(hv_Max);
      destroy_tuple(hv_Range);
      /***/T_min_max_gray(ho_SegmentationImageResult, ho_ImageAbsDiff, TTemp[SP-1], 
          &hv_Min, &hv_Max, &hv_Range);
      destroy_tuple(TTemp[--SP]);

      /*========== if (Min != Max) ==========*/
      T_tuple_not_equal(hv_Min,hv_Max,&TTemp[SP++]);
      if(get_i(TTemp[SP-1],0))
      {
        /*threshold (ImageAbsDiff, DiffRegion, 0.00001, Max)*/
        create_tuple_d(&TTemp[SP++],0.00001);
        clear_obj(ho_DiffRegion);
        /***/T_threshold(ho_ImageAbsDiff, &ho_DiffRegion, TTemp[SP-1], hv_Max);
        destroy_tuple(TTemp[--SP]);

        if (hdev_window_stack_is_open())
        {
          Htuple active_win;
          create_tuple(&active_win,0);
          hdev_window_stack_get_active(&active_win);
          /*dev_set_color ('#ff0000' + __get_dict_tuple( Params, ['segmentation_transparency']))*/
          create_tuple_s(&TTemp[SP++],"#ff0000");
          create_tuple_s(&TTemp[SP++],"segmentation_transparency");
          T_get_dict_tuple(hv_Params,TTemp[SP-1],&TTemp[SP]);
          destroy_tuple(TTemp[SP-1]);
          TTemp[SP-1]=TTemp[SP];
          T_tuple_add(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
          destroy_tuple(TTemp[SP-2]);
          destroy_tuple(TTemp[SP-1]);
          TTemp[SP-2]=TTemp[SP];
          SP--;
          /***/T_set_color(active_win,TTemp[SP-1]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(active_win);
        }
        if (hdev_window_stack_is_open())
        {
          Htuple active_win;
          create_tuple(&active_win,0);
          hdev_window_stack_get_active(&active_win);
          /*dev_display (DiffRegion)*/
          /***/T_disp_obj(ho_DiffRegion, active_win);
          destroy_tuple(active_win);
        }
      }
      else
      {
        if (hdev_window_stack_is_open())
        {
          Htuple active_win;
          create_tuple(&active_win,0);
          hdev_window_stack_get_active(&active_win);
          /*dev_disp_text ('No difference found.', 'window', 'top', 'left', 'black', [], [])*/
          create_tuple_s(&TTemp[SP++],"No difference found.");
          create_tuple_s(&TTemp[SP++],"window");
          create_tuple_s(&TTemp[SP++],"top");
          create_tuple_s(&TTemp[SP++],"left");
          create_tuple_s(&TTemp[SP++],"black");
          create_tuple(&TTemp[SP++],0);
          create_tuple(&TTemp[SP++],0);
          /***/T_disp_text(active_win,TTemp[SP-7], TTemp[SP-6], TTemp[SP-5], TTemp[SP-4], 
              TTemp[SP-3], TTemp[SP-2], TTemp[SP-1]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(active_win);
        }
      }
      destroy_tuple(TTemp[--SP]);
      /*========== end if ==========*/
      /*========== if (__get_dict_tuple( Params, ['display_bottom_desc'])) ==========*/
      create_tuple_s(&TTemp[SP++],"display_bottom_desc");
      T_get_dict_tuple(hv_Params,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      if(get_i(TTemp[SP-1],0))
      {
        /*Text := 'Difference of ground truth and result segmentation ' + ImageIDStringBraces*/
        create_tuple_s(&TTemp[SP++],"Difference of ground truth and result segmentation ");
        T_tuple_add(TTemp[SP-1],hv_ImageIDStringBraces,&TTemp[SP]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-1]=TTemp[SP];
        destroy_tuple(hv_Text);
        hv_Text=TTemp[--SP];

        if (hdev_window_stack_is_open())
        {
          Htuple active_win;
          create_tuple(&active_win,0);
          hdev_window_stack_get_active(&active_win);
          /*dev_disp_text (Text, 'window', 'bottom', 'left', 'white', 'box', 'false')*/
          create_tuple_s(&TTemp[SP++],"window");
          create_tuple_s(&TTemp[SP++],"bottom");
          create_tuple_s(&TTemp[SP++],"left");
          create_tuple_s(&TTemp[SP++],"white");
          create_tuple_s(&TTemp[SP++],"box");
          create_tuple_s(&TTemp[SP++],"false");
          /***/T_disp_text(active_win,hv_Text, TTemp[SP-6], TTemp[SP-5], TTemp[SP-4], 
              TTemp[SP-3], TTemp[SP-2], TTemp[SP-1]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(active_win);
        }
      }
      destroy_tuple(TTemp[--SP]);
      /*========== end if ==========*/
    }
    else
    {
    destroy_tuple(TTemp[--SP]);
    /*========== elseif (KeysForDisplay[KeyIndex] == 'segmentation_image_ground_truth') ==========*/

    T_tuple_select(hv_KeysForDisplay_COPY_INP_TMP,hv_KeyIndex,&TTemp[SP++]);
    create_tuple_s(&TTemp[SP++],"segmentation_image_ground_truth");
    T_tuple_equal(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-2]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-2]=TTemp[SP];
    SP--;
    if(get_i(TTemp[SP-1],0))
    {
      /**/
      /*Ground truth segmentation image.*/
      /*get_dl_sample_image (Image, SampleKeys, DLSample, 'image')*/
      create_tuple_s(&TTemp[SP++],"image");
      clear_obj(ho_Image);
      /***/get_dl_sample_image(&ho_Image, hv_SampleKeys, hv_DLSample, TTemp[SP-1]);
      destroy_tuple(TTemp[--SP]);

      /*get_segmentation_image_ground_truth (SegmentationImagGroundTruth, SampleKeys, DLSample)*/
      clear_obj(ho_SegmentationImagGroundTruth);
      /***/get_segmentation_image_ground_truth(&ho_SegmentationImagGroundTruth, hv_SampleKeys, 
          hv_DLSample);

      /**/
      /*Get or open next window.*/
      /*get_image_size (Image, WidthImage, HeightImage)*/
      destroy_tuple(hv_WidthImage);
      destroy_tuple(hv_HeightImage);
      /***/T_get_image_size(ho_Image, &hv_WidthImage, &hv_HeightImage);

      /*get_next_window (__get_dict_tuple( Params, ['font']), __get_dict_tuple( Params, ['font_size']), __get_dict_tuple( Params, ['display_bottom_desc']), WidthImage, HeightImage, 0, __get_dict_tuple( Params, ['scale_windows']), __get_dict_tuple( Params, ['threshold_width']), PrevWindowCoordinates, WindowHandleDict, KeysForDisplay[KeyIndex], CurrentWindowHandle, WindowImageRatio, PrevWindowCoordinates)*/
      create_tuple_s(&TTemp[SP++],"font");
      T_get_dict_tuple(hv_Params,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      create_tuple_s(&TTemp[SP++],"font_size");
      T_get_dict_tuple(hv_Params,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      create_tuple_s(&TTemp[SP++],"display_bottom_desc");
      T_get_dict_tuple(hv_Params,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      create_tuple_i(&TTemp[SP++],0);
      create_tuple_s(&TTemp[SP++],"scale_windows");
      T_get_dict_tuple(hv_Params,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      create_tuple_s(&TTemp[SP++],"threshold_width");
      T_get_dict_tuple(hv_Params,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      copy_tuple(hv_PrevWindowCoordinates,&TTemp[SP++]);
      T_tuple_select(hv_KeysForDisplay_COPY_INP_TMP,hv_KeyIndex,&TTemp[SP++]);
      destroy_tuple(hv_CurrentWindowHandle);
      destroy_tuple(hv_WindowImageRatio);
      destroy_tuple(hv_PrevWindowCoordinates);
      /***/get_next_window(TTemp[SP-8], TTemp[SP-7], TTemp[SP-6], hv_WidthImage, 
          hv_HeightImage, TTemp[SP-5], TTemp[SP-4], TTemp[SP-3], TTemp[SP-2], hv_WindowHandleDict, 
          TTemp[SP-1], &hv_CurrentWindowHandle, &hv_WindowImageRatio, &hv_PrevWindowCoordinates);
      destroy_tuple(TTemp[--SP]);
      destroy_tuple(TTemp[--SP]);
      destroy_tuple(TTemp[--SP]);
      destroy_tuple(TTemp[--SP]);
      destroy_tuple(TTemp[--SP]);
      destroy_tuple(TTemp[--SP]);
      destroy_tuple(TTemp[--SP]);
      destroy_tuple(TTemp[--SP]);

      /**/
      /*Visualization.*/
      if (hdev_window_stack_is_open())
      {
        Htuple active_win;
        create_tuple(&active_win,0);
        hdev_window_stack_get_active(&active_win);
        /*dev_display (Image)*/
        /***/T_disp_obj(ho_Image, active_win);
        destroy_tuple(active_win);
      }
      /**/
      /*Display segmentation regions.*/
      /*ColorsSegmentation := Colors + __get_dict_tuple( Params, ['segmentation_transparency'])*/
      create_tuple_s(&TTemp[SP++],"segmentation_transparency");
      T_get_dict_tuple(hv_Params,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      T_tuple_add(hv_Colors,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      destroy_tuple(hv_ColorsSegmentation);
      hv_ColorsSegmentation=TTemp[--SP];

      /*get_draw (CurrentWindowHandle, DrawMode)*/
      destroy_tuple(hv_DrawMode);
      /***/T_get_draw(hv_CurrentWindowHandle, &hv_DrawMode);

      if (hdev_window_stack_is_open())
      {
        Htuple active_win;
        create_tuple(&active_win,0);
        hdev_window_stack_get_active(&active_win);
        /*dev_set_draw (__get_dict_tuple( Params, ['segmentation_draw']))*/
        create_tuple_s(&TTemp[SP++],"segmentation_draw");
        T_get_dict_tuple(hv_Params,TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-1]=TTemp[SP];
        /***/T_set_draw(active_win,TTemp[SP-1]);
        destroy_tuple(TTemp[--SP]);
        destroy_tuple(active_win);
      }
      /*get_line_width (CurrentWindowHandle, Width)*/
      destroy_tuple(hv_Width);
      /***/T_get_line_width(hv_CurrentWindowHandle, &hv_Width);

      if (hdev_window_stack_is_open())
      {
        Htuple active_win;
        create_tuple(&active_win,0);
        hdev_window_stack_get_active(&active_win);
        /*dev_set_line_width (__get_dict_tuple( Params, ['line_width']))*/
        create_tuple_s(&TTemp[SP++],"line_width");
        T_get_dict_tuple(hv_Params,TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-1]=TTemp[SP];
        /***/T_set_line_width(active_win,TTemp[SP-1]);
        destroy_tuple(TTemp[--SP]);
        destroy_tuple(active_win);
      }
      /*dev_display_segmentation_regions (SegmentationImagGroundTruth, ClassIDs, ColorsSegmentation, __get_dict_tuple( Params, ['segmentation_exclude_class_ids']), ImageClassIDs)*/
      create_tuple_s(&TTemp[SP++],"segmentation_exclude_class_ids");
      T_get_dict_tuple(hv_Params,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      destroy_tuple(hv_ImageClassIDs);
      /***/dev_display_segmentation_regions(ho_SegmentationImagGroundTruth, hv_ClassIDs, 
          hv_ColorsSegmentation, TTemp[SP-1], &hv_ImageClassIDs);
      destroy_tuple(TTemp[--SP]);

      if (hdev_window_stack_is_open())
      {
        Htuple active_win;
        create_tuple(&active_win,0);
        hdev_window_stack_get_active(&active_win);
        /*dev_set_draw (DrawMode)*/
        /***/T_set_draw(active_win,hv_DrawMode);
        destroy_tuple(active_win);
      }
      if (hdev_window_stack_is_open())
      {
        Htuple active_win;
        create_tuple(&active_win,0);
        hdev_window_stack_get_active(&active_win);
        /*dev_set_line_width (int(Width))*/
        T_tuple_int(hv_Width,&TTemp[SP++]);
        /***/T_set_line_width(active_win,TTemp[SP-1]);
        destroy_tuple(TTemp[--SP]);
        destroy_tuple(active_win);
      }
      /*Text := 'Ground truth segmentation ' + ImageIDStringBraces*/
      create_tuple_s(&TTemp[SP++],"Ground truth segmentation ");
      T_tuple_add(TTemp[SP-1],hv_ImageIDStringBraces,&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      destroy_tuple(hv_Text);
      hv_Text=TTemp[--SP];

      /*========== if (__get_dict_tuple( Params, ['display_bottom_desc'])) ==========*/
      create_tuple_s(&TTemp[SP++],"display_bottom_desc");
      T_get_dict_tuple(hv_Params,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      if(get_i(TTemp[SP-1],0))
      {
        if (hdev_window_stack_is_open())
        {
          Htuple active_win;
          create_tuple(&active_win,0);
          hdev_window_stack_get_active(&active_win);
          /*dev_disp_text (Text, 'window', 'bottom', 'left', 'white', 'box', 'false')*/
          create_tuple_s(&TTemp[SP++],"window");
          create_tuple_s(&TTemp[SP++],"bottom");
          create_tuple_s(&TTemp[SP++],"left");
          create_tuple_s(&TTemp[SP++],"white");
          create_tuple_s(&TTemp[SP++],"box");
          create_tuple_s(&TTemp[SP++],"false");
          /***/T_disp_text(active_win,hv_Text, TTemp[SP-6], TTemp[SP-5], TTemp[SP-4], 
              TTemp[SP-3], TTemp[SP-2], TTemp[SP-1]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(active_win);
        }
      }
      destroy_tuple(TTemp[--SP]);
      /*========== end if ==========*/
      /**/
      /*Display the legend.*/
      /*========== if (__get_dict_tuple( Params, ['display_legend'])) ==========*/
      create_tuple_s(&TTemp[SP++],"display_legend");
      T_get_dict_tuple(hv_Params,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      if(get_i(TTemp[SP-1],0))
      {
        /*ImageClassIDsUniq := uniq(sort(ImageClassIDs))*/
        T_tuple_sort(hv_ImageClassIDs,&TTemp[SP++]);
        T_tuple_uniq(TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-1]=TTemp[SP];
        destroy_tuple(hv_ImageClassIDsUniq);
        hv_ImageClassIDsUniq=TTemp[--SP];

        /*Get Indices according to image class IDs.*/
        /*tuple_gen_const (|ImageClassIDsUniq|, 0, ImageClassIDsIndices)*/
        T_tuple_length(hv_ImageClassIDsUniq,&TTemp[SP++]);
        create_tuple_i(&TTemp[SP++],0);
        destroy_tuple(hv_ImageClassIDsIndices);
        /***/T_tuple_gen_const(TTemp[SP-2], TTemp[SP-1], &hv_ImageClassIDsIndices);
        destroy_tuple(TTemp[--SP]);
        destroy_tuple(TTemp[--SP]);

        /*========== for ImageClassIDsIndex := 0 to |ImageClassIDsUniq| - 1 by 1 ==========*/
        T_tuple_length(hv_ImageClassIDsUniq,&TTemp[SP++]);
        create_tuple_i(&TTemp[SP++],1);
        T_tuple_sub(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-2]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-2]=TTemp[SP];
        SP--;
        create_tuple_i(&TTemp[SP++],1);
        create_tuple_i(&TTemp[SP++],0);
        T_tuple_greater(TTemp[SP-1],TTemp[SP-3],&TTemp[SP]);
        SP++;
        T_tuple_equal(TTemp[SP-2],TTemp[SP-4],&TTemp[SP]);
        if(get_i(TTemp[SP],0) ||
           (!((( get_i(TTemp[SP-1],0)) && (get_d(TTemp[SP-3],0)>0)) ||
              ((!get_i(TTemp[SP-1],0)) && (get_d(TTemp[SP-3],0)<0)))))
        {
         destroy_tuple(TTemp[SP--]);
         destroy_tuple(TTemp[SP]);
         T_tuple_sub(TTemp[SP-1],TTemp[SP-2],&TTemp[SP]);
         destroy_tuple(hv_ImageClassIDsIndex);
         copy_tuple(TTemp[SP],&hv_ImageClassIDsIndex);
         destroy_tuple(TTemp[SP--]);
         destroy_tuple(TTemp[SP]);
         for(;;)
         {
         T_tuple_add(hv_ImageClassIDsIndex,TTemp[SP-1],&TTemp[SP]);
         destroy_tuple(hv_ImageClassIDsIndex);
         copy_tuple(TTemp[SP],&hv_ImageClassIDsIndex);
         destroy_tuple(TTemp[SP]);
         if(get_d(TTemp[SP-1],0)<0)
          T_tuple_less(hv_ImageClassIDsIndex,TTemp[SP-2],&TTemp[SP]);
         else
          T_tuple_greater(hv_ImageClassIDsIndex,TTemp[SP-2],&TTemp[SP]);
         if(get_i(TTemp[SP],0)) break;
         destroy_tuple(TTemp[SP]);
         /*========== for ==========*/

          /*ImageClassIDsIndices[ImageClassIDsIndex] := find_first(ClassIDs,ImageClassIDsUniq[ImageClassIDsIndex])*/
          T_tuple_select(hv_ImageClassIDsUniq,hv_ImageClassIDsIndex,&TTemp[SP++]);
          T_tuple_find_first(hv_ClassIDs,TTemp[SP-1],&TTemp[SP]);
          destroy_tuple(TTemp[SP-1]);
          TTemp[SP-1]=TTemp[SP];
          replace_elements(&hv_ImageClassIDsIndices,&hv_ImageClassIDsIndex,&TTemp[SP-1]);
          destroy_tuple(TTemp[--SP]);
         }
         destroy_tuple(TTemp[SP--]);
         destroy_tuple(TTemp[SP--]);
         destroy_tuple(TTemp[SP]);
        }
        else
        {
         destroy_tuple(TTemp[SP--]);
         destroy_tuple(TTemp[SP--]);
         destroy_tuple(TTemp[SP--]);
         destroy_tuple(TTemp[SP--]);
         destroy_tuple(TTemp[SP]);
        }/*========== end for ========*/

        /*Text := [Text,ClassesLegend[ImageClassIDsIndices]]*/
        copy_tuple(hv_Text,&TTemp[SP++]);
        T_tuple_select(hv_ClassesLegend,hv_ImageClassIDsIndices,&TTemp[SP++]);
        T_tuple_concat(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-2]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-2]=TTemp[SP];
        SP--;
        destroy_tuple(hv_Text);
        hv_Text=TTemp[--SP];

        /**/
        /*Get or open next child window*/
        /*get_child_window (HeightImage, __get_dict_tuple( Params, ['font']), __get_dict_tuple( Params, ['font_size']), Text, PrevWindowCoordinates, WindowHandleDict, KeysForDisplay[KeyIndex], WindowImageRatio, PrevWindowCoordinates)*/
        create_tuple_s(&TTemp[SP++],"font");
        T_get_dict_tuple(hv_Params,TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-1]=TTemp[SP];
        create_tuple_s(&TTemp[SP++],"font_size");
        T_get_dict_tuple(hv_Params,TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-1]=TTemp[SP];
        copy_tuple(hv_PrevWindowCoordinates,&TTemp[SP++]);
        T_tuple_select(hv_KeysForDisplay_COPY_INP_TMP,hv_KeyIndex,&TTemp[SP++]);
        destroy_tuple(hv_WindowImageRatio);
        destroy_tuple(hv_PrevWindowCoordinates);
        /***/get_child_window(hv_HeightImage, TTemp[SP-4], TTemp[SP-3], hv_Text, 
            TTemp[SP-2], hv_WindowHandleDict, TTemp[SP-1], &hv_WindowImageRatio, 
            &hv_PrevWindowCoordinates);
        destroy_tuple(TTemp[--SP]);
        destroy_tuple(TTemp[--SP]);
        destroy_tuple(TTemp[--SP]);
        destroy_tuple(TTemp[--SP]);

        if (hdev_window_stack_is_open())
        {
          Htuple active_win;
          create_tuple(&active_win,0);
          hdev_window_stack_get_active(&active_win);
          /*dev_disp_text (Text, 'window', 'top', 'left', ['white',Colors[ImageClassIDsIndices]], 'box', 'false')*/
          create_tuple_s(&TTemp[SP++],"window");
          create_tuple_s(&TTemp[SP++],"top");
          create_tuple_s(&TTemp[SP++],"left");
          create_tuple_s(&TTemp[SP++],"white");
          T_tuple_select(hv_Colors,hv_ImageClassIDsIndices,&TTemp[SP++]);
          T_tuple_concat(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
          destroy_tuple(TTemp[SP-2]);
          destroy_tuple(TTemp[SP-1]);
          TTemp[SP-2]=TTemp[SP];
          SP--;
          create_tuple_s(&TTemp[SP++],"box");
          create_tuple_s(&TTemp[SP++],"false");
          /***/T_disp_text(active_win,hv_Text, TTemp[SP-6], TTemp[SP-5], TTemp[SP-4], 
              TTemp[SP-3], TTemp[SP-2], TTemp[SP-1]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(active_win);
        }
      }
      destroy_tuple(TTemp[--SP]);
      /*========== end if ==========*/
    }
    else
    {
    destroy_tuple(TTemp[--SP]);
    /*========== elseif (KeysForDisplay[KeyIndex] == 'segmentation_image_result') ==========*/

    T_tuple_select(hv_KeysForDisplay_COPY_INP_TMP,hv_KeyIndex,&TTemp[SP++]);
    create_tuple_s(&TTemp[SP++],"segmentation_image_result");
    T_tuple_equal(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-2]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-2]=TTemp[SP];
    SP--;
    if(get_i(TTemp[SP-1],0))
    {
      /**/
      /*Result segmentation on image.*/
      /*get_dl_sample_image (Image, SampleKeys, DLSample, 'image')*/
      create_tuple_s(&TTemp[SP++],"image");
      clear_obj(ho_Image);
      /***/get_dl_sample_image(&ho_Image, hv_SampleKeys, hv_DLSample, TTemp[SP-1]);
      destroy_tuple(TTemp[--SP]);

      /*get_segmentation_image_result (SegmentationImageResult, ResultKeys, DLResult)*/
      clear_obj(ho_SegmentationImageResult);
      /***/get_segmentation_image_result(&ho_SegmentationImageResult, hv_ResultKeys, 
          hv_DLResult_COPY_INP_TMP);

      /**/
      /*Get or open next window.*/
      /*get_image_size (Image, WidthImage, HeightImage)*/
      destroy_tuple(hv_WidthImage);
      destroy_tuple(hv_HeightImage);
      /***/T_get_image_size(ho_Image, &hv_WidthImage, &hv_HeightImage);

      /*get_next_window (__get_dict_tuple( Params, ['font']), __get_dict_tuple( Params, ['font_size']), __get_dict_tuple( Params, ['display_bottom_desc']), WidthImage, HeightImage, 0, __get_dict_tuple( Params, ['scale_windows']), __get_dict_tuple( Params, ['threshold_width']), PrevWindowCoordinates, WindowHandleDict, KeysForDisplay[KeyIndex], CurrentWindowHandle, WindowImageRatio, PrevWindowCoordinates)*/
      create_tuple_s(&TTemp[SP++],"font");
      T_get_dict_tuple(hv_Params,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      create_tuple_s(&TTemp[SP++],"font_size");
      T_get_dict_tuple(hv_Params,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      create_tuple_s(&TTemp[SP++],"display_bottom_desc");
      T_get_dict_tuple(hv_Params,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      create_tuple_i(&TTemp[SP++],0);
      create_tuple_s(&TTemp[SP++],"scale_windows");
      T_get_dict_tuple(hv_Params,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      create_tuple_s(&TTemp[SP++],"threshold_width");
      T_get_dict_tuple(hv_Params,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      copy_tuple(hv_PrevWindowCoordinates,&TTemp[SP++]);
      T_tuple_select(hv_KeysForDisplay_COPY_INP_TMP,hv_KeyIndex,&TTemp[SP++]);
      destroy_tuple(hv_CurrentWindowHandle);
      destroy_tuple(hv_WindowImageRatio);
      destroy_tuple(hv_PrevWindowCoordinates);
      /***/get_next_window(TTemp[SP-8], TTemp[SP-7], TTemp[SP-6], hv_WidthImage, 
          hv_HeightImage, TTemp[SP-5], TTemp[SP-4], TTemp[SP-3], TTemp[SP-2], hv_WindowHandleDict, 
          TTemp[SP-1], &hv_CurrentWindowHandle, &hv_WindowImageRatio, &hv_PrevWindowCoordinates);
      destroy_tuple(TTemp[--SP]);
      destroy_tuple(TTemp[--SP]);
      destroy_tuple(TTemp[--SP]);
      destroy_tuple(TTemp[--SP]);
      destroy_tuple(TTemp[--SP]);
      destroy_tuple(TTemp[--SP]);
      destroy_tuple(TTemp[--SP]);
      destroy_tuple(TTemp[--SP]);

      /**/
      /*Visualization.*/
      if (hdev_window_stack_is_open())
      {
        Htuple active_win;
        create_tuple(&active_win,0);
        hdev_window_stack_get_active(&active_win);
        /*dev_display (Image)*/
        /***/T_disp_obj(ho_Image, active_win);
        destroy_tuple(active_win);
      }
      /**/
      /*Display result segmentation regions.*/
      /*ColorsResults := Colors + __get_dict_tuple( Params, ['segmentation_transparency'])*/
      create_tuple_s(&TTemp[SP++],"segmentation_transparency");
      T_get_dict_tuple(hv_Params,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      T_tuple_add(hv_Colors,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      destroy_tuple(hv_ColorsResults);
      hv_ColorsResults=TTemp[--SP];

      /*get_draw (CurrentWindowHandle, DrawMode)*/
      destroy_tuple(hv_DrawMode);
      /***/T_get_draw(hv_CurrentWindowHandle, &hv_DrawMode);

      if (hdev_window_stack_is_open())
      {
        Htuple active_win;
        create_tuple(&active_win,0);
        hdev_window_stack_get_active(&active_win);
        /*dev_set_draw (__get_dict_tuple( Params, ['segmentation_draw']))*/
        create_tuple_s(&TTemp[SP++],"segmentation_draw");
        T_get_dict_tuple(hv_Params,TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-1]=TTemp[SP];
        /***/T_set_draw(active_win,TTemp[SP-1]);
        destroy_tuple(TTemp[--SP]);
        destroy_tuple(active_win);
      }
      /*get_line_width (CurrentWindowHandle, Width)*/
      destroy_tuple(hv_Width);
      /***/T_get_line_width(hv_CurrentWindowHandle, &hv_Width);

      if (hdev_window_stack_is_open())
      {
        Htuple active_win;
        create_tuple(&active_win,0);
        hdev_window_stack_get_active(&active_win);
        /*dev_set_line_width (__get_dict_tuple( Params, ['line_width']))*/
        create_tuple_s(&TTemp[SP++],"line_width");
        T_get_dict_tuple(hv_Params,TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-1]=TTemp[SP];
        /***/T_set_line_width(active_win,TTemp[SP-1]);
        destroy_tuple(TTemp[--SP]);
        destroy_tuple(active_win);
      }
      /*dev_display_segmentation_regions (SegmentationImageResult, ClassIDs, ColorsResults, __get_dict_tuple( Params, ['segmentation_exclude_class_ids']), ImageClassIDs)*/
      create_tuple_s(&TTemp[SP++],"segmentation_exclude_class_ids");
      T_get_dict_tuple(hv_Params,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      destroy_tuple(hv_ImageClassIDs);
      /***/dev_display_segmentation_regions(ho_SegmentationImageResult, hv_ClassIDs, 
          hv_ColorsResults, TTemp[SP-1], &hv_ImageClassIDs);
      destroy_tuple(TTemp[--SP]);

      if (hdev_window_stack_is_open())
      {
        Htuple active_win;
        create_tuple(&active_win,0);
        hdev_window_stack_get_active(&active_win);
        /*dev_set_draw (DrawMode)*/
        /***/T_set_draw(active_win,hv_DrawMode);
        destroy_tuple(active_win);
      }
      if (hdev_window_stack_is_open())
      {
        Htuple active_win;
        create_tuple(&active_win,0);
        hdev_window_stack_get_active(&active_win);
        /*dev_set_line_width (int(Width))*/
        T_tuple_int(hv_Width,&TTemp[SP++]);
        /***/T_set_line_width(active_win,TTemp[SP-1]);
        destroy_tuple(TTemp[--SP]);
        destroy_tuple(active_win);
      }
      /*Text := 'Result segmentation ' + ImageIDStringBraces*/
      create_tuple_s(&TTemp[SP++],"Result segmentation ");
      T_tuple_add(TTemp[SP-1],hv_ImageIDStringBraces,&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      destroy_tuple(hv_Text);
      hv_Text=TTemp[--SP];

      /*========== if (__get_dict_tuple( Params, ['display_bottom_desc'])) ==========*/
      create_tuple_s(&TTemp[SP++],"display_bottom_desc");
      T_get_dict_tuple(hv_Params,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      if(get_i(TTemp[SP-1],0))
      {
        if (hdev_window_stack_is_open())
        {
          Htuple active_win;
          create_tuple(&active_win,0);
          hdev_window_stack_get_active(&active_win);
          /*dev_disp_text (Text, 'window', 'bottom', 'left', 'white', 'box', 'false')*/
          create_tuple_s(&TTemp[SP++],"window");
          create_tuple_s(&TTemp[SP++],"bottom");
          create_tuple_s(&TTemp[SP++],"left");
          create_tuple_s(&TTemp[SP++],"white");
          create_tuple_s(&TTemp[SP++],"box");
          create_tuple_s(&TTemp[SP++],"false");
          /***/T_disp_text(active_win,hv_Text, TTemp[SP-6], TTemp[SP-5], TTemp[SP-4], 
              TTemp[SP-3], TTemp[SP-2], TTemp[SP-1]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(active_win);
        }
      }
      destroy_tuple(TTemp[--SP]);
      /*========== end if ==========*/
      /**/
      /*Display the legend.*/
      /*========== if (__get_dict_tuple( Params, ['display_legend'])) ==========*/
      create_tuple_s(&TTemp[SP++],"display_legend");
      T_get_dict_tuple(hv_Params,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      if(get_i(TTemp[SP-1],0))
      {
        /*ImageClassIDsUniq := uniq(sort(ImageClassIDs))*/
        T_tuple_sort(hv_ImageClassIDs,&TTemp[SP++]);
        T_tuple_uniq(TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-1]=TTemp[SP];
        destroy_tuple(hv_ImageClassIDsUniq);
        hv_ImageClassIDsUniq=TTemp[--SP];

        /*Get Indices according to image class IDs.*/
        /*tuple_gen_const (|ImageClassIDsUniq|, 0, ImageClassIDsIndices)*/
        T_tuple_length(hv_ImageClassIDsUniq,&TTemp[SP++]);
        create_tuple_i(&TTemp[SP++],0);
        destroy_tuple(hv_ImageClassIDsIndices);
        /***/T_tuple_gen_const(TTemp[SP-2], TTemp[SP-1], &hv_ImageClassIDsIndices);
        destroy_tuple(TTemp[--SP]);
        destroy_tuple(TTemp[--SP]);

        /*========== for ImageClassIDsIndex := 0 to |ImageClassIDsUniq| - 1 by 1 ==========*/
        T_tuple_length(hv_ImageClassIDsUniq,&TTemp[SP++]);
        create_tuple_i(&TTemp[SP++],1);
        T_tuple_sub(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-2]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-2]=TTemp[SP];
        SP--;
        create_tuple_i(&TTemp[SP++],1);
        create_tuple_i(&TTemp[SP++],0);
        T_tuple_greater(TTemp[SP-1],TTemp[SP-3],&TTemp[SP]);
        SP++;
        T_tuple_equal(TTemp[SP-2],TTemp[SP-4],&TTemp[SP]);
        if(get_i(TTemp[SP],0) ||
           (!((( get_i(TTemp[SP-1],0)) && (get_d(TTemp[SP-3],0)>0)) ||
              ((!get_i(TTemp[SP-1],0)) && (get_d(TTemp[SP-3],0)<0)))))
        {
         destroy_tuple(TTemp[SP--]);
         destroy_tuple(TTemp[SP]);
         T_tuple_sub(TTemp[SP-1],TTemp[SP-2],&TTemp[SP]);
         destroy_tuple(hv_ImageClassIDsIndex);
         copy_tuple(TTemp[SP],&hv_ImageClassIDsIndex);
         destroy_tuple(TTemp[SP--]);
         destroy_tuple(TTemp[SP]);
         for(;;)
         {
         T_tuple_add(hv_ImageClassIDsIndex,TTemp[SP-1],&TTemp[SP]);
         destroy_tuple(hv_ImageClassIDsIndex);
         copy_tuple(TTemp[SP],&hv_ImageClassIDsIndex);
         destroy_tuple(TTemp[SP]);
         if(get_d(TTemp[SP-1],0)<0)
          T_tuple_less(hv_ImageClassIDsIndex,TTemp[SP-2],&TTemp[SP]);
         else
          T_tuple_greater(hv_ImageClassIDsIndex,TTemp[SP-2],&TTemp[SP]);
         if(get_i(TTemp[SP],0)) break;
         destroy_tuple(TTemp[SP]);
         /*========== for ==========*/

          /*ImageClassIDsIndices[ImageClassIDsIndex] := find_first(ClassIDs,ImageClassIDsUniq[ImageClassIDsIndex])*/
          T_tuple_select(hv_ImageClassIDsUniq,hv_ImageClassIDsIndex,&TTemp[SP++]);
          T_tuple_find_first(hv_ClassIDs,TTemp[SP-1],&TTemp[SP]);
          destroy_tuple(TTemp[SP-1]);
          TTemp[SP-1]=TTemp[SP];
          replace_elements(&hv_ImageClassIDsIndices,&hv_ImageClassIDsIndex,&TTemp[SP-1]);
          destroy_tuple(TTemp[--SP]);
         }
         destroy_tuple(TTemp[SP--]);
         destroy_tuple(TTemp[SP--]);
         destroy_tuple(TTemp[SP]);
        }
        else
        {
         destroy_tuple(TTemp[SP--]);
         destroy_tuple(TTemp[SP--]);
         destroy_tuple(TTemp[SP--]);
         destroy_tuple(TTemp[SP--]);
         destroy_tuple(TTemp[SP]);
        }/*========== end for ========*/

        /*Text := [Text,ClassesLegend[ImageClassIDsIndices]]*/
        copy_tuple(hv_Text,&TTemp[SP++]);
        T_tuple_select(hv_ClassesLegend,hv_ImageClassIDsIndices,&TTemp[SP++]);
        T_tuple_concat(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-2]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-2]=TTemp[SP];
        SP--;
        destroy_tuple(hv_Text);
        hv_Text=TTemp[--SP];

        /**/
        /*Get or open next child window.*/
        /*get_child_window (HeightImage, __get_dict_tuple( Params, ['font']), __get_dict_tuple( Params, ['font_size']), Text, PrevWindowCoordinates, WindowHandleDict, KeysForDisplay[KeyIndex], WindowImageRatio, PrevWindowCoordinates)*/
        create_tuple_s(&TTemp[SP++],"font");
        T_get_dict_tuple(hv_Params,TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-1]=TTemp[SP];
        create_tuple_s(&TTemp[SP++],"font_size");
        T_get_dict_tuple(hv_Params,TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-1]=TTemp[SP];
        copy_tuple(hv_PrevWindowCoordinates,&TTemp[SP++]);
        T_tuple_select(hv_KeysForDisplay_COPY_INP_TMP,hv_KeyIndex,&TTemp[SP++]);
        destroy_tuple(hv_WindowImageRatio);
        destroy_tuple(hv_PrevWindowCoordinates);
        /***/get_child_window(hv_HeightImage, TTemp[SP-4], TTemp[SP-3], hv_Text, 
            TTemp[SP-2], hv_WindowHandleDict, TTemp[SP-1], &hv_WindowImageRatio, 
            &hv_PrevWindowCoordinates);
        destroy_tuple(TTemp[--SP]);
        destroy_tuple(TTemp[--SP]);
        destroy_tuple(TTemp[--SP]);
        destroy_tuple(TTemp[--SP]);

        if (hdev_window_stack_is_open())
        {
          Htuple active_win;
          create_tuple(&active_win,0);
          hdev_window_stack_get_active(&active_win);
          /*dev_disp_text (Text, 'window', 'top', 'left', ['white',Colors[ImageClassIDsIndices]], 'box', 'false')*/
          create_tuple_s(&TTemp[SP++],"window");
          create_tuple_s(&TTemp[SP++],"top");
          create_tuple_s(&TTemp[SP++],"left");
          create_tuple_s(&TTemp[SP++],"white");
          T_tuple_select(hv_Colors,hv_ImageClassIDsIndices,&TTemp[SP++]);
          T_tuple_concat(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
          destroy_tuple(TTemp[SP-2]);
          destroy_tuple(TTemp[SP-1]);
          TTemp[SP-2]=TTemp[SP];
          SP--;
          create_tuple_s(&TTemp[SP++],"box");
          create_tuple_s(&TTemp[SP++],"false");
          /***/T_disp_text(active_win,hv_Text, TTemp[SP-6], TTemp[SP-5], TTemp[SP-4], 
              TTemp[SP-3], TTemp[SP-2], TTemp[SP-1]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(active_win);
        }
      }
      destroy_tuple(TTemp[--SP]);
      /*========== end if ==========*/
    }
    else
    {
    destroy_tuple(TTemp[--SP]);
    /*========== elseif (KeysForDisplay[KeyIndex] == 'segmentation_weight') ==========*/

    T_tuple_select(hv_KeysForDisplay_COPY_INP_TMP,hv_KeyIndex,&TTemp[SP++]);
    create_tuple_s(&TTemp[SP++],"segmentation_weight");
    T_tuple_equal(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-2]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-2]=TTemp[SP];
    SP--;
    if(get_i(TTemp[SP-1],0))
    {
      /**/
      /*Weight image.*/
      /*get_weight_image (ImageWeight, SampleKeys, DLSample)*/
      clear_obj(ho_ImageWeight);
      /***/get_weight_image(&ho_ImageWeight, hv_SampleKeys, hv_DLSample);

      /**/
      /*Get or open next window.*/
      /*get_image_size (ImageWeight, WidthImage, HeightImage)*/
      destroy_tuple(hv_WidthImage);
      destroy_tuple(hv_HeightImage);
      /***/T_get_image_size(ho_ImageWeight, &hv_WidthImage, &hv_HeightImage);

      /*get_next_window (__get_dict_tuple( Params, ['font']), __get_dict_tuple( Params, ['font_size']), __get_dict_tuple( Params, ['display_bottom_desc']), WidthImage, HeightImage, 0, __get_dict_tuple( Params, ['scale_windows']), __get_dict_tuple( Params, ['threshold_width']), PrevWindowCoordinates, WindowHandleDict, KeysForDisplay[KeyIndex], CurrentWindowHandle, WindowImageRatio, PrevWindowCoordinates)*/
      create_tuple_s(&TTemp[SP++],"font");
      T_get_dict_tuple(hv_Params,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      create_tuple_s(&TTemp[SP++],"font_size");
      T_get_dict_tuple(hv_Params,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      create_tuple_s(&TTemp[SP++],"display_bottom_desc");
      T_get_dict_tuple(hv_Params,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      create_tuple_i(&TTemp[SP++],0);
      create_tuple_s(&TTemp[SP++],"scale_windows");
      T_get_dict_tuple(hv_Params,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      create_tuple_s(&TTemp[SP++],"threshold_width");
      T_get_dict_tuple(hv_Params,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      copy_tuple(hv_PrevWindowCoordinates,&TTemp[SP++]);
      T_tuple_select(hv_KeysForDisplay_COPY_INP_TMP,hv_KeyIndex,&TTemp[SP++]);
      destroy_tuple(hv_CurrentWindowHandle);
      destroy_tuple(hv_WindowImageRatio);
      destroy_tuple(hv_PrevWindowCoordinates);
      /***/get_next_window(TTemp[SP-8], TTemp[SP-7], TTemp[SP-6], hv_WidthImage, 
          hv_HeightImage, TTemp[SP-5], TTemp[SP-4], TTemp[SP-3], TTemp[SP-2], hv_WindowHandleDict, 
          TTemp[SP-1], &hv_CurrentWindowHandle, &hv_WindowImageRatio, &hv_PrevWindowCoordinates);
      destroy_tuple(TTemp[--SP]);
      destroy_tuple(TTemp[--SP]);
      destroy_tuple(TTemp[--SP]);
      destroy_tuple(TTemp[--SP]);
      destroy_tuple(TTemp[--SP]);
      destroy_tuple(TTemp[--SP]);
      destroy_tuple(TTemp[--SP]);
      destroy_tuple(TTemp[--SP]);

      /**/
      if (hdev_window_stack_is_open())
      {
        Htuple active_win;
        create_tuple(&active_win,0);
        hdev_window_stack_get_active(&active_win);
        /*dev_display (ImageWeight)*/
        /***/T_disp_obj(ho_ImageWeight, active_win);
        destroy_tuple(active_win);
      }
      /*========== if (__get_dict_tuple( Params, ['display_bottom_desc'])) ==========*/
      create_tuple_s(&TTemp[SP++],"display_bottom_desc");
      T_get_dict_tuple(hv_Params,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      if(get_i(TTemp[SP-1],0))
      {
        if (hdev_window_stack_is_open())
        {
          Htuple active_win;
          create_tuple(&active_win,0);
          hdev_window_stack_get_active(&active_win);
          /*dev_disp_text ('Weight image ' + ImageIDStringBraces, 'window', 'bottom', 'left', 'white', 'box', 'false')*/
          create_tuple_s(&TTemp[SP++],"Weight image ");
          T_tuple_add(TTemp[SP-1],hv_ImageIDStringBraces,&TTemp[SP]);
          destroy_tuple(TTemp[SP-1]);
          TTemp[SP-1]=TTemp[SP];
          create_tuple_s(&TTemp[SP++],"window");
          create_tuple_s(&TTemp[SP++],"bottom");
          create_tuple_s(&TTemp[SP++],"left");
          create_tuple_s(&TTemp[SP++],"white");
          create_tuple_s(&TTemp[SP++],"box");
          create_tuple_s(&TTemp[SP++],"false");
          /***/T_disp_text(active_win,TTemp[SP-7], TTemp[SP-6], TTemp[SP-5], TTemp[SP-4], 
              TTemp[SP-3], TTemp[SP-2], TTemp[SP-1]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(active_win);
        }
      }
      destroy_tuple(TTemp[--SP]);
      /*========== end if ==========*/
    }
    else
    {
    destroy_tuple(TTemp[--SP]);
    /*========== elseif (KeysForDisplay[KeyIndex] == 'segmentation_weight_map') ==========*/

    T_tuple_select(hv_KeysForDisplay_COPY_INP_TMP,hv_KeyIndex,&TTemp[SP++]);
    create_tuple_s(&TTemp[SP++],"segmentation_weight_map");
    T_tuple_equal(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-2]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-2]=TTemp[SP];
    SP--;
    if(get_i(TTemp[SP-1],0))
    {
      /**/
      /*Weight map on image.*/
      /*get_dl_sample_image (Image, SampleKeys, DLSample, 'image')*/
      create_tuple_s(&TTemp[SP++],"image");
      clear_obj(ho_Image);
      /***/get_dl_sample_image(&ho_Image, hv_SampleKeys, hv_DLSample, TTemp[SP-1]);
      destroy_tuple(TTemp[--SP]);

      /*get_weight_image (ImageWeight, SampleKeys, DLSample)*/
      clear_obj(ho_ImageWeight);
      /***/get_weight_image(&ho_ImageWeight, hv_SampleKeys, hv_DLSample);

      /**/
      /*create_dict (__Tmp_Ctrl_Dict_Init_8)*/
      destroy_tuple(hv___Tmp_Ctrl_Dict_Init_8);
      /***/T_create_dict(&hv___Tmp_Ctrl_Dict_Init_8);

      /*set_dict_tuple (__Tmp_Ctrl_Dict_Init_8, ['comp'], 0)*/
      create_tuple_s(&TTemp[SP++],"comp");
      create_tuple_i(&TTemp[SP++],0);
      /***/T_set_dict_tuple(hv___Tmp_Ctrl_Dict_Init_8, TTemp[SP-2], TTemp[SP-1]);
      destroy_tuple(TTemp[--SP]);
      destroy_tuple(TTemp[--SP]);

      /*========== if (__test_equal_dict_item([Params, __Tmp_Ctrl_Dict_Init_8], ['segmentation_max_weight'], 'comp')) ==========*/
      T_tuple_concat(hv_Params,hv___Tmp_Ctrl_Dict_Init_8,&TTemp[SP++]);
      create_tuple_s(&TTemp[SP++],"segmentation_max_weight");
      create_tuple_s(&TTemp[SP++],"comp");
      T_test_equal_dict_item(TTemp[SP-3],TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-3]);
      destroy_tuple(TTemp[SP-2]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-3]=TTemp[SP];
      SP=SP-2;
      if(get_i(TTemp[SP-1],0))
      {
        /*Calculate SegMaxWeight if not given in GenParam.*/
        /*min_max_gray (ImageWeight, ImageWeight, 0, MinWeight, __Tmp_Ctrl_1, Range)*/
        create_tuple_i(&TTemp[SP++],0);
        destroy_tuple(hv_MinWeight);
        destroy_tuple(hv___Tmp_Ctrl_1);
        destroy_tuple(hv_Range);
        /***/T_min_max_gray(ho_ImageWeight, ho_ImageWeight, TTemp[SP-1], &hv_MinWeight, 
            &hv___Tmp_Ctrl_1, &hv_Range);
        destroy_tuple(TTemp[--SP]);

        /*set_dict_tuple (Params, ['segmentation_max_weight'], __Tmp_Ctrl_1)*/
        create_tuple_s(&TTemp[SP++],"segmentation_max_weight");
        /***/T_set_dict_tuple(hv_Params, TTemp[SP-1], hv___Tmp_Ctrl_1);
        destroy_tuple(TTemp[--SP]);

      }
      destroy_tuple(TTemp[--SP]);
      /*========== end if ==========*/
      /*__Tmp_Ctrl_Dict_Init_8 := constant('HNULL')*/
      create_tuple_s(&TTemp[SP++],"HNULL");
      T_tuple_constant(TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      destroy_tuple(hv___Tmp_Ctrl_Dict_Init_8);
      hv___Tmp_Ctrl_Dict_Init_8=TTemp[--SP];

      /**/
      /*Get or open next window.*/
      /*get_image_size (Image, WidthImage, HeightImage)*/
      destroy_tuple(hv_WidthImage);
      destroy_tuple(hv_HeightImage);
      /***/T_get_image_size(ho_Image, &hv_WidthImage, &hv_HeightImage);

      /*get_next_window (__get_dict_tuple( Params, ['font']), __get_dict_tuple( Params, ['font_size']), __get_dict_tuple( Params, ['display_bottom_desc']), WidthImage, HeightImage, __get_dict_tuple( Params, ['map_color_bar_width']), __get_dict_tuple( Params, ['scale_windows']), __get_dict_tuple( Params, ['threshold_width']), PrevWindowCoordinates, WindowHandleDict, KeysForDisplay[KeyIndex], CurrentWindowHandle, WindowImageRatio, PrevWindowCoordinates)*/
      create_tuple_s(&TTemp[SP++],"font");
      T_get_dict_tuple(hv_Params,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      create_tuple_s(&TTemp[SP++],"font_size");
      T_get_dict_tuple(hv_Params,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      create_tuple_s(&TTemp[SP++],"display_bottom_desc");
      T_get_dict_tuple(hv_Params,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      create_tuple_s(&TTemp[SP++],"map_color_bar_width");
      T_get_dict_tuple(hv_Params,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      create_tuple_s(&TTemp[SP++],"scale_windows");
      T_get_dict_tuple(hv_Params,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      create_tuple_s(&TTemp[SP++],"threshold_width");
      T_get_dict_tuple(hv_Params,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      copy_tuple(hv_PrevWindowCoordinates,&TTemp[SP++]);
      T_tuple_select(hv_KeysForDisplay_COPY_INP_TMP,hv_KeyIndex,&TTemp[SP++]);
      destroy_tuple(hv_CurrentWindowHandle);
      destroy_tuple(hv_WindowImageRatio);
      destroy_tuple(hv_PrevWindowCoordinates);
      /***/get_next_window(TTemp[SP-8], TTemp[SP-7], TTemp[SP-6], hv_WidthImage, 
          hv_HeightImage, TTemp[SP-5], TTemp[SP-4], TTemp[SP-3], TTemp[SP-2], hv_WindowHandleDict, 
          TTemp[SP-1], &hv_CurrentWindowHandle, &hv_WindowImageRatio, &hv_PrevWindowCoordinates);
      destroy_tuple(TTemp[--SP]);
      destroy_tuple(TTemp[--SP]);
      destroy_tuple(TTemp[--SP]);
      destroy_tuple(TTemp[--SP]);
      destroy_tuple(TTemp[--SP]);
      destroy_tuple(TTemp[--SP]);
      destroy_tuple(TTemp[--SP]);
      destroy_tuple(TTemp[--SP]);

      /**/
      /*Visualization.*/
      if (hdev_window_stack_is_open())
      {
        Htuple active_win;
        create_tuple(&active_win,0);
        hdev_window_stack_get_active(&active_win);
        /*dev_display (Image)*/
        /***/T_disp_obj(ho_Image, active_win);
        destroy_tuple(active_win);
      }
      /*dev_display_weight_regions (ImageWeight, __get_dict_tuple( Params, ['map_transparency']), __get_dict_tuple( Params, ['segmentation_max_weight']), WeightsColors)*/
      create_tuple_s(&TTemp[SP++],"map_transparency");
      T_get_dict_tuple(hv_Params,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      create_tuple_s(&TTemp[SP++],"segmentation_max_weight");
      T_get_dict_tuple(hv_Params,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      destroy_tuple(hv_WeightsColors);
      /***/dev_display_weight_regions(ho_ImageWeight, TTemp[SP-2], TTemp[SP-1], &hv_WeightsColors);
      destroy_tuple(TTemp[--SP]);
      destroy_tuple(TTemp[--SP]);

      /*dev_display_map_color_bar (WidthImage, HeightImage, __get_dict_tuple( Params, ['map_color_bar_width']), WeightsColors, __get_dict_tuple( Params, ['segmentation_max_weight']), WindowImageRatio, CurrentWindowHandle)*/
      create_tuple_s(&TTemp[SP++],"map_color_bar_width");
      T_get_dict_tuple(hv_Params,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      create_tuple_s(&TTemp[SP++],"segmentation_max_weight");
      T_get_dict_tuple(hv_Params,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      /***/dev_display_map_color_bar(hv_WidthImage, hv_HeightImage, TTemp[SP-2], 
          hv_WeightsColors, TTemp[SP-1], hv_WindowImageRatio, hv_CurrentWindowHandle);
      destroy_tuple(TTemp[--SP]);
      destroy_tuple(TTemp[--SP]);

      /*========== if (__get_dict_tuple( Params, ['display_bottom_desc'])) ==========*/
      create_tuple_s(&TTemp[SP++],"display_bottom_desc");
      T_get_dict_tuple(hv_Params,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      if(get_i(TTemp[SP-1],0))
      {
        if (hdev_window_stack_is_open())
        {
          Htuple active_win;
          create_tuple(&active_win,0);
          hdev_window_stack_get_active(&active_win);
          /*dev_disp_text ('Weight map ' + ImageIDStringBraces, 'window', 'bottom', 'left', 'white', 'box', 'false')*/
          create_tuple_s(&TTemp[SP++],"Weight map ");
          T_tuple_add(TTemp[SP-1],hv_ImageIDStringBraces,&TTemp[SP]);
          destroy_tuple(TTemp[SP-1]);
          TTemp[SP-1]=TTemp[SP];
          create_tuple_s(&TTemp[SP++],"window");
          create_tuple_s(&TTemp[SP++],"bottom");
          create_tuple_s(&TTemp[SP++],"left");
          create_tuple_s(&TTemp[SP++],"white");
          create_tuple_s(&TTemp[SP++],"box");
          create_tuple_s(&TTemp[SP++],"false");
          /***/T_disp_text(active_win,TTemp[SP-7], TTemp[SP-6], TTemp[SP-5], TTemp[SP-4], 
              TTemp[SP-3], TTemp[SP-2], TTemp[SP-1]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(active_win);
        }
      }
      destroy_tuple(TTemp[--SP]);
      /*========== end if ==========*/
    }
    else
    {
      /*Reset flush buffer of existing windows before throwing an exception.*/
      /*get_dict_param (WindowHandleDict, 'keys', [], WindowHandleKeys)*/
      create_tuple_s(&TTemp[SP++],"keys");
      create_tuple(&TTemp[SP++],0);
      destroy_tuple(hv_WindowHandleKeys);
      /***/T_get_dict_param(hv_WindowHandleDict, TTemp[SP-2], TTemp[SP-1], &hv_WindowHandleKeys);
      destroy_tuple(TTemp[--SP]);
      destroy_tuple(TTemp[--SP]);

      /*========== for Index := 0 to |WindowHandleKeys| - 1 by 1 ==========*/
      T_tuple_length(hv_WindowHandleKeys,&TTemp[SP++]);
      create_tuple_i(&TTemp[SP++],1);
      T_tuple_sub(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-2]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-2]=TTemp[SP];
      SP--;
      create_tuple_i(&TTemp[SP++],1);
      create_tuple_i(&TTemp[SP++],0);
      T_tuple_greater(TTemp[SP-1],TTemp[SP-3],&TTemp[SP]);
      SP++;
      T_tuple_equal(TTemp[SP-2],TTemp[SP-4],&TTemp[SP]);
      if(get_i(TTemp[SP],0) ||
         (!((( get_i(TTemp[SP-1],0)) && (get_d(TTemp[SP-3],0)>0)) ||
            ((!get_i(TTemp[SP-1],0)) && (get_d(TTemp[SP-3],0)<0)))))
      {
       destroy_tuple(TTemp[SP--]);
       destroy_tuple(TTemp[SP]);
       T_tuple_sub(TTemp[SP-1],TTemp[SP-2],&TTemp[SP]);
       destroy_tuple(hv_Index);
       copy_tuple(TTemp[SP],&hv_Index);
       destroy_tuple(TTemp[SP--]);
       destroy_tuple(TTemp[SP]);
       for(;;)
       {
       T_tuple_add(hv_Index,TTemp[SP-1],&TTemp[SP]);
       destroy_tuple(hv_Index);
       copy_tuple(TTemp[SP],&hv_Index);
       destroy_tuple(TTemp[SP]);
       if(get_d(TTemp[SP-1],0)<0)
        T_tuple_less(hv_Index,TTemp[SP-2],&TTemp[SP]);
       else
        T_tuple_greater(hv_Index,TTemp[SP-2],&TTemp[SP]);
       if(get_i(TTemp[SP],0)) break;
       destroy_tuple(TTemp[SP]);
       /*========== for ==========*/

        /*Only consider the WindowHandleKeys that are needed for the current visualization.*/
        /*Indices := find(KeysForDisplay,WindowHandleKeys[Index])*/
        T_tuple_select(hv_WindowHandleKeys,hv_Index,&TTemp[SP++]);
        T_tuple_find(hv_KeysForDisplay_COPY_INP_TMP,TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-1]=TTemp[SP];
        destroy_tuple(hv_Indices);
        hv_Indices=TTemp[--SP];

        /*========== if (Indices != -1 and Indices != []) ==========*/
        create_tuple_i(&TTemp[SP++],-1);
        T_tuple_not_equal(hv_Indices,TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-1]=TTemp[SP];
        create_tuple(&TTemp[SP++],0);
        T_tuple_not_equal(hv_Indices,TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-1]=TTemp[SP];
        T_tuple_and(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-2]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-2]=TTemp[SP];
        SP--;
        if(get_i(TTemp[SP-1],0))
        {
          /*get_dict_tuple (WindowHandleDict, WindowHandleKeys[Index], WindowHandles)*/
          T_tuple_select(hv_WindowHandleKeys,hv_Index,&TTemp[SP++]);
          destroy_tuple(hv_WindowHandles);
          /***/T_get_dict_tuple(hv_WindowHandleDict, TTemp[SP-1], &hv_WindowHandles);
          destroy_tuple(TTemp[--SP]);

          /*========== for WindowIndex := 0 to |WindowHandles| - 1 by 1 ==========*/
          T_tuple_length(hv_WindowHandles,&TTemp[SP++]);
          create_tuple_i(&TTemp[SP++],1);
          T_tuple_sub(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
          destroy_tuple(TTemp[SP-2]);
          destroy_tuple(TTemp[SP-1]);
          TTemp[SP-2]=TTemp[SP];
          SP--;
          create_tuple_i(&TTemp[SP++],1);
          create_tuple_i(&TTemp[SP++],0);
          T_tuple_greater(TTemp[SP-1],TTemp[SP-3],&TTemp[SP]);
          SP++;
          T_tuple_equal(TTemp[SP-2],TTemp[SP-4],&TTemp[SP]);
          if(get_i(TTemp[SP],0) ||
             (!((( get_i(TTemp[SP-1],0)) && (get_d(TTemp[SP-3],0)>0)) ||
                ((!get_i(TTemp[SP-1],0)) && (get_d(TTemp[SP-3],0)<0)))))
          {
           destroy_tuple(TTemp[SP--]);
           destroy_tuple(TTemp[SP]);
           T_tuple_sub(TTemp[SP-1],TTemp[SP-2],&TTemp[SP]);
           destroy_tuple(hv_WindowIndex);
           copy_tuple(TTemp[SP],&hv_WindowIndex);
           destroy_tuple(TTemp[SP--]);
           destroy_tuple(TTemp[SP]);
           for(;;)
           {
           T_tuple_add(hv_WindowIndex,TTemp[SP-1],&TTemp[SP]);
           destroy_tuple(hv_WindowIndex);
           copy_tuple(TTemp[SP],&hv_WindowIndex);
           destroy_tuple(TTemp[SP]);
           if(get_d(TTemp[SP-1],0)<0)
            T_tuple_less(hv_WindowIndex,TTemp[SP-2],&TTemp[SP]);
           else
            T_tuple_greater(hv_WindowIndex,TTemp[SP-2],&TTemp[SP]);
           if(get_i(TTemp[SP],0)) break;
           destroy_tuple(TTemp[SP]);
           /*========== for ==========*/

            /*Reset values of windows that have been changed temporarily.*/
            /*set_window_param (WindowHandles[WindowIndex], 'flush', FlushValues[Index])*/
            T_tuple_select(hv_WindowHandles,hv_WindowIndex,&TTemp[SP++]);
            create_tuple_s(&TTemp[SP++],"flush");
            T_tuple_select(hv_FlushValues,hv_Index,&TTemp[SP++]);
            /***/T_set_window_param(TTemp[SP-3], TTemp[SP-2], TTemp[SP-1]);
            destroy_tuple(TTemp[--SP]);
            destroy_tuple(TTemp[--SP]);
            destroy_tuple(TTemp[--SP]);

           }
           destroy_tuple(TTemp[SP--]);
           destroy_tuple(TTemp[SP--]);
           destroy_tuple(TTemp[SP]);
          }
          else
          {
           destroy_tuple(TTemp[SP--]);
           destroy_tuple(TTemp[SP--]);
           destroy_tuple(TTemp[SP--]);
           destroy_tuple(TTemp[SP--]);
           destroy_tuple(TTemp[SP]);
          }/*========== end for ========*/

        }
        destroy_tuple(TTemp[--SP]);
        /*========== end if ==========*/
       }
       destroy_tuple(TTemp[SP--]);
       destroy_tuple(TTemp[SP--]);
       destroy_tuple(TTemp[SP]);
      }
      else
      {
       destroy_tuple(TTemp[SP--]);
       destroy_tuple(TTemp[SP--]);
       destroy_tuple(TTemp[SP--]);
       destroy_tuple(TTemp[SP--]);
       destroy_tuple(TTemp[SP]);
      }/*========== end for ========*/

      /* throw(...); only in hdevelop*/
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    destroy_tuple(TTemp[--SP]);
    /*========== end if ==========*/
    /**/
    /*KeyIndex := KeyIndex + 1*/
    create_tuple_i(&TTemp[SP++],1);
    T_tuple_add(hv_KeyIndex,TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(hv_KeyIndex);
    hv_KeyIndex=TTemp[SP];
    destroy_tuple(TTemp[--SP]);

  }
  destroy_tuple(TTemp[--SP]);
  /*========== end while =====*/
  /**/
  /*Display results.*/
  /*get_dict_param (WindowHandleDict, 'keys', [], WindowHandleKeysNew)*/
  create_tuple_s(&TTemp[SP++],"keys");
  create_tuple(&TTemp[SP++],0);
  destroy_tuple(hv_WindowHandleKeysNew);
  /***/T_get_dict_param(hv_WindowHandleDict, TTemp[SP-2], TTemp[SP-1], &hv_WindowHandleKeysNew);
  destroy_tuple(TTemp[--SP]);
  destroy_tuple(TTemp[--SP]);

  /*========== for Index := 0 to |WindowHandleKeysNew| - 1 by 1 ==========*/
  T_tuple_length(hv_WindowHandleKeysNew,&TTemp[SP++]);
  create_tuple_i(&TTemp[SP++],1);
  T_tuple_sub(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-2]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-2]=TTemp[SP];
  SP--;
  create_tuple_i(&TTemp[SP++],1);
  create_tuple_i(&TTemp[SP++],0);
  T_tuple_greater(TTemp[SP-1],TTemp[SP-3],&TTemp[SP]);
  SP++;
  T_tuple_equal(TTemp[SP-2],TTemp[SP-4],&TTemp[SP]);
  if(get_i(TTemp[SP],0) ||
     (!((( get_i(TTemp[SP-1],0)) && (get_d(TTemp[SP-3],0)>0)) ||
        ((!get_i(TTemp[SP-1],0)) && (get_d(TTemp[SP-3],0)<0)))))
  {
   destroy_tuple(TTemp[SP--]);
   destroy_tuple(TTemp[SP]);
   T_tuple_sub(TTemp[SP-1],TTemp[SP-2],&TTemp[SP]);
   destroy_tuple(hv_Index);
   copy_tuple(TTemp[SP],&hv_Index);
   destroy_tuple(TTemp[SP--]);
   destroy_tuple(TTemp[SP]);
   for(;;)
   {
   T_tuple_add(hv_Index,TTemp[SP-1],&TTemp[SP]);
   destroy_tuple(hv_Index);
   copy_tuple(TTemp[SP],&hv_Index);
   destroy_tuple(TTemp[SP]);
   if(get_d(TTemp[SP-1],0)<0)
    T_tuple_less(hv_Index,TTemp[SP-2],&TTemp[SP]);
   else
    T_tuple_greater(hv_Index,TTemp[SP-2],&TTemp[SP]);
   if(get_i(TTemp[SP],0)) break;
   destroy_tuple(TTemp[SP]);
   /*========== for ==========*/

    /*Only consider the WindowHandleKeys that are needed for the current visualization.*/
    /*KeyIndex := find(KeysForDisplay,WindowHandleKeysNew[Index])*/
    T_tuple_select(hv_WindowHandleKeysNew,hv_Index,&TTemp[SP++]);
    T_tuple_find(hv_KeysForDisplay_COPY_INP_TMP,TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    destroy_tuple(hv_KeyIndex);
    hv_KeyIndex=TTemp[--SP];

    /*========== if (KeyIndex != -1 and KeyIndex != []) ==========*/
    create_tuple_i(&TTemp[SP++],-1);
    T_tuple_not_equal(hv_KeyIndex,TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    create_tuple(&TTemp[SP++],0);
    T_tuple_not_equal(hv_KeyIndex,TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    T_tuple_and(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-2]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-2]=TTemp[SP];
    SP--;
    if(get_i(TTemp[SP-1],0))
    {
      /*get_dict_tuple (WindowHandleDict, WindowHandleKeysNew[Index], WindowHandles)*/
      T_tuple_select(hv_WindowHandleKeysNew,hv_Index,&TTemp[SP++]);
      destroy_tuple(hv_WindowHandles);
      /***/T_get_dict_tuple(hv_WindowHandleDict, TTemp[SP-1], &hv_WindowHandles);
      destroy_tuple(TTemp[--SP]);

      /*========== for WindowIndex := 0 to |WindowHandles| - 1 by 1 ==========*/
      T_tuple_length(hv_WindowHandles,&TTemp[SP++]);
      create_tuple_i(&TTemp[SP++],1);
      T_tuple_sub(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-2]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-2]=TTemp[SP];
      SP--;
      create_tuple_i(&TTemp[SP++],1);
      create_tuple_i(&TTemp[SP++],0);
      T_tuple_greater(TTemp[SP-1],TTemp[SP-3],&TTemp[SP]);
      SP++;
      T_tuple_equal(TTemp[SP-2],TTemp[SP-4],&TTemp[SP]);
      if(get_i(TTemp[SP],0) ||
         (!((( get_i(TTemp[SP-1],0)) && (get_d(TTemp[SP-3],0)>0)) ||
            ((!get_i(TTemp[SP-1],0)) && (get_d(TTemp[SP-3],0)<0)))))
      {
       destroy_tuple(TTemp[SP--]);
       destroy_tuple(TTemp[SP]);
       T_tuple_sub(TTemp[SP-1],TTemp[SP-2],&TTemp[SP]);
       destroy_tuple(hv_WindowIndex);
       copy_tuple(TTemp[SP],&hv_WindowIndex);
       destroy_tuple(TTemp[SP--]);
       destroy_tuple(TTemp[SP]);
       for(;;)
       {
       T_tuple_add(hv_WindowIndex,TTemp[SP-1],&TTemp[SP]);
       destroy_tuple(hv_WindowIndex);
       copy_tuple(TTemp[SP],&hv_WindowIndex);
       destroy_tuple(TTemp[SP]);
       if(get_d(TTemp[SP-1],0)<0)
        T_tuple_less(hv_WindowIndex,TTemp[SP-2],&TTemp[SP]);
       else
        T_tuple_greater(hv_WindowIndex,TTemp[SP-2],&TTemp[SP]);
       if(get_i(TTemp[SP],0)) break;
       destroy_tuple(TTemp[SP]);
       /*========== for ==========*/

        /*Display content of window handle.*/
        /*========== if (|WindowHandleKeys| == |WindowHandleKeysNew|) ==========*/
        T_tuple_length(hv_WindowHandleKeys,&TTemp[SP++]);
        T_tuple_length(hv_WindowHandleKeysNew,&TTemp[SP++]);
        T_tuple_equal(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-2]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-2]=TTemp[SP];
        SP--;
        if(get_i(TTemp[SP-1],0))
        {
          /*Reset values of windows that have been changed temporarily.*/
          /*========== if (FlushValues[WindowIndex] == 'true') ==========*/
          T_tuple_select(hv_FlushValues,hv_WindowIndex,&TTemp[SP++]);
          create_tuple_s(&TTemp[SP++],"true");
          T_tuple_equal(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
          destroy_tuple(TTemp[SP-2]);
          destroy_tuple(TTemp[SP-1]);
          TTemp[SP-2]=TTemp[SP];
          SP--;
          if(get_i(TTemp[SP-1],0))
          {
            /*flush_buffer (WindowHandles[WindowIndex])*/
            T_tuple_select(hv_WindowHandles,hv_WindowIndex,&TTemp[SP++]);
            /***/T_flush_buffer(TTemp[SP-1]);
            destroy_tuple(TTemp[--SP]);

          }
          destroy_tuple(TTemp[--SP]);
          /*========== end if ==========*/
          /*set_window_param (WindowHandles[WindowIndex], 'flush', FlushValues[WindowIndex])*/
          T_tuple_select(hv_WindowHandles,hv_WindowIndex,&TTemp[SP++]);
          create_tuple_s(&TTemp[SP++],"flush");
          T_tuple_select(hv_FlushValues,hv_WindowIndex,&TTemp[SP++]);
          /***/T_set_window_param(TTemp[SP-3], TTemp[SP-2], TTemp[SP-1]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(TTemp[--SP]);

        }
        else
        {
          /*Per default, 'flush' of new windows should be set to 'true'.*/
          /*flush_buffer (WindowHandles[WindowIndex])*/
          T_tuple_select(hv_WindowHandles,hv_WindowIndex,&TTemp[SP++]);
          /***/T_flush_buffer(TTemp[SP-1]);
          destroy_tuple(TTemp[--SP]);

          /*set_window_param (WindowHandles[WindowIndex], 'flush', 'true')*/
          T_tuple_select(hv_WindowHandles,hv_WindowIndex,&TTemp[SP++]);
          create_tuple_s(&TTemp[SP++],"flush");
          create_tuple_s(&TTemp[SP++],"true");
          /***/T_set_window_param(TTemp[SP-3], TTemp[SP-2], TTemp[SP-1]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(TTemp[--SP]);

        }
        destroy_tuple(TTemp[--SP]);
        /*========== end if ==========*/
       }
       destroy_tuple(TTemp[SP--]);
       destroy_tuple(TTemp[SP--]);
       destroy_tuple(TTemp[SP]);
      }
      else
      {
       destroy_tuple(TTemp[SP--]);
       destroy_tuple(TTemp[SP--]);
       destroy_tuple(TTemp[SP--]);
       destroy_tuple(TTemp[SP--]);
       destroy_tuple(TTemp[SP]);
      }/*========== end for ========*/

    }
    destroy_tuple(TTemp[--SP]);
    /*========== end if ==========*/
   }
   destroy_tuple(TTemp[SP--]);
   destroy_tuple(TTemp[SP--]);
   destroy_tuple(TTemp[SP]);
  }
  else
  {
   destroy_tuple(TTemp[SP--]);
   destroy_tuple(TTemp[SP--]);
   destroy_tuple(TTemp[SP--]);
   destroy_tuple(TTemp[SP--]);
   destroy_tuple(TTemp[SP]);
  }/*========== end for ========*/

  /**/
  /*========== return ==========*/

  /* Clear temporary tuple stack */
  while (SP > 0)
    destroy_tuple(TTemp[--SP]);
  /* Clear temporary object stack */
  while (SPO > 0)
    clear_obj(OTemp[--SPO]);
  /* Clear temporary tuple vectors stack*/
  while (SPTV > 0)
    V_destroy_vector(TVTemp[--SPTV]);
  /* Clear temporary object vectors stack */
  while (SPOV > 0)
    V_destroy_vector(OVTemp[--SPOV]);
  /* Clear local iconic variables */
  clear_obj(ho_Image);
  clear_obj(ho_Domain);
  clear_obj(ho_GrippingMapImageResult);
  clear_obj(ho_Cross);
  clear_obj(ho_GrippingMapGroundTruth);
  clear_obj(ho_X);
  clear_obj(ho_Y);
  clear_obj(ho_Z);
  clear_obj(ho_AnomalyImage);
  clear_obj(ho_AnomalyRegion);
  clear_obj(ho_ConfidenceImage);
  clear_obj(ho_HeatmapScene);
  clear_obj(ho_ScoreMaps);
  clear_obj(ho_CharacterScoreMap);
  clear_obj(ho_LinkScoreMap);
  clear_obj(ho_OrientationSinScoreMap);
  clear_obj(ho_OrientationCosScoreMap);
  clear_obj(ho_ScoreMap);
  clear_obj(ho_OrientationScoreMap);
  clear_obj(ho_PredictionColorFrame);
  clear_obj(ho_ImageHeatmap);
  clear_obj(ho_PredictionSymbol);
  clear_obj(ho_CrossLineH);
  clear_obj(ho_CrossLineV);
  clear_obj(ho_ImageConfidence);
  clear_obj(ho_SegmentationImagGroundTruth);
  clear_obj(ho_SegmentationImageResult);
  clear_obj(ho_ImageAbsDiff);
  clear_obj(ho_DiffRegion);
  clear_obj(ho_ImageWeight);

  /* Clear local control variables */
  destroy_tuple(hv_Params);
  destroy_tuple(hv_GenParamNames);
  destroy_tuple(hv_ParamIndex);
  destroy_tuple(hv_GenParamName);
  destroy_tuple(hv_KeyExists);
  destroy_tuple(hv_SampleKeys);
  destroy_tuple(hv_ResultKeys);
  destroy_tuple(hv_ImageIDExists);
  destroy_tuple(hv_ImageID);
  destroy_tuple(hv_ImageIDString);
  destroy_tuple(hv_ImageIDStringBraces);
  destroy_tuple(hv_ImageIDStringCapital);
  destroy_tuple(hv_IsOCRDetection);
  destroy_tuple(hv_AdditionalGreenClassNames);
  destroy_tuple(hv_KeyIndex);
  destroy_tuple(hv_OcrResult);
  destroy_tuple(hv_MaxClassIdSample);
  destroy_tuple(hv_EmptySample);
  destroy_tuple(hv_MaxClassIdResult);
  destroy_tuple(hv_EmptyResult);
  destroy_tuple(hv_MaxClassId);
  destroy_tuple(hv_ClassNames);
  destroy_tuple(hv_ClassIDs);
  destroy_tuple(hv_ClassNameKey);
  destroy_tuple(hv_ClassIdKey);
  destroy_tuple(hv_ResultClassNames);
  destroy_tuple(hv_ResultClassIds);
  destroy_tuple(hv_SortIndices);
  destroy_tuple(hv_UniqueClassIds);
  destroy_tuple(hv_UniqueClassNames);
  destroy_tuple(hv_Colors);
  destroy_tuple(hv_ClassesLegend);
  destroy_tuple(hv_InvalidInput);
  destroy_tuple(hv_ClassKeys);
  destroy_tuple(hv_ClassKeysExist);
  destroy_tuple(hv_DLDatasetInfoKeys);
  destroy_tuple(hv_Index);
  destroy_tuple(hv_ClassIDstoIndex);
  destroy_tuple(hv_I);
  destroy_tuple(hv_PrevWindowCoordinates);
  destroy_tuple(hv_Keys);
  destroy_tuple(hv_Exception);
  destroy_tuple(hv_MetaInfoExists);
  destroy_tuple(hv_FlushValues);
  destroy_tuple(hv_WindowHandleKeys);
  destroy_tuple(hv_WindowHandles);
  destroy_tuple(hv_WindowIndex);
  destroy_tuple(hv_FlushValue);
  destroy_tuple(hv_WidthImage);
  destroy_tuple(hv_HeightImage);
  destroy_tuple(hv_CurrentWindowHandle);
  destroy_tuple(hv_WindowImageRatio);
  destroy_tuple(hv_ColorsGrippingGroundTruth);
  destroy_tuple(hv_ImageClassIDs);
  destroy_tuple(hv_GrippingPointsExists);
  destroy_tuple(hv_Rows);
  destroy_tuple(hv_Columns);
  destroy_tuple(hv_AnomalyImages);
  destroy_tuple(hv_PossibleKeysForDisplay);
  destroy_tuple(hv_AddDisplayKey);
  destroy_tuple(hv_AnomalyLabelGroundTruth);
  destroy_tuple(hv_AnomalyLabelIDGroundTruth);
  destroy_tuple(hv_AnomalyResultPostfix);
  destroy_tuple(hv_AnomalyScore);
  destroy_tuple(hv_AnomalyClassID);
  destroy_tuple(hv_AnomalyClassThresholdDisplay);
  destroy_tuple(hv_AnomalyRegionThresholdDisplay);
  destroy_tuple(hv_WindowHandleName);
  destroy_tuple(hv_AnomalyRegionGroundTruthExists);
  destroy_tuple(hv_Text);
  destroy_tuple(hv_PredictionColor);
  destroy_tuple(hv_LineColors);
  destroy_tuple(hv_ResultColorOffset);
  destroy_tuple(hv_AnomalyRegionExists);
  destroy_tuple(hv_AnomalyImageKey);
  destroy_tuple(hv_AnomalyScoreKey);
  destroy_tuple(hv_AnomalyResultKey);
  destroy_tuple(hv_AnomalyRegionKey);
  destroy_tuple(hv_DisplayDirectionTemp);
  destroy_tuple(hv_BboxLabelIndex);
  destroy_tuple(hv_BboxConfidences);
  destroy_tuple(hv_TextConf);
  destroy_tuple(hv_BboxClassIndex);
  destroy_tuple(hv_BboxColorsBoth);
  destroy_tuple(hv_BboxClassLabelIndexUniq);
  destroy_tuple(hv_BboxIDs);
  destroy_tuple(hv_BboxColors);
  destroy_tuple(hv_BboxIDsUniq);
  destroy_tuple(hv_BboxColorsResults);
  destroy_tuple(hv_BboxClassIndexUniq);
  destroy_tuple(hv_ClassificationLabelIDGroundTruth);
  destroy_tuple(hv_ClassificationLabelIDResult);
  destroy_tuple(hv_PredictionText);
  destroy_tuple(hv_BoarderOffset);
  destroy_tuple(hv_MetaInfo);
  destroy_tuple(hv_WindowImageRatioHeight);
  destroy_tuple(hv_WindowImageRatioWidth);
  destroy_tuple(hv_BoarderOffsetRow);
  destroy_tuple(hv_BoarderOffsetCol);
  destroy_tuple(hv_MarginBottom);
  destroy_tuple(hv_WindowCoordinates);
  destroy_tuple(hv_CurrentWindowHeight);
  destroy_tuple(hv__);
  destroy_tuple(hv_MaxHeight);
  destroy_tuple(hv_PluralPostfix);
  destroy_tuple(hv_ClassificationLabelIDGroundTruthList);
  destroy_tuple(hv_C);
  destroy_tuple(hv_ClassificationLabelIDResultList);
  destroy_tuple(hv_HasConfidences);
  destroy_tuple(hv_TPIndices);
  destroy_tuple(hv_RIdx);
  destroy_tuple(hv_ResultLine);
  destroy_tuple(hv_HasFalseNegatives);
  destroy_tuple(hv_FalseNegativeClassIDs);
  destroy_tuple(hv_FNIdx);
  destroy_tuple(hv_FNClassIdx);
  destroy_tuple(hv_FNLine);
  destroy_tuple(hv_NumFNLines);
  destroy_tuple(hv_IsMLC);
  destroy_tuple(hv_ResultColors);
  destroy_tuple(hv_SelectedHeatmapMethod);
  destroy_tuple(hv_DictHeatmap);
  destroy_tuple(hv_MethodName);
  destroy_tuple(hv_HeatmapKeys);
  destroy_tuple(hv_HeatmapImageName);
  destroy_tuple(hv_TargetClassID);
  destroy_tuple(hv_Confidences);
  destroy_tuple(hv_MaxDeviation);
  destroy_tuple(hv_ClassificationLabelNameResult);
  destroy_tuple(hv_TargetClassConfidence);
  destroy_tuple(hv_ClassificationLabelNamesGroundTruth);
  destroy_tuple(hv_ShowGT);
  destroy_tuple(hv_ShowResult);
  destroy_tuple(hv_NumLines);
  destroy_tuple(hv_Type);
  destroy_tuple(hv_GTWordKeyExists);
  destroy_tuple(hv_HeightWindow);
  destroy_tuple(hv_HeightMarginBottom);
  destroy_tuple(hv_Size);
  destroy_tuple(hv_Length);
  destroy_tuple(hv_Row);
  destroy_tuple(hv_Column);
  destroy_tuple(hv_HomMat2DIdentity);
  destroy_tuple(hv_HomMat2DRotate);
  destroy_tuple(hv_HomMat2DCompose);
  destroy_tuple(hv_PredictionForegroundColor);
  destroy_tuple(hv_PredictionBackgroundColor);
  destroy_tuple(hv_Spaces);
  destroy_tuple(hv_ConfidenceColors);
  destroy_tuple(hv_ColorsResults);
  destroy_tuple(hv_GroundTruthIDs);
  destroy_tuple(hv_ResultIDs);
  destroy_tuple(hv_ImageClassIDsUniq);
  destroy_tuple(hv_ImageClassIDsIndices);
  destroy_tuple(hv_ImageClassIDsIndex);
  destroy_tuple(hv_StringSegExcludeClassIDs);
  destroy_tuple(hv_StringIndex);
  destroy_tuple(hv_Min);
  destroy_tuple(hv_Max);
  destroy_tuple(hv_Range);
  destroy_tuple(hv_ColorsSegmentation);
  destroy_tuple(hv_DrawMode);
  destroy_tuple(hv_Width);
  destroy_tuple(hv_MinWeight);
  destroy_tuple(hv_WeightsColors);
  destroy_tuple(hv_Indices);
  destroy_tuple(hv_WindowHandleKeysNew);
  destroy_tuple(hv___Tmp_Ctrl_Dict_Init_2);
  destroy_tuple(hv___Tmp_Ctrl_Dict_Init_3);
  destroy_tuple(hv___Tmp_Ctrl_Dict_Init_4);
  destroy_tuple(hv___Tmp_Ctrl_Dict_Init_5);
  destroy_tuple(hv___Tmp_Ctrl_Dict_Init_6);
  destroy_tuple(hv___Tmp_Ctrl_Dict_Init_7);
  destroy_tuple(hv___Tmp_Ctrl_Dict_Init_8);
  destroy_tuple(hv___Tmp_Ctrl_1);
  destroy_tuple(hv___Tmp_Ctrl_Type);
  destroy_tuple(hv_DLResult_COPY_INP_TMP);
  destroy_tuple(hv_KeysForDisplay_COPY_INP_TMP);

  return;

  /****************************************************/
  /******************     End procedure   *************/
  /****************************************************/

}

/* Chapter: Deep Learning / Model*/
/* Short Description: Try to guess the maximum class id based on the given sample/result. */
void dev_display_dl_data_get_max_class_id (Htuple hv_DLSample, Htuple *hv_MaxClassId, 
    Htuple *hv_Empty)
{

  /* Stack for temporary tuples */
  Htuple   TTemp[100];
  int      SP=0;
  /* Stack for temporary tuple vectors */
  Hvector  TVTemp[100] = {0};
  int      SPTV=0;

  /* Local iconic variables */

  /* Local control variables */
  Htuple  hv_Keys, hv_Matches, hv_Length, hv_Greatereq;
  Htuple  hv_Indices, hv_LengthAll, hv_KeyIndex, hv_Key, hv_KeyType;
  Htuple  hv_Tuple, hv_MaxTuple, hv_Exception;

  /* Initialize control variables */
  create_tuple(&hv_Keys,0);
  create_tuple(&hv_Matches,0);
  create_tuple(&hv_Length,0);
  create_tuple(&hv_Greatereq,0);
  create_tuple(&hv_Indices,0);
  create_tuple(&hv_LengthAll,0);
  create_tuple(&hv_KeyIndex,0);
  create_tuple(&hv_Key,0);
  create_tuple(&hv_KeyType,0);
  create_tuple(&hv_Tuple,0);
  create_tuple(&hv_MaxTuple,0);
  create_tuple(&hv_Exception,0);
  create_tuple(&(*hv_MaxClassId),0);
  create_tuple(&(*hv_Empty),0);

  /****************************************************/
  /******************   Begin procedure   *************/
  /****************************************************/

  /*MaxClassId := -1*/
  reuse_tuple_i(&(*hv_MaxClassId),-1);

  /*Empty := false*/
  reuse_tuple_i(&(*hv_Empty),0);

  /* try(...); only in hdevelop*/
    /*get_dict_param (DLSample, 'keys', [], Keys)*/
    create_tuple_s(&TTemp[SP++],"keys");
    create_tuple(&TTemp[SP++],0);
    destroy_tuple(hv_Keys);
    /***/T_get_dict_param(hv_DLSample, TTemp[SP-2], TTemp[SP-1], &hv_Keys);
    destroy_tuple(TTemp[--SP]);
    destroy_tuple(TTemp[--SP]);

    /*Find keys that end on '_id'. (They contain ids!)*/
    /*tuple_regexp_match (Keys, '_id', Matches)*/
    create_tuple_s(&TTemp[SP++],"_id");
    destroy_tuple(hv_Matches);
    /***/T_tuple_regexp_match(hv_Keys, TTemp[SP-1], &hv_Matches);
    destroy_tuple(TTemp[--SP]);

    /*tuple_strlen (Matches, Length)*/
    destroy_tuple(hv_Length);
    /***/T_tuple_strlen(hv_Matches, &hv_Length);

    /*tuple_greater_equal_elem (Length, 1, Greatereq)*/
    create_tuple_i(&TTemp[SP++],1);
    destroy_tuple(hv_Greatereq);
    /***/T_tuple_greater_equal_elem(hv_Length, TTemp[SP-1], &hv_Greatereq);
    destroy_tuple(TTemp[--SP]);

    /*tuple_find (Greatereq, 1, Indices)*/
    create_tuple_i(&TTemp[SP++],1);
    destroy_tuple(hv_Indices);
    /***/T_tuple_find(hv_Greatereq, TTemp[SP-1], &hv_Indices);
    destroy_tuple(TTemp[--SP]);

    /*========== if (Indices > -1) ==========*/
    create_tuple_i(&TTemp[SP++],-1);
    T_tuple_greater(hv_Indices,TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    if(get_i(TTemp[SP-1],0))
    {
      /*Find the maximum given class id.*/
      /*LengthAll := 0*/
      reuse_tuple_i(&hv_LengthAll,0);

      /*========== for KeyIndex := 0 to |Indices| - 1 by 1 ==========*/
      T_tuple_length(hv_Indices,&TTemp[SP++]);
      create_tuple_i(&TTemp[SP++],1);
      T_tuple_sub(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-2]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-2]=TTemp[SP];
      SP--;
      create_tuple_i(&TTemp[SP++],1);
      create_tuple_i(&TTemp[SP++],0);
      T_tuple_greater(TTemp[SP-1],TTemp[SP-3],&TTemp[SP]);
      SP++;
      T_tuple_equal(TTemp[SP-2],TTemp[SP-4],&TTemp[SP]);
      if(get_i(TTemp[SP],0) ||
         (!((( get_i(TTemp[SP-1],0)) && (get_d(TTemp[SP-3],0)>0)) ||
            ((!get_i(TTemp[SP-1],0)) && (get_d(TTemp[SP-3],0)<0)))))
      {
       destroy_tuple(TTemp[SP--]);
       destroy_tuple(TTemp[SP]);
       T_tuple_sub(TTemp[SP-1],TTemp[SP-2],&TTemp[SP]);
       destroy_tuple(hv_KeyIndex);
       copy_tuple(TTemp[SP],&hv_KeyIndex);
       destroy_tuple(TTemp[SP--]);
       destroy_tuple(TTemp[SP]);
       for(;;)
       {
       T_tuple_add(hv_KeyIndex,TTemp[SP-1],&TTemp[SP]);
       destroy_tuple(hv_KeyIndex);
       copy_tuple(TTemp[SP],&hv_KeyIndex);
       destroy_tuple(TTemp[SP]);
       if(get_d(TTemp[SP-1],0)<0)
        T_tuple_less(hv_KeyIndex,TTemp[SP-2],&TTemp[SP]);
       else
        T_tuple_greater(hv_KeyIndex,TTemp[SP-2],&TTemp[SP]);
       if(get_i(TTemp[SP],0)) break;
       destroy_tuple(TTemp[SP]);
       /*========== for ==========*/

        /*Key := Keys[Indices[KeyIndex]]*/
        T_tuple_select(hv_Indices,hv_KeyIndex,&TTemp[SP++]);
        T_tuple_select(hv_Keys,TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-1]=TTemp[SP];
        destroy_tuple(hv_Key);
        hv_Key=TTemp[--SP];

        /*Skip image_id.*/
        /*========== if (Key == 'image_id') ==========*/
        create_tuple_s(&TTemp[SP++],"image_id");
        T_tuple_equal(hv_Key,TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-1]=TTemp[SP];
        if(get_i(TTemp[SP-1],0))
        {
          /*continue*/
          destroy_tuple(TTemp[--SP]);
          continue;
        }
        destroy_tuple(TTemp[--SP]);
        /*========== end if ==========*/
        /*get_dict_param (DLSample, 'key_data_type', Key, KeyType)*/
        create_tuple_s(&TTemp[SP++],"key_data_type");
        destroy_tuple(hv_KeyType);
        /***/T_get_dict_param(hv_DLSample, TTemp[SP-1], hv_Key, &hv_KeyType);
        destroy_tuple(TTemp[--SP]);

        /*========== if (KeyType != 'tuple') ==========*/
        create_tuple_s(&TTemp[SP++],"tuple");
        T_tuple_not_equal(hv_KeyType,TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-1]=TTemp[SP];
        if(get_i(TTemp[SP-1],0))
        {
          /*continue*/
          destroy_tuple(TTemp[--SP]);
          continue;
        }
        destroy_tuple(TTemp[--SP]);
        /*========== end if ==========*/
        /*get_dict_tuple (DLSample, Key, Tuple)*/
        destroy_tuple(hv_Tuple);
        /***/T_get_dict_tuple(hv_DLSample, hv_Key, &hv_Tuple);

        /*LengthAll := LengthAll + |Tuple|*/
        T_tuple_length(hv_Tuple,&TTemp[SP++]);
        T_tuple_add(hv_LengthAll,TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(hv_LengthAll);
        hv_LengthAll=TTemp[SP];
        destroy_tuple(TTemp[--SP]);

        /*========== if (|Tuple| == 0) ==========*/
        T_tuple_length(hv_Tuple,&TTemp[SP++]);
        create_tuple_i(&TTemp[SP++],0);
        T_tuple_equal(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-2]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-2]=TTemp[SP];
        SP--;
        if(get_i(TTemp[SP-1],0))
        {
          /*continue*/
          destroy_tuple(TTemp[--SP]);
          continue;
        }
        destroy_tuple(TTemp[--SP]);
        /*========== end if ==========*/
        /*tuple_max (Tuple, MaxTuple)*/
        destroy_tuple(hv_MaxTuple);
        /***/T_tuple_max(hv_Tuple, &hv_MaxTuple);

        /*========== if (MaxTuple > MaxClassId) ==========*/
        T_tuple_greater(hv_MaxTuple,(*hv_MaxClassId),&TTemp[SP++]);
        if(get_i(TTemp[SP-1],0))
        {
          /*MaxClassId := MaxTuple*/
          destroy_tuple((*hv_MaxClassId));
          copy_tuple(hv_MaxTuple,&(*hv_MaxClassId));

        }
        destroy_tuple(TTemp[--SP]);
        /*========== end if ==========*/
       }
       destroy_tuple(TTemp[SP--]);
       destroy_tuple(TTemp[SP--]);
       destroy_tuple(TTemp[SP]);
      }
      else
      {
       destroy_tuple(TTemp[SP--]);
       destroy_tuple(TTemp[SP--]);
       destroy_tuple(TTemp[SP--]);
       destroy_tuple(TTemp[SP--]);
       destroy_tuple(TTemp[SP]);
      }/*========== end for ========*/

      /*========== if (LengthAll == 0) ==========*/
      create_tuple_i(&TTemp[SP++],0);
      T_tuple_equal(hv_LengthAll,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      if(get_i(TTemp[SP-1],0))
      {
        /*Empty := true*/
        reuse_tuple_i(&(*hv_Empty),1);

      }
      destroy_tuple(TTemp[--SP]);
      /*========== end if ==========*/
    }
    destroy_tuple(TTemp[--SP]);
    /*========== end if ==========*/
  /* catch(...); only in hdevelop*/
    /*Ignore any exception.*/
  /* endtry(...); only in hdevelop*/
  /*========== return ==========*/

  /* Clear temporary tuple stack */
  while (SP > 0)
    destroy_tuple(TTemp[--SP]);
  /* Clear temporary tuple vectors stack*/
  while (SPTV > 0)
    V_destroy_vector(TVTemp[--SPTV]);
  /* Clear local control variables */
  destroy_tuple(hv_Keys);
  destroy_tuple(hv_Matches);
  destroy_tuple(hv_Length);
  destroy_tuple(hv_Greatereq);
  destroy_tuple(hv_Indices);
  destroy_tuple(hv_LengthAll);
  destroy_tuple(hv_KeyIndex);
  destroy_tuple(hv_Key);
  destroy_tuple(hv_KeyType);
  destroy_tuple(hv_Tuple);
  destroy_tuple(hv_MaxTuple);
  destroy_tuple(hv_Exception);

  return;

  /****************************************************/
  /******************     End procedure   *************/
  /****************************************************/

}

/* Chapter: Deep Learning / Anomaly Detection and Global Context Anomaly Detection*/
/* Short Description: Display the ground truth anomaly regions of the given DLSample. */
void dev_display_ground_truth_anomaly_regions (Htuple hv_SampleKeys, Htuple hv_DLSample, 
    Htuple hv_CurrentWindowHandle, Htuple hv_LineWidth, Htuple hv_AnomalyRegionLabelColor, 
    Htuple hv_AnomalyColorTransparency, Htuple *hv_AnomalyRegionExists)
{

  /* Stack for temporary tuples */
  Htuple   TTemp[100];
  int      SP=0;
  /* Stack for temporary tuple vectors */
  Hvector  TVTemp[100] = {0};
  int      SPTV=0;

  /* Local iconic variables */
  Hobject  ho_AnomalyImage, ho_AnomalyRegion;

  /* Local control variables */
  Htuple  hv_Red, hv_Green, hv_Blue, hv_Alpha, hv_InitialColor;
  Htuple  hv_IndexColor, hv_Color_RGBA, hv_Area;

  /* Initialize iconic variables */
  gen_empty_obj(&ho_AnomalyImage);
  gen_empty_obj(&ho_AnomalyRegion);

  /* Initialize control variables */
  create_tuple(&hv_Red,0);
  create_tuple(&hv_Green,0);
  create_tuple(&hv_Blue,0);
  create_tuple(&hv_Alpha,0);
  create_tuple(&hv_InitialColor,0);
  create_tuple(&hv_IndexColor,0);
  create_tuple(&hv_Color_RGBA,0);
  create_tuple(&hv_Area,0);
  create_tuple(&(*hv_AnomalyRegionExists),0);

  /****************************************************/
  /******************   Begin procedure   *************/
  /****************************************************/

  /**/
  /*This procedure visualizes the ground truth anomalies*/
  /*if there is an anomaly_ground_truth in DLSample.*/
  /**/
  /*Get current set color.*/
  /*get_rgba (CurrentWindowHandle, Red, Green, Blue, Alpha)*/
  destroy_tuple(hv_Red);
  destroy_tuple(hv_Green);
  destroy_tuple(hv_Blue);
  destroy_tuple(hv_Alpha);
  /***/T_get_rgba(hv_CurrentWindowHandle, &hv_Red, &hv_Green, &hv_Blue, &hv_Alpha);

  /*InitialColor := []*/
  create_tuple(&TTemp[SP++],0);
  destroy_tuple(hv_InitialColor);
  hv_InitialColor=TTemp[--SP];

  /*========== for IndexColor := 0 to |Red| - 1 by 1 ==========*/
  T_tuple_length(hv_Red,&TTemp[SP++]);
  create_tuple_i(&TTemp[SP++],1);
  T_tuple_sub(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-2]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-2]=TTemp[SP];
  SP--;
  create_tuple_i(&TTemp[SP++],1);
  create_tuple_i(&TTemp[SP++],0);
  T_tuple_greater(TTemp[SP-1],TTemp[SP-3],&TTemp[SP]);
  SP++;
  T_tuple_equal(TTemp[SP-2],TTemp[SP-4],&TTemp[SP]);
  if(get_i(TTemp[SP],0) ||
     (!((( get_i(TTemp[SP-1],0)) && (get_d(TTemp[SP-3],0)>0)) ||
        ((!get_i(TTemp[SP-1],0)) && (get_d(TTemp[SP-3],0)<0)))))
  {
   destroy_tuple(TTemp[SP--]);
   destroy_tuple(TTemp[SP]);
   T_tuple_sub(TTemp[SP-1],TTemp[SP-2],&TTemp[SP]);
   destroy_tuple(hv_IndexColor);
   copy_tuple(TTemp[SP],&hv_IndexColor);
   destroy_tuple(TTemp[SP--]);
   destroy_tuple(TTemp[SP]);
   for(;;)
   {
   T_tuple_add(hv_IndexColor,TTemp[SP-1],&TTemp[SP]);
   destroy_tuple(hv_IndexColor);
   copy_tuple(TTemp[SP],&hv_IndexColor);
   destroy_tuple(TTemp[SP]);
   if(get_d(TTemp[SP-1],0)<0)
    T_tuple_less(hv_IndexColor,TTemp[SP-2],&TTemp[SP]);
   else
    T_tuple_greater(hv_IndexColor,TTemp[SP-2],&TTemp[SP]);
   if(get_i(TTemp[SP],0)) break;
   destroy_tuple(TTemp[SP]);
   /*========== for ==========*/

    /*Color_RGBA := '#' + Red[IndexColor]$'2x' + Green[IndexColor]$'2x' + Blue[IndexColor]$'2x' + Alpha[IndexColor]$'2x'*/
    create_tuple_s(&TTemp[SP++],"#");
    T_tuple_select(hv_Red,hv_IndexColor,&TTemp[SP++]);
    create_tuple_s(&TTemp[SP++],"2x");
    T_tuple_string(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-2]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-2]=TTemp[SP];
    SP--;
    T_tuple_add(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-2]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-2]=TTemp[SP];
    SP--;
    T_tuple_select(hv_Green,hv_IndexColor,&TTemp[SP++]);
    create_tuple_s(&TTemp[SP++],"2x");
    T_tuple_string(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-2]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-2]=TTemp[SP];
    SP--;
    T_tuple_add(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-2]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-2]=TTemp[SP];
    SP--;
    T_tuple_select(hv_Blue,hv_IndexColor,&TTemp[SP++]);
    create_tuple_s(&TTemp[SP++],"2x");
    T_tuple_string(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-2]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-2]=TTemp[SP];
    SP--;
    T_tuple_add(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-2]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-2]=TTemp[SP];
    SP--;
    T_tuple_select(hv_Alpha,hv_IndexColor,&TTemp[SP++]);
    create_tuple_s(&TTemp[SP++],"2x");
    T_tuple_string(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-2]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-2]=TTemp[SP];
    SP--;
    T_tuple_add(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-2]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-2]=TTemp[SP];
    SP--;
    destroy_tuple(hv_Color_RGBA);
    hv_Color_RGBA=TTemp[--SP];

    /*tuple_regexp_replace (Color_RGBA, [' ', 'replace_all'], '0', Color_RGBA)*/
    copy_tuple(hv_Color_RGBA,&TTemp[SP++]);
    create_tuple(&TTemp[SP++],2);
    set_s(TTemp[SP-1]," ",0);
    set_s(TTemp[SP-1],"replace_all",1);
    create_tuple_s(&TTemp[SP++],"0");
    destroy_tuple(hv_Color_RGBA);
    /***/T_tuple_regexp_replace(TTemp[SP-3], TTemp[SP-2], TTemp[SP-1], &hv_Color_RGBA);
    destroy_tuple(TTemp[--SP]);
    destroy_tuple(TTemp[--SP]);
    destroy_tuple(TTemp[--SP]);

    /*InitialColor := [InitialColor,Color_RGBA]*/
    copy_tuple(hv_InitialColor,&TTemp[SP++]);
    T_tuple_concat(TTemp[SP-1],hv_Color_RGBA,&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    destroy_tuple(hv_InitialColor);
    hv_InitialColor=TTemp[--SP];

   }
   destroy_tuple(TTemp[SP--]);
   destroy_tuple(TTemp[SP--]);
   destroy_tuple(TTemp[SP]);
  }
  else
  {
   destroy_tuple(TTemp[SP--]);
   destroy_tuple(TTemp[SP--]);
   destroy_tuple(TTemp[SP--]);
   destroy_tuple(TTemp[SP--]);
   destroy_tuple(TTemp[SP]);
  }/*========== end for ========*/

  /**/
  /*========== if (find(SampleKeys,'anomaly_ground_truth') != -1) ==========*/
  create_tuple_s(&TTemp[SP++],"anomaly_ground_truth");
  T_tuple_find(hv_SampleKeys,TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-1]=TTemp[SP];
  create_tuple_i(&TTemp[SP++],-1);
  T_tuple_not_equal(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-2]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-2]=TTemp[SP];
  SP--;
  if(get_i(TTemp[SP-1],0))
  {
    /*get_dict_object (AnomalyImage, DLSample, 'anomaly_ground_truth')*/
    create_tuple_s(&TTemp[SP++],"anomaly_ground_truth");
    clear_obj(ho_AnomalyImage);
    /***/T_get_dict_object(&ho_AnomalyImage, hv_DLSample, TTemp[SP-1]);
    destroy_tuple(TTemp[--SP]);

    /*threshold (AnomalyImage, AnomalyRegion, 1, 255)*/
    clear_obj(ho_AnomalyRegion);
    /***/threshold(ho_AnomalyImage, &ho_AnomalyRegion, 1, 255);

    /*Get non-empty regions.*/
    /*region_features (AnomalyRegion, 'area', Area)*/
    create_tuple_s(&TTemp[SP++],"area");
    destroy_tuple(hv_Area);
    /***/T_region_features(ho_AnomalyRegion, TTemp[SP-1], &hv_Area);
    destroy_tuple(TTemp[--SP]);

    /*========== if (Area > 0) ==========*/
    create_tuple_i(&TTemp[SP++],0);
    T_tuple_greater(hv_Area,TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    if(get_i(TTemp[SP-1],0))
    {
      if (hdev_window_stack_is_open())
      {
        Htuple active_win;
        create_tuple(&active_win,0);
        hdev_window_stack_get_active(&active_win);
        /*dev_set_color (AnomalyRegionLabelColor + AnomalyColorTransparency)*/
        T_tuple_add(hv_AnomalyRegionLabelColor,hv_AnomalyColorTransparency,&TTemp[SP++]);
        /***/T_set_color(active_win,TTemp[SP-1]);
        destroy_tuple(TTemp[--SP]);
        destroy_tuple(active_win);
      }
      /*Display the anomaly region.*/
      if (hdev_window_stack_is_open())
      {
        Htuple active_win;
        create_tuple(&active_win,0);
        hdev_window_stack_get_active(&active_win);
        /*dev_set_draw ('fill')*/
        create_tuple_s(&TTemp[SP++],"fill");
        /***/T_set_draw(active_win,TTemp[SP-1]);
        destroy_tuple(TTemp[--SP]);
        destroy_tuple(active_win);
      }
      if (hdev_window_stack_is_open())
      {
        Htuple active_win;
        create_tuple(&active_win,0);
        hdev_window_stack_get_active(&active_win);
        /*dev_display (AnomalyRegion)*/
        /***/T_disp_obj(ho_AnomalyRegion, active_win);
        destroy_tuple(active_win);
      }
    }
    destroy_tuple(TTemp[--SP]);
    /*========== end if ==========*/
    /*AnomalyRegionExists := 'true'*/
    reuse_tuple_s(&(*hv_AnomalyRegionExists),"true");
  }
  else
  {
    /*AnomalyRegionExists := 'false'*/
    reuse_tuple_s(&(*hv_AnomalyRegionExists),"false");
  }
  destroy_tuple(TTemp[--SP]);
  /*========== end if ==========*/
  /**/
  /*Reset colors.*/
  if (hdev_window_stack_is_open())
  {
    Htuple active_win;
    create_tuple(&active_win,0);
    hdev_window_stack_get_active(&active_win);
    /*dev_set_color (InitialColor)*/
    /***/T_set_color(active_win,hv_InitialColor);
    destroy_tuple(active_win);
  }
  /**/
  /*========== return ==========*/

  /* Clear temporary tuple stack */
  while (SP > 0)
    destroy_tuple(TTemp[--SP]);
  /* Clear temporary tuple vectors stack*/
  while (SPTV > 0)
    V_destroy_vector(TVTemp[--SPTV]);
  /* Clear local iconic variables */
  clear_obj(ho_AnomalyImage);
  clear_obj(ho_AnomalyRegion);

  /* Clear local control variables */
  destroy_tuple(hv_Red);
  destroy_tuple(hv_Green);
  destroy_tuple(hv_Blue);
  destroy_tuple(hv_Alpha);
  destroy_tuple(hv_InitialColor);
  destroy_tuple(hv_IndexColor);
  destroy_tuple(hv_Color_RGBA);
  destroy_tuple(hv_Area);

  return;

  /****************************************************/
  /******************     End procedure   *************/
  /****************************************************/

}

/* Chapter: Graphics / Output*/
/* Short Description: Display the ground truth bounding boxes of DLSample. */
void dev_display_ground_truth_detection (Htuple hv_DLSample, Htuple hv_SampleKeys, 
    Htuple hv_LineWidthBbox, Htuple hv_ClassIDs, Htuple hv_BboxColors, Htuple hv_BboxLabelColor, 
    Htuple hv_WindowImageRatio, Htuple hv_TextColor, Htuple hv_ShowLabels, Htuple hv_ShowDirection, 
    Htuple hv_WindowHandle, Htuple *hv_BboxIDs)
{

  /* Stack for temporary tuples */
  Htuple   TTemp[100];
  int      SP=0;
  /* Stack for temporary tuple vectors */
  Hvector  TVTemp[100] = {0};
  int      SPTV=0;

  /* Local iconic variables */
  Hobject  ho_InstanceMask, ho_BboxRectangle, ho_OrientationArrows;
  Hobject  ho_RectangleSelected, ho_MaskSelected, ho_ArrowSelected;

  /* Local control variables */
  Htuple  hv_InstanceType, hv_MaskExists, hv_BboxRow1;
  Htuple  hv_BboxCol1, hv_BboxRow2, hv_BboxCol2, hv_BboxRow;
  Htuple  hv_BboxCol, hv_BboxLength1, hv_BboxLength2, hv_BboxPhi;
  Htuple  hv_BboxLabels, hv_Text, hv_Ascent, hv_Descent, hv__;
  Htuple  hv_TextOffset, hv_LabelRow, hv_LabelCol, hv_ArrowSizeFactorLength;
  Htuple  hv_ArrowSizeFactorHead, hv_MaxLengthArrow, hv_HalfLengthArrow;
  Htuple  hv_ArrowBaseRow, hv_ArrowBaseCol, hv_ArrowHeadRow;
  Htuple  hv_ArrowHeadCol, hv_ArrowHeadSize, hv_ContourStyle;
  Htuple  hv_Style, hv_IndexBbox, hv_ClassID, hv_TextColorClasses;

  /* Array for temporary output ctrl variables */
  Htuple  CExpDummyOCvar[3];

  /* Initialize iconic variables */
  gen_empty_obj(&ho_InstanceMask);
  gen_empty_obj(&ho_BboxRectangle);
  gen_empty_obj(&ho_OrientationArrows);
  gen_empty_obj(&ho_RectangleSelected);
  gen_empty_obj(&ho_MaskSelected);
  gen_empty_obj(&ho_ArrowSelected);

  /* Initialize control variables */
  create_tuple(&hv_InstanceType,0);
  create_tuple(&hv_MaskExists,0);
  create_tuple(&hv_BboxRow1,0);
  create_tuple(&hv_BboxCol1,0);
  create_tuple(&hv_BboxRow2,0);
  create_tuple(&hv_BboxCol2,0);
  create_tuple(&hv_BboxRow,0);
  create_tuple(&hv_BboxCol,0);
  create_tuple(&hv_BboxLength1,0);
  create_tuple(&hv_BboxLength2,0);
  create_tuple(&hv_BboxPhi,0);
  create_tuple(&hv_BboxLabels,0);
  create_tuple(&hv_Text,0);
  create_tuple(&hv_Ascent,0);
  create_tuple(&hv_Descent,0);
  create_tuple(&hv__,0);
  create_tuple(&hv_TextOffset,0);
  create_tuple(&hv_LabelRow,0);
  create_tuple(&hv_LabelCol,0);
  create_tuple(&hv_ArrowSizeFactorLength,0);
  create_tuple(&hv_ArrowSizeFactorHead,0);
  create_tuple(&hv_MaxLengthArrow,0);
  create_tuple(&hv_HalfLengthArrow,0);
  create_tuple(&hv_ArrowBaseRow,0);
  create_tuple(&hv_ArrowBaseCol,0);
  create_tuple(&hv_ArrowHeadRow,0);
  create_tuple(&hv_ArrowHeadCol,0);
  create_tuple(&hv_ArrowHeadSize,0);
  create_tuple(&hv_ContourStyle,0);
  create_tuple(&hv_Style,0);
  create_tuple(&hv_IndexBbox,0);
  create_tuple(&hv_ClassID,0);
  create_tuple(&hv_TextColorClasses,0);
  create_tuple(&(*hv_BboxIDs),0);

  /****************************************************/
  /******************   Begin procedure   *************/
  /****************************************************/

  /**/
  /*This procedure displays the ground truth bounding boxes and masks (if present) of a DLSample.*/
  /**/
  /*InstanceType := ''*/
  reuse_tuple_s(&hv_InstanceType,"");
  /*MaskExists := false*/
  reuse_tuple_i(&hv_MaskExists,0);

  /*========== if (find(SampleKeys,'bbox_row1') != -1) ==========*/
  create_tuple_s(&TTemp[SP++],"bbox_row1");
  T_tuple_find(hv_SampleKeys,TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-1]=TTemp[SP];
  create_tuple_i(&TTemp[SP++],-1);
  T_tuple_not_equal(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-2]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-2]=TTemp[SP];
  SP--;
  if(get_i(TTemp[SP-1],0))
  {
    /*get_dict_tuple (DLSample, 'bbox_row1', BboxRow1)*/
    create_tuple_s(&TTemp[SP++],"bbox_row1");
    destroy_tuple(hv_BboxRow1);
    /***/T_get_dict_tuple(hv_DLSample, TTemp[SP-1], &hv_BboxRow1);
    destroy_tuple(TTemp[--SP]);

    /*get_dict_tuple (DLSample, 'bbox_col1', BboxCol1)*/
    create_tuple_s(&TTemp[SP++],"bbox_col1");
    destroy_tuple(hv_BboxCol1);
    /***/T_get_dict_tuple(hv_DLSample, TTemp[SP-1], &hv_BboxCol1);
    destroy_tuple(TTemp[--SP]);

    /*get_dict_tuple (DLSample, 'bbox_row2', BboxRow2)*/
    create_tuple_s(&TTemp[SP++],"bbox_row2");
    destroy_tuple(hv_BboxRow2);
    /***/T_get_dict_tuple(hv_DLSample, TTemp[SP-1], &hv_BboxRow2);
    destroy_tuple(TTemp[--SP]);

    /*get_dict_tuple (DLSample, 'bbox_col2', BboxCol2)*/
    create_tuple_s(&TTemp[SP++],"bbox_col2");
    destroy_tuple(hv_BboxCol2);
    /***/T_get_dict_tuple(hv_DLSample, TTemp[SP-1], &hv_BboxCol2);
    destroy_tuple(TTemp[--SP]);

    /*InstanceType := 'rectangle1'*/
    reuse_tuple_s(&hv_InstanceType,"rectangle1");
  }
  else
  {
  destroy_tuple(TTemp[--SP]);
  /*========== elseif (find(SampleKeys,'bbox_phi') != -1) ==========*/

  create_tuple_s(&TTemp[SP++],"bbox_phi");
  T_tuple_find(hv_SampleKeys,TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-1]=TTemp[SP];
  create_tuple_i(&TTemp[SP++],-1);
  T_tuple_not_equal(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-2]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-2]=TTemp[SP];
  SP--;
  if(get_i(TTemp[SP-1],0))
  {
    /*get_dict_tuple (DLSample, 'bbox_row', BboxRow)*/
    create_tuple_s(&TTemp[SP++],"bbox_row");
    destroy_tuple(hv_BboxRow);
    /***/T_get_dict_tuple(hv_DLSample, TTemp[SP-1], &hv_BboxRow);
    destroy_tuple(TTemp[--SP]);

    /*get_dict_tuple (DLSample, 'bbox_col', BboxCol)*/
    create_tuple_s(&TTemp[SP++],"bbox_col");
    destroy_tuple(hv_BboxCol);
    /***/T_get_dict_tuple(hv_DLSample, TTemp[SP-1], &hv_BboxCol);
    destroy_tuple(TTemp[--SP]);

    /*get_dict_tuple (DLSample, 'bbox_length1', BboxLength1)*/
    create_tuple_s(&TTemp[SP++],"bbox_length1");
    destroy_tuple(hv_BboxLength1);
    /***/T_get_dict_tuple(hv_DLSample, TTemp[SP-1], &hv_BboxLength1);
    destroy_tuple(TTemp[--SP]);

    /*get_dict_tuple (DLSample, 'bbox_length2', BboxLength2)*/
    create_tuple_s(&TTemp[SP++],"bbox_length2");
    destroy_tuple(hv_BboxLength2);
    /***/T_get_dict_tuple(hv_DLSample, TTemp[SP-1], &hv_BboxLength2);
    destroy_tuple(TTemp[--SP]);

    /*get_dict_tuple (DLSample, 'bbox_phi', BboxPhi)*/
    create_tuple_s(&TTemp[SP++],"bbox_phi");
    destroy_tuple(hv_BboxPhi);
    /***/T_get_dict_tuple(hv_DLSample, TTemp[SP-1], &hv_BboxPhi);
    destroy_tuple(TTemp[--SP]);

    /*InstanceType := 'rectangle2'*/
    reuse_tuple_s(&hv_InstanceType,"rectangle2");
  }
  else
  {
    /* throw(...); only in hdevelop*/
  }
  }
  destroy_tuple(TTemp[--SP]);
  /*========== end if ==========*/
  /*========== if (find(SampleKeys,'mask') != -1) ==========*/
  create_tuple_s(&TTemp[SP++],"mask");
  T_tuple_find(hv_SampleKeys,TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-1]=TTemp[SP];
  create_tuple_i(&TTemp[SP++],-1);
  T_tuple_not_equal(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-2]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-2]=TTemp[SP];
  SP--;
  if(get_i(TTemp[SP-1],0))
  {
    /*get_dict_object (InstanceMask, DLSample, 'mask')*/
    create_tuple_s(&TTemp[SP++],"mask");
    clear_obj(ho_InstanceMask);
    /***/T_get_dict_object(&ho_InstanceMask, hv_DLSample, TTemp[SP-1]);
    destroy_tuple(TTemp[--SP]);

    /*MaskExists := true*/
    reuse_tuple_i(&hv_MaskExists,1);

  }
  destroy_tuple(TTemp[--SP]);
  /*========== end if ==========*/
  /*========== if (InstanceType != 'rectangle1' and InstanceType != 'rectangle2' and not MaskExists) ==========*/
  create_tuple_s(&TTemp[SP++],"rectangle1");
  T_tuple_not_equal(hv_InstanceType,TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-1]=TTemp[SP];
  create_tuple_s(&TTemp[SP++],"rectangle2");
  T_tuple_not_equal(hv_InstanceType,TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-1]=TTemp[SP];
  T_tuple_and(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-2]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-2]=TTemp[SP];
  SP--;
  T_tuple_not(hv_MaskExists,&TTemp[SP++]);
  T_tuple_and(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-2]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-2]=TTemp[SP];
  SP--;
  if(get_i(TTemp[SP-1],0))
  {
    /* throw(...); only in hdevelop*/
  }
  destroy_tuple(TTemp[--SP]);
  /*========== end if ==========*/
  /*get_dict_tuple (DLSample, 'bbox_label_id', BboxLabels)*/
  create_tuple_s(&TTemp[SP++],"bbox_label_id");
  destroy_tuple(hv_BboxLabels);
  /***/T_get_dict_tuple(hv_DLSample, TTemp[SP-1], &hv_BboxLabels);
  destroy_tuple(TTemp[--SP]);

  /*========== if (|BboxLabels| > 0) ==========*/
  T_tuple_length(hv_BboxLabels,&TTemp[SP++]);
  create_tuple_i(&TTemp[SP++],0);
  T_tuple_greater(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-2]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-2]=TTemp[SP];
  SP--;
  if(get_i(TTemp[SP-1],0))
  {
    /**/
    /*Get text and text size for correct positioning of label IDs.*/
    /*========== if (ShowLabels) ==========*/
    copy_tuple(hv_ShowLabels,&TTemp[SP++]);
    if(get_i(TTemp[SP-1],0))
    {
      /*Text := BboxLabels*/
      destroy_tuple(hv_Text);
      copy_tuple(hv_BboxLabels,&hv_Text);

      /*get_string_extents (WindowHandle, Text, Ascent, Descent, _, _)*/
      destroy_tuple(hv_Ascent);
      destroy_tuple(hv_Descent);
      destroy_tuple(hv__);
      /***/T_get_string_extents(hv_WindowHandle, hv_Text, &hv_Ascent, &hv_Descent, 
          &hv__, &(CExpDummyOCvar[0]));
      destroy_tuple(CExpDummyOCvar[0]);

      /*TextOffset := (Ascent + Descent) / WindowImageRatio*/
      T_tuple_add(hv_Ascent,hv_Descent,&TTemp[SP++]);
      T_tuple_div(TTemp[SP-1],hv_WindowImageRatio,&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      destroy_tuple(hv_TextOffset);
      hv_TextOffset=TTemp[--SP];

    }
    destroy_tuple(TTemp[--SP]);
    /*========== end if ==========*/
    /**/
    /*Generate bounding box XLDs.*/
    /*========== if (InstanceType == 'rectangle1') ==========*/
    create_tuple_s(&TTemp[SP++],"rectangle1");
    T_tuple_equal(hv_InstanceType,TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    if(get_i(TTemp[SP-1],0))
    {
      /*tuple_gen_const (|BboxRow1|, 0.0, BboxPhi)*/
      T_tuple_length(hv_BboxRow1,&TTemp[SP++]);
      create_tuple_d(&TTemp[SP++],0.0);
      destroy_tuple(hv_BboxPhi);
      /***/T_tuple_gen_const(TTemp[SP-2], TTemp[SP-1], &hv_BboxPhi);
      destroy_tuple(TTemp[--SP]);
      destroy_tuple(TTemp[--SP]);

      /*gen_rectangle2_contour_xld (BboxRectangle, 0.5 * (BboxRow1 + BboxRow2), 0.5 * (BboxCol1 + BboxCol2), BboxPhi, 0.5 * (BboxCol2 - BboxCol1), 0.5 * (BboxRow2 - BboxRow1))*/
      create_tuple_d(&TTemp[SP++],0.5);
      T_tuple_add(hv_BboxRow1,hv_BboxRow2,&TTemp[SP++]);
      T_tuple_mult(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-2]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-2]=TTemp[SP];
      SP--;
      create_tuple_d(&TTemp[SP++],0.5);
      T_tuple_add(hv_BboxCol1,hv_BboxCol2,&TTemp[SP++]);
      T_tuple_mult(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-2]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-2]=TTemp[SP];
      SP--;
      create_tuple_d(&TTemp[SP++],0.5);
      T_tuple_sub(hv_BboxCol2,hv_BboxCol1,&TTemp[SP++]);
      T_tuple_mult(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-2]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-2]=TTemp[SP];
      SP--;
      create_tuple_d(&TTemp[SP++],0.5);
      T_tuple_sub(hv_BboxRow2,hv_BboxRow1,&TTemp[SP++]);
      T_tuple_mult(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-2]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-2]=TTemp[SP];
      SP--;
      clear_obj(ho_BboxRectangle);
      /***/T_gen_rectangle2_contour_xld(&ho_BboxRectangle, TTemp[SP-4], TTemp[SP-3], 
          hv_BboxPhi, TTemp[SP-2], TTemp[SP-1]);
      destroy_tuple(TTemp[--SP]);
      destroy_tuple(TTemp[--SP]);
      destroy_tuple(TTemp[--SP]);
      destroy_tuple(TTemp[--SP]);

      /*========== if (ShowLabels) ==========*/
      copy_tuple(hv_ShowLabels,&TTemp[SP++]);
      if(get_i(TTemp[SP-1],0))
      {
        /*LabelRow := BboxRow1*/
        destroy_tuple(hv_LabelRow);
        copy_tuple(hv_BboxRow1,&hv_LabelRow);

        /*LabelCol := BboxCol1*/
        destroy_tuple(hv_LabelCol);
        copy_tuple(hv_BboxCol1,&hv_LabelCol);

      }
      destroy_tuple(TTemp[--SP]);
      /*========== end if ==========*/
    }
    else
    {
    destroy_tuple(TTemp[--SP]);
    /*========== elseif (InstanceType == 'rectangle2') ==========*/

    create_tuple_s(&TTemp[SP++],"rectangle2");
    T_tuple_equal(hv_InstanceType,TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    if(get_i(TTemp[SP-1],0))
    {
      /*gen_rectangle2_contour_xld (BboxRectangle, BboxRow, BboxCol, BboxPhi, BboxLength1, BboxLength2)*/
      clear_obj(ho_BboxRectangle);
      /***/T_gen_rectangle2_contour_xld(&ho_BboxRectangle, hv_BboxRow, hv_BboxCol, 
          hv_BboxPhi, hv_BboxLength1, hv_BboxLength2);

      /*========== if (ShowLabels) ==========*/
      copy_tuple(hv_ShowLabels,&TTemp[SP++]);
      if(get_i(TTemp[SP-1],0))
      {
        /*LabelRow := BboxRow - TextOffset*/
        T_tuple_sub(hv_BboxRow,hv_TextOffset,&TTemp[SP++]);
        destroy_tuple(hv_LabelRow);
        hv_LabelRow=TTemp[--SP];

        /*LabelCol := BboxCol*/
        destroy_tuple(hv_LabelCol);
        copy_tuple(hv_BboxCol,&hv_LabelCol);

      }
      destroy_tuple(TTemp[--SP]);
      /*========== end if ==========*/
      /*========== if (ShowDirection) ==========*/
      copy_tuple(hv_ShowDirection,&TTemp[SP++]);
      if(get_i(TTemp[SP-1],0))
      {
        /*========== if (ShowDirection == -1) ==========*/
        create_tuple_i(&TTemp[SP++],-1);
        T_tuple_equal(hv_ShowDirection,TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-1]=TTemp[SP];
        if(get_i(TTemp[SP-1],0))
        {
          /*ArrowSizeFactorLength := 0.4*/
          reuse_tuple_d(&hv_ArrowSizeFactorLength,0.4);

          /*ArrowSizeFactorHead := 0.2*/
          reuse_tuple_d(&hv_ArrowSizeFactorHead,0.2);

          /*MaxLengthArrow := 20*/
          reuse_tuple_i(&hv_MaxLengthArrow,20);

          /*HalfLengthArrow := min2(MaxLengthArrow,BboxLength1 * ArrowSizeFactorLength)*/
          T_tuple_mult(hv_BboxLength1,hv_ArrowSizeFactorLength,&TTemp[SP++]);
          T_tuple_min2(hv_MaxLengthArrow,TTemp[SP-1],&TTemp[SP]);
          destroy_tuple(TTemp[SP-1]);
          TTemp[SP-1]=TTemp[SP];
          destroy_tuple(hv_HalfLengthArrow);
          hv_HalfLengthArrow=TTemp[--SP];

          /*ArrowBaseRow := BboxRow - (BboxLength1 - HalfLengthArrow) * sin(BboxPhi)*/
          T_tuple_sub(hv_BboxLength1,hv_HalfLengthArrow,&TTemp[SP++]);
          T_tuple_sin(hv_BboxPhi,&TTemp[SP++]);
          T_tuple_mult(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
          destroy_tuple(TTemp[SP-2]);
          destroy_tuple(TTemp[SP-1]);
          TTemp[SP-2]=TTemp[SP];
          SP--;
          T_tuple_sub(hv_BboxRow,TTemp[SP-1],&TTemp[SP]);
          destroy_tuple(TTemp[SP-1]);
          TTemp[SP-1]=TTemp[SP];
          destroy_tuple(hv_ArrowBaseRow);
          hv_ArrowBaseRow=TTemp[--SP];

          /*ArrowBaseCol := BboxCol + (BboxLength1 - HalfLengthArrow) * cos(BboxPhi)*/
          T_tuple_sub(hv_BboxLength1,hv_HalfLengthArrow,&TTemp[SP++]);
          T_tuple_cos(hv_BboxPhi,&TTemp[SP++]);
          T_tuple_mult(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
          destroy_tuple(TTemp[SP-2]);
          destroy_tuple(TTemp[SP-1]);
          TTemp[SP-2]=TTemp[SP];
          SP--;
          T_tuple_add(hv_BboxCol,TTemp[SP-1],&TTemp[SP]);
          destroy_tuple(TTemp[SP-1]);
          TTemp[SP-1]=TTemp[SP];
          destroy_tuple(hv_ArrowBaseCol);
          hv_ArrowBaseCol=TTemp[--SP];

          /*ArrowHeadRow := BboxRow - (BboxLength1 + HalfLengthArrow) * sin(BboxPhi)*/
          T_tuple_add(hv_BboxLength1,hv_HalfLengthArrow,&TTemp[SP++]);
          T_tuple_sin(hv_BboxPhi,&TTemp[SP++]);
          T_tuple_mult(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
          destroy_tuple(TTemp[SP-2]);
          destroy_tuple(TTemp[SP-1]);
          TTemp[SP-2]=TTemp[SP];
          SP--;
          T_tuple_sub(hv_BboxRow,TTemp[SP-1],&TTemp[SP]);
          destroy_tuple(TTemp[SP-1]);
          TTemp[SP-1]=TTemp[SP];
          destroy_tuple(hv_ArrowHeadRow);
          hv_ArrowHeadRow=TTemp[--SP];

          /*ArrowHeadCol := BboxCol + (BboxLength1 + HalfLengthArrow) * cos(BboxPhi)*/
          T_tuple_add(hv_BboxLength1,hv_HalfLengthArrow,&TTemp[SP++]);
          T_tuple_cos(hv_BboxPhi,&TTemp[SP++]);
          T_tuple_mult(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
          destroy_tuple(TTemp[SP-2]);
          destroy_tuple(TTemp[SP-1]);
          TTemp[SP-2]=TTemp[SP];
          SP--;
          T_tuple_add(hv_BboxCol,TTemp[SP-1],&TTemp[SP]);
          destroy_tuple(TTemp[SP-1]);
          TTemp[SP-1]=TTemp[SP];
          destroy_tuple(hv_ArrowHeadCol);
          hv_ArrowHeadCol=TTemp[--SP];

          /*ArrowHeadSize := min2(MaxLengthArrow,min2(BboxLength1,BboxLength2)) * ArrowSizeFactorHead*/
          T_tuple_min2(hv_BboxLength1,hv_BboxLength2,&TTemp[SP++]);
          T_tuple_min2(hv_MaxLengthArrow,TTemp[SP-1],&TTemp[SP]);
          destroy_tuple(TTemp[SP-1]);
          TTemp[SP-1]=TTemp[SP];
          T_tuple_mult(TTemp[SP-1],hv_ArrowSizeFactorHead,&TTemp[SP]);
          destroy_tuple(TTemp[SP-1]);
          TTemp[SP-1]=TTemp[SP];
          destroy_tuple(hv_ArrowHeadSize);
          hv_ArrowHeadSize=TTemp[--SP];

        }
        else
        {
          /*ArrowHeadSize := 20.0*/
          reuse_tuple_d(&hv_ArrowHeadSize,20.0);

          /*ArrowBaseRow := BboxRow*/
          destroy_tuple(hv_ArrowBaseRow);
          copy_tuple(hv_BboxRow,&hv_ArrowBaseRow);

          /*ArrowBaseCol := BboxCol*/
          destroy_tuple(hv_ArrowBaseCol);
          copy_tuple(hv_BboxCol,&hv_ArrowBaseCol);

          /*ArrowHeadRow := BboxRow - (BboxLength1 + ArrowHeadSize) * sin(BboxPhi)*/
          T_tuple_add(hv_BboxLength1,hv_ArrowHeadSize,&TTemp[SP++]);
          T_tuple_sin(hv_BboxPhi,&TTemp[SP++]);
          T_tuple_mult(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
          destroy_tuple(TTemp[SP-2]);
          destroy_tuple(TTemp[SP-1]);
          TTemp[SP-2]=TTemp[SP];
          SP--;
          T_tuple_sub(hv_BboxRow,TTemp[SP-1],&TTemp[SP]);
          destroy_tuple(TTemp[SP-1]);
          TTemp[SP-1]=TTemp[SP];
          destroy_tuple(hv_ArrowHeadRow);
          hv_ArrowHeadRow=TTemp[--SP];

          /*ArrowHeadCol := BboxCol + (BboxLength1 + ArrowHeadSize) * cos(BboxPhi)*/
          T_tuple_add(hv_BboxLength1,hv_ArrowHeadSize,&TTemp[SP++]);
          T_tuple_cos(hv_BboxPhi,&TTemp[SP++]);
          T_tuple_mult(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
          destroy_tuple(TTemp[SP-2]);
          destroy_tuple(TTemp[SP-1]);
          TTemp[SP-2]=TTemp[SP];
          SP--;
          T_tuple_add(hv_BboxCol,TTemp[SP-1],&TTemp[SP]);
          destroy_tuple(TTemp[SP-1]);
          TTemp[SP-1]=TTemp[SP];
          destroy_tuple(hv_ArrowHeadCol);
          hv_ArrowHeadCol=TTemp[--SP];

        }
        destroy_tuple(TTemp[--SP]);
        /*========== end if ==========*/
        /*gen_arrow_contour_xld (OrientationArrows, ArrowBaseRow, ArrowBaseCol, ArrowHeadRow, ArrowHeadCol, ArrowHeadSize, ArrowHeadSize)*/
        clear_obj(ho_OrientationArrows);
        /***/gen_arrow_contour_xld(&ho_OrientationArrows, hv_ArrowBaseRow, hv_ArrowBaseCol, 
            hv_ArrowHeadRow, hv_ArrowHeadCol, hv_ArrowHeadSize, hv_ArrowHeadSize);

      }
      destroy_tuple(TTemp[--SP]);
      /*========== end if ==========*/
    }
    else
    {
    destroy_tuple(TTemp[--SP]);
    /*========== elseif (MaskExists) ==========*/

    copy_tuple(hv_MaskExists,&TTemp[SP++]);
    if(get_i(TTemp[SP-1],0))
    {
      /*========== if (ShowLabels) ==========*/
      copy_tuple(hv_ShowLabels,&TTemp[SP++]);
      if(get_i(TTemp[SP-1],0))
      {
        /*area_center (InstanceMask, _, LabelRow, LabelCol)*/
        destroy_tuple(hv__);
        destroy_tuple(hv_LabelRow);
        destroy_tuple(hv_LabelCol);
        /***/T_area_center(ho_InstanceMask, &hv__, &hv_LabelRow, &hv_LabelCol);

      }
      destroy_tuple(TTemp[--SP]);
      /*========== end if ==========*/
    }
    else
    {
      /* throw(...); only in hdevelop*/
    }
    }
    }
    destroy_tuple(TTemp[--SP]);
    /*========== end if ==========*/
    /**/
    /*Collect the ClassIDs of the bounding boxes.*/
    /*tuple_gen_const (|BboxLabels|, 0, BboxIDs)*/
    T_tuple_length(hv_BboxLabels,&TTemp[SP++]);
    create_tuple_i(&TTemp[SP++],0);
    destroy_tuple((*hv_BboxIDs));
    /***/T_tuple_gen_const(TTemp[SP-2], TTemp[SP-1], &(*hv_BboxIDs));
    destroy_tuple(TTemp[--SP]);
    destroy_tuple(TTemp[--SP]);

    /**/
    /*Draw the bounding boxes.*/
    /*get_contour_style (WindowHandle, ContourStyle)*/
    destroy_tuple(hv_ContourStyle);
    /***/T_get_contour_style(hv_WindowHandle, &hv_ContourStyle);

    if (hdev_window_stack_is_open())
    {
      Htuple active_win;
      create_tuple(&active_win,0);
      hdev_window_stack_get_active(&active_win);
      /*dev_set_contour_style ('stroke_and_fill')*/
      create_tuple_s(&TTemp[SP++],"stroke_and_fill");
      /***/T_set_contour_style(active_win,TTemp[SP-1]);
      destroy_tuple(TTemp[--SP]);
      destroy_tuple(active_win);
    }
    /*get_line_style (WindowHandle, Style)*/
    destroy_tuple(hv_Style);
    /***/T_get_line_style(hv_WindowHandle, &hv_Style);

    if (hdev_window_stack_is_open())
    {
      Htuple active_win;
      create_tuple(&active_win,0);
      hdev_window_stack_get_active(&active_win);
      /*dev_set_line_width (LineWidthBbox)*/
      /***/T_set_line_width(active_win,hv_LineWidthBbox);
      destroy_tuple(active_win);
    }
    /*========== for IndexBbox := 0 to |BboxLabels| - 1 by 1 ==========*/
    T_tuple_length(hv_BboxLabels,&TTemp[SP++]);
    create_tuple_i(&TTemp[SP++],1);
    T_tuple_sub(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-2]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-2]=TTemp[SP];
    SP--;
    create_tuple_i(&TTemp[SP++],1);
    create_tuple_i(&TTemp[SP++],0);
    T_tuple_greater(TTemp[SP-1],TTemp[SP-3],&TTemp[SP]);
    SP++;
    T_tuple_equal(TTemp[SP-2],TTemp[SP-4],&TTemp[SP]);
    if(get_i(TTemp[SP],0) ||
       (!((( get_i(TTemp[SP-1],0)) && (get_d(TTemp[SP-3],0)>0)) ||
          ((!get_i(TTemp[SP-1],0)) && (get_d(TTemp[SP-3],0)<0)))))
    {
     destroy_tuple(TTemp[SP--]);
     destroy_tuple(TTemp[SP]);
     T_tuple_sub(TTemp[SP-1],TTemp[SP-2],&TTemp[SP]);
     destroy_tuple(hv_IndexBbox);
     copy_tuple(TTemp[SP],&hv_IndexBbox);
     destroy_tuple(TTemp[SP--]);
     destroy_tuple(TTemp[SP]);
     for(;;)
     {
     T_tuple_add(hv_IndexBbox,TTemp[SP-1],&TTemp[SP]);
     destroy_tuple(hv_IndexBbox);
     copy_tuple(TTemp[SP],&hv_IndexBbox);
     destroy_tuple(TTemp[SP]);
     if(get_d(TTemp[SP-1],0)<0)
      T_tuple_less(hv_IndexBbox,TTemp[SP-2],&TTemp[SP]);
     else
      T_tuple_greater(hv_IndexBbox,TTemp[SP-2],&TTemp[SP]);
     if(get_i(TTemp[SP],0)) break;
     destroy_tuple(TTemp[SP]);
     /*========== for ==========*/

      /*select_obj (BboxRectangle, RectangleSelected, IndexBbox + 1)*/
      create_tuple_i(&TTemp[SP++],1);
      T_tuple_add(hv_IndexBbox,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      clear_obj(ho_RectangleSelected);
      /***/T_select_obj(ho_BboxRectangle, &ho_RectangleSelected, TTemp[SP-1]);
      destroy_tuple(TTemp[--SP]);

      /*ClassID := find(ClassIDs,BboxLabels[IndexBbox])*/
      T_tuple_select(hv_BboxLabels,hv_IndexBbox,&TTemp[SP++]);
      T_tuple_find(hv_ClassIDs,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      destroy_tuple(hv_ClassID);
      hv_ClassID=TTemp[--SP];

      /*BboxIDs[IndexBbox] := ClassID*/
      replace_elements(&(*hv_BboxIDs),&hv_IndexBbox,&hv_ClassID);
      if (hdev_window_stack_is_open())
      {
        Htuple active_win;
        create_tuple(&active_win,0);
        hdev_window_stack_get_active(&active_win);
        /*dev_set_color (BboxColors[ClassID] + '60')*/
        T_tuple_select(hv_BboxColors,hv_ClassID,&TTemp[SP++]);
        create_tuple_s(&TTemp[SP++],"60");
        T_tuple_add(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-2]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-2]=TTemp[SP];
        SP--;
        /***/T_set_color(active_win,TTemp[SP-1]);
        destroy_tuple(TTemp[--SP]);
        destroy_tuple(active_win);
      }
      /*========== if (MaskExists) ==========*/
      copy_tuple(hv_MaskExists,&TTemp[SP++]);
      if(get_i(TTemp[SP-1],0))
      {
        if (hdev_window_stack_is_open())
        {
          Htuple active_win;
          create_tuple(&active_win,0);
          hdev_window_stack_get_active(&active_win);
          /*dev_set_draw ('fill')*/
          create_tuple_s(&TTemp[SP++],"fill");
          /***/T_set_draw(active_win,TTemp[SP-1]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(active_win);
        }
        /*select_obj (InstanceMask, MaskSelected, IndexBbox + 1)*/
        create_tuple_i(&TTemp[SP++],1);
        T_tuple_add(hv_IndexBbox,TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-1]=TTemp[SP];
        clear_obj(ho_MaskSelected);
        /***/T_select_obj(ho_InstanceMask, &ho_MaskSelected, TTemp[SP-1]);
        destroy_tuple(TTemp[--SP]);

        if (hdev_window_stack_is_open())
        {
          Htuple active_win;
          create_tuple(&active_win,0);
          hdev_window_stack_get_active(&active_win);
          /*dev_display (MaskSelected)*/
          /***/T_disp_obj(ho_MaskSelected, active_win);
          destroy_tuple(active_win);
        }
        if (hdev_window_stack_is_open())
        {
          Htuple active_win;
          create_tuple(&active_win,0);
          hdev_window_stack_get_active(&active_win);
          /*dev_set_contour_style ('stroke')*/
          create_tuple_s(&TTemp[SP++],"stroke");
          /***/T_set_contour_style(active_win,TTemp[SP-1]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(active_win);
        }
      }
      destroy_tuple(TTemp[--SP]);
      /*========== end if ==========*/
      /*========== if (InstanceType != '') ==========*/
      create_tuple_s(&TTemp[SP++],"");
      T_tuple_not_equal(hv_InstanceType,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      if(get_i(TTemp[SP-1],0))
      {
        /*select_obj (BboxRectangle, RectangleSelected, IndexBbox + 1)*/
        create_tuple_i(&TTemp[SP++],1);
        T_tuple_add(hv_IndexBbox,TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-1]=TTemp[SP];
        clear_obj(ho_RectangleSelected);
        /***/T_select_obj(ho_BboxRectangle, &ho_RectangleSelected, TTemp[SP-1]);
        destroy_tuple(TTemp[--SP]);

        if (hdev_window_stack_is_open())
        {
          Htuple active_win;
          create_tuple(&active_win,0);
          hdev_window_stack_get_active(&active_win);
          /*dev_display (RectangleSelected)*/
          /***/T_disp_obj(ho_RectangleSelected, active_win);
          destroy_tuple(active_win);
        }
        /*========== if (InstanceType == 'rectangle2' and ShowDirection) ==========*/
        create_tuple_s(&TTemp[SP++],"rectangle2");
        T_tuple_equal(hv_InstanceType,TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-1]=TTemp[SP];
        T_tuple_and(TTemp[SP-1],hv_ShowDirection,&TTemp[SP]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-1]=TTemp[SP];
        if(get_i(TTemp[SP-1],0))
        {
          /*select_obj (OrientationArrows, ArrowSelected, IndexBbox + 1)*/
          create_tuple_i(&TTemp[SP++],1);
          T_tuple_add(hv_IndexBbox,TTemp[SP-1],&TTemp[SP]);
          destroy_tuple(TTemp[SP-1]);
          TTemp[SP-1]=TTemp[SP];
          clear_obj(ho_ArrowSelected);
          /***/T_select_obj(ho_OrientationArrows, &ho_ArrowSelected, TTemp[SP-1]);
          destroy_tuple(TTemp[--SP]);

          if (hdev_window_stack_is_open())
          {
            Htuple active_win;
            create_tuple(&active_win,0);
            hdev_window_stack_get_active(&active_win);
            /*dev_set_color (BboxColors[ClassID] + 'FF')*/
            T_tuple_select(hv_BboxColors,hv_ClassID,&TTemp[SP++]);
            create_tuple_s(&TTemp[SP++],"FF");
            T_tuple_add(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
            destroy_tuple(TTemp[SP-2]);
            destroy_tuple(TTemp[SP-1]);
            TTemp[SP-2]=TTemp[SP];
            SP--;
            /***/T_set_color(active_win,TTemp[SP-1]);
            destroy_tuple(TTemp[--SP]);
            destroy_tuple(active_win);
          }
          if (hdev_window_stack_is_open())
          {
            Htuple active_win;
            create_tuple(&active_win,0);
            hdev_window_stack_get_active(&active_win);
            /*dev_display (ArrowSelected)*/
            /***/T_disp_obj(ho_ArrowSelected, active_win);
            destroy_tuple(active_win);
          }
          if (hdev_window_stack_is_open())
          {
            Htuple active_win;
            create_tuple(&active_win,0);
            hdev_window_stack_get_active(&active_win);
            /*dev_set_color (BboxColors[ClassID] + '60')*/
            T_tuple_select(hv_BboxColors,hv_ClassID,&TTemp[SP++]);
            create_tuple_s(&TTemp[SP++],"60");
            T_tuple_add(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
            destroy_tuple(TTemp[SP-2]);
            destroy_tuple(TTemp[SP-1]);
            TTemp[SP-2]=TTemp[SP];
            SP--;
            /***/T_set_color(active_win,TTemp[SP-1]);
            destroy_tuple(TTemp[--SP]);
            destroy_tuple(active_win);
          }
        }
        destroy_tuple(TTemp[--SP]);
        /*========== end if ==========*/
      }
      destroy_tuple(TTemp[--SP]);
      /*========== end if ==========*/
     }
     destroy_tuple(TTemp[SP--]);
     destroy_tuple(TTemp[SP--]);
     destroy_tuple(TTemp[SP]);
    }
    else
    {
     destroy_tuple(TTemp[SP--]);
     destroy_tuple(TTemp[SP--]);
     destroy_tuple(TTemp[SP--]);
     destroy_tuple(TTemp[SP--]);
     destroy_tuple(TTemp[SP]);
    }/*========== end for ========*/

    /**/
    /*Write text to the bounding boxes.*/
    /*========== if (ShowLabels) ==========*/
    copy_tuple(hv_ShowLabels,&TTemp[SP++]);
    if(get_i(TTemp[SP-1],0))
    {
      /*For better visibility the text is displayed after all bounding boxes are drawn.*/
      /*Select text color.*/
      /*========== if (TextColor == '') ==========*/
      create_tuple_s(&TTemp[SP++],"");
      T_tuple_equal(hv_TextColor,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      if(get_i(TTemp[SP-1],0))
      {
        /*TextColorClasses := BboxColors[BboxIDs]*/
        T_tuple_select(hv_BboxColors,(*hv_BboxIDs),&TTemp[SP++]);
        destroy_tuple(hv_TextColorClasses);
        hv_TextColorClasses=TTemp[--SP];

      }
      else
      {
        /*tuple_gen_const (|BboxIDs|, TextColor, TextColorClasses)*/
        T_tuple_length((*hv_BboxIDs),&TTemp[SP++]);
        destroy_tuple(hv_TextColorClasses);
        /***/T_tuple_gen_const(TTemp[SP-1], hv_TextColor, &hv_TextColorClasses);
        destroy_tuple(TTemp[--SP]);

      }
      destroy_tuple(TTemp[--SP]);
      /*========== end if ==========*/
      /*Display text.*/
      if (hdev_window_stack_is_open())
      {
        Htuple active_win;
        create_tuple(&active_win,0);
        hdev_window_stack_get_active(&active_win);
        /*dev_disp_text (BboxLabels, 'image', LabelRow, LabelCol, TextColorClasses, ['box_color', 'shadow', 'border_radius'], [BboxLabelColor,'false', 0])*/
        create_tuple_s(&TTemp[SP++],"image");
        create_tuple(&TTemp[SP++],3);
        set_s(TTemp[SP-1],"box_color",0);
        set_s(TTemp[SP-1],"shadow",1);
        set_s(TTemp[SP-1],"border_radius",2);
        create_tuple(&TTemp[SP++],2);
        set_s(TTemp[SP-1],"false",0);
        set_i(TTemp[SP-1],0        ,1);
        T_tuple_concat(hv_BboxLabelColor,TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-1]=TTemp[SP];
        /***/T_disp_text(active_win,hv_BboxLabels, TTemp[SP-3], hv_LabelRow, hv_LabelCol, 
            hv_TextColorClasses, TTemp[SP-2], TTemp[SP-1]);
        destroy_tuple(TTemp[--SP]);
        destroy_tuple(TTemp[--SP]);
        destroy_tuple(TTemp[--SP]);
        destroy_tuple(active_win);
      }
    }
    destroy_tuple(TTemp[--SP]);
    /*========== end if ==========*/
    /**/
    if (hdev_window_stack_is_open())
    {
      Htuple active_win;
      create_tuple(&active_win,0);
      hdev_window_stack_get_active(&active_win);
      /*dev_set_contour_style (ContourStyle)*/
      /***/T_set_contour_style(active_win,hv_ContourStyle);
      destroy_tuple(active_win);
    }
    /*set_line_style (WindowHandle, Style)*/
    /***/T_set_line_style(hv_WindowHandle, hv_Style);

  }
  else
  {
    /*Do nothing if there are no ground truth bounding boxes.*/
    /*BboxIDs := []*/
    create_tuple(&TTemp[SP++],0);
    destroy_tuple((*hv_BboxIDs));
    (*hv_BboxIDs)=TTemp[--SP];

  }
  destroy_tuple(TTemp[--SP]);
  /*========== end if ==========*/
  /**/
  /*========== return ==========*/

  /* Clear temporary tuple stack */
  while (SP > 0)
    destroy_tuple(TTemp[--SP]);
  /* Clear temporary tuple vectors stack*/
  while (SPTV > 0)
    V_destroy_vector(TVTemp[--SPTV]);
  /* Clear local iconic variables */
  clear_obj(ho_InstanceMask);
  clear_obj(ho_BboxRectangle);
  clear_obj(ho_OrientationArrows);
  clear_obj(ho_RectangleSelected);
  clear_obj(ho_MaskSelected);
  clear_obj(ho_ArrowSelected);

  /* Clear local control variables */
  destroy_tuple(hv_InstanceType);
  destroy_tuple(hv_MaskExists);
  destroy_tuple(hv_BboxRow1);
  destroy_tuple(hv_BboxCol1);
  destroy_tuple(hv_BboxRow2);
  destroy_tuple(hv_BboxCol2);
  destroy_tuple(hv_BboxRow);
  destroy_tuple(hv_BboxCol);
  destroy_tuple(hv_BboxLength1);
  destroy_tuple(hv_BboxLength2);
  destroy_tuple(hv_BboxPhi);
  destroy_tuple(hv_BboxLabels);
  destroy_tuple(hv_Text);
  destroy_tuple(hv_Ascent);
  destroy_tuple(hv_Descent);
  destroy_tuple(hv__);
  destroy_tuple(hv_TextOffset);
  destroy_tuple(hv_LabelRow);
  destroy_tuple(hv_LabelCol);
  destroy_tuple(hv_ArrowSizeFactorLength);
  destroy_tuple(hv_ArrowSizeFactorHead);
  destroy_tuple(hv_MaxLengthArrow);
  destroy_tuple(hv_HalfLengthArrow);
  destroy_tuple(hv_ArrowBaseRow);
  destroy_tuple(hv_ArrowBaseCol);
  destroy_tuple(hv_ArrowHeadRow);
  destroy_tuple(hv_ArrowHeadCol);
  destroy_tuple(hv_ArrowHeadSize);
  destroy_tuple(hv_ContourStyle);
  destroy_tuple(hv_Style);
  destroy_tuple(hv_IndexBbox);
  destroy_tuple(hv_ClassID);
  destroy_tuple(hv_TextColorClasses);

  return;

  /****************************************************/
  /******************     End procedure   *************/
  /****************************************************/

}

/* Chapter: Graphics / Output*/
/* Short Description: Display a color bar next to an image. */
void dev_display_map_color_bar (Htuple hv_ImageWidth, Htuple hv_ImageHeight, Htuple hv_MapColorBarWidth, 
    Htuple hv_Colors, Htuple hv_MaxValue, Htuple hv_WindowImageRatio, Htuple hv_WindowHandle)
{

  /* Stack for temporary tuples */
  Htuple   TTemp[100];
  int      SP=0;
  /* Stack for temporary tuple vectors */
  Hvector  TVTemp[100] = {0};
  int      SPTV=0;

  /* Local iconic variables */
  Hobject  ho_Rectangle;

  /* Local control variables */
  Htuple  hv_ClipRegion, hv_ColorIndex, hv_RectHeight;
  Htuple  hv_DrawMode, hv_Row, hv_Row1, hv_Column1, hv_Row2;
  Htuple  hv_Column2, hv__, hv_TextHeight, hv_Index, hv_Text;

  /* Array for temporary output ctrl variables */
  Htuple  CExpDummyOCvar[3];

  /* Initialize iconic variables */
  gen_empty_obj(&ho_Rectangle);

  /* Initialize control variables */
  create_tuple(&hv_ClipRegion,0);
  create_tuple(&hv_ColorIndex,0);
  create_tuple(&hv_RectHeight,0);
  create_tuple(&hv_DrawMode,0);
  create_tuple(&hv_Row,0);
  create_tuple(&hv_Row1,0);
  create_tuple(&hv_Column1,0);
  create_tuple(&hv_Row2,0);
  create_tuple(&hv_Column2,0);
  create_tuple(&hv__,0);
  create_tuple(&hv_TextHeight,0);
  create_tuple(&hv_Index,0);
  create_tuple(&hv_Text,0);

  /****************************************************/
  /******************   Begin procedure   *************/
  /****************************************************/

  /**/
  /*This procedure displays a color bar next to the image*/
  /*specified with ImageWidth and ImageHeight.*/
  /**/
  /*get_system ('clip_region', ClipRegion)*/
  create_tuple_s(&TTemp[SP++],"clip_region");
  destroy_tuple(hv_ClipRegion);
  /***/T_get_system(TTemp[SP-1], &hv_ClipRegion);
  destroy_tuple(TTemp[--SP]);

  /*set_system ('clip_region', 'false')*/
  /***/set_system("clip_region", "false");

  /**/
  /*Display the color bar.*/
  /*ColorIndex := 0*/
  reuse_tuple_i(&hv_ColorIndex,0);

  /*RectHeight := 1.0 * ImageHeight / |Colors|*/
  create_tuple_d(&TTemp[SP++],1.0);
  T_tuple_mult(TTemp[SP-1],hv_ImageHeight,&TTemp[SP]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-1]=TTemp[SP];
  T_tuple_length(hv_Colors,&TTemp[SP++]);
  T_tuple_div(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-2]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-2]=TTemp[SP];
  SP--;
  destroy_tuple(hv_RectHeight);
  hv_RectHeight=TTemp[--SP];

  /*Set draw mode to fill*/
  /*get_draw (WindowHandle, DrawMode)*/
  destroy_tuple(hv_DrawMode);
  /***/T_get_draw(hv_WindowHandle, &hv_DrawMode);

  if (hdev_window_stack_is_open())
  {
    Htuple active_win;
    create_tuple(&active_win,0);
    hdev_window_stack_get_active(&active_win);
    /*dev_set_draw ('fill')*/
    create_tuple_s(&TTemp[SP++],"fill");
    /***/T_set_draw(active_win,TTemp[SP-1]);
    destroy_tuple(TTemp[--SP]);
    destroy_tuple(active_win);
  }
  /*========== for Row := ImageHeight - 1 to 0 by -RectHeight ==========*/
  create_tuple_i(&TTemp[SP++],0);
  T_tuple_neg(hv_RectHeight,&TTemp[SP++]);
  create_tuple_i(&TTemp[SP++],1);
  T_tuple_sub(hv_ImageHeight,TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-1]=TTemp[SP];
  T_tuple_greater(TTemp[SP-1],TTemp[SP-3],&TTemp[SP]);
  SP++;
  T_tuple_equal(TTemp[SP-2],TTemp[SP-4],&TTemp[SP]);
  if(get_i(TTemp[SP],0) ||
     (!((( get_i(TTemp[SP-1],0)) && (get_d(TTemp[SP-3],0)>0)) ||
        ((!get_i(TTemp[SP-1],0)) && (get_d(TTemp[SP-3],0)<0)))))
  {
   destroy_tuple(TTemp[SP--]);
   destroy_tuple(TTemp[SP]);
   T_tuple_sub(TTemp[SP-1],TTemp[SP-2],&TTemp[SP]);
   destroy_tuple(hv_Row);
   copy_tuple(TTemp[SP],&hv_Row);
   destroy_tuple(TTemp[SP--]);
   destroy_tuple(TTemp[SP]);
   for(;;)
   {
   T_tuple_add(hv_Row,TTemp[SP-1],&TTemp[SP]);
   destroy_tuple(hv_Row);
   copy_tuple(TTemp[SP],&hv_Row);
   destroy_tuple(TTemp[SP]);
   if(get_d(TTemp[SP-1],0)<0)
    T_tuple_less(hv_Row,TTemp[SP-2],&TTemp[SP]);
   else
    T_tuple_greater(hv_Row,TTemp[SP-2],&TTemp[SP]);
   if(get_i(TTemp[SP],0)) break;
   destroy_tuple(TTemp[SP]);
   /*========== for ==========*/

    /*The color bar consists of multiple rectangle1.*/
    /*Row1 := Row - RectHeight*/
    T_tuple_sub(hv_Row,hv_RectHeight,&TTemp[SP++]);
    destroy_tuple(hv_Row1);
    hv_Row1=TTemp[--SP];

    /*Column1 := ImageWidth + 20 / WindowImageRatio*/
    create_tuple_i(&TTemp[SP++],20);
    T_tuple_div(TTemp[SP-1],hv_WindowImageRatio,&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    T_tuple_add(hv_ImageWidth,TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    destroy_tuple(hv_Column1);
    hv_Column1=TTemp[--SP];

    /*Row2 := Row*/
    destroy_tuple(hv_Row2);
    copy_tuple(hv_Row,&hv_Row2);

    /*Column2 := ImageWidth + 20 + MapColorBarWidth / WindowImageRatio*/
    create_tuple_i(&TTemp[SP++],20);
    T_tuple_add(hv_ImageWidth,TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    T_tuple_div(hv_MapColorBarWidth,hv_WindowImageRatio,&TTemp[SP++]);
    T_tuple_add(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-2]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-2]=TTemp[SP];
    SP--;
    destroy_tuple(hv_Column2);
    hv_Column2=TTemp[--SP];

    /*gen_rectangle1 (Rectangle, Row1, Column1, Row2, Column2)*/
    clear_obj(ho_Rectangle);
    /***/T_gen_rectangle1(&ho_Rectangle, hv_Row1, hv_Column1, hv_Row2, hv_Column2);

    if (hdev_window_stack_is_open())
    {
      Htuple active_win;
      create_tuple(&active_win,0);
      hdev_window_stack_get_active(&active_win);
      /*dev_set_color (Colors[ColorIndex])*/
      T_tuple_select(hv_Colors,hv_ColorIndex,&TTemp[SP++]);
      /***/T_set_color(active_win,TTemp[SP-1]);
      destroy_tuple(TTemp[--SP]);
      destroy_tuple(active_win);
    }
    if (hdev_window_stack_is_open())
    {
      Htuple active_win;
      create_tuple(&active_win,0);
      hdev_window_stack_get_active(&active_win);
      /*dev_display (Rectangle)*/
      /***/T_disp_obj(ho_Rectangle, active_win);
      destroy_tuple(active_win);
    }
    /*ColorIndex := ColorIndex + 1*/
    create_tuple_i(&TTemp[SP++],1);
    T_tuple_add(hv_ColorIndex,TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(hv_ColorIndex);
    hv_ColorIndex=TTemp[SP];
    destroy_tuple(TTemp[--SP]);

   }
   destroy_tuple(TTemp[SP--]);
   destroy_tuple(TTemp[SP--]);
   destroy_tuple(TTemp[SP]);
  }
  else
  {
   destroy_tuple(TTemp[SP--]);
   destroy_tuple(TTemp[SP--]);
   destroy_tuple(TTemp[SP--]);
   destroy_tuple(TTemp[SP--]);
   destroy_tuple(TTemp[SP]);
  }/*========== end for ========*/

  /**/
  /*Display labels for color bar.*/
  /*get_string_extents (WindowHandle, '0123456789', _, _, _, TextHeight)*/
  create_tuple_s(&TTemp[SP++],"0123456789");
  destroy_tuple(hv__);
  destroy_tuple(hv_TextHeight);
  /***/T_get_string_extents(hv_WindowHandle, TTemp[SP-1], &hv__, &(CExpDummyOCvar[0]), 
      &(CExpDummyOCvar[1]), &hv_TextHeight);
  destroy_tuple(TTemp[--SP]);
  destroy_tuple(CExpDummyOCvar[0]);
  destroy_tuple(CExpDummyOCvar[1]);

  /*========== for Index := 0 to 1 by 0.2 ==========*/
  create_tuple_i(&TTemp[SP++],1);
  create_tuple_d(&TTemp[SP++],0.2);
  create_tuple_i(&TTemp[SP++],0);
  T_tuple_greater(TTemp[SP-1],TTemp[SP-3],&TTemp[SP]);
  SP++;
  T_tuple_equal(TTemp[SP-2],TTemp[SP-4],&TTemp[SP]);
  if(get_i(TTemp[SP],0) ||
     (!((( get_i(TTemp[SP-1],0)) && (get_d(TTemp[SP-3],0)>0)) ||
        ((!get_i(TTemp[SP-1],0)) && (get_d(TTemp[SP-3],0)<0)))))
  {
   destroy_tuple(TTemp[SP--]);
   destroy_tuple(TTemp[SP]);
   T_tuple_sub(TTemp[SP-1],TTemp[SP-2],&TTemp[SP]);
   destroy_tuple(hv_Index);
   copy_tuple(TTemp[SP],&hv_Index);
   destroy_tuple(TTemp[SP--]);
   destroy_tuple(TTemp[SP]);
   for(;;)
   {
   T_tuple_add(hv_Index,TTemp[SP-1],&TTemp[SP]);
   destroy_tuple(hv_Index);
   copy_tuple(TTemp[SP],&hv_Index);
   destroy_tuple(TTemp[SP]);
   if(get_d(TTemp[SP-1],0)<0)
    T_tuple_less(hv_Index,TTemp[SP-2],&TTemp[SP]);
   else
    T_tuple_greater(hv_Index,TTemp[SP-2],&TTemp[SP]);
   if(get_i(TTemp[SP],0)) break;
   destroy_tuple(TTemp[SP]);
   /*========== for ==========*/

    /*Text := (MaxValue - Index * MaxValue)$'.1f'*/
    T_tuple_mult(hv_Index,hv_MaxValue,&TTemp[SP++]);
    T_tuple_sub(hv_MaxValue,TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    create_tuple_s(&TTemp[SP++],".1f");
    T_tuple_string(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-2]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-2]=TTemp[SP];
    SP--;
    destroy_tuple(hv_Text);
    hv_Text=TTemp[--SP];

    if (hdev_window_stack_is_open())
    {
      Htuple active_win;
      create_tuple(&active_win,0);
      hdev_window_stack_get_active(&active_win);
      /*dev_disp_text (Text, 'image', Index * (ImageHeight - 2 * (TextHeight / WindowImageRatio)), ImageWidth + 40 / WindowImageRatio, 'black', 'box', 'false')*/
      create_tuple_s(&TTemp[SP++],"image");
      create_tuple_i(&TTemp[SP++],2);
      T_tuple_div(hv_TextHeight,hv_WindowImageRatio,&TTemp[SP++]);
      T_tuple_mult(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-2]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-2]=TTemp[SP];
      SP--;
      T_tuple_sub(hv_ImageHeight,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      T_tuple_mult(hv_Index,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      create_tuple_i(&TTemp[SP++],40);
      T_tuple_div(TTemp[SP-1],hv_WindowImageRatio,&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      T_tuple_add(hv_ImageWidth,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      create_tuple_s(&TTemp[SP++],"black");
      create_tuple_s(&TTemp[SP++],"box");
      create_tuple_s(&TTemp[SP++],"false");
      /***/T_disp_text(active_win,hv_Text, TTemp[SP-6], TTemp[SP-5], TTemp[SP-4], 
          TTemp[SP-3], TTemp[SP-2], TTemp[SP-1]);
      destroy_tuple(TTemp[--SP]);
      destroy_tuple(TTemp[--SP]);
      destroy_tuple(TTemp[--SP]);
      destroy_tuple(TTemp[--SP]);
      destroy_tuple(TTemp[--SP]);
      destroy_tuple(TTemp[--SP]);
      destroy_tuple(active_win);
    }
   }
   destroy_tuple(TTemp[SP--]);
   destroy_tuple(TTemp[SP--]);
   destroy_tuple(TTemp[SP]);
  }
  else
  {
   destroy_tuple(TTemp[SP--]);
   destroy_tuple(TTemp[SP--]);
   destroy_tuple(TTemp[SP--]);
   destroy_tuple(TTemp[SP--]);
   destroy_tuple(TTemp[SP]);
  }/*========== end for ========*/

  /**/
  /*set_system ('clip_region', ClipRegion)*/
  create_tuple_s(&TTemp[SP++],"clip_region");
  /***/T_set_system(TTemp[SP-1], hv_ClipRegion);
  destroy_tuple(TTemp[--SP]);

  if (hdev_window_stack_is_open())
  {
    Htuple active_win;
    create_tuple(&active_win,0);
    hdev_window_stack_get_active(&active_win);
    /*dev_set_draw (DrawMode)*/
    /***/T_set_draw(active_win,hv_DrawMode);
    destroy_tuple(active_win);
  }
  /*========== return ==========*/

  /* Clear temporary tuple stack */
  while (SP > 0)
    destroy_tuple(TTemp[--SP]);
  /* Clear temporary tuple vectors stack*/
  while (SPTV > 0)
    V_destroy_vector(TVTemp[--SPTV]);
  /* Clear local iconic variables */
  clear_obj(ho_Rectangle);

  /* Clear local control variables */
  destroy_tuple(hv_ClipRegion);
  destroy_tuple(hv_ColorIndex);
  destroy_tuple(hv_RectHeight);
  destroy_tuple(hv_DrawMode);
  destroy_tuple(hv_Row);
  destroy_tuple(hv_Row1);
  destroy_tuple(hv_Column1);
  destroy_tuple(hv_Row2);
  destroy_tuple(hv_Column2);
  destroy_tuple(hv__);
  destroy_tuple(hv_TextHeight);
  destroy_tuple(hv_Index);
  destroy_tuple(hv_Text);

  return;

  /****************************************************/
  /******************     End procedure   *************/
  /****************************************************/

}

/* Chapter: Deep Learning / Anomaly Detection and Global Context Anomaly Detection*/
/* Short Description: Display the detected anomaly regions. */
void dev_display_result_anomaly_regions (Hobject ho_AnomalyRegion, Htuple hv_CurrentWindowHandle, 
    Htuple hv_LineWidth, Htuple hv_AnomalyRegionResultColor)
{


  /* Stack for temporary tuples */
  Htuple   TTemp[100];
  int      SP=0;
  /* Stack for temporary tuple vectors */
  Hvector  TVTemp[100] = {0};
  int      SPTV=0;

  /* Local iconic variables */

  /* Local control variables */
  Htuple  hv_Red, hv_Green, hv_Blue, hv_Alpha, hv_InitialColor;
  Htuple  hv_IndexColor, hv_Color_RGBA, hv_Area;

  /* Initialize control variables */
  create_tuple(&hv_Red,0);
  create_tuple(&hv_Green,0);
  create_tuple(&hv_Blue,0);
  create_tuple(&hv_Alpha,0);
  create_tuple(&hv_InitialColor,0);
  create_tuple(&hv_IndexColor,0);
  create_tuple(&hv_Color_RGBA,0);
  create_tuple(&hv_Area,0);

  /****************************************************/
  /******************   Begin procedure   *************/
  /****************************************************/

  /**/
  /*This procedure displays the result anomaly regions.*/
  /**/
  /*Get current set color.*/
  /*get_rgba (CurrentWindowHandle, Red, Green, Blue, Alpha)*/
  destroy_tuple(hv_Red);
  destroy_tuple(hv_Green);
  destroy_tuple(hv_Blue);
  destroy_tuple(hv_Alpha);
  /***/T_get_rgba(hv_CurrentWindowHandle, &hv_Red, &hv_Green, &hv_Blue, &hv_Alpha);

  /*InitialColor := []*/
  create_tuple(&TTemp[SP++],0);
  destroy_tuple(hv_InitialColor);
  hv_InitialColor=TTemp[--SP];

  /*========== for IndexColor := 0 to |Red| - 1 by 1 ==========*/
  T_tuple_length(hv_Red,&TTemp[SP++]);
  create_tuple_i(&TTemp[SP++],1);
  T_tuple_sub(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-2]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-2]=TTemp[SP];
  SP--;
  create_tuple_i(&TTemp[SP++],1);
  create_tuple_i(&TTemp[SP++],0);
  T_tuple_greater(TTemp[SP-1],TTemp[SP-3],&TTemp[SP]);
  SP++;
  T_tuple_equal(TTemp[SP-2],TTemp[SP-4],&TTemp[SP]);
  if(get_i(TTemp[SP],0) ||
     (!((( get_i(TTemp[SP-1],0)) && (get_d(TTemp[SP-3],0)>0)) ||
        ((!get_i(TTemp[SP-1],0)) && (get_d(TTemp[SP-3],0)<0)))))
  {
   destroy_tuple(TTemp[SP--]);
   destroy_tuple(TTemp[SP]);
   T_tuple_sub(TTemp[SP-1],TTemp[SP-2],&TTemp[SP]);
   destroy_tuple(hv_IndexColor);
   copy_tuple(TTemp[SP],&hv_IndexColor);
   destroy_tuple(TTemp[SP--]);
   destroy_tuple(TTemp[SP]);
   for(;;)
   {
   T_tuple_add(hv_IndexColor,TTemp[SP-1],&TTemp[SP]);
   destroy_tuple(hv_IndexColor);
   copy_tuple(TTemp[SP],&hv_IndexColor);
   destroy_tuple(TTemp[SP]);
   if(get_d(TTemp[SP-1],0)<0)
    T_tuple_less(hv_IndexColor,TTemp[SP-2],&TTemp[SP]);
   else
    T_tuple_greater(hv_IndexColor,TTemp[SP-2],&TTemp[SP]);
   if(get_i(TTemp[SP],0)) break;
   destroy_tuple(TTemp[SP]);
   /*========== for ==========*/

    /*Color_RGBA := '#' + Red[IndexColor]$'2x' + Green[IndexColor]$'2x' + Blue[IndexColor]$'2x' + Alpha[IndexColor]$'2x'*/
    create_tuple_s(&TTemp[SP++],"#");
    T_tuple_select(hv_Red,hv_IndexColor,&TTemp[SP++]);
    create_tuple_s(&TTemp[SP++],"2x");
    T_tuple_string(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-2]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-2]=TTemp[SP];
    SP--;
    T_tuple_add(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-2]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-2]=TTemp[SP];
    SP--;
    T_tuple_select(hv_Green,hv_IndexColor,&TTemp[SP++]);
    create_tuple_s(&TTemp[SP++],"2x");
    T_tuple_string(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-2]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-2]=TTemp[SP];
    SP--;
    T_tuple_add(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-2]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-2]=TTemp[SP];
    SP--;
    T_tuple_select(hv_Blue,hv_IndexColor,&TTemp[SP++]);
    create_tuple_s(&TTemp[SP++],"2x");
    T_tuple_string(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-2]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-2]=TTemp[SP];
    SP--;
    T_tuple_add(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-2]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-2]=TTemp[SP];
    SP--;
    T_tuple_select(hv_Alpha,hv_IndexColor,&TTemp[SP++]);
    create_tuple_s(&TTemp[SP++],"2x");
    T_tuple_string(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-2]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-2]=TTemp[SP];
    SP--;
    T_tuple_add(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-2]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-2]=TTemp[SP];
    SP--;
    destroy_tuple(hv_Color_RGBA);
    hv_Color_RGBA=TTemp[--SP];

    /*tuple_regexp_replace (Color_RGBA, [' ', 'replace_all'], '0', Color_RGBA)*/
    copy_tuple(hv_Color_RGBA,&TTemp[SP++]);
    create_tuple(&TTemp[SP++],2);
    set_s(TTemp[SP-1]," ",0);
    set_s(TTemp[SP-1],"replace_all",1);
    create_tuple_s(&TTemp[SP++],"0");
    destroy_tuple(hv_Color_RGBA);
    /***/T_tuple_regexp_replace(TTemp[SP-3], TTemp[SP-2], TTemp[SP-1], &hv_Color_RGBA);
    destroy_tuple(TTemp[--SP]);
    destroy_tuple(TTemp[--SP]);
    destroy_tuple(TTemp[--SP]);

    /*InitialColor := [InitialColor,Color_RGBA]*/
    copy_tuple(hv_InitialColor,&TTemp[SP++]);
    T_tuple_concat(TTemp[SP-1],hv_Color_RGBA,&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    destroy_tuple(hv_InitialColor);
    hv_InitialColor=TTemp[--SP];

   }
   destroy_tuple(TTemp[SP--]);
   destroy_tuple(TTemp[SP--]);
   destroy_tuple(TTemp[SP]);
  }
  else
  {
   destroy_tuple(TTemp[SP--]);
   destroy_tuple(TTemp[SP--]);
   destroy_tuple(TTemp[SP--]);
   destroy_tuple(TTemp[SP--]);
   destroy_tuple(TTemp[SP]);
  }/*========== end for ========*/

  /**/
  /*Display anomaly regions.*/
  /*Get non-empty regions.*/
  /*region_features (AnomalyRegion, 'area', Area)*/
  create_tuple_s(&TTemp[SP++],"area");
  destroy_tuple(hv_Area);
  /***/T_region_features(ho_AnomalyRegion, TTemp[SP-1], &hv_Area);
  destroy_tuple(TTemp[--SP]);

  /**/
  /*Display all non-empty class regions in distinct colors.*/
  /*========== if (Area > 0) ==========*/
  create_tuple_i(&TTemp[SP++],0);
  T_tuple_greater(hv_Area,TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-1]=TTemp[SP];
  if(get_i(TTemp[SP-1],0))
  {
    if (hdev_window_stack_is_open())
    {
      Htuple active_win;
      create_tuple(&active_win,0);
      hdev_window_stack_get_active(&active_win);
      /*dev_set_color (AnomalyRegionResultColor)*/
      /***/T_set_color(active_win,hv_AnomalyRegionResultColor);
      destroy_tuple(active_win);
    }
    if (hdev_window_stack_is_open())
    {
      Htuple active_win;
      create_tuple(&active_win,0);
      hdev_window_stack_get_active(&active_win);
      /*dev_set_line_width (LineWidth)*/
      /***/T_set_line_width(active_win,hv_LineWidth);
      destroy_tuple(active_win);
    }
    if (hdev_window_stack_is_open())
    {
      Htuple active_win;
      create_tuple(&active_win,0);
      hdev_window_stack_get_active(&active_win);
      /*dev_set_draw ('margin')*/
      create_tuple_s(&TTemp[SP++],"margin");
      /***/T_set_draw(active_win,TTemp[SP-1]);
      destroy_tuple(TTemp[--SP]);
      destroy_tuple(active_win);
    }
    if (hdev_window_stack_is_open())
    {
      Htuple active_win;
      create_tuple(&active_win,0);
      hdev_window_stack_get_active(&active_win);
      /*dev_display (AnomalyRegion)*/
      /***/T_disp_obj(ho_AnomalyRegion, active_win);
      destroy_tuple(active_win);
    }
  }
  destroy_tuple(TTemp[--SP]);
  /*========== end if ==========*/
  /**/
  /*Reset colors.*/
  if (hdev_window_stack_is_open())
  {
    Htuple active_win;
    create_tuple(&active_win,0);
    hdev_window_stack_get_active(&active_win);
    /*dev_set_color (InitialColor)*/
    /***/T_set_color(active_win,hv_InitialColor);
    destroy_tuple(active_win);
  }
  /**/
  /*========== return ==========*/

  /* Clear temporary tuple stack */
  while (SP > 0)
    destroy_tuple(TTemp[--SP]);
  /* Clear temporary tuple vectors stack*/
  while (SPTV > 0)
    V_destroy_vector(TVTemp[--SPTV]);
  /* Clear local control variables */
  destroy_tuple(hv_Red);
  destroy_tuple(hv_Green);
  destroy_tuple(hv_Blue);
  destroy_tuple(hv_Alpha);
  destroy_tuple(hv_InitialColor);
  destroy_tuple(hv_IndexColor);
  destroy_tuple(hv_Color_RGBA);
  destroy_tuple(hv_Area);

  return;

  /****************************************************/
  /******************     End procedure   *************/
  /****************************************************/

}

/* Chapter: Graphics / Output*/
/* Short Description: Display result bounding boxes. */
void dev_display_result_detection (Htuple hv_DLResult, Htuple hv_ResultKeys, Htuple hv_LineWidthBbox, 
    Htuple hv_ClassIDs, Htuple hv_TextConf, Htuple hv_Colors, Htuple hv_BoxLabelColor, 
    Htuple hv_WindowImageRatio, Htuple hv_TextPositionRow, Htuple hv_TextColor, Htuple hv_ShowLabels, 
    Htuple hv_ShowDirection, Htuple hv_WindowHandle, Htuple *hv_BboxClassIndices)
{

  /* Stack for temporary tuples */
  Htuple   TTemp[100];
  int      SP=0;
  /* Stack for temporary tuple vectors */
  Hvector  TVTemp[100] = {0};
  int      SPTV=0;

  /* Local iconic variables */
  Hobject  ho_InstanceMask, ho_BboxRectangle, ho_OrientationArrows;
  Hobject  ho_MaskSelected, ho_RectangleSelected, ho_ArrowSelected;

  /* Local control variables */
  Htuple  hv_InstanceType, hv_MaskExists, hv_BboxRow1;
  Htuple  hv_BboxCol1, hv_BboxRow2, hv_BboxCol2, hv_BboxRow;
  Htuple  hv_BboxCol, hv_BboxLength1, hv_BboxLength2, hv_BboxPhi;
  Htuple  hv_BboxClasses, hv_Text, hv_Ascent, hv_Descent;
  Htuple  hv__, hv_TextOffset, hv_LabelRowTop, hv_LabelRowBottom;
  Htuple  hv_LabelCol, hv_ArrowSizeFactorLength, hv_ArrowSizeFactorHead;
  Htuple  hv_MaxLengthArrow, hv_HalfLengthArrow, hv_ArrowBaseRow;
  Htuple  hv_ArrowBaseCol, hv_ArrowHeadRow, hv_ArrowHeadCol;
  Htuple  hv_ArrowHeadSize, hv_MaskRow, hv_MaskCol, hv_ContourStyle;
  Htuple  hv_Style, hv_LineWidths, hv_IndexBbox, hv_ClassID;
  Htuple  hv_CurrentColors, hv_IndexStyle, hv_TextColorClasses;
  Htuple  hv_LabelRow;

  /* Array for temporary output ctrl variables */
  Htuple  CExpDummyOCvar[3];

  /* Initialize iconic variables */
  gen_empty_obj(&ho_InstanceMask);
  gen_empty_obj(&ho_BboxRectangle);
  gen_empty_obj(&ho_OrientationArrows);
  gen_empty_obj(&ho_MaskSelected);
  gen_empty_obj(&ho_RectangleSelected);
  gen_empty_obj(&ho_ArrowSelected);

  /* Initialize control variables */
  create_tuple(&hv_InstanceType,0);
  create_tuple(&hv_MaskExists,0);
  create_tuple(&hv_BboxRow1,0);
  create_tuple(&hv_BboxCol1,0);
  create_tuple(&hv_BboxRow2,0);
  create_tuple(&hv_BboxCol2,0);
  create_tuple(&hv_BboxRow,0);
  create_tuple(&hv_BboxCol,0);
  create_tuple(&hv_BboxLength1,0);
  create_tuple(&hv_BboxLength2,0);
  create_tuple(&hv_BboxPhi,0);
  create_tuple(&hv_BboxClasses,0);
  create_tuple(&hv_Text,0);
  create_tuple(&hv_Ascent,0);
  create_tuple(&hv_Descent,0);
  create_tuple(&hv__,0);
  create_tuple(&hv_TextOffset,0);
  create_tuple(&hv_LabelRowTop,0);
  create_tuple(&hv_LabelRowBottom,0);
  create_tuple(&hv_LabelCol,0);
  create_tuple(&hv_ArrowSizeFactorLength,0);
  create_tuple(&hv_ArrowSizeFactorHead,0);
  create_tuple(&hv_MaxLengthArrow,0);
  create_tuple(&hv_HalfLengthArrow,0);
  create_tuple(&hv_ArrowBaseRow,0);
  create_tuple(&hv_ArrowBaseCol,0);
  create_tuple(&hv_ArrowHeadRow,0);
  create_tuple(&hv_ArrowHeadCol,0);
  create_tuple(&hv_ArrowHeadSize,0);
  create_tuple(&hv_MaskRow,0);
  create_tuple(&hv_MaskCol,0);
  create_tuple(&hv_ContourStyle,0);
  create_tuple(&hv_Style,0);
  create_tuple(&hv_LineWidths,0);
  create_tuple(&hv_IndexBbox,0);
  create_tuple(&hv_ClassID,0);
  create_tuple(&hv_CurrentColors,0);
  create_tuple(&hv_IndexStyle,0);
  create_tuple(&hv_TextColorClasses,0);
  create_tuple(&hv_LabelRow,0);
  create_tuple(&(*hv_BboxClassIndices),0);

  /****************************************************/
  /******************   Begin procedure   *************/
  /****************************************************/

  /**/
  /*This procedure displays the bounding boxes and masks (if present) defined by a DLResult.*/
  /*The ClassIDs are necessary to display bounding boxes from the same class*/
  /*always with the same color.*/
  /**/
  /*InstanceType := ''*/
  reuse_tuple_s(&hv_InstanceType,"");
  /*MaskExists := false*/
  reuse_tuple_i(&hv_MaskExists,0);

  /*========== if (find(ResultKeys,'bbox_row1') != -1) ==========*/
  create_tuple_s(&TTemp[SP++],"bbox_row1");
  T_tuple_find(hv_ResultKeys,TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-1]=TTemp[SP];
  create_tuple_i(&TTemp[SP++],-1);
  T_tuple_not_equal(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-2]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-2]=TTemp[SP];
  SP--;
  if(get_i(TTemp[SP-1],0))
  {
    /*get_dict_tuple (DLResult, 'bbox_row1', BboxRow1)*/
    create_tuple_s(&TTemp[SP++],"bbox_row1");
    destroy_tuple(hv_BboxRow1);
    /***/T_get_dict_tuple(hv_DLResult, TTemp[SP-1], &hv_BboxRow1);
    destroy_tuple(TTemp[--SP]);

    /*get_dict_tuple (DLResult, 'bbox_col1', BboxCol1)*/
    create_tuple_s(&TTemp[SP++],"bbox_col1");
    destroy_tuple(hv_BboxCol1);
    /***/T_get_dict_tuple(hv_DLResult, TTemp[SP-1], &hv_BboxCol1);
    destroy_tuple(TTemp[--SP]);

    /*get_dict_tuple (DLResult, 'bbox_row2', BboxRow2)*/
    create_tuple_s(&TTemp[SP++],"bbox_row2");
    destroy_tuple(hv_BboxRow2);
    /***/T_get_dict_tuple(hv_DLResult, TTemp[SP-1], &hv_BboxRow2);
    destroy_tuple(TTemp[--SP]);

    /*get_dict_tuple (DLResult, 'bbox_col2', BboxCol2)*/
    create_tuple_s(&TTemp[SP++],"bbox_col2");
    destroy_tuple(hv_BboxCol2);
    /***/T_get_dict_tuple(hv_DLResult, TTemp[SP-1], &hv_BboxCol2);
    destroy_tuple(TTemp[--SP]);

    /*InstanceType := 'rectangle1'*/
    reuse_tuple_s(&hv_InstanceType,"rectangle1");
  }
  else
  {
  destroy_tuple(TTemp[--SP]);
  /*========== elseif (find(ResultKeys,'bbox_phi') != -1) ==========*/

  create_tuple_s(&TTemp[SP++],"bbox_phi");
  T_tuple_find(hv_ResultKeys,TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-1]=TTemp[SP];
  create_tuple_i(&TTemp[SP++],-1);
  T_tuple_not_equal(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-2]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-2]=TTemp[SP];
  SP--;
  if(get_i(TTemp[SP-1],0))
  {
    /*get_dict_tuple (DLResult, 'bbox_row', BboxRow)*/
    create_tuple_s(&TTemp[SP++],"bbox_row");
    destroy_tuple(hv_BboxRow);
    /***/T_get_dict_tuple(hv_DLResult, TTemp[SP-1], &hv_BboxRow);
    destroy_tuple(TTemp[--SP]);

    /*get_dict_tuple (DLResult, 'bbox_col', BboxCol)*/
    create_tuple_s(&TTemp[SP++],"bbox_col");
    destroy_tuple(hv_BboxCol);
    /***/T_get_dict_tuple(hv_DLResult, TTemp[SP-1], &hv_BboxCol);
    destroy_tuple(TTemp[--SP]);

    /*get_dict_tuple (DLResult, 'bbox_length1', BboxLength1)*/
    create_tuple_s(&TTemp[SP++],"bbox_length1");
    destroy_tuple(hv_BboxLength1);
    /***/T_get_dict_tuple(hv_DLResult, TTemp[SP-1], &hv_BboxLength1);
    destroy_tuple(TTemp[--SP]);

    /*get_dict_tuple (DLResult, 'bbox_length2', BboxLength2)*/
    create_tuple_s(&TTemp[SP++],"bbox_length2");
    destroy_tuple(hv_BboxLength2);
    /***/T_get_dict_tuple(hv_DLResult, TTemp[SP-1], &hv_BboxLength2);
    destroy_tuple(TTemp[--SP]);

    /*get_dict_tuple (DLResult, 'bbox_phi', BboxPhi)*/
    create_tuple_s(&TTemp[SP++],"bbox_phi");
    destroy_tuple(hv_BboxPhi);
    /***/T_get_dict_tuple(hv_DLResult, TTemp[SP-1], &hv_BboxPhi);
    destroy_tuple(TTemp[--SP]);

    /*get_dict_tuple (DLResult, 'bbox_class_id', BboxClasses)*/
    create_tuple_s(&TTemp[SP++],"bbox_class_id");
    destroy_tuple(hv_BboxClasses);
    /***/T_get_dict_tuple(hv_DLResult, TTemp[SP-1], &hv_BboxClasses);
    destroy_tuple(TTemp[--SP]);

    /*InstanceType := 'rectangle2'*/
    reuse_tuple_s(&hv_InstanceType,"rectangle2");
  }
  else
  {
    /* throw(...); only in hdevelop*/
  }
  }
  destroy_tuple(TTemp[--SP]);
  /*========== end if ==========*/
  /*========== if (find(ResultKeys,'mask') != -1) ==========*/
  create_tuple_s(&TTemp[SP++],"mask");
  T_tuple_find(hv_ResultKeys,TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-1]=TTemp[SP];
  create_tuple_i(&TTemp[SP++],-1);
  T_tuple_not_equal(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-2]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-2]=TTemp[SP];
  SP--;
  if(get_i(TTemp[SP-1],0))
  {
    /*get_dict_object (InstanceMask, DLResult, 'mask')*/
    create_tuple_s(&TTemp[SP++],"mask");
    clear_obj(ho_InstanceMask);
    /***/T_get_dict_object(&ho_InstanceMask, hv_DLResult, TTemp[SP-1]);
    destroy_tuple(TTemp[--SP]);

    /*MaskExists := true*/
    reuse_tuple_i(&hv_MaskExists,1);

  }
  destroy_tuple(TTemp[--SP]);
  /*========== end if ==========*/
  /*========== if (InstanceType != 'rectangle1' and InstanceType != 'rectangle2' and not MaskExists) ==========*/
  create_tuple_s(&TTemp[SP++],"rectangle1");
  T_tuple_not_equal(hv_InstanceType,TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-1]=TTemp[SP];
  create_tuple_s(&TTemp[SP++],"rectangle2");
  T_tuple_not_equal(hv_InstanceType,TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-1]=TTemp[SP];
  T_tuple_and(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-2]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-2]=TTemp[SP];
  SP--;
  T_tuple_not(hv_MaskExists,&TTemp[SP++]);
  T_tuple_and(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-2]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-2]=TTemp[SP];
  SP--;
  if(get_i(TTemp[SP-1],0))
  {
    /* throw(...); only in hdevelop*/
  }
  destroy_tuple(TTemp[--SP]);
  /*========== end if ==========*/
  /*get_dict_tuple (DLResult, 'bbox_class_id', BboxClasses)*/
  create_tuple_s(&TTemp[SP++],"bbox_class_id");
  destroy_tuple(hv_BboxClasses);
  /***/T_get_dict_tuple(hv_DLResult, TTemp[SP-1], &hv_BboxClasses);
  destroy_tuple(TTemp[--SP]);

  /*========== if (|BboxClasses| > 0) ==========*/
  T_tuple_length(hv_BboxClasses,&TTemp[SP++]);
  create_tuple_i(&TTemp[SP++],0);
  T_tuple_greater(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-2]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-2]=TTemp[SP];
  SP--;
  if(get_i(TTemp[SP-1],0))
  {
    /**/
    /*Get text and text size for correct positioning of result class IDs.*/
    /*========== if (ShowLabels) ==========*/
    copy_tuple(hv_ShowLabels,&TTemp[SP++]);
    if(get_i(TTemp[SP-1],0))
    {
      /*Text := BboxClasses + TextConf*/
      T_tuple_add(hv_BboxClasses,hv_TextConf,&TTemp[SP++]);
      destroy_tuple(hv_Text);
      hv_Text=TTemp[--SP];

      /*get_string_extents (WindowHandle, Text, Ascent, Descent, _, _)*/
      destroy_tuple(hv_Ascent);
      destroy_tuple(hv_Descent);
      destroy_tuple(hv__);
      /***/T_get_string_extents(hv_WindowHandle, hv_Text, &hv_Ascent, &hv_Descent, 
          &hv__, &(CExpDummyOCvar[0]));
      destroy_tuple(CExpDummyOCvar[0]);

      /*TextOffset := (Ascent + Descent) / WindowImageRatio*/
      T_tuple_add(hv_Ascent,hv_Descent,&TTemp[SP++]);
      T_tuple_div(TTemp[SP-1],hv_WindowImageRatio,&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      destroy_tuple(hv_TextOffset);
      hv_TextOffset=TTemp[--SP];

    }
    destroy_tuple(TTemp[--SP]);
    /*========== end if ==========*/
    /**/
    /*Generate bounding box XLDs.*/
    /*========== if (InstanceType == 'rectangle1') ==========*/
    create_tuple_s(&TTemp[SP++],"rectangle1");
    T_tuple_equal(hv_InstanceType,TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    if(get_i(TTemp[SP-1],0))
    {
      /*tuple_gen_const (|BboxRow1|, 0.0, BboxPhi)*/
      T_tuple_length(hv_BboxRow1,&TTemp[SP++]);
      create_tuple_d(&TTemp[SP++],0.0);
      destroy_tuple(hv_BboxPhi);
      /***/T_tuple_gen_const(TTemp[SP-2], TTemp[SP-1], &hv_BboxPhi);
      destroy_tuple(TTemp[--SP]);
      destroy_tuple(TTemp[--SP]);

      /*gen_rectangle2_contour_xld (BboxRectangle, 0.5 * (BboxRow1 + BboxRow2), 0.5 * (BboxCol1 + BboxCol2), BboxPhi, 0.5 * (BboxCol2 - BboxCol1), 0.5 * (BboxRow2 - BboxRow1))*/
      create_tuple_d(&TTemp[SP++],0.5);
      T_tuple_add(hv_BboxRow1,hv_BboxRow2,&TTemp[SP++]);
      T_tuple_mult(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-2]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-2]=TTemp[SP];
      SP--;
      create_tuple_d(&TTemp[SP++],0.5);
      T_tuple_add(hv_BboxCol1,hv_BboxCol2,&TTemp[SP++]);
      T_tuple_mult(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-2]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-2]=TTemp[SP];
      SP--;
      create_tuple_d(&TTemp[SP++],0.5);
      T_tuple_sub(hv_BboxCol2,hv_BboxCol1,&TTemp[SP++]);
      T_tuple_mult(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-2]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-2]=TTemp[SP];
      SP--;
      create_tuple_d(&TTemp[SP++],0.5);
      T_tuple_sub(hv_BboxRow2,hv_BboxRow1,&TTemp[SP++]);
      T_tuple_mult(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-2]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-2]=TTemp[SP];
      SP--;
      clear_obj(ho_BboxRectangle);
      /***/T_gen_rectangle2_contour_xld(&ho_BboxRectangle, TTemp[SP-4], TTemp[SP-3], 
          hv_BboxPhi, TTemp[SP-2], TTemp[SP-1]);
      destroy_tuple(TTemp[--SP]);
      destroy_tuple(TTemp[--SP]);
      destroy_tuple(TTemp[--SP]);
      destroy_tuple(TTemp[--SP]);

      /*========== if (ShowLabels) ==========*/
      copy_tuple(hv_ShowLabels,&TTemp[SP++]);
      if(get_i(TTemp[SP-1],0))
      {
        /*LabelRowTop := BboxRow1*/
        destroy_tuple(hv_LabelRowTop);
        copy_tuple(hv_BboxRow1,&hv_LabelRowTop);

        /*LabelRowBottom := BboxRow2 - TextOffset*/
        T_tuple_sub(hv_BboxRow2,hv_TextOffset,&TTemp[SP++]);
        destroy_tuple(hv_LabelRowBottom);
        hv_LabelRowBottom=TTemp[--SP];

        /*LabelCol := BboxCol1*/
        destroy_tuple(hv_LabelCol);
        copy_tuple(hv_BboxCol1,&hv_LabelCol);

      }
      destroy_tuple(TTemp[--SP]);
      /*========== end if ==========*/
    }
    else
    {
    destroy_tuple(TTemp[--SP]);
    /*========== elseif (InstanceType == 'rectangle2') ==========*/

    create_tuple_s(&TTemp[SP++],"rectangle2");
    T_tuple_equal(hv_InstanceType,TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    if(get_i(TTemp[SP-1],0))
    {
      /*gen_rectangle2_contour_xld (BboxRectangle, BboxRow, BboxCol, BboxPhi, BboxLength1, BboxLength2)*/
      clear_obj(ho_BboxRectangle);
      /***/T_gen_rectangle2_contour_xld(&ho_BboxRectangle, hv_BboxRow, hv_BboxCol, 
          hv_BboxPhi, hv_BboxLength1, hv_BboxLength2);

      /*========== if (ShowLabels) ==========*/
      copy_tuple(hv_ShowLabels,&TTemp[SP++]);
      if(get_i(TTemp[SP-1],0))
      {
        /*LabelRowTop := BboxRow - TextOffset*/
        T_tuple_sub(hv_BboxRow,hv_TextOffset,&TTemp[SP++]);
        destroy_tuple(hv_LabelRowTop);
        hv_LabelRowTop=TTemp[--SP];

        /*LabelRowBottom := BboxRow*/
        destroy_tuple(hv_LabelRowBottom);
        copy_tuple(hv_BboxRow,&hv_LabelRowBottom);

        /*LabelCol := BboxCol*/
        destroy_tuple(hv_LabelCol);
        copy_tuple(hv_BboxCol,&hv_LabelCol);

      }
      destroy_tuple(TTemp[--SP]);
      /*========== end if ==========*/
      /*========== if (ShowDirection) ==========*/
      copy_tuple(hv_ShowDirection,&TTemp[SP++]);
      if(get_i(TTemp[SP-1],0))
      {
        /*========== if (ShowDirection == -1) ==========*/
        create_tuple_i(&TTemp[SP++],-1);
        T_tuple_equal(hv_ShowDirection,TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-1]=TTemp[SP];
        if(get_i(TTemp[SP-1],0))
        {
          /*ArrowSizeFactorLength := 0.4*/
          reuse_tuple_d(&hv_ArrowSizeFactorLength,0.4);

          /*ArrowSizeFactorHead := 0.2*/
          reuse_tuple_d(&hv_ArrowSizeFactorHead,0.2);

          /*MaxLengthArrow := 20*/
          reuse_tuple_i(&hv_MaxLengthArrow,20);

          /*HalfLengthArrow := min2(MaxLengthArrow,BboxLength1 * ArrowSizeFactorLength)*/
          T_tuple_mult(hv_BboxLength1,hv_ArrowSizeFactorLength,&TTemp[SP++]);
          T_tuple_min2(hv_MaxLengthArrow,TTemp[SP-1],&TTemp[SP]);
          destroy_tuple(TTemp[SP-1]);
          TTemp[SP-1]=TTemp[SP];
          destroy_tuple(hv_HalfLengthArrow);
          hv_HalfLengthArrow=TTemp[--SP];

          /*ArrowBaseRow := BboxRow - (BboxLength1 - HalfLengthArrow) * sin(BboxPhi)*/
          T_tuple_sub(hv_BboxLength1,hv_HalfLengthArrow,&TTemp[SP++]);
          T_tuple_sin(hv_BboxPhi,&TTemp[SP++]);
          T_tuple_mult(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
          destroy_tuple(TTemp[SP-2]);
          destroy_tuple(TTemp[SP-1]);
          TTemp[SP-2]=TTemp[SP];
          SP--;
          T_tuple_sub(hv_BboxRow,TTemp[SP-1],&TTemp[SP]);
          destroy_tuple(TTemp[SP-1]);
          TTemp[SP-1]=TTemp[SP];
          destroy_tuple(hv_ArrowBaseRow);
          hv_ArrowBaseRow=TTemp[--SP];

          /*ArrowBaseCol := BboxCol + (BboxLength1 - HalfLengthArrow) * cos(BboxPhi)*/
          T_tuple_sub(hv_BboxLength1,hv_HalfLengthArrow,&TTemp[SP++]);
          T_tuple_cos(hv_BboxPhi,&TTemp[SP++]);
          T_tuple_mult(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
          destroy_tuple(TTemp[SP-2]);
          destroy_tuple(TTemp[SP-1]);
          TTemp[SP-2]=TTemp[SP];
          SP--;
          T_tuple_add(hv_BboxCol,TTemp[SP-1],&TTemp[SP]);
          destroy_tuple(TTemp[SP-1]);
          TTemp[SP-1]=TTemp[SP];
          destroy_tuple(hv_ArrowBaseCol);
          hv_ArrowBaseCol=TTemp[--SP];

          /*ArrowHeadRow := BboxRow - (BboxLength1 + HalfLengthArrow) * sin(BboxPhi)*/
          T_tuple_add(hv_BboxLength1,hv_HalfLengthArrow,&TTemp[SP++]);
          T_tuple_sin(hv_BboxPhi,&TTemp[SP++]);
          T_tuple_mult(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
          destroy_tuple(TTemp[SP-2]);
          destroy_tuple(TTemp[SP-1]);
          TTemp[SP-2]=TTemp[SP];
          SP--;
          T_tuple_sub(hv_BboxRow,TTemp[SP-1],&TTemp[SP]);
          destroy_tuple(TTemp[SP-1]);
          TTemp[SP-1]=TTemp[SP];
          destroy_tuple(hv_ArrowHeadRow);
          hv_ArrowHeadRow=TTemp[--SP];

          /*ArrowHeadCol := BboxCol + (BboxLength1 + HalfLengthArrow) * cos(BboxPhi)*/
          T_tuple_add(hv_BboxLength1,hv_HalfLengthArrow,&TTemp[SP++]);
          T_tuple_cos(hv_BboxPhi,&TTemp[SP++]);
          T_tuple_mult(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
          destroy_tuple(TTemp[SP-2]);
          destroy_tuple(TTemp[SP-1]);
          TTemp[SP-2]=TTemp[SP];
          SP--;
          T_tuple_add(hv_BboxCol,TTemp[SP-1],&TTemp[SP]);
          destroy_tuple(TTemp[SP-1]);
          TTemp[SP-1]=TTemp[SP];
          destroy_tuple(hv_ArrowHeadCol);
          hv_ArrowHeadCol=TTemp[--SP];

          /*ArrowHeadSize := min2(MaxLengthArrow,min2(BboxLength1,BboxLength2)) * ArrowSizeFactorHead*/
          T_tuple_min2(hv_BboxLength1,hv_BboxLength2,&TTemp[SP++]);
          T_tuple_min2(hv_MaxLengthArrow,TTemp[SP-1],&TTemp[SP]);
          destroy_tuple(TTemp[SP-1]);
          TTemp[SP-1]=TTemp[SP];
          T_tuple_mult(TTemp[SP-1],hv_ArrowSizeFactorHead,&TTemp[SP]);
          destroy_tuple(TTemp[SP-1]);
          TTemp[SP-1]=TTemp[SP];
          destroy_tuple(hv_ArrowHeadSize);
          hv_ArrowHeadSize=TTemp[--SP];

        }
        else
        {
          /*ArrowHeadSize := 20.0*/
          reuse_tuple_d(&hv_ArrowHeadSize,20.0);

          /*ArrowBaseRow := BboxRow*/
          destroy_tuple(hv_ArrowBaseRow);
          copy_tuple(hv_BboxRow,&hv_ArrowBaseRow);

          /*ArrowBaseCol := BboxCol*/
          destroy_tuple(hv_ArrowBaseCol);
          copy_tuple(hv_BboxCol,&hv_ArrowBaseCol);

          /*ArrowHeadRow := BboxRow - (BboxLength1 + ArrowHeadSize) * sin(BboxPhi)*/
          T_tuple_add(hv_BboxLength1,hv_ArrowHeadSize,&TTemp[SP++]);
          T_tuple_sin(hv_BboxPhi,&TTemp[SP++]);
          T_tuple_mult(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
          destroy_tuple(TTemp[SP-2]);
          destroy_tuple(TTemp[SP-1]);
          TTemp[SP-2]=TTemp[SP];
          SP--;
          T_tuple_sub(hv_BboxRow,TTemp[SP-1],&TTemp[SP]);
          destroy_tuple(TTemp[SP-1]);
          TTemp[SP-1]=TTemp[SP];
          destroy_tuple(hv_ArrowHeadRow);
          hv_ArrowHeadRow=TTemp[--SP];

          /*ArrowHeadCol := BboxCol + (BboxLength1 + ArrowHeadSize) * cos(BboxPhi)*/
          T_tuple_add(hv_BboxLength1,hv_ArrowHeadSize,&TTemp[SP++]);
          T_tuple_cos(hv_BboxPhi,&TTemp[SP++]);
          T_tuple_mult(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
          destroy_tuple(TTemp[SP-2]);
          destroy_tuple(TTemp[SP-1]);
          TTemp[SP-2]=TTemp[SP];
          SP--;
          T_tuple_add(hv_BboxCol,TTemp[SP-1],&TTemp[SP]);
          destroy_tuple(TTemp[SP-1]);
          TTemp[SP-1]=TTemp[SP];
          destroy_tuple(hv_ArrowHeadCol);
          hv_ArrowHeadCol=TTemp[--SP];

        }
        destroy_tuple(TTemp[--SP]);
        /*========== end if ==========*/
        /*gen_arrow_contour_xld (OrientationArrows, ArrowBaseRow, ArrowBaseCol, ArrowHeadRow, ArrowHeadCol, ArrowHeadSize, ArrowHeadSize)*/
        clear_obj(ho_OrientationArrows);
        /***/gen_arrow_contour_xld(&ho_OrientationArrows, hv_ArrowBaseRow, hv_ArrowBaseCol, 
            hv_ArrowHeadRow, hv_ArrowHeadCol, hv_ArrowHeadSize, hv_ArrowHeadSize);

      }
      destroy_tuple(TTemp[--SP]);
      /*========== end if ==========*/
    }
    else
    {
    destroy_tuple(TTemp[--SP]);
    /*========== elseif (MaskExists) ==========*/

    copy_tuple(hv_MaskExists,&TTemp[SP++]);
    if(get_i(TTemp[SP-1],0))
    {
      /*area_center (InstanceMask, _, MaskRow, MaskCol)*/
      destroy_tuple(hv__);
      destroy_tuple(hv_MaskRow);
      destroy_tuple(hv_MaskCol);
      /***/T_area_center(ho_InstanceMask, &hv__, &hv_MaskRow, &hv_MaskCol);

      /*LabelRowTop := MaskRow - TextOffset*/
      T_tuple_sub(hv_MaskRow,hv_TextOffset,&TTemp[SP++]);
      destroy_tuple(hv_LabelRowTop);
      hv_LabelRowTop=TTemp[--SP];

      /*LabelRowBottom := MaskRow*/
      destroy_tuple(hv_LabelRowBottom);
      copy_tuple(hv_MaskRow,&hv_LabelRowBottom);

      /*LabelCol := MaskCol*/
      destroy_tuple(hv_LabelCol);
      copy_tuple(hv_MaskCol,&hv_LabelCol);

    }
    else
    {
      /* throw(...); only in hdevelop*/
    }
    }
    }
    destroy_tuple(TTemp[--SP]);
    /*========== end if ==========*/
    /**/
    /*get_contour_style (WindowHandle, ContourStyle)*/
    destroy_tuple(hv_ContourStyle);
    /***/T_get_contour_style(hv_WindowHandle, &hv_ContourStyle);

    if (hdev_window_stack_is_open())
    {
      Htuple active_win;
      create_tuple(&active_win,0);
      hdev_window_stack_get_active(&active_win);
      /*dev_set_contour_style ('stroke')*/
      create_tuple_s(&TTemp[SP++],"stroke");
      /***/T_set_contour_style(active_win,TTemp[SP-1]);
      destroy_tuple(TTemp[--SP]);
      destroy_tuple(active_win);
    }
    /*get_line_style (WindowHandle, Style)*/
    destroy_tuple(hv_Style);
    /***/T_get_line_style(hv_WindowHandle, &hv_Style);

    /*LineWidths := [LineWidthBbox + 2,LineWidthBbox]*/
    create_tuple_i(&TTemp[SP++],2);
    T_tuple_add(hv_LineWidthBbox,TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    T_tuple_concat(TTemp[SP-1],hv_LineWidthBbox,&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    destroy_tuple(hv_LineWidths);
    hv_LineWidths=TTemp[--SP];

    if (hdev_window_stack_is_open())
    {
      Htuple active_win;
      create_tuple(&active_win,0);
      hdev_window_stack_get_active(&active_win);
      /*dev_set_line_width (LineWidthBbox)*/
      /***/T_set_line_width(active_win,hv_LineWidthBbox);
      destroy_tuple(active_win);
    }
    /**/
    /*Collect ClassIDs of the bounding boxes.*/
    /*tuple_gen_const (|BboxClasses|, 0, BboxClassIndices)*/
    T_tuple_length(hv_BboxClasses,&TTemp[SP++]);
    create_tuple_i(&TTemp[SP++],0);
    destroy_tuple((*hv_BboxClassIndices));
    /***/T_tuple_gen_const(TTemp[SP-2], TTemp[SP-1], &(*hv_BboxClassIndices));
    destroy_tuple(TTemp[--SP]);
    destroy_tuple(TTemp[--SP]);

    /**/
    /*Draw bounding boxes.*/
    /*========== for IndexBbox := 0 to |BboxClasses| - 1 by 1 ==========*/
    T_tuple_length(hv_BboxClasses,&TTemp[SP++]);
    create_tuple_i(&TTemp[SP++],1);
    T_tuple_sub(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-2]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-2]=TTemp[SP];
    SP--;
    create_tuple_i(&TTemp[SP++],1);
    create_tuple_i(&TTemp[SP++],0);
    T_tuple_greater(TTemp[SP-1],TTemp[SP-3],&TTemp[SP]);
    SP++;
    T_tuple_equal(TTemp[SP-2],TTemp[SP-4],&TTemp[SP]);
    if(get_i(TTemp[SP],0) ||
       (!((( get_i(TTemp[SP-1],0)) && (get_d(TTemp[SP-3],0)>0)) ||
          ((!get_i(TTemp[SP-1],0)) && (get_d(TTemp[SP-3],0)<0)))))
    {
     destroy_tuple(TTemp[SP--]);
     destroy_tuple(TTemp[SP]);
     T_tuple_sub(TTemp[SP-1],TTemp[SP-2],&TTemp[SP]);
     destroy_tuple(hv_IndexBbox);
     copy_tuple(TTemp[SP],&hv_IndexBbox);
     destroy_tuple(TTemp[SP--]);
     destroy_tuple(TTemp[SP]);
     for(;;)
     {
     T_tuple_add(hv_IndexBbox,TTemp[SP-1],&TTemp[SP]);
     destroy_tuple(hv_IndexBbox);
     copy_tuple(TTemp[SP],&hv_IndexBbox);
     destroy_tuple(TTemp[SP]);
     if(get_d(TTemp[SP-1],0)<0)
      T_tuple_less(hv_IndexBbox,TTemp[SP-2],&TTemp[SP]);
     else
      T_tuple_greater(hv_IndexBbox,TTemp[SP-2],&TTemp[SP]);
     if(get_i(TTemp[SP],0)) break;
     destroy_tuple(TTemp[SP]);
     /*========== for ==========*/

      /*ClassID := find(ClassIDs,BboxClasses[IndexBbox])*/
      T_tuple_select(hv_BboxClasses,hv_IndexBbox,&TTemp[SP++]);
      T_tuple_find(hv_ClassIDs,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      destroy_tuple(hv_ClassID);
      hv_ClassID=TTemp[--SP];

      /*BboxClassIndices[IndexBbox] := ClassID*/
      replace_elements(&(*hv_BboxClassIndices),&hv_IndexBbox,&hv_ClassID);
      /*First draw in black to make the class-color visible.*/
      /*CurrentColors := ['black',Colors[ClassID]]*/
      create_tuple_s(&TTemp[SP++],"black");
      T_tuple_select(hv_Colors,hv_ClassID,&TTemp[SP++]);
      T_tuple_concat(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-2]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-2]=TTemp[SP];
      SP--;
      destroy_tuple(hv_CurrentColors);
      hv_CurrentColors=TTemp[--SP];

      /*========== if (MaskExists) ==========*/
      copy_tuple(hv_MaskExists,&TTemp[SP++]);
      if(get_i(TTemp[SP-1],0))
      {
        /*select_obj (InstanceMask, MaskSelected, IndexBbox + 1)*/
        create_tuple_i(&TTemp[SP++],1);
        T_tuple_add(hv_IndexBbox,TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-1]=TTemp[SP];
        clear_obj(ho_MaskSelected);
        /***/T_select_obj(ho_InstanceMask, &ho_MaskSelected, TTemp[SP-1]);
        destroy_tuple(TTemp[--SP]);

        if (hdev_window_stack_is_open())
        {
          Htuple active_win;
          create_tuple(&active_win,0);
          hdev_window_stack_get_active(&active_win);
          /*dev_set_draw ('fill')*/
          create_tuple_s(&TTemp[SP++],"fill");
          /***/T_set_draw(active_win,TTemp[SP-1]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(active_win);
        }
        if (hdev_window_stack_is_open())
        {
          Htuple active_win;
          create_tuple(&active_win,0);
          hdev_window_stack_get_active(&active_win);
          /*dev_set_color (Colors[ClassID] + '80')*/
          T_tuple_select(hv_Colors,hv_ClassID,&TTemp[SP++]);
          create_tuple_s(&TTemp[SP++],"80");
          T_tuple_add(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
          destroy_tuple(TTemp[SP-2]);
          destroy_tuple(TTemp[SP-1]);
          TTemp[SP-2]=TTemp[SP];
          SP--;
          /***/T_set_color(active_win,TTemp[SP-1]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(active_win);
        }
        if (hdev_window_stack_is_open())
        {
          Htuple active_win;
          create_tuple(&active_win,0);
          hdev_window_stack_get_active(&active_win);
          /*dev_display (MaskSelected)*/
          /***/T_disp_obj(ho_MaskSelected, active_win);
          destroy_tuple(active_win);
        }
        if (hdev_window_stack_is_open())
        {
          Htuple active_win;
          create_tuple(&active_win,0);
          hdev_window_stack_get_active(&active_win);
          /*dev_set_draw ('margin')*/
          create_tuple_s(&TTemp[SP++],"margin");
          /***/T_set_draw(active_win,TTemp[SP-1]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(active_win);
        }
      }
      destroy_tuple(TTemp[--SP]);
      /*========== end if ==========*/
      /*========== for IndexStyle := 0 to |CurrentColors| - 1 by 1 ==========*/
      T_tuple_length(hv_CurrentColors,&TTemp[SP++]);
      create_tuple_i(&TTemp[SP++],1);
      T_tuple_sub(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-2]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-2]=TTemp[SP];
      SP--;
      create_tuple_i(&TTemp[SP++],1);
      create_tuple_i(&TTemp[SP++],0);
      T_tuple_greater(TTemp[SP-1],TTemp[SP-3],&TTemp[SP]);
      SP++;
      T_tuple_equal(TTemp[SP-2],TTemp[SP-4],&TTemp[SP]);
      if(get_i(TTemp[SP],0) ||
         (!((( get_i(TTemp[SP-1],0)) && (get_d(TTemp[SP-3],0)>0)) ||
            ((!get_i(TTemp[SP-1],0)) && (get_d(TTemp[SP-3],0)<0)))))
      {
       destroy_tuple(TTemp[SP--]);
       destroy_tuple(TTemp[SP]);
       T_tuple_sub(TTemp[SP-1],TTemp[SP-2],&TTemp[SP]);
       destroy_tuple(hv_IndexStyle);
       copy_tuple(TTemp[SP],&hv_IndexStyle);
       destroy_tuple(TTemp[SP--]);
       destroy_tuple(TTemp[SP]);
       for(;;)
       {
       T_tuple_add(hv_IndexStyle,TTemp[SP-1],&TTemp[SP]);
       destroy_tuple(hv_IndexStyle);
       copy_tuple(TTemp[SP],&hv_IndexStyle);
       destroy_tuple(TTemp[SP]);
       if(get_d(TTemp[SP-1],0)<0)
        T_tuple_less(hv_IndexStyle,TTemp[SP-2],&TTemp[SP]);
       else
        T_tuple_greater(hv_IndexStyle,TTemp[SP-2],&TTemp[SP]);
       if(get_i(TTemp[SP],0)) break;
       destroy_tuple(TTemp[SP]);
       /*========== for ==========*/

        if (hdev_window_stack_is_open())
        {
          Htuple active_win;
          create_tuple(&active_win,0);
          hdev_window_stack_get_active(&active_win);
          /*dev_set_color (CurrentColors[IndexStyle])*/
          T_tuple_select(hv_CurrentColors,hv_IndexStyle,&TTemp[SP++]);
          /***/T_set_color(active_win,TTemp[SP-1]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(active_win);
        }
        if (hdev_window_stack_is_open())
        {
          Htuple active_win;
          create_tuple(&active_win,0);
          hdev_window_stack_get_active(&active_win);
          /*dev_set_line_width (LineWidths[IndexStyle])*/
          T_tuple_select(hv_LineWidths,hv_IndexStyle,&TTemp[SP++]);
          /***/T_set_line_width(active_win,TTemp[SP-1]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(active_win);
        }
        /*========== if (InstanceType != '') ==========*/
        create_tuple_s(&TTemp[SP++],"");
        T_tuple_not_equal(hv_InstanceType,TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-1]=TTemp[SP];
        if(get_i(TTemp[SP-1],0))
        {
          /*select_obj (BboxRectangle, RectangleSelected, IndexBbox + 1)*/
          create_tuple_i(&TTemp[SP++],1);
          T_tuple_add(hv_IndexBbox,TTemp[SP-1],&TTemp[SP]);
          destroy_tuple(TTemp[SP-1]);
          TTemp[SP-1]=TTemp[SP];
          clear_obj(ho_RectangleSelected);
          /***/T_select_obj(ho_BboxRectangle, &ho_RectangleSelected, TTemp[SP-1]);
          destroy_tuple(TTemp[--SP]);

          if (hdev_window_stack_is_open())
          {
            Htuple active_win;
            create_tuple(&active_win,0);
            hdev_window_stack_get_active(&active_win);
            /*dev_display (RectangleSelected)*/
            /***/T_disp_obj(ho_RectangleSelected, active_win);
            destroy_tuple(active_win);
          }
          /*========== if (InstanceType == 'rectangle2' and ShowDirection) ==========*/
          create_tuple_s(&TTemp[SP++],"rectangle2");
          T_tuple_equal(hv_InstanceType,TTemp[SP-1],&TTemp[SP]);
          destroy_tuple(TTemp[SP-1]);
          TTemp[SP-1]=TTemp[SP];
          T_tuple_and(TTemp[SP-1],hv_ShowDirection,&TTemp[SP]);
          destroy_tuple(TTemp[SP-1]);
          TTemp[SP-1]=TTemp[SP];
          if(get_i(TTemp[SP-1],0))
          {
            /*select_obj (OrientationArrows, ArrowSelected, IndexBbox + 1)*/
            create_tuple_i(&TTemp[SP++],1);
            T_tuple_add(hv_IndexBbox,TTemp[SP-1],&TTemp[SP]);
            destroy_tuple(TTemp[SP-1]);
            TTemp[SP-1]=TTemp[SP];
            clear_obj(ho_ArrowSelected);
            /***/T_select_obj(ho_OrientationArrows, &ho_ArrowSelected, TTemp[SP-1]);
            destroy_tuple(TTemp[--SP]);

            if (hdev_window_stack_is_open())
            {
              Htuple active_win;
              create_tuple(&active_win,0);
              hdev_window_stack_get_active(&active_win);
              /*dev_display (ArrowSelected)*/
              /***/T_disp_obj(ho_ArrowSelected, active_win);
              destroy_tuple(active_win);
            }
          }
          destroy_tuple(TTemp[--SP]);
          /*========== end if ==========*/
        }
        destroy_tuple(TTemp[--SP]);
        /*========== end if ==========*/
       }
       destroy_tuple(TTemp[SP--]);
       destroy_tuple(TTemp[SP--]);
       destroy_tuple(TTemp[SP]);
      }
      else
      {
       destroy_tuple(TTemp[SP--]);
       destroy_tuple(TTemp[SP--]);
       destroy_tuple(TTemp[SP--]);
       destroy_tuple(TTemp[SP--]);
       destroy_tuple(TTemp[SP]);
      }/*========== end for ========*/

     }
     destroy_tuple(TTemp[SP--]);
     destroy_tuple(TTemp[SP--]);
     destroy_tuple(TTemp[SP]);
    }
    else
    {
     destroy_tuple(TTemp[SP--]);
     destroy_tuple(TTemp[SP--]);
     destroy_tuple(TTemp[SP--]);
     destroy_tuple(TTemp[SP--]);
     destroy_tuple(TTemp[SP]);
    }/*========== end for ========*/

    /**/
    /*Draw text of bounding boxes.*/
    /*========== if (ShowLabels) ==========*/
    copy_tuple(hv_ShowLabels,&TTemp[SP++]);
    if(get_i(TTemp[SP-1],0))
    {
      /*For better visibility the text is displayed after all bounding boxes are drawn.*/
      /*Get text and text size for correct positioning of result class IDs.*/
      /*Text := BboxClasses + TextConf*/
      T_tuple_add(hv_BboxClasses,hv_TextConf,&TTemp[SP++]);
      destroy_tuple(hv_Text);
      hv_Text=TTemp[--SP];

      /*Select text color.*/
      /*========== if (TextColor == '') ==========*/
      create_tuple_s(&TTemp[SP++],"");
      T_tuple_equal(hv_TextColor,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      if(get_i(TTemp[SP-1],0))
      {
        /*TextColorClasses := Colors[BboxClassIndices]*/
        T_tuple_select(hv_Colors,(*hv_BboxClassIndices),&TTemp[SP++]);
        destroy_tuple(hv_TextColorClasses);
        hv_TextColorClasses=TTemp[--SP];

      }
      else
      {
        /*tuple_gen_const (|BboxClassIndices|, TextColor, TextColorClasses)*/
        T_tuple_length((*hv_BboxClassIndices),&TTemp[SP++]);
        destroy_tuple(hv_TextColorClasses);
        /***/T_tuple_gen_const(TTemp[SP-1], hv_TextColor, &hv_TextColorClasses);
        destroy_tuple(TTemp[--SP]);

      }
      destroy_tuple(TTemp[--SP]);
      /*========== end if ==========*/
      /*Select correct position of the text.*/
      /*LabelRow := LabelRowTop*/
      destroy_tuple(hv_LabelRow);
      copy_tuple(hv_LabelRowTop,&hv_LabelRow);

      /*========== if (TextPositionRow == 'bottom') ==========*/
      create_tuple_s(&TTemp[SP++],"bottom");
      T_tuple_equal(hv_TextPositionRow,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      if(get_i(TTemp[SP-1],0))
      {
        /*LabelRow := LabelRowBottom*/
        destroy_tuple(hv_LabelRow);
        copy_tuple(hv_LabelRowBottom,&hv_LabelRow);

      }
      destroy_tuple(TTemp[--SP]);
      /*========== end if ==========*/
      /*Display text.*/
      if (hdev_window_stack_is_open())
      {
        Htuple active_win;
        create_tuple(&active_win,0);
        hdev_window_stack_get_active(&active_win);
        /*dev_disp_text (Text, 'image', LabelRow, LabelCol, TextColorClasses, ['box_color', 'shadow', 'border_radius'], [BoxLabelColor,'false', 0])*/
        create_tuple_s(&TTemp[SP++],"image");
        create_tuple(&TTemp[SP++],3);
        set_s(TTemp[SP-1],"box_color",0);
        set_s(TTemp[SP-1],"shadow",1);
        set_s(TTemp[SP-1],"border_radius",2);
        create_tuple(&TTemp[SP++],2);
        set_s(TTemp[SP-1],"false",0);
        set_i(TTemp[SP-1],0        ,1);
        T_tuple_concat(hv_BoxLabelColor,TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-1]=TTemp[SP];
        /***/T_disp_text(active_win,hv_Text, TTemp[SP-3], hv_LabelRow, hv_LabelCol, 
            hv_TextColorClasses, TTemp[SP-2], TTemp[SP-1]);
        destroy_tuple(TTemp[--SP]);
        destroy_tuple(TTemp[--SP]);
        destroy_tuple(TTemp[--SP]);
        destroy_tuple(active_win);
      }
    }
    destroy_tuple(TTemp[--SP]);
    /*========== end if ==========*/
    /**/
    if (hdev_window_stack_is_open())
    {
      Htuple active_win;
      create_tuple(&active_win,0);
      hdev_window_stack_get_active(&active_win);
      /*dev_set_contour_style (ContourStyle)*/
      /***/T_set_contour_style(active_win,hv_ContourStyle);
      destroy_tuple(active_win);
    }
    /*set_line_style (WindowHandle, Style)*/
    /***/T_set_line_style(hv_WindowHandle, hv_Style);

  }
  else
  {
    /*Do nothing if no results are present.*/
    /*BboxClassIndices := []*/
    create_tuple(&TTemp[SP++],0);
    destroy_tuple((*hv_BboxClassIndices));
    (*hv_BboxClassIndices)=TTemp[--SP];

  }
  destroy_tuple(TTemp[--SP]);
  /*========== end if ==========*/
  /**/
  /*========== return ==========*/

  /* Clear temporary tuple stack */
  while (SP > 0)
    destroy_tuple(TTemp[--SP]);
  /* Clear temporary tuple vectors stack*/
  while (SPTV > 0)
    V_destroy_vector(TVTemp[--SPTV]);
  /* Clear local iconic variables */
  clear_obj(ho_InstanceMask);
  clear_obj(ho_BboxRectangle);
  clear_obj(ho_OrientationArrows);
  clear_obj(ho_MaskSelected);
  clear_obj(ho_RectangleSelected);
  clear_obj(ho_ArrowSelected);

  /* Clear local control variables */
  destroy_tuple(hv_InstanceType);
  destroy_tuple(hv_MaskExists);
  destroy_tuple(hv_BboxRow1);
  destroy_tuple(hv_BboxCol1);
  destroy_tuple(hv_BboxRow2);
  destroy_tuple(hv_BboxCol2);
  destroy_tuple(hv_BboxRow);
  destroy_tuple(hv_BboxCol);
  destroy_tuple(hv_BboxLength1);
  destroy_tuple(hv_BboxLength2);
  destroy_tuple(hv_BboxPhi);
  destroy_tuple(hv_BboxClasses);
  destroy_tuple(hv_Text);
  destroy_tuple(hv_Ascent);
  destroy_tuple(hv_Descent);
  destroy_tuple(hv__);
  destroy_tuple(hv_TextOffset);
  destroy_tuple(hv_LabelRowTop);
  destroy_tuple(hv_LabelRowBottom);
  destroy_tuple(hv_LabelCol);
  destroy_tuple(hv_ArrowSizeFactorLength);
  destroy_tuple(hv_ArrowSizeFactorHead);
  destroy_tuple(hv_MaxLengthArrow);
  destroy_tuple(hv_HalfLengthArrow);
  destroy_tuple(hv_ArrowBaseRow);
  destroy_tuple(hv_ArrowBaseCol);
  destroy_tuple(hv_ArrowHeadRow);
  destroy_tuple(hv_ArrowHeadCol);
  destroy_tuple(hv_ArrowHeadSize);
  destroy_tuple(hv_MaskRow);
  destroy_tuple(hv_MaskCol);
  destroy_tuple(hv_ContourStyle);
  destroy_tuple(hv_Style);
  destroy_tuple(hv_LineWidths);
  destroy_tuple(hv_IndexBbox);
  destroy_tuple(hv_ClassID);
  destroy_tuple(hv_CurrentColors);
  destroy_tuple(hv_IndexStyle);
  destroy_tuple(hv_TextColorClasses);
  destroy_tuple(hv_LabelRow);

  return;

  /****************************************************/
  /******************     End procedure   *************/
  /****************************************************/

}

/* Chapter: Graphics / Output*/
/* Short Description: Display the ground truth/result segmentation as regions. */
void dev_display_segmentation_regions (Hobject ho_SegmentationImage, Htuple hv_ClassIDs, 
    Htuple hv_ColorsSegmentation, Htuple hv_ExcludeClassIDs, Htuple *hv_ImageClassIDs)
{


  /* Stack for temporary tuples */
  Htuple   TTemp[100];
  int      SP=0;
  /* Stack for temporary tuple vectors */
  Hvector  TVTemp[100] = {0};
  int      SPTV=0;

  /* Local iconic variables */
  Hobject  ho_Regions, ho_SelectedRegion;

  /* Local control variables */
  Htuple  hv_IncludedClassIDs, hv_Area, hv_Index;
  Htuple  hv_ClassID, hv_IndexColor;

  /* Initialize iconic variables */
  gen_empty_obj(&ho_Regions);
  gen_empty_obj(&ho_SelectedRegion);

  /* Initialize control variables */
  create_tuple(&hv_IncludedClassIDs,0);
  create_tuple(&hv_Area,0);
  create_tuple(&hv_Index,0);
  create_tuple(&hv_ClassID,0);
  create_tuple(&hv_IndexColor,0);
  create_tuple(&(*hv_ImageClassIDs),0);

  /****************************************************/
  /******************   Begin procedure   *************/
  /****************************************************/

  /**/
  /*This procedure displays the ground truth/result segmentation*/
  /*given in SegmentationImage as regions. The ClassIDs are necessary to*/
  /*display ground truth/result segmentations from the same class*/
  /*always with the same color. It is possible to exclude certain ClassIDs*/
  /*from being displayed. The displayed classes are returned in ImageClassIDs.*/
  /**/
  /**/
  /*Remove excluded class IDs from the list.*/
  /*IncludedClassIDs := difference(ClassIDs,ExcludeClassIDs)*/
  T_tuple_difference(hv_ClassIDs,hv_ExcludeClassIDs,&TTemp[SP++]);
  destroy_tuple(hv_IncludedClassIDs);
  hv_IncludedClassIDs=TTemp[--SP];

  /**/
  /*Get a region for each class ID.*/
  /*threshold (SegmentationImage, Regions, IncludedClassIDs, IncludedClassIDs)*/
  clear_obj(ho_Regions);
  /***/T_threshold(ho_SegmentationImage, &ho_Regions, hv_IncludedClassIDs, hv_IncludedClassIDs);

  /**/
  /*Get classes with non-empty regions.*/
  /*region_features (Regions, 'area', Area)*/
  create_tuple_s(&TTemp[SP++],"area");
  destroy_tuple(hv_Area);
  /***/T_region_features(ho_Regions, TTemp[SP-1], &hv_Area);
  destroy_tuple(TTemp[--SP]);

  /*========== if (|Area| != |IncludedClassIDs|) ==========*/
  T_tuple_length(hv_Area,&TTemp[SP++]);
  T_tuple_length(hv_IncludedClassIDs,&TTemp[SP++]);
  T_tuple_not_equal(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-2]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-2]=TTemp[SP];
  SP--;
  if(get_i(TTemp[SP-1],0))
  {
    /* throw(...); only in hdevelop*/
  }
  destroy_tuple(TTemp[--SP]);
  /*========== end if ==========*/
  /*tuple_select_mask (IncludedClassIDs, Area [>] 0, ImageClassIDs)*/
  create_tuple_i(&TTemp[SP++],0);
  T_tuple_greater_elem(hv_Area,TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-1]=TTemp[SP];
  destroy_tuple((*hv_ImageClassIDs));
  /***/T_tuple_select_mask(hv_IncludedClassIDs, TTemp[SP-1], &(*hv_ImageClassIDs));
  destroy_tuple(TTemp[--SP]);

  /**/
  /*Display all non-empty class regions in distinct colors.*/
  /*========== for Index := 0 to |IncludedClassIDs| - 1 by 1 ==========*/
  T_tuple_length(hv_IncludedClassIDs,&TTemp[SP++]);
  create_tuple_i(&TTemp[SP++],1);
  T_tuple_sub(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-2]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-2]=TTemp[SP];
  SP--;
  create_tuple_i(&TTemp[SP++],1);
  create_tuple_i(&TTemp[SP++],0);
  T_tuple_greater(TTemp[SP-1],TTemp[SP-3],&TTemp[SP]);
  SP++;
  T_tuple_equal(TTemp[SP-2],TTemp[SP-4],&TTemp[SP]);
  if(get_i(TTemp[SP],0) ||
     (!((( get_i(TTemp[SP-1],0)) && (get_d(TTemp[SP-3],0)>0)) ||
        ((!get_i(TTemp[SP-1],0)) && (get_d(TTemp[SP-3],0)<0)))))
  {
   destroy_tuple(TTemp[SP--]);
   destroy_tuple(TTemp[SP]);
   T_tuple_sub(TTemp[SP-1],TTemp[SP-2],&TTemp[SP]);
   destroy_tuple(hv_Index);
   copy_tuple(TTemp[SP],&hv_Index);
   destroy_tuple(TTemp[SP--]);
   destroy_tuple(TTemp[SP]);
   for(;;)
   {
   T_tuple_add(hv_Index,TTemp[SP-1],&TTemp[SP]);
   destroy_tuple(hv_Index);
   copy_tuple(TTemp[SP],&hv_Index);
   destroy_tuple(TTemp[SP]);
   if(get_d(TTemp[SP-1],0)<0)
    T_tuple_less(hv_Index,TTemp[SP-2],&TTemp[SP]);
   else
    T_tuple_greater(hv_Index,TTemp[SP-2],&TTemp[SP]);
   if(get_i(TTemp[SP],0)) break;
   destroy_tuple(TTemp[SP]);
   /*========== for ==========*/

    /*========== if (Area[Index] > 0) ==========*/
    T_tuple_select(hv_Area,hv_Index,&TTemp[SP++]);
    create_tuple_i(&TTemp[SP++],0);
    T_tuple_greater(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-2]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-2]=TTemp[SP];
    SP--;
    if(get_i(TTemp[SP-1],0))
    {
      /*Use class ID to determine region color.*/
      /*ClassID := IncludedClassIDs[Index]*/
      T_tuple_select(hv_IncludedClassIDs,hv_Index,&TTemp[SP++]);
      destroy_tuple(hv_ClassID);
      hv_ClassID=TTemp[--SP];

      /*IndexColor := find_first(ClassIDs,ClassID)*/
      T_tuple_find_first(hv_ClassIDs,hv_ClassID,&TTemp[SP++]);
      destroy_tuple(hv_IndexColor);
      hv_IndexColor=TTemp[--SP];

      if (hdev_window_stack_is_open())
      {
        Htuple active_win;
        create_tuple(&active_win,0);
        hdev_window_stack_get_active(&active_win);
        /*dev_set_color (ColorsSegmentation[IndexColor])*/
        T_tuple_select(hv_ColorsSegmentation,hv_IndexColor,&TTemp[SP++]);
        /***/T_set_color(active_win,TTemp[SP-1]);
        destroy_tuple(TTemp[--SP]);
        destroy_tuple(active_win);
      }
      /*Display the segmentation region.*/
      /*select_obj (Regions, SelectedRegion, Index + 1)*/
      create_tuple_i(&TTemp[SP++],1);
      T_tuple_add(hv_Index,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      clear_obj(ho_SelectedRegion);
      /***/T_select_obj(ho_Regions, &ho_SelectedRegion, TTemp[SP-1]);
      destroy_tuple(TTemp[--SP]);

      if (hdev_window_stack_is_open())
      {
        Htuple active_win;
        create_tuple(&active_win,0);
        hdev_window_stack_get_active(&active_win);
        /*dev_display (SelectedRegion)*/
        /***/T_disp_obj(ho_SelectedRegion, active_win);
        destroy_tuple(active_win);
      }
    }
    destroy_tuple(TTemp[--SP]);
    /*========== end if ==========*/
   }
   destroy_tuple(TTemp[SP--]);
   destroy_tuple(TTemp[SP--]);
   destroy_tuple(TTemp[SP]);
  }
  else
  {
   destroy_tuple(TTemp[SP--]);
   destroy_tuple(TTemp[SP--]);
   destroy_tuple(TTemp[SP--]);
   destroy_tuple(TTemp[SP--]);
   destroy_tuple(TTemp[SP]);
  }/*========== end for ========*/

  /*========== return ==========*/

  /* Clear temporary tuple stack */
  while (SP > 0)
    destroy_tuple(TTemp[--SP]);
  /* Clear temporary tuple vectors stack*/
  while (SPTV > 0)
    V_destroy_vector(TVTemp[--SPTV]);
  /* Clear local iconic variables */
  clear_obj(ho_Regions);
  clear_obj(ho_SelectedRegion);

  /* Clear local control variables */
  destroy_tuple(hv_IncludedClassIDs);
  destroy_tuple(hv_Area);
  destroy_tuple(hv_Index);
  destroy_tuple(hv_ClassID);
  destroy_tuple(hv_IndexColor);

  return;

  /****************************************************/
  /******************     End procedure   *************/
  /****************************************************/

}

/* Chapter: Graphics / Output*/
/* Short Description: Display a map of weights. */
void dev_display_weight_regions (Hobject ho_ImageWeight, Htuple hv_DrawTransparency, 
    Htuple hv_SegMaxWeight, Htuple *hv_Colors)
{


  /* Stack for temporary tuples */
  Htuple   TTemp[100];
  int      SP=0;
  /* Stack for temporary tuple vectors */
  Hvector  TVTemp[100] = {0};
  int      SPTV=0;

  /* Local iconic variables */
  Hobject  ho_Domain, ho_WeightsRegion;

  /* Local control variables */
  Htuple  hv_NumColors, hv_WeightsColorsAlpha, hv_Rows;
  Htuple  hv_Columns, hv_GrayVal, hv_GrayValWeight, hv_ColorIndex;
  Htuple  hv_ClassColor;

  /* Initialize iconic variables */
  gen_empty_obj(&ho_Domain);
  gen_empty_obj(&ho_WeightsRegion);

  /* Initialize control variables */
  create_tuple(&hv_NumColors,0);
  create_tuple(&hv_WeightsColorsAlpha,0);
  create_tuple(&hv_Rows,0);
  create_tuple(&hv_Columns,0);
  create_tuple(&hv_GrayVal,0);
  create_tuple(&hv_GrayValWeight,0);
  create_tuple(&hv_ColorIndex,0);
  create_tuple(&hv_ClassColor,0);
  create_tuple(&(*hv_Colors),0);

  /****************************************************/
  /******************   Begin procedure   *************/
  /****************************************************/

  /**/
  /*This procedure displays a map of the weights*/
  /*given in ImageWeight as regions.*/
  /*The transparency can be adjusted.*/
  /*The used colors are returned.*/
  /**/
  /*Define colors.*/
  /*NumColors := 20*/
  reuse_tuple_i(&hv_NumColors,20);

  /*get_distinct_colors (NumColors, false, 0, 160, Colors)*/
  create_tuple_i(&TTemp[SP++],0);
  create_tuple_i(&TTemp[SP++],0);
  create_tuple_i(&TTemp[SP++],160);
  destroy_tuple((*hv_Colors));
  /***/get_distinct_colors(hv_NumColors, TTemp[SP-3], TTemp[SP-2], TTemp[SP-1], &(*hv_Colors));
  destroy_tuple(TTemp[--SP]);
  destroy_tuple(TTemp[--SP]);
  destroy_tuple(TTemp[--SP]);

  /*tuple_inverse (Colors, Colors)*/
  copy_tuple((*hv_Colors),&TTemp[SP++]);
  destroy_tuple((*hv_Colors));
  /***/T_tuple_inverse(TTemp[SP-1], &(*hv_Colors));
  destroy_tuple(TTemp[--SP]);

  /*WeightsColorsAlpha := Colors + DrawTransparency*/
  T_tuple_add((*hv_Colors),hv_DrawTransparency,&TTemp[SP++]);
  destroy_tuple(hv_WeightsColorsAlpha);
  hv_WeightsColorsAlpha=TTemp[--SP];

  /**/
  /*Get gay values of ImageWeight.*/
  /*get_domain (ImageWeight, Domain)*/
  clear_obj(ho_Domain);
  /***/get_domain(ho_ImageWeight, &ho_Domain);

  /*get_region_points (Domain, Rows, Columns)*/
  destroy_tuple(hv_Rows);
  destroy_tuple(hv_Columns);
  /***/T_get_region_points(ho_Domain, &hv_Rows, &hv_Columns);

  /*get_grayval (ImageWeight, Rows, Columns, GrayVal)*/
  destroy_tuple(hv_GrayVal);
  /***/T_get_grayval(ho_ImageWeight, hv_Rows, hv_Columns, &hv_GrayVal);

  /**/
  /*Check that the gray values of the image*/
  /*are below the specified maximum.*/
  /*========== if (max(GrayVal) > SegMaxWeight) ==========*/
  T_tuple_max(hv_GrayVal,&TTemp[SP++]);
  T_tuple_greater(TTemp[SP-1],hv_SegMaxWeight,&TTemp[SP]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-1]=TTemp[SP];
  if(get_i(TTemp[SP-1],0))
  {
    /* throw(...); only in hdevelop*/
  }
  destroy_tuple(TTemp[--SP]);
  /*========== end if ==========*/
  /**/
  /*========== while (GrayVal != []) ==========*/
  for(;;)
  {
  create_tuple(&TTemp[SP++],0);
  T_tuple_not_equal(hv_GrayVal,TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-1]=TTemp[SP];
  if(!get_i(TTemp[SP-1],0)) break;
  destroy_tuple(TTemp[--SP]);
    /*Go through all gray value 'groups',*/
    /*starting from the maximum.*/
    /*GrayValWeight := max(GrayVal)*/
    T_tuple_max(hv_GrayVal,&TTemp[SP++]);
    destroy_tuple(hv_GrayValWeight);
    hv_GrayValWeight=TTemp[--SP];

    /*GrayVal := remove(GrayVal,find(GrayVal,GrayValWeight))*/
    copy_tuple(hv_GrayVal,&TTemp[SP++]);
    copy_tuple(hv_GrayVal,&TTemp[SP++]);
    T_tuple_find(TTemp[SP-1],hv_GrayValWeight,&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    T_tuple_remove(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-2]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-2]=TTemp[SP];
    SP--;
    destroy_tuple(hv_GrayVal);
    hv_GrayVal=TTemp[--SP];

    /*threshold (ImageWeight, WeightsRegion, GrayValWeight, GrayValWeight)*/
    clear_obj(ho_WeightsRegion);
    /***/T_threshold(ho_ImageWeight, &ho_WeightsRegion, hv_GrayValWeight, hv_GrayValWeight);

    /**/
    /*Visualize the respective group.*/
    /*ColorIndex := int(ceil(GrayValWeight / SegMaxWeight * (NumColors - 1)))*/
    T_tuple_div(hv_GrayValWeight,hv_SegMaxWeight,&TTemp[SP++]);
    create_tuple_i(&TTemp[SP++],1);
    T_tuple_sub(hv_NumColors,TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    T_tuple_mult(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-2]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-2]=TTemp[SP];
    SP--;
    T_tuple_ceil(TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    T_tuple_int(TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    destroy_tuple(hv_ColorIndex);
    hv_ColorIndex=TTemp[--SP];

    /*ClassColor := WeightsColorsAlpha[ColorIndex]*/
    T_tuple_select(hv_WeightsColorsAlpha,hv_ColorIndex,&TTemp[SP++]);
    destroy_tuple(hv_ClassColor);
    hv_ClassColor=TTemp[--SP];

    if (hdev_window_stack_is_open())
    {
      Htuple active_win;
      create_tuple(&active_win,0);
      hdev_window_stack_get_active(&active_win);
      /*dev_set_color (ClassColor)*/
      /***/T_set_color(active_win,hv_ClassColor);
      destroy_tuple(active_win);
    }
    if (hdev_window_stack_is_open())
    {
      Htuple active_win;
      create_tuple(&active_win,0);
      hdev_window_stack_get_active(&active_win);
      /*dev_display (WeightsRegion)*/
      /***/T_disp_obj(ho_WeightsRegion, active_win);
      destroy_tuple(active_win);
    }
  }
  destroy_tuple(TTemp[--SP]);
  /*========== end while =====*/
  /*========== return ==========*/

  /* Clear temporary tuple stack */
  while (SP > 0)
    destroy_tuple(TTemp[--SP]);
  /* Clear temporary tuple vectors stack*/
  while (SPTV > 0)
    V_destroy_vector(TVTemp[--SPTV]);
  /* Clear local iconic variables */
  clear_obj(ho_Domain);
  clear_obj(ho_WeightsRegion);

  /* Clear local control variables */
  destroy_tuple(hv_NumColors);
  destroy_tuple(hv_WeightsColorsAlpha);
  destroy_tuple(hv_Rows);
  destroy_tuple(hv_Columns);
  destroy_tuple(hv_GrayVal);
  destroy_tuple(hv_GrayValWeight);
  destroy_tuple(hv_ColorIndex);
  destroy_tuple(hv_ClassColor);

  return;

  /****************************************************/
  /******************     End procedure   *************/
  /****************************************************/

}

/* Chapter: Develop*/
/* Short Description: Open a new graphics window that preserves the aspect ratio of the given image size. */
void dev_open_window_fit_size (Htuple hv_Row, Htuple hv_Column, Htuple hv_Width, 
    Htuple hv_Height, Htuple hv_WidthLimit, Htuple hv_HeightLimit, Htuple *hv_WindowHandle)
{

  /* Stack for temporary tuples */
  Htuple   TTemp[100];
  int      SP=0;
  /* Stack for temporary tuple vectors */
  Hvector  TVTemp[100] = {0};
  int      SPTV=0;

  /* Local iconic variables */

  /* Local control variables */
  Htuple  hv_MinWidth, hv_MaxWidth, hv_MinHeight;
  Htuple  hv_MaxHeight, hv_ResizeFactor, hv_TempWidth, hv_TempHeight;
  Htuple  hv_WindowWidth, hv_WindowHeight;

  /* Initialize control variables */
  create_tuple(&hv_MinWidth,0);
  create_tuple(&hv_MaxWidth,0);
  create_tuple(&hv_MinHeight,0);
  create_tuple(&hv_MaxHeight,0);
  create_tuple(&hv_ResizeFactor,0);
  create_tuple(&hv_TempWidth,0);
  create_tuple(&hv_TempHeight,0);
  create_tuple(&hv_WindowWidth,0);
  create_tuple(&hv_WindowHeight,0);
  create_tuple(&(*hv_WindowHandle),0);

  /****************************************************/
  /******************   Begin procedure   *************/
  /****************************************************/

  /*This procedure open a new graphic window*/
  /*such that it fits into the limits specified by WidthLimit*/
  /*and HeightLimit, but also maintains the correct aspect ratio*/
  /*given by Width and Height.*/
  /**/
  /*If it is impossible to match the minimum and maximum extent requirements*/
  /*at the same time (f.e. if the image is very long but narrow),*/
  /*the maximum value gets a higher priority.*/
  /**/
  /*Parse input tuple WidthLimit*/
  /*========== if (|WidthLimit| == 0 or WidthLimit < 0) ==========*/
  T_tuple_length(hv_WidthLimit,&TTemp[SP++]);
  create_tuple_i(&TTemp[SP++],0);
  T_tuple_equal(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-2]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-2]=TTemp[SP];
  SP--;
  create_tuple_i(&TTemp[SP++],0);
  T_tuple_less(hv_WidthLimit,TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-1]=TTemp[SP];
  T_tuple_or(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-2]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-2]=TTemp[SP];
  SP--;
  if(get_i(TTemp[SP-1],0))
  {
    /*MinWidth := 500*/
    reuse_tuple_i(&hv_MinWidth,500);

    /*MaxWidth := 800*/
    reuse_tuple_i(&hv_MaxWidth,800);

  }
  else
  {
  destroy_tuple(TTemp[--SP]);
  /*========== elseif (|WidthLimit| == 1) ==========*/

  T_tuple_length(hv_WidthLimit,&TTemp[SP++]);
  create_tuple_i(&TTemp[SP++],1);
  T_tuple_equal(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-2]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-2]=TTemp[SP];
  SP--;
  if(get_i(TTemp[SP-1],0))
  {
    /*MinWidth := 0*/
    reuse_tuple_i(&hv_MinWidth,0);

    /*MaxWidth := WidthLimit*/
    destroy_tuple(hv_MaxWidth);
    copy_tuple(hv_WidthLimit,&hv_MaxWidth);

  }
  else
  {
    /*MinWidth := WidthLimit[0]*/
    create_tuple_i(&TTemp[SP++],0);
    T_tuple_select(hv_WidthLimit,TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    destroy_tuple(hv_MinWidth);
    hv_MinWidth=TTemp[--SP];

    /*MaxWidth := WidthLimit[1]*/
    create_tuple_i(&TTemp[SP++],1);
    T_tuple_select(hv_WidthLimit,TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    destroy_tuple(hv_MaxWidth);
    hv_MaxWidth=TTemp[--SP];

  }
  }
  destroy_tuple(TTemp[--SP]);
  /*========== end if ==========*/
  /*Parse input tuple HeightLimit*/
  /*========== if (|HeightLimit| == 0 or HeightLimit < 0) ==========*/
  T_tuple_length(hv_HeightLimit,&TTemp[SP++]);
  create_tuple_i(&TTemp[SP++],0);
  T_tuple_equal(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-2]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-2]=TTemp[SP];
  SP--;
  create_tuple_i(&TTemp[SP++],0);
  T_tuple_less(hv_HeightLimit,TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-1]=TTemp[SP];
  T_tuple_or(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-2]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-2]=TTemp[SP];
  SP--;
  if(get_i(TTemp[SP-1],0))
  {
    /*MinHeight := 400*/
    reuse_tuple_i(&hv_MinHeight,400);

    /*MaxHeight := 600*/
    reuse_tuple_i(&hv_MaxHeight,600);

  }
  else
  {
  destroy_tuple(TTemp[--SP]);
  /*========== elseif (|HeightLimit| == 1) ==========*/

  T_tuple_length(hv_HeightLimit,&TTemp[SP++]);
  create_tuple_i(&TTemp[SP++],1);
  T_tuple_equal(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-2]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-2]=TTemp[SP];
  SP--;
  if(get_i(TTemp[SP-1],0))
  {
    /*MinHeight := 0*/
    reuse_tuple_i(&hv_MinHeight,0);

    /*MaxHeight := HeightLimit*/
    destroy_tuple(hv_MaxHeight);
    copy_tuple(hv_HeightLimit,&hv_MaxHeight);

  }
  else
  {
    /*MinHeight := HeightLimit[0]*/
    create_tuple_i(&TTemp[SP++],0);
    T_tuple_select(hv_HeightLimit,TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    destroy_tuple(hv_MinHeight);
    hv_MinHeight=TTemp[--SP];

    /*MaxHeight := HeightLimit[1]*/
    create_tuple_i(&TTemp[SP++],1);
    T_tuple_select(hv_HeightLimit,TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    destroy_tuple(hv_MaxHeight);
    hv_MaxHeight=TTemp[--SP];

  }
  }
  destroy_tuple(TTemp[--SP]);
  /*========== end if ==========*/
  /**/
  /*Test, if window size has to be changed.*/
  /*ResizeFactor := 1*/
  reuse_tuple_i(&hv_ResizeFactor,1);

  /*First, expand window to the minimum extents (if necessary).*/
  /*========== if (MinWidth > Width or MinHeight > Height) ==========*/
  T_tuple_greater(hv_MinWidth,hv_Width,&TTemp[SP++]);
  T_tuple_greater(hv_MinHeight,hv_Height,&TTemp[SP++]);
  T_tuple_or(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-2]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-2]=TTemp[SP];
  SP--;
  if(get_i(TTemp[SP-1],0))
  {
    /*ResizeFactor := max([real(MinWidth) / Width,real(MinHeight) / Height])*/
    T_tuple_real(hv_MinWidth,&TTemp[SP++]);
    T_tuple_div(TTemp[SP-1],hv_Width,&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    T_tuple_real(hv_MinHeight,&TTemp[SP++]);
    T_tuple_div(TTemp[SP-1],hv_Height,&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    T_tuple_concat(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-2]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-2]=TTemp[SP];
    SP--;
    T_tuple_max(TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    destroy_tuple(hv_ResizeFactor);
    hv_ResizeFactor=TTemp[--SP];

  }
  destroy_tuple(TTemp[--SP]);
  /*========== end if ==========*/
  /*TempWidth := Width * ResizeFactor*/
  T_tuple_mult(hv_Width,hv_ResizeFactor,&TTemp[SP++]);
  destroy_tuple(hv_TempWidth);
  hv_TempWidth=TTemp[--SP];

  /*TempHeight := Height * ResizeFactor*/
  T_tuple_mult(hv_Height,hv_ResizeFactor,&TTemp[SP++]);
  destroy_tuple(hv_TempHeight);
  hv_TempHeight=TTemp[--SP];

  /*Then, shrink window to maximum extents (if necessary).*/
  /*========== if (MaxWidth < TempWidth or MaxHeight < TempHeight) ==========*/
  T_tuple_less(hv_MaxWidth,hv_TempWidth,&TTemp[SP++]);
  T_tuple_less(hv_MaxHeight,hv_TempHeight,&TTemp[SP++]);
  T_tuple_or(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-2]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-2]=TTemp[SP];
  SP--;
  if(get_i(TTemp[SP-1],0))
  {
    /*ResizeFactor := ResizeFactor * min([real(MaxWidth) / TempWidth,real(MaxHeight) / TempHeight])*/
    copy_tuple(hv_ResizeFactor,&TTemp[SP++]);
    T_tuple_real(hv_MaxWidth,&TTemp[SP++]);
    T_tuple_div(TTemp[SP-1],hv_TempWidth,&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    T_tuple_real(hv_MaxHeight,&TTemp[SP++]);
    T_tuple_div(TTemp[SP-1],hv_TempHeight,&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    T_tuple_concat(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-2]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-2]=TTemp[SP];
    SP--;
    T_tuple_min(TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    T_tuple_mult(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-2]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-2]=TTemp[SP];
    SP--;
    destroy_tuple(hv_ResizeFactor);
    hv_ResizeFactor=TTemp[--SP];

  }
  destroy_tuple(TTemp[--SP]);
  /*========== end if ==========*/
  /*WindowWidth := Width * ResizeFactor*/
  T_tuple_mult(hv_Width,hv_ResizeFactor,&TTemp[SP++]);
  destroy_tuple(hv_WindowWidth);
  hv_WindowWidth=TTemp[--SP];

  /*WindowHeight := Height * ResizeFactor*/
  T_tuple_mult(hv_Height,hv_ResizeFactor,&TTemp[SP++]);
  destroy_tuple(hv_WindowHeight);
  hv_WindowHeight=TTemp[--SP];

  /*Resize window*/
  /*dev_open_window (Row, Column, WindowWidth, WindowHeight, 'black', WindowHandle)*/
  create_tuple_s(&TTemp[SP++],"black");
  create_tuple_s(&TTemp[SP++],"background_color");
  T_set_window_attr(TTemp[SP-1],TTemp[SP-2]);
  destroy_tuple(TTemp[--SP]);
  destroy_tuple(TTemp[--SP]);
  create_tuple_i(&TTemp[SP++],0);
  create_tuple_s(&TTemp[SP++],"visible");
  create_tuple_s(&TTemp[SP++],"");
  destroy_tuple((*hv_WindowHandle));
  /***/T_open_window(hv_Row,hv_Column,hv_WindowWidth,hv_WindowHeight,TTemp[SP-3],TTemp[SP-2],TTemp[SP-1],&(*hv_WindowHandle));
  destroy_tuple(TTemp[--SP]);
  destroy_tuple(TTemp[--SP]);
  destroy_tuple(TTemp[--SP]);
  hdev_window_stack_push((*hv_WindowHandle));

  if (hdev_window_stack_is_open())
  {
    Htuple active_win;
    create_tuple(&active_win,0);
    hdev_window_stack_get_active(&active_win);
    /*dev_set_part (0, 0, Height - 1, Width - 1)*/
    create_tuple_i(&TTemp[SP++],0);
    create_tuple_i(&TTemp[SP++],0);
    create_tuple_i(&TTemp[SP++],1);
    T_tuple_sub(hv_Height,TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    create_tuple_i(&TTemp[SP++],1);
    T_tuple_sub(hv_Width,TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    /***/T_set_part(active_win,TTemp[SP-4], TTemp[SP-3], TTemp[SP-2], TTemp[SP-1]);
    destroy_tuple(TTemp[--SP]);
    destroy_tuple(TTemp[--SP]);
    destroy_tuple(TTemp[--SP]);
    destroy_tuple(TTemp[--SP]);
    destroy_tuple(active_win);
  }
  /*========== return ==========*/

  /* Clear temporary tuple stack */
  while (SP > 0)
    destroy_tuple(TTemp[--SP]);
  /* Clear temporary tuple vectors stack*/
  while (SPTV > 0)
    V_destroy_vector(TVTemp[--SPTV]);
  /* Clear local control variables */
  destroy_tuple(hv_MinWidth);
  destroy_tuple(hv_MaxWidth);
  destroy_tuple(hv_MinHeight);
  destroy_tuple(hv_MaxHeight);
  destroy_tuple(hv_ResizeFactor);
  destroy_tuple(hv_TempWidth);
  destroy_tuple(hv_TempHeight);
  destroy_tuple(hv_WindowWidth);
  destroy_tuple(hv_WindowHeight);

  return;

  /****************************************************/
  /******************     End procedure   *************/
  /****************************************************/

}

/* Chapter: Deep Learning / Object Detection and Instance Segmentation*/
/* Short Description: Filter the instance segmentation masks of a DL sample based on a given selection. */
void filter_dl_sample_instance_segmentation_masks (Htuple hv_DLSample, Htuple hv_BBoxSelectionMask)
{

  /* Stack for temporary tuples */
  Htuple   TTemp[100];
  int      SP=0;
  /* Stack for temporary objects */
  Hobject  OTemp[20] = {0};
  int      SPO=0;
  /* Stack for temporary tuple vectors */
  Hvector  TVTemp[100] = {0};
  int      SPTV=0;

  /* Local iconic variables */
  Hobject  ho_EmptyMasks, ho_Masks;

  /* Local control variables */
  Htuple  hv_MaskKeyExists, hv_Indices;

  /* Initialize iconic variables */
  gen_empty_obj(&ho_EmptyMasks);
  gen_empty_obj(&ho_Masks);

  /* Initialize control variables */
  create_tuple(&hv_MaskKeyExists,0);
  create_tuple(&hv_Indices,0);

  /****************************************************/
  /******************   Begin procedure   *************/
  /****************************************************/

  /*get_dict_param (DLSample, 'key_exists', 'mask', MaskKeyExists)*/
  create_tuple_s(&TTemp[SP++],"key_exists");
  create_tuple_s(&TTemp[SP++],"mask");
  destroy_tuple(hv_MaskKeyExists);
  /***/T_get_dict_param(hv_DLSample, TTemp[SP-2], TTemp[SP-1], &hv_MaskKeyExists);
  destroy_tuple(TTemp[--SP]);
  destroy_tuple(TTemp[--SP]);

  /*========== if (MaskKeyExists) ==========*/
  copy_tuple(hv_MaskKeyExists,&TTemp[SP++]);
  if(get_i(TTemp[SP-1],0))
  {
    /*Only if masks exist (-> instance segmentation).*/
    /*tuple_find (BBoxSelectionMask, 1, Indices)*/
    create_tuple_i(&TTemp[SP++],1);
    destroy_tuple(hv_Indices);
    /***/T_tuple_find(hv_BBoxSelectionMask, TTemp[SP-1], &hv_Indices);
    destroy_tuple(TTemp[--SP]);

    /*========== if (Indices == -1) ==========*/
    create_tuple_i(&TTemp[SP++],-1);
    T_tuple_equal(hv_Indices,TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    if(get_i(TTemp[SP-1],0))
    {
      /*We define here that this case will result in an empty object value*/
      /*for the mask key. Another option would be to remove the*/
      /*key 'mask'. However, this would be an unwanted big change in the dictionary.*/
      /*gen_empty_obj (EmptyMasks)*/
      clear_obj(ho_EmptyMasks);
      /***/gen_empty_obj(&ho_EmptyMasks);

      /*set_dict_object (EmptyMasks, DLSample, 'mask')*/
      create_tuple_s(&TTemp[SP++],"mask");
      /***/T_set_dict_object(ho_EmptyMasks, hv_DLSample, TTemp[SP-1]);
      destroy_tuple(TTemp[--SP]);

    }
    else
    {
      /*get_dict_object (Masks, DLSample, 'mask')*/
      create_tuple_s(&TTemp[SP++],"mask");
      clear_obj(ho_Masks);
      /***/T_get_dict_object(&ho_Masks, hv_DLSample, TTemp[SP-1]);
      destroy_tuple(TTemp[--SP]);

      /*Remove all unused masks.*/
      /*select_obj (Masks, Masks, Indices + 1)*/
      create_tuple_i(&TTemp[SP++],1);
      T_tuple_add(hv_Indices,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      /***/T_select_obj(ho_Masks, &(OTemp[SPO]), TTemp[SP-1]);
      SPO++;
      clear_obj(ho_Masks);
      ho_Masks = OTemp[--SPO];
      destroy_tuple(TTemp[--SP]);

      /*set_dict_object (Masks, DLSample, 'mask')*/
      create_tuple_s(&TTemp[SP++],"mask");
      /***/T_set_dict_object(ho_Masks, hv_DLSample, TTemp[SP-1]);
      destroy_tuple(TTemp[--SP]);

    }
    destroy_tuple(TTemp[--SP]);
    /*========== end if ==========*/
  }
  destroy_tuple(TTemp[--SP]);
  /*========== end if ==========*/
  /*========== return ==========*/

  /* Clear temporary tuple stack */
  while (SP > 0)
    destroy_tuple(TTemp[--SP]);
  /* Clear temporary tuple vectors stack*/
  while (SPTV > 0)
    V_destroy_vector(TVTemp[--SPTV]);
  /* Clear local iconic variables */
  clear_obj(ho_EmptyMasks);
  clear_obj(ho_Masks);

  /* Clear local control variables */
  destroy_tuple(hv_MaskKeyExists);
  destroy_tuple(hv_Indices);

  return;

  /****************************************************/
  /******************     End procedure   *************/
  /****************************************************/

}

/* Chapter: XLD / Creation*/
/* Short Description: Create an arrow shaped XLD contour. */
void gen_arrow_contour_xld (Hobject *ho_Arrow, Htuple hv_Row1, Htuple hv_Column1, 
    Htuple hv_Row2, Htuple hv_Column2, Htuple hv_HeadLength, Htuple hv_HeadWidth)
{

  /* Stack for temporary tuples */
  Htuple   TTemp[100];
  int      SP=0;
  /* Stack for temporary objects */
  Hobject  OTemp[20] = {0};
  int      SPO=0;
  /* Stack for temporary tuple vectors */
  Hvector  TVTemp[100] = {0};
  int      SPTV=0;

  /* Local iconic variables */
  Hobject  ho_TempArrow;

  /* Local control variables */
  Htuple  hv_Length, hv_ZeroLengthIndices, hv_DR;
  Htuple  hv_DC, hv_HalfHeadWidth, hv_RowP1, hv_ColP1, hv_RowP2;
  Htuple  hv_ColP2, hv_Index;

  /* Initialize iconic variables */
  gen_empty_obj(&ho_TempArrow);
  gen_empty_obj(&(*ho_Arrow));

  /* Initialize control variables */
  create_tuple(&hv_Length,0);
  create_tuple(&hv_ZeroLengthIndices,0);
  create_tuple(&hv_DR,0);
  create_tuple(&hv_DC,0);
  create_tuple(&hv_HalfHeadWidth,0);
  create_tuple(&hv_RowP1,0);
  create_tuple(&hv_ColP1,0);
  create_tuple(&hv_RowP2,0);
  create_tuple(&hv_ColP2,0);
  create_tuple(&hv_Index,0);

  /****************************************************/
  /******************   Begin procedure   *************/
  /****************************************************/

  /*This procedure generates arrow shaped XLD contours,*/
  /*pointing from (Row1, Column1) to (Row2, Column2).*/
  /*If starting and end point are identical, a contour consisting*/
  /*of a single point is returned.*/
  /**/
  /*input parameters:*/
  /*Row1, Column1: Coordinates of the arrows' starting points*/
  /*Row2, Column2: Coordinates of the arrows' end points*/
  /*HeadLength, HeadWidth: Size of the arrow heads in pixels*/
  /**/
  /*output parameter:*/
  /*Arrow: The resulting XLD contour*/
  /**/
  /*The input tuples Row1, Column1, Row2, and Column2 have to be of*/
  /*the same length.*/
  /*HeadLength and HeadWidth either have to be of the same length as*/
  /*Row1, Column1, Row2, and Column2 or have to be a single element.*/
  /*If one of the above restrictions is violated, an error will occur.*/
  /**/
  /**/
  /*Initialization.*/
  /*gen_empty_obj (Arrow)*/
  clear_obj((*ho_Arrow));
  /***/gen_empty_obj(&(*ho_Arrow));

  /**/
  /*Calculate the arrow length*/
  /*distance_pp (Row1, Column1, Row2, Column2, Length)*/
  destroy_tuple(hv_Length);
  /***/T_distance_pp(hv_Row1, hv_Column1, hv_Row2, hv_Column2, &hv_Length);

  /**/
  /*Mark arrows with identical start and end point*/
  /*(set Length to -1 to avoid division-by-zero exception)*/
  /*ZeroLengthIndices := find(Length,0)*/
  create_tuple_i(&TTemp[SP++],0);
  T_tuple_find(hv_Length,TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-1]=TTemp[SP];
  destroy_tuple(hv_ZeroLengthIndices);
  hv_ZeroLengthIndices=TTemp[--SP];

  /*========== if (ZeroLengthIndices != -1) ==========*/
  create_tuple_i(&TTemp[SP++],-1);
  T_tuple_not_equal(hv_ZeroLengthIndices,TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-1]=TTemp[SP];
  if(get_i(TTemp[SP-1],0))
  {
    /*Length[ZeroLengthIndices] := -1*/
    create_tuple_i(&TTemp[SP++],-1);
    replace_elements(&hv_Length,&hv_ZeroLengthIndices,&TTemp[SP-1]);
    destroy_tuple(TTemp[--SP]);
  }
  destroy_tuple(TTemp[--SP]);
  /*========== end if ==========*/
  /**/
  /*Calculate auxiliary variables.*/
  /*DR := 1.0 * (Row2 - Row1) / Length*/
  create_tuple_d(&TTemp[SP++],1.0);
  T_tuple_sub(hv_Row2,hv_Row1,&TTemp[SP++]);
  T_tuple_mult(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-2]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-2]=TTemp[SP];
  SP--;
  T_tuple_div(TTemp[SP-1],hv_Length,&TTemp[SP]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-1]=TTemp[SP];
  destroy_tuple(hv_DR);
  hv_DR=TTemp[--SP];

  /*DC := 1.0 * (Column2 - Column1) / Length*/
  create_tuple_d(&TTemp[SP++],1.0);
  T_tuple_sub(hv_Column2,hv_Column1,&TTemp[SP++]);
  T_tuple_mult(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-2]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-2]=TTemp[SP];
  SP--;
  T_tuple_div(TTemp[SP-1],hv_Length,&TTemp[SP]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-1]=TTemp[SP];
  destroy_tuple(hv_DC);
  hv_DC=TTemp[--SP];

  /*HalfHeadWidth := HeadWidth / 2.0*/
  create_tuple_d(&TTemp[SP++],2.0);
  T_tuple_div(hv_HeadWidth,TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-1]=TTemp[SP];
  destroy_tuple(hv_HalfHeadWidth);
  hv_HalfHeadWidth=TTemp[--SP];

  /**/
  /*Calculate end points of the arrow head.*/
  /*RowP1 := Row1 + (Length - HeadLength) * DR + HalfHeadWidth * DC*/
  T_tuple_sub(hv_Length,hv_HeadLength,&TTemp[SP++]);
  T_tuple_mult(TTemp[SP-1],hv_DR,&TTemp[SP]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-1]=TTemp[SP];
  T_tuple_add(hv_Row1,TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-1]=TTemp[SP];
  T_tuple_mult(hv_HalfHeadWidth,hv_DC,&TTemp[SP++]);
  T_tuple_add(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-2]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-2]=TTemp[SP];
  SP--;
  destroy_tuple(hv_RowP1);
  hv_RowP1=TTemp[--SP];

  /*ColP1 := Column1 + (Length - HeadLength) * DC - HalfHeadWidth * DR*/
  T_tuple_sub(hv_Length,hv_HeadLength,&TTemp[SP++]);
  T_tuple_mult(TTemp[SP-1],hv_DC,&TTemp[SP]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-1]=TTemp[SP];
  T_tuple_add(hv_Column1,TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-1]=TTemp[SP];
  T_tuple_mult(hv_HalfHeadWidth,hv_DR,&TTemp[SP++]);
  T_tuple_sub(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-2]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-2]=TTemp[SP];
  SP--;
  destroy_tuple(hv_ColP1);
  hv_ColP1=TTemp[--SP];

  /*RowP2 := Row1 + (Length - HeadLength) * DR - HalfHeadWidth * DC*/
  T_tuple_sub(hv_Length,hv_HeadLength,&TTemp[SP++]);
  T_tuple_mult(TTemp[SP-1],hv_DR,&TTemp[SP]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-1]=TTemp[SP];
  T_tuple_add(hv_Row1,TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-1]=TTemp[SP];
  T_tuple_mult(hv_HalfHeadWidth,hv_DC,&TTemp[SP++]);
  T_tuple_sub(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-2]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-2]=TTemp[SP];
  SP--;
  destroy_tuple(hv_RowP2);
  hv_RowP2=TTemp[--SP];

  /*ColP2 := Column1 + (Length - HeadLength) * DC + HalfHeadWidth * DR*/
  T_tuple_sub(hv_Length,hv_HeadLength,&TTemp[SP++]);
  T_tuple_mult(TTemp[SP-1],hv_DC,&TTemp[SP]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-1]=TTemp[SP];
  T_tuple_add(hv_Column1,TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-1]=TTemp[SP];
  T_tuple_mult(hv_HalfHeadWidth,hv_DR,&TTemp[SP++]);
  T_tuple_add(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-2]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-2]=TTemp[SP];
  SP--;
  destroy_tuple(hv_ColP2);
  hv_ColP2=TTemp[--SP];

  /**/
  /*Finally create output XLD contour for each input point pair*/
  /*========== for Index := 0 to |Length| - 1 by 1 ==========*/
  T_tuple_length(hv_Length,&TTemp[SP++]);
  create_tuple_i(&TTemp[SP++],1);
  T_tuple_sub(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-2]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-2]=TTemp[SP];
  SP--;
  create_tuple_i(&TTemp[SP++],1);
  create_tuple_i(&TTemp[SP++],0);
  T_tuple_greater(TTemp[SP-1],TTemp[SP-3],&TTemp[SP]);
  SP++;
  T_tuple_equal(TTemp[SP-2],TTemp[SP-4],&TTemp[SP]);
  if(get_i(TTemp[SP],0) ||
     (!((( get_i(TTemp[SP-1],0)) && (get_d(TTemp[SP-3],0)>0)) ||
        ((!get_i(TTemp[SP-1],0)) && (get_d(TTemp[SP-3],0)<0)))))
  {
   destroy_tuple(TTemp[SP--]);
   destroy_tuple(TTemp[SP]);
   T_tuple_sub(TTemp[SP-1],TTemp[SP-2],&TTemp[SP]);
   destroy_tuple(hv_Index);
   copy_tuple(TTemp[SP],&hv_Index);
   destroy_tuple(TTemp[SP--]);
   destroy_tuple(TTemp[SP]);
   for(;;)
   {
   T_tuple_add(hv_Index,TTemp[SP-1],&TTemp[SP]);
   destroy_tuple(hv_Index);
   copy_tuple(TTemp[SP],&hv_Index);
   destroy_tuple(TTemp[SP]);
   if(get_d(TTemp[SP-1],0)<0)
    T_tuple_less(hv_Index,TTemp[SP-2],&TTemp[SP]);
   else
    T_tuple_greater(hv_Index,TTemp[SP-2],&TTemp[SP]);
   if(get_i(TTemp[SP],0)) break;
   destroy_tuple(TTemp[SP]);
   /*========== for ==========*/

    /*========== if (Length[Index] == -1) ==========*/
    T_tuple_select(hv_Length,hv_Index,&TTemp[SP++]);
    create_tuple_i(&TTemp[SP++],-1);
    T_tuple_equal(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-2]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-2]=TTemp[SP];
    SP--;
    if(get_i(TTemp[SP-1],0))
    {
      /*Create_ single points for arrows with identical start and end point*/
      /*gen_contour_polygon_xld (TempArrow, Row1[Index], Column1[Index])*/
      T_tuple_select(hv_Row1,hv_Index,&TTemp[SP++]);
      T_tuple_select(hv_Column1,hv_Index,&TTemp[SP++]);
      clear_obj(ho_TempArrow);
      /***/T_gen_contour_polygon_xld(&ho_TempArrow, TTemp[SP-2], TTemp[SP-1]);
      destroy_tuple(TTemp[--SP]);
      destroy_tuple(TTemp[--SP]);

    }
    else
    {
      /*Create arrow contour*/
      /*gen_contour_polygon_xld (TempArrow, [Row1[Index],Row2[Index],RowP1[Index],Row2[Index],RowP2[Index],Row2[Index]], [Column1[Index],Column2[Index],ColP1[Index],Column2[Index],ColP2[Index],Column2[Index]])*/
      T_tuple_select(hv_Row1,hv_Index,&TTemp[SP++]);
      T_tuple_select(hv_Row2,hv_Index,&TTemp[SP++]);
      T_tuple_concat(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-2]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-2]=TTemp[SP];
      SP--;
      T_tuple_select(hv_RowP1,hv_Index,&TTemp[SP++]);
      T_tuple_concat(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-2]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-2]=TTemp[SP];
      SP--;
      T_tuple_select(hv_Row2,hv_Index,&TTemp[SP++]);
      T_tuple_concat(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-2]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-2]=TTemp[SP];
      SP--;
      T_tuple_select(hv_RowP2,hv_Index,&TTemp[SP++]);
      T_tuple_concat(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-2]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-2]=TTemp[SP];
      SP--;
      T_tuple_select(hv_Row2,hv_Index,&TTemp[SP++]);
      T_tuple_concat(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-2]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-2]=TTemp[SP];
      SP--;
      T_tuple_select(hv_Column1,hv_Index,&TTemp[SP++]);
      T_tuple_select(hv_Column2,hv_Index,&TTemp[SP++]);
      T_tuple_concat(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-2]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-2]=TTemp[SP];
      SP--;
      T_tuple_select(hv_ColP1,hv_Index,&TTemp[SP++]);
      T_tuple_concat(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-2]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-2]=TTemp[SP];
      SP--;
      T_tuple_select(hv_Column2,hv_Index,&TTemp[SP++]);
      T_tuple_concat(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-2]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-2]=TTemp[SP];
      SP--;
      T_tuple_select(hv_ColP2,hv_Index,&TTemp[SP++]);
      T_tuple_concat(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-2]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-2]=TTemp[SP];
      SP--;
      T_tuple_select(hv_Column2,hv_Index,&TTemp[SP++]);
      T_tuple_concat(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-2]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-2]=TTemp[SP];
      SP--;
      clear_obj(ho_TempArrow);
      /***/T_gen_contour_polygon_xld(&ho_TempArrow, TTemp[SP-2], TTemp[SP-1]);
      destroy_tuple(TTemp[--SP]);
      destroy_tuple(TTemp[--SP]);

    }
    destroy_tuple(TTemp[--SP]);
    /*========== end if ==========*/
    /*concat_obj (Arrow, TempArrow, Arrow)*/
    /***/concat_obj((*ho_Arrow), ho_TempArrow, &(OTemp[SPO]));
    SPO++;
    clear_obj((*ho_Arrow));
    (*ho_Arrow) = OTemp[--SPO];

   }
   destroy_tuple(TTemp[SP--]);
   destroy_tuple(TTemp[SP--]);
   destroy_tuple(TTemp[SP]);
  }
  else
  {
   destroy_tuple(TTemp[SP--]);
   destroy_tuple(TTemp[SP--]);
   destroy_tuple(TTemp[SP--]);
   destroy_tuple(TTemp[SP--]);
   destroy_tuple(TTemp[SP]);
  }/*========== end for ========*/

  /*========== return ==========*/

  /* Clear temporary tuple stack */
  while (SP > 0)
    destroy_tuple(TTemp[--SP]);
  /* Clear temporary tuple vectors stack*/
  while (SPTV > 0)
    V_destroy_vector(TVTemp[--SPTV]);
  /* Clear local iconic variables */
  clear_obj(ho_TempArrow);

  /* Clear local control variables */
  destroy_tuple(hv_Length);
  destroy_tuple(hv_ZeroLengthIndices);
  destroy_tuple(hv_DR);
  destroy_tuple(hv_DC);
  destroy_tuple(hv_HalfHeadWidth);
  destroy_tuple(hv_RowP1);
  destroy_tuple(hv_ColP1);
  destroy_tuple(hv_RowP2);
  destroy_tuple(hv_ColP2);
  destroy_tuple(hv_Index);

  return;

  /****************************************************/
  /******************     End procedure   *************/
  /****************************************************/

}

/* Chapter: OCR / Deep OCR*/
/* Short Description: Generate ground truth characters if they don't exist and words to characters mapping. */
void gen_dl_ocr_detection_gt_chars (Htuple hv_DLSampleTargets, Htuple hv_DLSample, 
    Htuple hv_ScaleWidth, Htuple hv_ScaleHeight, Hvector/*{eTupleVector,Dim=1}*/ *hvec_WordsCharsMapping)
{

  /* Stack for temporary tuples */
  Htuple   TTemp[100];
  int      SP=0;
  /* Stack for temporary tuple vectors */
  Hvector  TVTemp[100] = {0};
  int      SPTV=0;

  /* Local iconic variables */

  /* Local control variables */
  Htuple  hv_CharBoxIndex, hv_WordLengths, hv_J;
  Htuple  hv_Start, hv_End, hv_SplitRow, hv_SplitColumn, hv_SplitPhi;
  Htuple  hv_SplitLength1, hv_SplitLength2, hv_CharsIds, hv_EmptyWordStrings;

  /* Initialize control variables */
  create_tuple(&hv_CharBoxIndex,0);
  create_tuple(&hv_WordLengths,0);
  create_tuple(&hv_J,0);
  create_tuple(&hv_Start,0);
  create_tuple(&hv_End,0);
  create_tuple(&hv_SplitRow,0);
  create_tuple(&hv_SplitColumn,0);
  create_tuple(&hv_SplitPhi,0);
  create_tuple(&hv_SplitLength1,0);
  create_tuple(&hv_SplitLength2,0);
  create_tuple(&hv_CharsIds,0);
  create_tuple(&hv_EmptyWordStrings,0);
  V_create_tuple_vector(1,&(*hvec_WordsCharsMapping));

  /****************************************************/
  /******************   Begin procedure   *************/
  /****************************************************/

  /*WordsCharsMapping.at(0) := []*/
  create_tuple(&TTemp[SP++],0);
  create_tuple(&TTemp[SP++],1);
  set_i(TTemp[SP-1],0,0);
  V_set_vector_tuple((*hvec_WordsCharsMapping),TTemp[SP-1],TTemp[SP-2]);
  destroy_tuple(TTemp[--SP]);
  destroy_tuple(TTemp[--SP]);
  /*========== if (|__get_dict_tuple( DLSample, ['bbox_label_id'])| > 0) ==========*/
  create_tuple_s(&TTemp[SP++],"bbox_label_id");
  T_get_dict_tuple(hv_DLSample,TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-1]=TTemp[SP];
  T_tuple_length(TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-1]=TTemp[SP];
  create_tuple_i(&TTemp[SP++],0);
  T_tuple_greater(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-2]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-2]=TTemp[SP];
  SP--;
  if(get_i(TTemp[SP-1],0))
  {
    /*Check if chars GT exist otherwise generate them.*/
    /*tuple_find_first (__get_dict_tuple( DLSample, ['bbox_label_id']), 1, CharBoxIndex)*/
    create_tuple_s(&TTemp[SP++],"bbox_label_id");
    T_get_dict_tuple(hv_DLSample,TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    create_tuple_i(&TTemp[SP++],1);
    destroy_tuple(hv_CharBoxIndex);
    /***/T_tuple_find_first(TTemp[SP-2], TTemp[SP-1], &hv_CharBoxIndex);
    destroy_tuple(TTemp[--SP]);
    destroy_tuple(TTemp[--SP]);

    /*========== if (CharBoxIndex == -1) ==========*/
    create_tuple_i(&TTemp[SP++],-1);
    T_tuple_equal(hv_CharBoxIndex,TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    if(get_i(TTemp[SP-1],0))
    {
      /*WordLengths := strlen(__get_dict_tuple( DLSample, ['word']))*/
      create_tuple_s(&TTemp[SP++],"word");
      T_get_dict_tuple(hv_DLSample,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      T_tuple_strlen(TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      destroy_tuple(hv_WordLengths);
      hv_WordLengths=TTemp[--SP];

      /*WordsCharsMapping.at(|__get_dict_tuple( DLSample, ['bbox_label_id'])|-1) := []*/
      create_tuple(&TTemp[SP++],0);
      create_tuple(&TTemp[SP++],1);
      create_tuple_s(&TTemp[SP++],"bbox_label_id");
      T_get_dict_tuple(hv_DLSample,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      T_tuple_length(TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      create_tuple_i(&TTemp[SP++],1);
      T_tuple_sub(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-2]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-2]=TTemp[SP];
      SP--;
      set_i(TTemp[SP-2],get_i(TTemp[SP-1],0),0);
      destroy_tuple(TTemp[--SP]);
      V_set_vector_tuple((*hvec_WordsCharsMapping),TTemp[SP-1],TTemp[SP-2]);
      destroy_tuple(TTemp[--SP]);
      destroy_tuple(TTemp[--SP]);
      /*========== for J := 0 to |__get_dict_tuple( DLSample, ['bbox_label_id'])| - 1 by 1 ==========*/
      create_tuple_s(&TTemp[SP++],"bbox_label_id");
      T_get_dict_tuple(hv_DLSample,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      T_tuple_length(TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      create_tuple_i(&TTemp[SP++],1);
      T_tuple_sub(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-2]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-2]=TTemp[SP];
      SP--;
      create_tuple_i(&TTemp[SP++],1);
      create_tuple_i(&TTemp[SP++],0);
      T_tuple_greater(TTemp[SP-1],TTemp[SP-3],&TTemp[SP]);
      SP++;
      T_tuple_equal(TTemp[SP-2],TTemp[SP-4],&TTemp[SP]);
      if(get_i(TTemp[SP],0) ||
         (!((( get_i(TTemp[SP-1],0)) && (get_d(TTemp[SP-3],0)>0)) ||
            ((!get_i(TTemp[SP-1],0)) && (get_d(TTemp[SP-3],0)<0)))))
      {
       destroy_tuple(TTemp[SP--]);
       destroy_tuple(TTemp[SP]);
       T_tuple_sub(TTemp[SP-1],TTemp[SP-2],&TTemp[SP]);
       destroy_tuple(hv_J);
       copy_tuple(TTemp[SP],&hv_J);
       destroy_tuple(TTemp[SP--]);
       destroy_tuple(TTemp[SP]);
       for(;;)
       {
       T_tuple_add(hv_J,TTemp[SP-1],&TTemp[SP]);
       destroy_tuple(hv_J);
       copy_tuple(TTemp[SP],&hv_J);
       destroy_tuple(TTemp[SP]);
       if(get_d(TTemp[SP-1],0)<0)
        T_tuple_less(hv_J,TTemp[SP-2],&TTemp[SP]);
       else
        T_tuple_greater(hv_J,TTemp[SP-2],&TTemp[SP]);
       if(get_i(TTemp[SP],0)) break;
       destroy_tuple(TTemp[SP]);
       /*========== for ==========*/

        /*For each word box*/
        /*========== if (__get_dict_tuple( DLSample, ['bbox_label_id'])[J] == 0) ==========*/
        create_tuple_s(&TTemp[SP++],"bbox_label_id");
        T_get_dict_tuple(hv_DLSample,TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-1]=TTemp[SP];
        T_tuple_select(TTemp[SP-1],hv_J,&TTemp[SP]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-1]=TTemp[SP];
        create_tuple_i(&TTemp[SP++],0);
        T_tuple_equal(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-2]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-2]=TTemp[SP];
        SP--;
        if(get_i(TTemp[SP-1],0))
        {
          /*========== if (WordLengths[J] != 0) ==========*/
          T_tuple_select(hv_WordLengths,hv_J,&TTemp[SP++]);
          create_tuple_i(&TTemp[SP++],0);
          T_tuple_not_equal(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
          destroy_tuple(TTemp[SP-2]);
          destroy_tuple(TTemp[SP-1]);
          TTemp[SP-2]=TTemp[SP];
          SP--;
          if(get_i(TTemp[SP-1],0))
          {
            /*Start := |__get_dict_tuple( DLSampleTargets, ['bbox_label_id'])|*/
            create_tuple_s(&TTemp[SP++],"bbox_label_id");
            T_get_dict_tuple(hv_DLSampleTargets,TTemp[SP-1],&TTemp[SP]);
            destroy_tuple(TTemp[SP-1]);
            TTemp[SP-1]=TTemp[SP];
            T_tuple_length(TTemp[SP-1],&TTemp[SP]);
            destroy_tuple(TTemp[SP-1]);
            TTemp[SP-1]=TTemp[SP];
            destroy_tuple(hv_Start);
            hv_Start=TTemp[--SP];

            /*End := |__get_dict_tuple( DLSampleTargets, ['bbox_label_id'])| - 1 + WordLengths[J]*/
            create_tuple_s(&TTemp[SP++],"bbox_label_id");
            T_get_dict_tuple(hv_DLSampleTargets,TTemp[SP-1],&TTemp[SP]);
            destroy_tuple(TTemp[SP-1]);
            TTemp[SP-1]=TTemp[SP];
            T_tuple_length(TTemp[SP-1],&TTemp[SP]);
            destroy_tuple(TTemp[SP-1]);
            TTemp[SP-1]=TTemp[SP];
            create_tuple_i(&TTemp[SP++],1);
            T_tuple_sub(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
            destroy_tuple(TTemp[SP-2]);
            destroy_tuple(TTemp[SP-1]);
            TTemp[SP-2]=TTemp[SP];
            SP--;
            T_tuple_select(hv_WordLengths,hv_J,&TTemp[SP++]);
            T_tuple_add(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
            destroy_tuple(TTemp[SP-2]);
            destroy_tuple(TTemp[SP-1]);
            TTemp[SP-2]=TTemp[SP];
            SP--;
            destroy_tuple(hv_End);
            hv_End=TTemp[--SP];

            /*WordsCharsMapping.at(J) := [Start:1:End]*/
            create_tuple_i(&TTemp[SP++],1);
            T_tuple_gen_sequence(hv_Start,hv_End,TTemp[SP-1],&TTemp[SP]);
            destroy_tuple(TTemp[SP-1]);
            TTemp[SP-1]=TTemp[SP];
            create_tuple(&TTemp[SP++],1);
            set_i(TTemp[SP-1],get_i(hv_J,0),0);
            V_set_vector_tuple((*hvec_WordsCharsMapping),TTemp[SP-1],TTemp[SP-2]);
            destroy_tuple(TTemp[--SP]);
            destroy_tuple(TTemp[--SP]);
            /*split_rectangle2 (__get_dict_tuple( DLSample, ['bbox_row'])[J], __get_dict_tuple( DLSample, ['bbox_col'])[J], __get_dict_tuple( DLSample, ['bbox_phi'])[J], __get_dict_tuple( DLSample, ['bbox_length1'])[J], __get_dict_tuple( DLSample, ['bbox_length2'])[J], WordLengths[J], SplitRow, SplitColumn, SplitPhi, SplitLength1, SplitLength2)*/
            create_tuple_s(&TTemp[SP++],"bbox_row");
            T_get_dict_tuple(hv_DLSample,TTemp[SP-1],&TTemp[SP]);
            destroy_tuple(TTemp[SP-1]);
            TTemp[SP-1]=TTemp[SP];
            T_tuple_select(TTemp[SP-1],hv_J,&TTemp[SP]);
            destroy_tuple(TTemp[SP-1]);
            TTemp[SP-1]=TTemp[SP];
            create_tuple_s(&TTemp[SP++],"bbox_col");
            T_get_dict_tuple(hv_DLSample,TTemp[SP-1],&TTemp[SP]);
            destroy_tuple(TTemp[SP-1]);
            TTemp[SP-1]=TTemp[SP];
            T_tuple_select(TTemp[SP-1],hv_J,&TTemp[SP]);
            destroy_tuple(TTemp[SP-1]);
            TTemp[SP-1]=TTemp[SP];
            create_tuple_s(&TTemp[SP++],"bbox_phi");
            T_get_dict_tuple(hv_DLSample,TTemp[SP-1],&TTemp[SP]);
            destroy_tuple(TTemp[SP-1]);
            TTemp[SP-1]=TTemp[SP];
            T_tuple_select(TTemp[SP-1],hv_J,&TTemp[SP]);
            destroy_tuple(TTemp[SP-1]);
            TTemp[SP-1]=TTemp[SP];
            create_tuple_s(&TTemp[SP++],"bbox_length1");
            T_get_dict_tuple(hv_DLSample,TTemp[SP-1],&TTemp[SP]);
            destroy_tuple(TTemp[SP-1]);
            TTemp[SP-1]=TTemp[SP];
            T_tuple_select(TTemp[SP-1],hv_J,&TTemp[SP]);
            destroy_tuple(TTemp[SP-1]);
            TTemp[SP-1]=TTemp[SP];
            create_tuple_s(&TTemp[SP++],"bbox_length2");
            T_get_dict_tuple(hv_DLSample,TTemp[SP-1],&TTemp[SP]);
            destroy_tuple(TTemp[SP-1]);
            TTemp[SP-1]=TTemp[SP];
            T_tuple_select(TTemp[SP-1],hv_J,&TTemp[SP]);
            destroy_tuple(TTemp[SP-1]);
            TTemp[SP-1]=TTemp[SP];
            T_tuple_select(hv_WordLengths,hv_J,&TTemp[SP++]);
            destroy_tuple(hv_SplitRow);
            destroy_tuple(hv_SplitColumn);
            destroy_tuple(hv_SplitPhi);
            destroy_tuple(hv_SplitLength1);
            destroy_tuple(hv_SplitLength2);
            /***/split_rectangle2(TTemp[SP-6], TTemp[SP-5], TTemp[SP-4], TTemp[SP-3], 
                TTemp[SP-2], TTemp[SP-1], &hv_SplitRow, &hv_SplitColumn, &hv_SplitPhi, 
                &hv_SplitLength1, &hv_SplitLength2);
            destroy_tuple(TTemp[--SP]);
            destroy_tuple(TTemp[--SP]);
            destroy_tuple(TTemp[--SP]);
            destroy_tuple(TTemp[--SP]);
            destroy_tuple(TTemp[--SP]);
            destroy_tuple(TTemp[--SP]);

            /*tuple_gen_const (WordLengths[J], 1, CharsIds)*/
            T_tuple_select(hv_WordLengths,hv_J,&TTemp[SP++]);
            create_tuple_i(&TTemp[SP++],1);
            destroy_tuple(hv_CharsIds);
            /***/T_tuple_gen_const(TTemp[SP-2], TTemp[SP-1], &hv_CharsIds);
            destroy_tuple(TTemp[--SP]);
            destroy_tuple(TTemp[--SP]);

            /*tuple_gen_const (WordLengths[J], '', EmptyWordStrings)*/
            T_tuple_select(hv_WordLengths,hv_J,&TTemp[SP++]);
            create_tuple_s(&TTemp[SP++],"");
            destroy_tuple(hv_EmptyWordStrings);
            /***/T_tuple_gen_const(TTemp[SP-2], TTemp[SP-1], &hv_EmptyWordStrings);
            destroy_tuple(TTemp[--SP]);
            destroy_tuple(TTemp[--SP]);

            /*set_dict_tuple (DLSampleTargets, ['bbox_label_id'], [__get_dict_tuple( DLSampleTargets, ['bbox_label_id']),CharsIds])*/
            create_tuple_s(&TTemp[SP++],"bbox_label_id");
            create_tuple_s(&TTemp[SP++],"bbox_label_id");
            T_get_dict_tuple(hv_DLSampleTargets,TTemp[SP-1],&TTemp[SP]);
            destroy_tuple(TTemp[SP-1]);
            TTemp[SP-1]=TTemp[SP];
            T_tuple_concat(TTemp[SP-1],hv_CharsIds,&TTemp[SP]);
            destroy_tuple(TTemp[SP-1]);
            TTemp[SP-1]=TTemp[SP];
            /***/T_set_dict_tuple(hv_DLSampleTargets, TTemp[SP-2], TTemp[SP-1]);
            destroy_tuple(TTemp[--SP]);
            destroy_tuple(TTemp[--SP]);

            /*set_dict_tuple (DLSampleTargets, ['bbox_row'], [__get_dict_tuple( DLSampleTargets, ['bbox_row']),SplitRow])*/
            create_tuple_s(&TTemp[SP++],"bbox_row");
            create_tuple_s(&TTemp[SP++],"bbox_row");
            T_get_dict_tuple(hv_DLSampleTargets,TTemp[SP-1],&TTemp[SP]);
            destroy_tuple(TTemp[SP-1]);
            TTemp[SP-1]=TTemp[SP];
            T_tuple_concat(TTemp[SP-1],hv_SplitRow,&TTemp[SP]);
            destroy_tuple(TTemp[SP-1]);
            TTemp[SP-1]=TTemp[SP];
            /***/T_set_dict_tuple(hv_DLSampleTargets, TTemp[SP-2], TTemp[SP-1]);
            destroy_tuple(TTemp[--SP]);
            destroy_tuple(TTemp[--SP]);

            /*set_dict_tuple (DLSampleTargets, ['bbox_col'], [__get_dict_tuple( DLSampleTargets, ['bbox_col']),SplitColumn])*/
            create_tuple_s(&TTemp[SP++],"bbox_col");
            create_tuple_s(&TTemp[SP++],"bbox_col");
            T_get_dict_tuple(hv_DLSampleTargets,TTemp[SP-1],&TTemp[SP]);
            destroy_tuple(TTemp[SP-1]);
            TTemp[SP-1]=TTemp[SP];
            T_tuple_concat(TTemp[SP-1],hv_SplitColumn,&TTemp[SP]);
            destroy_tuple(TTemp[SP-1]);
            TTemp[SP-1]=TTemp[SP];
            /***/T_set_dict_tuple(hv_DLSampleTargets, TTemp[SP-2], TTemp[SP-1]);
            destroy_tuple(TTemp[--SP]);
            destroy_tuple(TTemp[--SP]);

            /*set_dict_tuple (DLSampleTargets, ['bbox_phi'], [__get_dict_tuple( DLSampleTargets, ['bbox_phi']),SplitPhi])*/
            create_tuple_s(&TTemp[SP++],"bbox_phi");
            create_tuple_s(&TTemp[SP++],"bbox_phi");
            T_get_dict_tuple(hv_DLSampleTargets,TTemp[SP-1],&TTemp[SP]);
            destroy_tuple(TTemp[SP-1]);
            TTemp[SP-1]=TTemp[SP];
            T_tuple_concat(TTemp[SP-1],hv_SplitPhi,&TTemp[SP]);
            destroy_tuple(TTemp[SP-1]);
            TTemp[SP-1]=TTemp[SP];
            /***/T_set_dict_tuple(hv_DLSampleTargets, TTemp[SP-2], TTemp[SP-1]);
            destroy_tuple(TTemp[--SP]);
            destroy_tuple(TTemp[--SP]);

            /*set_dict_tuple (DLSampleTargets, ['bbox_length1'], [__get_dict_tuple( DLSampleTargets, ['bbox_length1']),SplitLength1 * ScaleWidth])*/
            create_tuple_s(&TTemp[SP++],"bbox_length1");
            create_tuple_s(&TTemp[SP++],"bbox_length1");
            T_get_dict_tuple(hv_DLSampleTargets,TTemp[SP-1],&TTemp[SP]);
            destroy_tuple(TTemp[SP-1]);
            TTemp[SP-1]=TTemp[SP];
            T_tuple_mult(hv_SplitLength1,hv_ScaleWidth,&TTemp[SP++]);
            T_tuple_concat(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
            destroy_tuple(TTemp[SP-2]);
            destroy_tuple(TTemp[SP-1]);
            TTemp[SP-2]=TTemp[SP];
            SP--;
            /***/T_set_dict_tuple(hv_DLSampleTargets, TTemp[SP-2], TTemp[SP-1]);
            destroy_tuple(TTemp[--SP]);
            destroy_tuple(TTemp[--SP]);

            /*set_dict_tuple (DLSampleTargets, ['bbox_length2'], [__get_dict_tuple( DLSampleTargets, ['bbox_length2']),SplitLength2 * ScaleHeight])*/
            create_tuple_s(&TTemp[SP++],"bbox_length2");
            create_tuple_s(&TTemp[SP++],"bbox_length2");
            T_get_dict_tuple(hv_DLSampleTargets,TTemp[SP-1],&TTemp[SP]);
            destroy_tuple(TTemp[SP-1]);
            TTemp[SP-1]=TTemp[SP];
            T_tuple_mult(hv_SplitLength2,hv_ScaleHeight,&TTemp[SP++]);
            T_tuple_concat(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
            destroy_tuple(TTemp[SP-2]);
            destroy_tuple(TTemp[SP-1]);
            TTemp[SP-2]=TTemp[SP];
            SP--;
            /***/T_set_dict_tuple(hv_DLSampleTargets, TTemp[SP-2], TTemp[SP-1]);
            destroy_tuple(TTemp[--SP]);
            destroy_tuple(TTemp[--SP]);

            /*set_dict_tuple (DLSampleTargets, ['word'], [__get_dict_tuple( DLSampleTargets, ['word']),EmptyWordStrings])*/
            create_tuple_s(&TTemp[SP++],"word");
            create_tuple_s(&TTemp[SP++],"word");
            T_get_dict_tuple(hv_DLSampleTargets,TTemp[SP-1],&TTemp[SP]);
            destroy_tuple(TTemp[SP-1]);
            TTemp[SP-1]=TTemp[SP];
            T_tuple_concat(TTemp[SP-1],hv_EmptyWordStrings,&TTemp[SP]);
            destroy_tuple(TTemp[SP-1]);
            TTemp[SP-1]=TTemp[SP];
            /***/T_set_dict_tuple(hv_DLSampleTargets, TTemp[SP-2], TTemp[SP-1]);
            destroy_tuple(TTemp[--SP]);
            destroy_tuple(TTemp[--SP]);

          }
          else
          {
            /* throw(...); only in hdevelop*/
          }
          destroy_tuple(TTemp[--SP]);
          /*========== end if ==========*/
        }
        destroy_tuple(TTemp[--SP]);
        /*========== end if ==========*/
       }
       destroy_tuple(TTemp[SP--]);
       destroy_tuple(TTemp[SP--]);
       destroy_tuple(TTemp[SP]);
      }
      else
      {
       destroy_tuple(TTemp[SP--]);
       destroy_tuple(TTemp[SP--]);
       destroy_tuple(TTemp[SP--]);
       destroy_tuple(TTemp[SP--]);
       destroy_tuple(TTemp[SP]);
      }/*========== end for ========*/

    }
    else
    {
      /*gen_words_chars_mapping (DLSample, WordsCharsMapping)*/
      V_destroy_vector((*hvec_WordsCharsMapping));
      /***/gen_words_chars_mapping(hv_DLSample, &(*hvec_WordsCharsMapping));

    }
    destroy_tuple(TTemp[--SP]);
    /*========== end if ==========*/
  }
  destroy_tuple(TTemp[--SP]);
  /*========== end if ==========*/
  /*========== return ==========*/

  /* Clear temporary tuple stack */
  while (SP > 0)
    destroy_tuple(TTemp[--SP]);
  /* Clear temporary tuple vectors stack*/
  while (SPTV > 0)
    V_destroy_vector(TVTemp[--SPTV]);
  /* Clear local control variables */
  destroy_tuple(hv_CharBoxIndex);
  destroy_tuple(hv_WordLengths);
  destroy_tuple(hv_J);
  destroy_tuple(hv_Start);
  destroy_tuple(hv_End);
  destroy_tuple(hv_SplitRow);
  destroy_tuple(hv_SplitColumn);
  destroy_tuple(hv_SplitPhi);
  destroy_tuple(hv_SplitLength1);
  destroy_tuple(hv_SplitLength2);
  destroy_tuple(hv_CharsIds);
  destroy_tuple(hv_EmptyWordStrings);

  return;

  /****************************************************/
  /******************     End procedure   *************/
  /****************************************************/

}

/* Chapter: OCR / Deep OCR*/
/* Short Description: Generate target link score map for ocr detection training. */
void gen_dl_ocr_detection_gt_link_map (Hobject *ho_GtLinkMap, Htuple hv_ImageWidth, 
    Htuple hv_ImageHeight, Htuple hv_DLSampleTargets, Hvector/*{eTupleVector,Dim=1}*/ hvec_WordToCharVec, 
    Htuple hv_Alpha)
{

  /* Stack for temporary tuples */
  Htuple   TTemp[100];
  int      SP=0;
  /* Stack for temporary objects */
  Hobject  OTemp[20] = {0};
  int      SPO=0;
  /* Stack for temporary tuple vectors */
  Hvector  TVTemp[100] = {0};
  int      SPTV=0;

  /* Local iconic variables */
  Hobject  ho_Lines, ho_Line, ho_LineDilated;

  /* Local control variables */
  Htuple  hv_InitImage, hv_CRow, hv_CCol, hv_DiameterC;
  Htuple  hv_IndexW, hv_CharBoxIndices, hv_CharCRows, hv_CharCCols;
  Htuple  hv_CharDistToWordCenter, hv_ExtremeCharIndex, hv_DistToExtreme;
  Htuple  hv_CharIndexSorted, hv_Box1Idx, hv_Box2Idx, hv_Diameter1;
  Htuple  hv_Diameter2, hv_DilationRadius, hv_NumLines, hv_Index;

  /* Initialize iconic variables */
  gen_empty_obj(&ho_Lines);
  gen_empty_obj(&ho_Line);
  gen_empty_obj(&ho_LineDilated);
  gen_empty_obj(&(*ho_GtLinkMap));

  /* Initialize control variables */
  create_tuple(&hv_InitImage,0);
  create_tuple(&hv_CRow,0);
  create_tuple(&hv_CCol,0);
  create_tuple(&hv_DiameterC,0);
  create_tuple(&hv_IndexW,0);
  create_tuple(&hv_CharBoxIndices,0);
  create_tuple(&hv_CharCRows,0);
  create_tuple(&hv_CharCCols,0);
  create_tuple(&hv_CharDistToWordCenter,0);
  create_tuple(&hv_ExtremeCharIndex,0);
  create_tuple(&hv_DistToExtreme,0);
  create_tuple(&hv_CharIndexSorted,0);
  create_tuple(&hv_Box1Idx,0);
  create_tuple(&hv_Box2Idx,0);
  create_tuple(&hv_Diameter1,0);
  create_tuple(&hv_Diameter2,0);
  create_tuple(&hv_DilationRadius,0);
  create_tuple(&hv_NumLines,0);
  create_tuple(&hv_Index,0);

  /****************************************************/
  /******************   Begin procedure   *************/
  /****************************************************/

  /*gen_image_const (GtLinkMap, 'real', ImageWidth, ImageHeight)*/
  create_tuple_s(&TTemp[SP++],"real");
  clear_obj((*ho_GtLinkMap));
  /***/T_gen_image_const(&(*ho_GtLinkMap), TTemp[SP-1], hv_ImageWidth, hv_ImageHeight);
  destroy_tuple(TTemp[--SP]);

  /*get_system ('init_new_image', InitImage)*/
  create_tuple_s(&TTemp[SP++],"init_new_image");
  destroy_tuple(hv_InitImage);
  /***/T_get_system(TTemp[SP-1], &hv_InitImage);
  destroy_tuple(TTemp[--SP]);

  /*========== if (InitImage == 'false') ==========*/
  create_tuple_s(&TTemp[SP++],"false");
  T_tuple_equal(hv_InitImage,TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-1]=TTemp[SP];
  if(get_i(TTemp[SP-1],0))
  {
    /*overpaint_region (GtLinkMap, GtLinkMap, 0.0, 'fill')*/
    /***/overpaint_region((*ho_GtLinkMap), (*ho_GtLinkMap), 0.0, "fill");

  }
  destroy_tuple(TTemp[--SP]);
  /*========== end if ==========*/
  /*Compute box centers.*/
  /*CRow := __get_dict_tuple( DLSampleTargets, ['bbox_row'])*/
  create_tuple_s(&TTemp[SP++],"bbox_row");
  T_get_dict_tuple(hv_DLSampleTargets,TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-1]=TTemp[SP];
  destroy_tuple(hv_CRow);
  hv_CRow=TTemp[--SP];

  /*CCol := __get_dict_tuple( DLSampleTargets, ['bbox_col'])*/
  create_tuple_s(&TTemp[SP++],"bbox_col");
  T_get_dict_tuple(hv_DLSampleTargets,TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-1]=TTemp[SP];
  destroy_tuple(hv_CCol);
  hv_CCol=TTemp[--SP];

  /*DiameterC := 2 * hypot(__get_dict_tuple( DLSampleTargets, ['bbox_length1']),__get_dict_tuple( DLSampleTargets, ['bbox_length2']))*/
  create_tuple_i(&TTemp[SP++],2);
  create_tuple_s(&TTemp[SP++],"bbox_length1");
  T_get_dict_tuple(hv_DLSampleTargets,TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-1]=TTemp[SP];
  create_tuple_s(&TTemp[SP++],"bbox_length2");
  T_get_dict_tuple(hv_DLSampleTargets,TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-1]=TTemp[SP];
  T_tuple_hypot(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-2]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-2]=TTemp[SP];
  SP--;
  T_tuple_mult(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-2]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-2]=TTemp[SP];
  SP--;
  destroy_tuple(hv_DiameterC);
  hv_DiameterC=TTemp[--SP];

  /*Loop over word boxes.*/
  /*========== for IndexW := 0 to |__get_dict_tuple( DLSampleTargets, ['bbox_label_id'])| - 1 by 1 ==========*/
  create_tuple_s(&TTemp[SP++],"bbox_label_id");
  T_get_dict_tuple(hv_DLSampleTargets,TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-1]=TTemp[SP];
  T_tuple_length(TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-1]=TTemp[SP];
  create_tuple_i(&TTemp[SP++],1);
  T_tuple_sub(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-2]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-2]=TTemp[SP];
  SP--;
  create_tuple_i(&TTemp[SP++],1);
  create_tuple_i(&TTemp[SP++],0);
  T_tuple_greater(TTemp[SP-1],TTemp[SP-3],&TTemp[SP]);
  SP++;
  T_tuple_equal(TTemp[SP-2],TTemp[SP-4],&TTemp[SP]);
  if(get_i(TTemp[SP],0) ||
     (!((( get_i(TTemp[SP-1],0)) && (get_d(TTemp[SP-3],0)>0)) ||
        ((!get_i(TTemp[SP-1],0)) && (get_d(TTemp[SP-3],0)<0)))))
  {
   destroy_tuple(TTemp[SP--]);
   destroy_tuple(TTemp[SP]);
   T_tuple_sub(TTemp[SP-1],TTemp[SP-2],&TTemp[SP]);
   destroy_tuple(hv_IndexW);
   copy_tuple(TTemp[SP],&hv_IndexW);
   destroy_tuple(TTemp[SP--]);
   destroy_tuple(TTemp[SP]);
   for(;;)
   {
   T_tuple_add(hv_IndexW,TTemp[SP-1],&TTemp[SP]);
   destroy_tuple(hv_IndexW);
   copy_tuple(TTemp[SP],&hv_IndexW);
   destroy_tuple(TTemp[SP]);
   if(get_d(TTemp[SP-1],0)<0)
    T_tuple_less(hv_IndexW,TTemp[SP-2],&TTemp[SP]);
   else
    T_tuple_greater(hv_IndexW,TTemp[SP-2],&TTemp[SP]);
   if(get_i(TTemp[SP],0)) break;
   destroy_tuple(TTemp[SP]);
   /*========== for ==========*/

    /*For each word box*/
    /*========== if (__get_dict_tuple( DLSampleTargets, ['bbox_label_id'])[IndexW] == 0) ==========*/
    create_tuple_s(&TTemp[SP++],"bbox_label_id");
    T_get_dict_tuple(hv_DLSampleTargets,TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    T_tuple_select(TTemp[SP-1],hv_IndexW,&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    create_tuple_i(&TTemp[SP++],0);
    T_tuple_equal(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-2]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-2]=TTemp[SP];
    SP--;
    if(get_i(TTemp[SP-1],0))
    {
      /*CharBoxIndices := WordToCharVec.at(IndexW)*/
      create_tuple(&TTemp[SP++],1);
      set_i(TTemp[SP-1],get_i(hv_IndexW,0),0);
      V_get_vector_tuple(hvec_WordToCharVec,TTemp[SP-1],&TTemp[SP]);
      SP++;
      destroy_tuple(TTemp[SP-2]);
      TTemp[SP-2]=TTemp[SP-1];
      SP--;
      destroy_tuple(hv_CharBoxIndices);
      hv_CharBoxIndices=TTemp[--SP];

      /*========== if (|CharBoxIndices| == 0) ==========*/
      T_tuple_length(hv_CharBoxIndices,&TTemp[SP++]);
      create_tuple_i(&TTemp[SP++],0);
      T_tuple_equal(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-2]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-2]=TTemp[SP];
      SP--;
      if(get_i(TTemp[SP-1],0))
      {
        /*continue*/
        destroy_tuple(TTemp[--SP]);
        destroy_tuple(TTemp[--SP]);
        continue;
      }
      else
      {
      destroy_tuple(TTemp[--SP]);
      /*========== elseif (|CharBoxIndices| == 1) ==========*/

      T_tuple_length(hv_CharBoxIndices,&TTemp[SP++]);
      create_tuple_i(&TTemp[SP++],1);
      T_tuple_equal(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-2]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-2]=TTemp[SP];
      SP--;
      if(get_i(TTemp[SP-1],0))
      {
        /*Generate a dot in the char center.*/
        /*gen_circle (Lines, CRow[CharBoxIndices], CCol[CharBoxIndices], round(0.5 * Alpha * DiameterC[CharBoxIndices]) + 0.5)*/
        T_tuple_select(hv_CRow,hv_CharBoxIndices,&TTemp[SP++]);
        T_tuple_select(hv_CCol,hv_CharBoxIndices,&TTemp[SP++]);
        create_tuple_d(&TTemp[SP++],0.5);
        T_tuple_mult(TTemp[SP-1],hv_Alpha,&TTemp[SP]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-1]=TTemp[SP];
        T_tuple_select(hv_DiameterC,hv_CharBoxIndices,&TTemp[SP++]);
        T_tuple_mult(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-2]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-2]=TTemp[SP];
        SP--;
        T_tuple_round(TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-1]=TTemp[SP];
        create_tuple_d(&TTemp[SP++],0.5);
        T_tuple_add(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-2]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-2]=TTemp[SP];
        SP--;
        clear_obj(ho_Lines);
        /***/T_gen_circle(&ho_Lines, TTemp[SP-3], TTemp[SP-2], TTemp[SP-1]);
        destroy_tuple(TTemp[--SP]);
        destroy_tuple(TTemp[--SP]);
        destroy_tuple(TTemp[--SP]);

      }
      else
      {
        /*Generate link lines between chars.*/
        /*CharCRows := CRow[CharBoxIndices]*/
        T_tuple_select(hv_CRow,hv_CharBoxIndices,&TTemp[SP++]);
        destroy_tuple(hv_CharCRows);
        hv_CharCRows=TTemp[--SP];

        /*CharCCols := CCol[CharBoxIndices]*/
        T_tuple_select(hv_CCol,hv_CharBoxIndices,&TTemp[SP++]);
        destroy_tuple(hv_CharCCols);
        hv_CharCCols=TTemp[--SP];

        /*Sort the char boxes within the word.*/
        /*CharDistToWordCenter := hypot(CharCRows - CRow[IndexW],CharCCols - CCol[IndexW])*/
        T_tuple_select(hv_CRow,hv_IndexW,&TTemp[SP++]);
        T_tuple_sub(hv_CharCRows,TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-1]=TTemp[SP];
        T_tuple_select(hv_CCol,hv_IndexW,&TTemp[SP++]);
        T_tuple_sub(hv_CharCCols,TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-1]=TTemp[SP];
        T_tuple_hypot(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-2]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-2]=TTemp[SP];
        SP--;
        destroy_tuple(hv_CharDistToWordCenter);
        hv_CharDistToWordCenter=TTemp[--SP];

        /*ExtremeCharIndex := sort_index(CharDistToWordCenter)[|CharDistToWordCenter| - 1]*/
        T_tuple_sort_index(hv_CharDistToWordCenter,&TTemp[SP++]);
        T_tuple_length(hv_CharDistToWordCenter,&TTemp[SP++]);
        create_tuple_i(&TTemp[SP++],1);
        T_tuple_sub(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-2]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-2]=TTemp[SP];
        SP--;
        T_tuple_select(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-2]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-2]=TTemp[SP];
        SP--;
        destroy_tuple(hv_ExtremeCharIndex);
        hv_ExtremeCharIndex=TTemp[--SP];

        /*DistToExtreme := hypot(CharCRows - CharCRows[ExtremeCharIndex],CharCCols - CharCCols[ExtremeCharIndex])*/
        T_tuple_select(hv_CharCRows,hv_ExtremeCharIndex,&TTemp[SP++]);
        T_tuple_sub(hv_CharCRows,TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-1]=TTemp[SP];
        T_tuple_select(hv_CharCCols,hv_ExtremeCharIndex,&TTemp[SP++]);
        T_tuple_sub(hv_CharCCols,TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-1]=TTemp[SP];
        T_tuple_hypot(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-2]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-2]=TTemp[SP];
        SP--;
        destroy_tuple(hv_DistToExtreme);
        hv_DistToExtreme=TTemp[--SP];

        /*CharIndexSorted := sort_index(DistToExtreme)*/
        T_tuple_sort_index(hv_DistToExtreme,&TTemp[SP++]);
        destroy_tuple(hv_CharIndexSorted);
        hv_CharIndexSorted=TTemp[--SP];

        /*Get the indices of adjacent characters.*/
        /*Box1Idx := CharIndexSorted[0:|CharIndexSorted| - 2]*/
        create_tuple_i(&TTemp[SP++],0);
        T_tuple_length(hv_CharIndexSorted,&TTemp[SP++]);
        create_tuple_i(&TTemp[SP++],2);
        T_tuple_sub(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-2]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-2]=TTemp[SP];
        SP--;
        T_tuple_select_range(hv_CharIndexSorted,TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-2]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-2]=TTemp[SP];
        SP=SP-1;
        destroy_tuple(hv_Box1Idx);
        hv_Box1Idx=TTemp[--SP];

        /*Box2Idx := CharIndexSorted[1:|CharIndexSorted| - 1]*/
        create_tuple_i(&TTemp[SP++],1);
        T_tuple_length(hv_CharIndexSorted,&TTemp[SP++]);
        create_tuple_i(&TTemp[SP++],1);
        T_tuple_sub(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-2]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-2]=TTemp[SP];
        SP--;
        T_tuple_select_range(hv_CharIndexSorted,TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-2]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-2]=TTemp[SP];
        SP=SP-1;
        destroy_tuple(hv_Box2Idx);
        hv_Box2Idx=TTemp[--SP];

        /*Generate link lines between each pair of adjacent characters.*/
        /*gen_region_line (Lines, CharCRows[Box1Idx], CharCCols[Box1Idx], CharCRows[Box2Idx], CharCCols[Box2Idx])*/
        T_tuple_select(hv_CharCRows,hv_Box1Idx,&TTemp[SP++]);
        T_tuple_select(hv_CharCCols,hv_Box1Idx,&TTemp[SP++]);
        T_tuple_select(hv_CharCRows,hv_Box2Idx,&TTemp[SP++]);
        T_tuple_select(hv_CharCCols,hv_Box2Idx,&TTemp[SP++]);
        clear_obj(ho_Lines);
        /***/T_gen_region_line(&ho_Lines, TTemp[SP-4], TTemp[SP-3], TTemp[SP-2], 
            TTemp[SP-1]);
        destroy_tuple(TTemp[--SP]);
        destroy_tuple(TTemp[--SP]);
        destroy_tuple(TTemp[--SP]);
        destroy_tuple(TTemp[--SP]);

        /*Dilate the lines by 0.5/1.5/2.5/... pixels, such that the line thickness is approximately Alpha*mean(D1, D2)*/
        /*Diameter1 := DiameterC[CharBoxIndices[Box1Idx]]*/
        T_tuple_select(hv_CharBoxIndices,hv_Box1Idx,&TTemp[SP++]);
        T_tuple_select(hv_DiameterC,TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-1]=TTemp[SP];
        destroy_tuple(hv_Diameter1);
        hv_Diameter1=TTemp[--SP];

        /*Diameter2 := DiameterC[CharBoxIndices[Box2Idx]]*/
        T_tuple_select(hv_CharBoxIndices,hv_Box2Idx,&TTemp[SP++]);
        T_tuple_select(hv_DiameterC,TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-1]=TTemp[SP];
        destroy_tuple(hv_Diameter2);
        hv_Diameter2=TTemp[--SP];

        /*DilationRadius := round(0.25 * Alpha * (Diameter1 + Diameter2)) + 0.5*/
        create_tuple_d(&TTemp[SP++],0.25);
        T_tuple_mult(TTemp[SP-1],hv_Alpha,&TTemp[SP]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-1]=TTemp[SP];
        T_tuple_add(hv_Diameter1,hv_Diameter2,&TTemp[SP++]);
        T_tuple_mult(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-2]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-2]=TTemp[SP];
        SP--;
        T_tuple_round(TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-1]=TTemp[SP];
        create_tuple_d(&TTemp[SP++],0.5);
        T_tuple_add(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-2]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-2]=TTemp[SP];
        SP--;
        destroy_tuple(hv_DilationRadius);
        hv_DilationRadius=TTemp[--SP];

        /*dilation_circle only accepts a single radius, so we need to loop over the lines.*/
        /*count_obj (Lines, NumLines)*/
        destroy_tuple(hv_NumLines);
        /***/T_count_obj(ho_Lines, &hv_NumLines);

        /*========== for Index := 1 to NumLines by 1 ==========*/
        copy_tuple(hv_NumLines,&TTemp[SP++]);
        create_tuple_i(&TTemp[SP++],1);
        create_tuple_i(&TTemp[SP++],1);
        T_tuple_greater(TTemp[SP-1],TTemp[SP-3],&TTemp[SP]);
        SP++;
        T_tuple_equal(TTemp[SP-2],TTemp[SP-4],&TTemp[SP]);
        if(get_i(TTemp[SP],0) ||
           (!((( get_i(TTemp[SP-1],0)) && (get_d(TTemp[SP-3],0)>0)) ||
              ((!get_i(TTemp[SP-1],0)) && (get_d(TTemp[SP-3],0)<0)))))
        {
         destroy_tuple(TTemp[SP--]);
         destroy_tuple(TTemp[SP]);
         T_tuple_sub(TTemp[SP-1],TTemp[SP-2],&TTemp[SP]);
         destroy_tuple(hv_Index);
         copy_tuple(TTemp[SP],&hv_Index);
         destroy_tuple(TTemp[SP--]);
         destroy_tuple(TTemp[SP]);
         for(;;)
         {
         T_tuple_add(hv_Index,TTemp[SP-1],&TTemp[SP]);
         destroy_tuple(hv_Index);
         copy_tuple(TTemp[SP],&hv_Index);
         destroy_tuple(TTemp[SP]);
         if(get_d(TTemp[SP-1],0)<0)
          T_tuple_less(hv_Index,TTemp[SP-2],&TTemp[SP]);
         else
          T_tuple_greater(hv_Index,TTemp[SP-2],&TTemp[SP]);
         if(get_i(TTemp[SP],0)) break;
         destroy_tuple(TTemp[SP]);
         /*========== for ==========*/

          /*select_obj (Lines, Line, Index)*/
          clear_obj(ho_Line);
          /***/T_select_obj(ho_Lines, &ho_Line, hv_Index);

          /*dilation_circle (Line, LineDilated, DilationRadius[Index - 1])*/
          create_tuple_i(&TTemp[SP++],1);
          T_tuple_sub(hv_Index,TTemp[SP-1],&TTemp[SP]);
          destroy_tuple(TTemp[SP-1]);
          TTemp[SP-1]=TTemp[SP];
          T_tuple_select(hv_DilationRadius,TTemp[SP-1],&TTemp[SP]);
          destroy_tuple(TTemp[SP-1]);
          TTemp[SP-1]=TTemp[SP];
          clear_obj(ho_LineDilated);
          /***/T_dilation_circle(ho_Line, &ho_LineDilated, TTemp[SP-1]);
          destroy_tuple(TTemp[--SP]);

          /*replace_obj (Lines, LineDilated, Lines, Index)*/
          /***/T_replace_obj(ho_Lines, ho_LineDilated, &(OTemp[SPO]), hv_Index);
          SPO++;
          clear_obj(ho_Lines);
          ho_Lines = OTemp[--SPO];

         }
         destroy_tuple(TTemp[SP--]);
         destroy_tuple(TTemp[SP--]);
         destroy_tuple(TTemp[SP]);
        }
        else
        {
         destroy_tuple(TTemp[SP--]);
         destroy_tuple(TTemp[SP--]);
         destroy_tuple(TTemp[SP--]);
         destroy_tuple(TTemp[SP--]);
         destroy_tuple(TTemp[SP]);
        }/*========== end for ========*/

      }
      }
      destroy_tuple(TTemp[--SP]);
      /*========== end if ==========*/
      /*overpaint_region (GtLinkMap, Lines, 1.0, 'fill')*/
      /***/overpaint_region((*ho_GtLinkMap), ho_Lines, 1.0, "fill");

    }
    destroy_tuple(TTemp[--SP]);
    /*========== end if ==========*/
   }
   destroy_tuple(TTemp[SP--]);
   destroy_tuple(TTemp[SP--]);
   destroy_tuple(TTemp[SP]);
  }
  else
  {
   destroy_tuple(TTemp[SP--]);
   destroy_tuple(TTemp[SP--]);
   destroy_tuple(TTemp[SP--]);
   destroy_tuple(TTemp[SP--]);
   destroy_tuple(TTemp[SP]);
  }/*========== end for ========*/

  /*========== return ==========*/

  /* Clear temporary tuple stack */
  while (SP > 0)
    destroy_tuple(TTemp[--SP]);
  /* Clear temporary tuple vectors stack*/
  while (SPTV > 0)
    V_destroy_vector(TVTemp[--SPTV]);
  /* Clear local iconic variables */
  clear_obj(ho_Lines);
  clear_obj(ho_Line);
  clear_obj(ho_LineDilated);

  /* Clear local control variables */
  destroy_tuple(hv_InitImage);
  destroy_tuple(hv_CRow);
  destroy_tuple(hv_CCol);
  destroy_tuple(hv_DiameterC);
  destroy_tuple(hv_IndexW);
  destroy_tuple(hv_CharBoxIndices);
  destroy_tuple(hv_CharCRows);
  destroy_tuple(hv_CharCCols);
  destroy_tuple(hv_CharDistToWordCenter);
  destroy_tuple(hv_ExtremeCharIndex);
  destroy_tuple(hv_DistToExtreme);
  destroy_tuple(hv_CharIndexSorted);
  destroy_tuple(hv_Box1Idx);
  destroy_tuple(hv_Box2Idx);
  destroy_tuple(hv_Diameter1);
  destroy_tuple(hv_Diameter2);
  destroy_tuple(hv_DilationRadius);
  destroy_tuple(hv_NumLines);
  destroy_tuple(hv_Index);

  return;

  /****************************************************/
  /******************     End procedure   *************/
  /****************************************************/

}

/* Chapter: OCR / Deep OCR*/
/* Short Description: Generate target orientation score maps for ocr detection training. */
void gen_dl_ocr_detection_gt_orientation_map (Hobject *ho_GtOrientationMaps, Htuple hv_ImageWidth, 
    Htuple hv_ImageHeight, Htuple hv_DLSample)
{

  /* Stack for temporary tuples */
  Htuple   TTemp[100];
  int      SP=0;
  /* Stack for temporary tuple vectors */
  Hvector  TVTemp[100] = {0};
  int      SPTV=0;

  /* Local iconic variables */
  Hobject  ho_GtOrientationSin, ho_GtOrientationCos;
  Hobject  ho_Region;

  /* Local control variables */
  Htuple  hv_InitImage, hv_Indices, hv_Phi;

  /* Initialize iconic variables */
  gen_empty_obj(&ho_GtOrientationSin);
  gen_empty_obj(&ho_GtOrientationCos);
  gen_empty_obj(&ho_Region);
  gen_empty_obj(&(*ho_GtOrientationMaps));

  /* Initialize control variables */
  create_tuple(&hv_InitImage,0);
  create_tuple(&hv_Indices,0);
  create_tuple(&hv_Phi,0);

  /****************************************************/
  /******************   Begin procedure   *************/
  /****************************************************/

  /*gen_image_const (GtOrientationSin, 'real', ImageWidth, ImageHeight)*/
  create_tuple_s(&TTemp[SP++],"real");
  clear_obj(ho_GtOrientationSin);
  /***/T_gen_image_const(&ho_GtOrientationSin, TTemp[SP-1], hv_ImageWidth, hv_ImageHeight);
  destroy_tuple(TTemp[--SP]);

  /*gen_image_const (GtOrientationCos, 'real', ImageWidth, ImageHeight)*/
  create_tuple_s(&TTemp[SP++],"real");
  clear_obj(ho_GtOrientationCos);
  /***/T_gen_image_const(&ho_GtOrientationCos, TTemp[SP-1], hv_ImageWidth, hv_ImageHeight);
  destroy_tuple(TTemp[--SP]);

  /*get_system ('init_new_image', InitImage)*/
  create_tuple_s(&TTemp[SP++],"init_new_image");
  destroy_tuple(hv_InitImage);
  /***/T_get_system(TTemp[SP-1], &hv_InitImage);
  destroy_tuple(TTemp[--SP]);

  /*========== if (InitImage == 'false') ==========*/
  create_tuple_s(&TTemp[SP++],"false");
  T_tuple_equal(hv_InitImage,TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-1]=TTemp[SP];
  if(get_i(TTemp[SP-1],0))
  {
    /*overpaint_region (GtOrientationSin, GtOrientationSin, 0.0, 'fill')*/
    /***/overpaint_region(ho_GtOrientationSin, ho_GtOrientationSin, 0.0, "fill");

    /*overpaint_region (GtOrientationCos, GtOrientationCos, 0.0, 'fill')*/
    /***/overpaint_region(ho_GtOrientationCos, ho_GtOrientationCos, 0.0, "fill");

  }
  destroy_tuple(TTemp[--SP]);
  /*========== end if ==========*/
  /*========== if (|__get_dict_tuple( DLSample, ['bbox_label_id'])| > 0) ==========*/
  create_tuple_s(&TTemp[SP++],"bbox_label_id");
  T_get_dict_tuple(hv_DLSample,TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-1]=TTemp[SP];
  T_tuple_length(TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-1]=TTemp[SP];
  create_tuple_i(&TTemp[SP++],0);
  T_tuple_greater(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-2]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-2]=TTemp[SP];
  SP--;
  if(get_i(TTemp[SP-1],0))
  {
    /*Process char boxes*/
    /*tuple_find (__get_dict_tuple( DLSample, ['bbox_label_id']), 1, Indices)*/
    create_tuple_s(&TTemp[SP++],"bbox_label_id");
    T_get_dict_tuple(hv_DLSample,TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    create_tuple_i(&TTemp[SP++],1);
    destroy_tuple(hv_Indices);
    /***/T_tuple_find(TTemp[SP-2], TTemp[SP-1], &hv_Indices);
    destroy_tuple(TTemp[--SP]);
    destroy_tuple(TTemp[--SP]);

    /*========== if (Indices != -1) ==========*/
    create_tuple_i(&TTemp[SP++],-1);
    T_tuple_not_equal(hv_Indices,TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    if(get_i(TTemp[SP-1],0))
    {
      /*Phi := __get_dict_tuple( DLSample, ['bbox_phi'])*/
      create_tuple_s(&TTemp[SP++],"bbox_phi");
      T_get_dict_tuple(hv_DLSample,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      destroy_tuple(hv_Phi);
      hv_Phi=TTemp[--SP];

      /*gen_rectangle2 (Region, __get_dict_tuple( DLSample, ['bbox_row'])[Indices], __get_dict_tuple( DLSample, ['bbox_col'])[Indices], __get_dict_tuple( DLSample, ['bbox_phi'])[Indices], __get_dict_tuple( DLSample, ['bbox_length1'])[Indices], __get_dict_tuple( DLSample, ['bbox_length2'])[Indices])*/
      create_tuple_s(&TTemp[SP++],"bbox_row");
      T_get_dict_tuple(hv_DLSample,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      T_tuple_select(TTemp[SP-1],hv_Indices,&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      create_tuple_s(&TTemp[SP++],"bbox_col");
      T_get_dict_tuple(hv_DLSample,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      T_tuple_select(TTemp[SP-1],hv_Indices,&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      create_tuple_s(&TTemp[SP++],"bbox_phi");
      T_get_dict_tuple(hv_DLSample,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      T_tuple_select(TTemp[SP-1],hv_Indices,&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      create_tuple_s(&TTemp[SP++],"bbox_length1");
      T_get_dict_tuple(hv_DLSample,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      T_tuple_select(TTemp[SP-1],hv_Indices,&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      create_tuple_s(&TTemp[SP++],"bbox_length2");
      T_get_dict_tuple(hv_DLSample,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      T_tuple_select(TTemp[SP-1],hv_Indices,&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      clear_obj(ho_Region);
      /***/T_gen_rectangle2(&ho_Region, TTemp[SP-5], TTemp[SP-4], TTemp[SP-3], TTemp[SP-2], 
          TTemp[SP-1]);
      destroy_tuple(TTemp[--SP]);
      destroy_tuple(TTemp[--SP]);
      destroy_tuple(TTemp[--SP]);
      destroy_tuple(TTemp[--SP]);
      destroy_tuple(TTemp[--SP]);

      /*overpaint_region (GtOrientationSin, Region, sin(Phi[Indices]), 'fill')*/
      T_tuple_select(hv_Phi,hv_Indices,&TTemp[SP++]);
      T_tuple_sin(TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      create_tuple_s(&TTemp[SP++],"fill");
      /***/T_overpaint_region(ho_GtOrientationSin, ho_Region, TTemp[SP-2], TTemp[SP-1]);
      destroy_tuple(TTemp[--SP]);
      destroy_tuple(TTemp[--SP]);

      /*overpaint_region (GtOrientationCos, Region, cos(Phi[Indices]), 'fill')*/
      T_tuple_select(hv_Phi,hv_Indices,&TTemp[SP++]);
      T_tuple_cos(TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      create_tuple_s(&TTemp[SP++],"fill");
      /***/T_overpaint_region(ho_GtOrientationCos, ho_Region, TTemp[SP-2], TTemp[SP-1]);
      destroy_tuple(TTemp[--SP]);
      destroy_tuple(TTemp[--SP]);

    }
    destroy_tuple(TTemp[--SP]);
    /*========== end if ==========*/
  }
  destroy_tuple(TTemp[--SP]);
  /*========== end if ==========*/
  /*compose2 (GtOrientationSin, GtOrientationCos, GtOrientationMaps)*/
  clear_obj((*ho_GtOrientationMaps));
  /***/compose2(ho_GtOrientationSin, ho_GtOrientationCos, &(*ho_GtOrientationMaps)
      );

  /*========== return ==========*/

  /* Clear temporary tuple stack */
  while (SP > 0)
    destroy_tuple(TTemp[--SP]);
  /* Clear temporary tuple vectors stack*/
  while (SPTV > 0)
    V_destroy_vector(TVTemp[--SPTV]);
  /* Clear local iconic variables */
  clear_obj(ho_GtOrientationSin);
  clear_obj(ho_GtOrientationCos);
  clear_obj(ho_Region);

  /* Clear local control variables */
  destroy_tuple(hv_InitImage);
  destroy_tuple(hv_Indices);
  destroy_tuple(hv_Phi);

  return;

  /****************************************************/
  /******************     End procedure   *************/
  /****************************************************/

}

/* Chapter: OCR / Deep OCR*/
/* Short Description: Generate target text score map for ocr detection training. */
void gen_dl_ocr_detection_gt_score_map (Hobject *ho_TargetText, Htuple hv_DLSample, 
    Htuple hv_BoxCutoff, Htuple hv_RenderCutoff, Htuple hv_ImageWidth, Htuple hv_ImageHeight)
{

  /* Stack for temporary tuples */
  Htuple   TTemp[100];
  int      SP=0;
  /* Stack for temporary objects */
  Hobject  OTemp[20] = {0};
  int      SPO=0;
  /* Stack for temporary tuple vectors */
  Hvector  TVTemp[100] = {0};
  int      SPTV=0;

  /* Local iconic variables */
  Hobject  ho_ExtendedRectangle;

  /* Local control variables */
  Htuple  hv_InitImage, hv_Index, hv_Sigma1, hv_Sigma2;
  Htuple  hv_ExtendedLength1, hv_ExtendedLength2, hv_Rows;
  Htuple  hv_Columns, hv_Area, hv_Row, hv_Column, hv_HomMat2D;
  Htuple  hv_DistRow, hv_DistCol, hv_ScaledGaussian, hv_Grayval;

  /* Initialize iconic variables */
  gen_empty_obj(&ho_ExtendedRectangle);
  gen_empty_obj(&(*ho_TargetText));

  /* Initialize control variables */
  create_tuple(&hv_InitImage,0);
  create_tuple(&hv_Index,0);
  create_tuple(&hv_Sigma1,0);
  create_tuple(&hv_Sigma2,0);
  create_tuple(&hv_ExtendedLength1,0);
  create_tuple(&hv_ExtendedLength2,0);
  create_tuple(&hv_Rows,0);
  create_tuple(&hv_Columns,0);
  create_tuple(&hv_Area,0);
  create_tuple(&hv_Row,0);
  create_tuple(&hv_Column,0);
  create_tuple(&hv_HomMat2D,0);
  create_tuple(&hv_DistRow,0);
  create_tuple(&hv_DistCol,0);
  create_tuple(&hv_ScaledGaussian,0);
  create_tuple(&hv_Grayval,0);

  /****************************************************/
  /******************   Begin procedure   *************/
  /****************************************************/

  /*gen_image_const (TargetText, 'real', ImageWidth, ImageHeight)*/
  create_tuple_s(&TTemp[SP++],"real");
  clear_obj((*ho_TargetText));
  /***/T_gen_image_const(&(*ho_TargetText), TTemp[SP-1], hv_ImageWidth, hv_ImageHeight);
  destroy_tuple(TTemp[--SP]);

  /*get_system ('init_new_image', InitImage)*/
  create_tuple_s(&TTemp[SP++],"init_new_image");
  destroy_tuple(hv_InitImage);
  /***/T_get_system(TTemp[SP-1], &hv_InitImage);
  destroy_tuple(TTemp[--SP]);

  /*========== if (InitImage == 'false') ==========*/
  create_tuple_s(&TTemp[SP++],"false");
  T_tuple_equal(hv_InitImage,TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-1]=TTemp[SP];
  if(get_i(TTemp[SP-1],0))
  {
    /*overpaint_region (TargetText, TargetText, 0.0, 'fill')*/
    /***/overpaint_region((*ho_TargetText), (*ho_TargetText), 0.0, "fill");

  }
  destroy_tuple(TTemp[--SP]);
  /*========== end if ==========*/
  /*========== for Index := 0 to |__get_dict_tuple( DLSample, ['bbox_label_id'])| - 1 by 1 ==========*/
  create_tuple_s(&TTemp[SP++],"bbox_label_id");
  T_get_dict_tuple(hv_DLSample,TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-1]=TTemp[SP];
  T_tuple_length(TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-1]=TTemp[SP];
  create_tuple_i(&TTemp[SP++],1);
  T_tuple_sub(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-2]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-2]=TTemp[SP];
  SP--;
  create_tuple_i(&TTemp[SP++],1);
  create_tuple_i(&TTemp[SP++],0);
  T_tuple_greater(TTemp[SP-1],TTemp[SP-3],&TTemp[SP]);
  SP++;
  T_tuple_equal(TTemp[SP-2],TTemp[SP-4],&TTemp[SP]);
  if(get_i(TTemp[SP],0) ||
     (!((( get_i(TTemp[SP-1],0)) && (get_d(TTemp[SP-3],0)>0)) ||
        ((!get_i(TTemp[SP-1],0)) && (get_d(TTemp[SP-3],0)<0)))))
  {
   destroy_tuple(TTemp[SP--]);
   destroy_tuple(TTemp[SP]);
   T_tuple_sub(TTemp[SP-1],TTemp[SP-2],&TTemp[SP]);
   destroy_tuple(hv_Index);
   copy_tuple(TTemp[SP],&hv_Index);
   destroy_tuple(TTemp[SP--]);
   destroy_tuple(TTemp[SP]);
   for(;;)
   {
   T_tuple_add(hv_Index,TTemp[SP-1],&TTemp[SP]);
   destroy_tuple(hv_Index);
   copy_tuple(TTemp[SP],&hv_Index);
   destroy_tuple(TTemp[SP]);
   if(get_d(TTemp[SP-1],0)<0)
    T_tuple_less(hv_Index,TTemp[SP-2],&TTemp[SP]);
   else
    T_tuple_greater(hv_Index,TTemp[SP-2],&TTemp[SP]);
   if(get_i(TTemp[SP],0)) break;
   destroy_tuple(TTemp[SP]);
   /*========== for ==========*/

    /*For each char box*/
    /*========== if (__get_dict_tuple( DLSample, ['bbox_label_id'])[Index] == 1 and BoxCutoff != 0) ==========*/
    create_tuple_s(&TTemp[SP++],"bbox_label_id");
    T_get_dict_tuple(hv_DLSample,TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    T_tuple_select(TTemp[SP-1],hv_Index,&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    create_tuple_i(&TTemp[SP++],1);
    T_tuple_equal(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-2]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-2]=TTemp[SP];
    SP--;
    create_tuple_i(&TTemp[SP++],0);
    T_tuple_not_equal(hv_BoxCutoff,TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    T_tuple_and(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-2]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-2]=TTemp[SP];
    SP--;
    if(get_i(TTemp[SP-1],0))
    {
      /*Compute the sigma of an unnormalized normal distribution, such that*/
      /*a certain threshold value is reached at the interval of a certain size.*/
      /*Sigma1 := __get_dict_tuple( DLSample, ['bbox_length1'])[Index] * sqrt(-0.5 / log(BoxCutoff))*/
      create_tuple_s(&TTemp[SP++],"bbox_length1");
      T_get_dict_tuple(hv_DLSample,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      T_tuple_select(TTemp[SP-1],hv_Index,&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      create_tuple_d(&TTemp[SP++],-0.5);
      T_tuple_log(hv_BoxCutoff,&TTemp[SP++]);
      T_tuple_div(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-2]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-2]=TTemp[SP];
      SP--;
      T_tuple_sqrt(TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      T_tuple_mult(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-2]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-2]=TTemp[SP];
      SP--;
      destroy_tuple(hv_Sigma1);
      hv_Sigma1=TTemp[--SP];

      /*Sigma2 := __get_dict_tuple( DLSample, ['bbox_length2'])[Index] * sqrt(-0.5 / log(BoxCutoff))*/
      create_tuple_s(&TTemp[SP++],"bbox_length2");
      T_get_dict_tuple(hv_DLSample,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      T_tuple_select(TTemp[SP-1],hv_Index,&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      create_tuple_d(&TTemp[SP++],-0.5);
      T_tuple_log(hv_BoxCutoff,&TTemp[SP++]);
      T_tuple_div(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-2]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-2]=TTemp[SP];
      SP--;
      T_tuple_sqrt(TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      T_tuple_mult(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-2]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-2]=TTemp[SP];
      SP--;
      destroy_tuple(hv_Sigma2);
      hv_Sigma2=TTemp[--SP];

      /*========== if (Sigma1 != 0 and Sigma2 != 0 and RenderCutoff != 0) ==========*/
      create_tuple_i(&TTemp[SP++],0);
      T_tuple_not_equal(hv_Sigma1,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      create_tuple_i(&TTemp[SP++],0);
      T_tuple_not_equal(hv_Sigma2,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      T_tuple_and(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-2]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-2]=TTemp[SP];
      SP--;
      create_tuple_i(&TTemp[SP++],0);
      T_tuple_not_equal(hv_RenderCutoff,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      T_tuple_and(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-2]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-2]=TTemp[SP];
      SP--;
      if(get_i(TTemp[SP-1],0))
      {
        /*Compute the radius of an unnormalized normal distribution,*/
        /*where a certain threshold value is reached at the end.*/
        /*ExtendedLength1 := Sigma1 * sqrt(-2 * log(RenderCutoff))*/
        create_tuple_i(&TTemp[SP++],-2);
        T_tuple_log(hv_RenderCutoff,&TTemp[SP++]);
        T_tuple_mult(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-2]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-2]=TTemp[SP];
        SP--;
        T_tuple_sqrt(TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-1]=TTemp[SP];
        T_tuple_mult(hv_Sigma1,TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-1]=TTemp[SP];
        destroy_tuple(hv_ExtendedLength1);
        hv_ExtendedLength1=TTemp[--SP];

        /*ExtendedLength2 := Sigma2 * sqrt(-2 * log(RenderCutoff))*/
        create_tuple_i(&TTemp[SP++],-2);
        T_tuple_log(hv_RenderCutoff,&TTemp[SP++]);
        T_tuple_mult(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-2]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-2]=TTemp[SP];
        SP--;
        T_tuple_sqrt(TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-1]=TTemp[SP];
        T_tuple_mult(hv_Sigma2,TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-1]=TTemp[SP];
        destroy_tuple(hv_ExtendedLength2);
        hv_ExtendedLength2=TTemp[--SP];

        /*gen_rectangle2 (ExtendedRectangle, __get_dict_tuple( DLSample, ['bbox_row'])[Index], __get_dict_tuple( DLSample, ['bbox_col'])[Index], __get_dict_tuple( DLSample, ['bbox_phi'])[Index], ExtendedLength1, ExtendedLength2)*/
        create_tuple_s(&TTemp[SP++],"bbox_row");
        T_get_dict_tuple(hv_DLSample,TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-1]=TTemp[SP];
        T_tuple_select(TTemp[SP-1],hv_Index,&TTemp[SP]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-1]=TTemp[SP];
        create_tuple_s(&TTemp[SP++],"bbox_col");
        T_get_dict_tuple(hv_DLSample,TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-1]=TTemp[SP];
        T_tuple_select(TTemp[SP-1],hv_Index,&TTemp[SP]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-1]=TTemp[SP];
        create_tuple_s(&TTemp[SP++],"bbox_phi");
        T_get_dict_tuple(hv_DLSample,TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-1]=TTemp[SP];
        T_tuple_select(TTemp[SP-1],hv_Index,&TTemp[SP]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-1]=TTemp[SP];
        clear_obj(ho_ExtendedRectangle);
        /***/T_gen_rectangle2(&ho_ExtendedRectangle, TTemp[SP-3], TTemp[SP-2], TTemp[SP-1], 
            hv_ExtendedLength1, hv_ExtendedLength2);
        destroy_tuple(TTemp[--SP]);
        destroy_tuple(TTemp[--SP]);
        destroy_tuple(TTemp[--SP]);

        /*clip_region (ExtendedRectangle, ExtendedRectangle, 0, 0, ImageHeight - 1, ImageWidth - 1)*/
        create_tuple_i(&TTemp[SP++],0);
        create_tuple_i(&TTemp[SP++],0);
        create_tuple_i(&TTemp[SP++],1);
        T_tuple_sub(hv_ImageHeight,TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-1]=TTemp[SP];
        create_tuple_i(&TTemp[SP++],1);
        T_tuple_sub(hv_ImageWidth,TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-1]=TTemp[SP];
        /***/T_clip_region(ho_ExtendedRectangle, &(OTemp[SPO]), TTemp[SP-4], TTemp[SP-3], 
            TTemp[SP-2], TTemp[SP-1]);
        SPO++;
        clear_obj(ho_ExtendedRectangle);
        ho_ExtendedRectangle = OTemp[--SPO];
        destroy_tuple(TTemp[--SP]);
        destroy_tuple(TTemp[--SP]);
        destroy_tuple(TTemp[--SP]);
        destroy_tuple(TTemp[--SP]);

        /*get_region_points (ExtendedRectangle, Rows, Columns)*/
        destroy_tuple(hv_Rows);
        destroy_tuple(hv_Columns);
        /***/T_get_region_points(ho_ExtendedRectangle, &hv_Rows, &hv_Columns);

        /*Verify that the bounding box has an area to plot a gaussian*/
        /*area_center (ExtendedRectangle, Area, Row, Column)*/
        destroy_tuple(hv_Area);
        destroy_tuple(hv_Row);
        destroy_tuple(hv_Column);
        /***/T_area_center(ho_ExtendedRectangle, &hv_Area, &hv_Row, &hv_Column);

        /*========== if (Area > 1) ==========*/
        create_tuple_i(&TTemp[SP++],1);
        T_tuple_greater(hv_Area,TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-1]=TTemp[SP];
        if(get_i(TTemp[SP-1],0))
        {
          /*hom_mat2d_identity (HomMat2D)*/
          destroy_tuple(hv_HomMat2D);
          /***/T_hom_mat2d_identity(&hv_HomMat2D);

          /*hom_mat2d_translate (HomMat2D, -__get_dict_tuple( DLSample, ['bbox_row'])[Index], -__get_dict_tuple( DLSample, ['bbox_col'])[Index], HomMat2D)*/
          copy_tuple(hv_HomMat2D,&TTemp[SP++]);
          create_tuple_s(&TTemp[SP++],"bbox_row");
          T_get_dict_tuple(hv_DLSample,TTemp[SP-1],&TTemp[SP]);
          destroy_tuple(TTemp[SP-1]);
          TTemp[SP-1]=TTemp[SP];
          T_tuple_select(TTemp[SP-1],hv_Index,&TTemp[SP]);
          destroy_tuple(TTemp[SP-1]);
          TTemp[SP-1]=TTemp[SP];
          T_tuple_neg(TTemp[SP-1],&TTemp[SP]);
          destroy_tuple(TTemp[SP-1]);
          TTemp[SP-1]=TTemp[SP];
          create_tuple_s(&TTemp[SP++],"bbox_col");
          T_get_dict_tuple(hv_DLSample,TTemp[SP-1],&TTemp[SP]);
          destroy_tuple(TTemp[SP-1]);
          TTemp[SP-1]=TTemp[SP];
          T_tuple_select(TTemp[SP-1],hv_Index,&TTemp[SP]);
          destroy_tuple(TTemp[SP-1]);
          TTemp[SP-1]=TTemp[SP];
          T_tuple_neg(TTemp[SP-1],&TTemp[SP]);
          destroy_tuple(TTemp[SP-1]);
          TTemp[SP-1]=TTemp[SP];
          destroy_tuple(hv_HomMat2D);
          /***/T_hom_mat2d_translate(TTemp[SP-3], TTemp[SP-2], TTemp[SP-1], &hv_HomMat2D);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(TTemp[--SP]);

          /*hom_mat2d_rotate (HomMat2D, -__get_dict_tuple( DLSample, ['bbox_phi'])[Index], 0, 0, HomMat2D)*/
          copy_tuple(hv_HomMat2D,&TTemp[SP++]);
          create_tuple_s(&TTemp[SP++],"bbox_phi");
          T_get_dict_tuple(hv_DLSample,TTemp[SP-1],&TTemp[SP]);
          destroy_tuple(TTemp[SP-1]);
          TTemp[SP-1]=TTemp[SP];
          T_tuple_select(TTemp[SP-1],hv_Index,&TTemp[SP]);
          destroy_tuple(TTemp[SP-1]);
          TTemp[SP-1]=TTemp[SP];
          T_tuple_neg(TTemp[SP-1],&TTemp[SP]);
          destroy_tuple(TTemp[SP-1]);
          TTemp[SP-1]=TTemp[SP];
          create_tuple_i(&TTemp[SP++],0);
          create_tuple_i(&TTemp[SP++],0);
          destroy_tuple(hv_HomMat2D);
          /***/T_hom_mat2d_rotate(TTemp[SP-4], TTemp[SP-3], TTemp[SP-2], TTemp[SP-1], 
              &hv_HomMat2D);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(TTemp[--SP]);

          /*affine_trans_point_2d (HomMat2D, Rows, Columns, DistRow, DistCol)*/
          destroy_tuple(hv_DistRow);
          destroy_tuple(hv_DistCol);
          /***/T_affine_trans_point_2d(hv_HomMat2D, hv_Rows, hv_Columns, &hv_DistRow, 
              &hv_DistCol);

          /*ScaledGaussian := exp(-0.5 * ((DistCol * DistCol) / (Sigma1 * Sigma1) + (DistRow * DistRow) / (Sigma2 * Sigma2)))*/
          create_tuple_d(&TTemp[SP++],-0.5);
          T_tuple_mult(hv_DistCol,hv_DistCol,&TTemp[SP++]);
          T_tuple_mult(hv_Sigma1,hv_Sigma1,&TTemp[SP++]);
          T_tuple_div(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
          destroy_tuple(TTemp[SP-2]);
          destroy_tuple(TTemp[SP-1]);
          TTemp[SP-2]=TTemp[SP];
          SP--;
          T_tuple_mult(hv_DistRow,hv_DistRow,&TTemp[SP++]);
          T_tuple_mult(hv_Sigma2,hv_Sigma2,&TTemp[SP++]);
          T_tuple_div(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
          destroy_tuple(TTemp[SP-2]);
          destroy_tuple(TTemp[SP-1]);
          TTemp[SP-2]=TTemp[SP];
          SP--;
          T_tuple_add(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
          destroy_tuple(TTemp[SP-2]);
          destroy_tuple(TTemp[SP-1]);
          TTemp[SP-2]=TTemp[SP];
          SP--;
          T_tuple_mult(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
          destroy_tuple(TTemp[SP-2]);
          destroy_tuple(TTemp[SP-1]);
          TTemp[SP-2]=TTemp[SP];
          SP--;
          T_tuple_exp(TTemp[SP-1],&TTemp[SP]);
          destroy_tuple(TTemp[SP-1]);
          TTemp[SP-1]=TTemp[SP];
          destroy_tuple(hv_ScaledGaussian);
          hv_ScaledGaussian=TTemp[--SP];

          /*get_grayval (TargetText, Rows, Columns, Grayval)*/
          destroy_tuple(hv_Grayval);
          /***/T_get_grayval((*ho_TargetText), hv_Rows, hv_Columns, &hv_Grayval);

          /*set_grayval (TargetText, Rows, Columns, max2(ScaledGaussian,Grayval))*/
          T_tuple_max2(hv_ScaledGaussian,hv_Grayval,&TTemp[SP++]);
          /***/T_set_grayval((*ho_TargetText), hv_Rows, hv_Columns, TTemp[SP-1]);
          destroy_tuple(TTemp[--SP]);

        }
        destroy_tuple(TTemp[--SP]);
        /*========== end if ==========*/
      }
      destroy_tuple(TTemp[--SP]);
      /*========== end if ==========*/
    }
    destroy_tuple(TTemp[--SP]);
    /*========== end if ==========*/
   }
   destroy_tuple(TTemp[SP--]);
   destroy_tuple(TTemp[SP--]);
   destroy_tuple(TTemp[SP]);
  }
  else
  {
   destroy_tuple(TTemp[SP--]);
   destroy_tuple(TTemp[SP--]);
   destroy_tuple(TTemp[SP--]);
   destroy_tuple(TTemp[SP--]);
   destroy_tuple(TTemp[SP]);
  }/*========== end for ========*/

  /*========== return ==========*/

  /* Clear temporary tuple stack */
  while (SP > 0)
    destroy_tuple(TTemp[--SP]);
  /* Clear temporary tuple vectors stack*/
  while (SPTV > 0)
    V_destroy_vector(TVTemp[--SPTV]);
  /* Clear local iconic variables */
  clear_obj(ho_ExtendedRectangle);

  /* Clear local control variables */
  destroy_tuple(hv_InitImage);
  destroy_tuple(hv_Index);
  destroy_tuple(hv_Sigma1);
  destroy_tuple(hv_Sigma2);
  destroy_tuple(hv_ExtendedLength1);
  destroy_tuple(hv_ExtendedLength2);
  destroy_tuple(hv_Rows);
  destroy_tuple(hv_Columns);
  destroy_tuple(hv_Area);
  destroy_tuple(hv_Row);
  destroy_tuple(hv_Column);
  destroy_tuple(hv_HomMat2D);
  destroy_tuple(hv_DistRow);
  destroy_tuple(hv_DistCol);
  destroy_tuple(hv_ScaledGaussian);
  destroy_tuple(hv_Grayval);

  return;

  /****************************************************/
  /******************     End procedure   *************/
  /****************************************************/

}

/* Chapter: OCR / Deep OCR*/
/* Short Description: Preprocess dl samples and generate targets and weights for ocr detection training. */
void gen_dl_ocr_detection_targets (Htuple hv_DLSampleOriginal, Htuple hv_DLPreprocessParam)
{

  /* Stack for temporary tuples */
  Htuple   TTemp[100];
  int      SP=0;
  /* Stack for temporary objects */
  Hobject  OTemp[100] = {0};
  int      SPO=0;
  /* Stack for temporary tuple vectors */
  Hvector  TVTemp[100] = {0};
  int      SPTV=0;
  /* Stack for temporary object vectors */
  Hvector  OVTemp[100] = {0};
  int      SPOV=0;

  /* Local iconic variables */
  Hobject  ho_TargetText, ho_TargetLink, ho_TargetOrientation;
  Hobject  ho_TargetWeightText, ho_TargetWeightLink, ho_WeightedCharScore;
  Hobject  ho_TargetWeightOrientation, ho_OriginalDomain, ho_Image;
  Hobject  ho_DomainWeight, ho_Domain, ho_TargetOrientationOut;
  Hobject  ho_TargetWeightOrientationOut, ho_TargetOrientationChannel;
  Hobject  ho_TargetWeightOrientationChannel;

  /* Local control variables */
  Htuple  hv_ImageWidth, hv_ImageHeight, hv_Stride;
  Htuple  hv_ScaleHeight, hv_ScaleWidth, hv_BoxCutoff, hv_RenderCutoff;
  Htuple  hv_Alpha, hv_WSWeightRenderThreshold, hv_LinkZeroWeightRadius;
  Htuple  hv_Confidence, hv_ScoreMapsWidth, hv_ScoreMapsHeight;
  Htuple  hv_DLSample, hv_HomMat2DIdentity, hv_HomMat2DScale;
  Htuple  hv_DLSampleTargets, hv_OriginalDomainArea, hv__;
  Htuple  hv_OriginalWidth, hv_OriginalHeight, hv_IsOriginalDomainFull;
  Htuple  hv_ChannelIdx, hv___Tmp_Ctrl_0, hv___Tmp_Ctrl_1;
  Hvector  hvec_WordsCharsMapping;

  /* Array for temporary output ctrl variables */
  Htuple  CExpDummyOCvar[2];

  /* Initialize iconic variables */
  gen_empty_obj(&ho_TargetText);
  gen_empty_obj(&ho_TargetLink);
  gen_empty_obj(&ho_TargetOrientation);
  gen_empty_obj(&ho_TargetWeightText);
  gen_empty_obj(&ho_TargetWeightLink);
  gen_empty_obj(&ho_WeightedCharScore);
  gen_empty_obj(&ho_TargetWeightOrientation);
  gen_empty_obj(&ho_OriginalDomain);
  gen_empty_obj(&ho_Image);
  gen_empty_obj(&ho_DomainWeight);
  gen_empty_obj(&ho_Domain);
  gen_empty_obj(&ho_TargetOrientationOut);
  gen_empty_obj(&ho_TargetWeightOrientationOut);
  gen_empty_obj(&ho_TargetOrientationChannel);
  gen_empty_obj(&ho_TargetWeightOrientationChannel);

  /* Initialize control variables */
  create_tuple(&hv_ImageWidth,0);
  create_tuple(&hv_ImageHeight,0);
  create_tuple(&hv_Stride,0);
  create_tuple(&hv_ScaleHeight,0);
  create_tuple(&hv_ScaleWidth,0);
  create_tuple(&hv_BoxCutoff,0);
  create_tuple(&hv_RenderCutoff,0);
  create_tuple(&hv_Alpha,0);
  create_tuple(&hv_WSWeightRenderThreshold,0);
  create_tuple(&hv_LinkZeroWeightRadius,0);
  create_tuple(&hv_Confidence,0);
  create_tuple(&hv_ScoreMapsWidth,0);
  create_tuple(&hv_ScoreMapsHeight,0);
  create_tuple(&hv_DLSample,0);
  create_tuple(&hv_HomMat2DIdentity,0);
  create_tuple(&hv_HomMat2DScale,0);
  create_tuple(&hv_DLSampleTargets,0);
  create_tuple(&hv_OriginalDomainArea,0);
  create_tuple(&hv__,0);
  create_tuple(&hv_OriginalWidth,0);
  create_tuple(&hv_OriginalHeight,0);
  create_tuple(&hv_IsOriginalDomainFull,0);
  create_tuple(&hv_ChannelIdx,0);
  create_tuple(&hv___Tmp_Ctrl_0,0);
  create_tuple(&hv___Tmp_Ctrl_1,0);
  V_create_tuple_vector(1,&hvec_WordsCharsMapping);

  /****************************************************/
  /******************   Begin procedure   *************/
  /****************************************************/

  /*check_dl_preprocess_param (DLPreprocessParam)*/
  /***/check_dl_preprocess_param(hv_DLPreprocessParam);

  /*get_dict_tuple (DLPreprocessParam, 'image_width', ImageWidth)*/
  create_tuple_s(&TTemp[SP++],"image_width");
  destroy_tuple(hv_ImageWidth);
  /***/T_get_dict_tuple(hv_DLPreprocessParam, TTemp[SP-1], &hv_ImageWidth);
  destroy_tuple(TTemp[--SP]);

  /*get_dict_tuple (DLPreprocessParam, 'image_height', ImageHeight)*/
  create_tuple_s(&TTemp[SP++],"image_height");
  destroy_tuple(hv_ImageHeight);
  /***/T_get_dict_tuple(hv_DLPreprocessParam, TTemp[SP-1], &hv_ImageHeight);
  destroy_tuple(TTemp[--SP]);

  /*Stride := 2*/
  reuse_tuple_i(&hv_Stride,2);

  /*Parameters used in the fallback weak supervision case.*/
  /*They make the the uniformly sized char boxes a bit smaller, as we can expect a spacing between the characters.*/
  /*ScaleHeight := 0.9*/
  reuse_tuple_d(&hv_ScaleHeight,0.9);

  /*ScaleWidth := 0.8*/
  reuse_tuple_d(&hv_ScaleWidth,0.8);

  /*Parameters relevant to plot the gaussian blobs in the score map.*/
  /*BoxCutoff := 0.3*/
  reuse_tuple_d(&hv_BoxCutoff,0.3);

  /*RenderCutoff := 0.01*/
  reuse_tuple_d(&hv_RenderCutoff,0.01);

  /*Parameter used to determine the dilation of lines in link map.*/
  /*Alpha := 0.1*/
  reuse_tuple_d(&hv_Alpha,0.1);

  /*Parameter used to determine the dilation radius of word boxes in the weight score map.*/
  /*WSWeightRenderThreshold := 0.05*/
  reuse_tuple_d(&hv_WSWeightRenderThreshold,0.05);

  /*Parameter represents the dilation radius of word lines in the weight link map.*/
  /*LinkZeroWeightRadius := 2.5*/
  reuse_tuple_d(&hv_LinkZeroWeightRadius,2.5);

  /*Confidence is here only a place holder for the fallback weak supervision case.*/
  /*Confidence := 1.0*/
  reuse_tuple_d(&hv_Confidence,1.0);

  /*========== if (Stride == 0) ==========*/
  create_tuple_i(&TTemp[SP++],0);
  T_tuple_equal(hv_Stride,TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-1]=TTemp[SP];
  if(get_i(TTemp[SP-1],0))
  {
    /* throw(...); only in hdevelop*/
  }
  destroy_tuple(TTemp[--SP]);
  /*========== end if ==========*/
  /*Calculate the size of score maps.*/
  /*ScoreMapsWidth := ImageWidth / Stride*/
  T_tuple_div(hv_ImageWidth,hv_Stride,&TTemp[SP++]);
  destroy_tuple(hv_ScoreMapsWidth);
  hv_ScoreMapsWidth=TTemp[--SP];

  /*ScoreMapsHeight := ImageHeight / Stride*/
  T_tuple_div(hv_ImageHeight,hv_Stride,&TTemp[SP++]);
  destroy_tuple(hv_ScoreMapsHeight);
  hv_ScoreMapsHeight=TTemp[--SP];

  /*Copy DLSample to maintain the original bounding boxes dimensions.*/
  /*copy_dict (DLSampleOriginal, [], [], DLSample)*/
  create_tuple(&TTemp[SP++],0);
  create_tuple(&TTemp[SP++],0);
  destroy_tuple(hv_DLSample);
  /***/T_copy_dict(hv_DLSampleOriginal, TTemp[SP-2], TTemp[SP-1], &hv_DLSample);
  destroy_tuple(TTemp[--SP]);
  destroy_tuple(TTemp[--SP]);

  /*Preprocess bounding boxes to match targets dimensions.*/
  /*hom_mat2d_identity (HomMat2DIdentity)*/
  destroy_tuple(hv_HomMat2DIdentity);
  /***/T_hom_mat2d_identity(&hv_HomMat2DIdentity);

  /*hom_mat2d_scale (HomMat2DIdentity, 1.0 / Stride, 1.0 / Stride, 0, 0, HomMat2DScale)*/
  create_tuple_d(&TTemp[SP++],1.0);
  T_tuple_div(TTemp[SP-1],hv_Stride,&TTemp[SP]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-1]=TTemp[SP];
  create_tuple_d(&TTemp[SP++],1.0);
  T_tuple_div(TTemp[SP-1],hv_Stride,&TTemp[SP]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-1]=TTemp[SP];
  create_tuple_i(&TTemp[SP++],0);
  create_tuple_i(&TTemp[SP++],0);
  destroy_tuple(hv_HomMat2DScale);
  /***/T_hom_mat2d_scale(hv_HomMat2DIdentity, TTemp[SP-4], TTemp[SP-3], TTemp[SP-2], 
      TTemp[SP-1], &hv_HomMat2DScale);
  destroy_tuple(TTemp[--SP]);
  destroy_tuple(TTemp[--SP]);
  destroy_tuple(TTemp[--SP]);
  destroy_tuple(TTemp[--SP]);

  /*affine_trans_point_2d (HomMat2DScale, __get_dict_tuple( DLSample, ['bbox_col']), __get_dict_tuple( DLSample, ['bbox_row']), __Tmp_Ctrl_0, __Tmp_Ctrl_1)*/
  create_tuple_s(&TTemp[SP++],"bbox_col");
  T_get_dict_tuple(hv_DLSample,TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-1]=TTemp[SP];
  create_tuple_s(&TTemp[SP++],"bbox_row");
  T_get_dict_tuple(hv_DLSample,TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-1]=TTemp[SP];
  destroy_tuple(hv___Tmp_Ctrl_0);
  destroy_tuple(hv___Tmp_Ctrl_1);
  /***/T_affine_trans_point_2d(hv_HomMat2DScale, TTemp[SP-2], TTemp[SP-1], &hv___Tmp_Ctrl_0, 
      &hv___Tmp_Ctrl_1);
  destroy_tuple(TTemp[--SP]);
  destroy_tuple(TTemp[--SP]);

  /*set_dict_tuple (DLSample, ['bbox_row'], __Tmp_Ctrl_1)*/
  create_tuple_s(&TTemp[SP++],"bbox_row");
  /***/T_set_dict_tuple(hv_DLSample, TTemp[SP-1], hv___Tmp_Ctrl_1);
  destroy_tuple(TTemp[--SP]);

  /*set_dict_tuple (DLSample, ['bbox_col'], __Tmp_Ctrl_0)*/
  create_tuple_s(&TTemp[SP++],"bbox_col");
  /***/T_set_dict_tuple(hv_DLSample, TTemp[SP-1], hv___Tmp_Ctrl_0);
  destroy_tuple(TTemp[--SP]);

  /*set_dict_tuple (DLSample, ['bbox_length1'], __get_dict_tuple( DLSample, ['bbox_length1']) / Stride)*/
  create_tuple_s(&TTemp[SP++],"bbox_length1");
  create_tuple_s(&TTemp[SP++],"bbox_length1");
  T_get_dict_tuple(hv_DLSample,TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-1]=TTemp[SP];
  T_tuple_div(TTemp[SP-1],hv_Stride,&TTemp[SP]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-1]=TTemp[SP];
  /***/T_set_dict_tuple(hv_DLSample, TTemp[SP-2], TTemp[SP-1]);
  destroy_tuple(TTemp[--SP]);
  destroy_tuple(TTemp[--SP]);

  /*set_dict_tuple (DLSample, ['bbox_length2'], __get_dict_tuple( DLSample, ['bbox_length2']) / Stride)*/
  create_tuple_s(&TTemp[SP++],"bbox_length2");
  create_tuple_s(&TTemp[SP++],"bbox_length2");
  T_get_dict_tuple(hv_DLSample,TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-1]=TTemp[SP];
  T_tuple_div(TTemp[SP-1],hv_Stride,&TTemp[SP]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-1]=TTemp[SP];
  /***/T_set_dict_tuple(hv_DLSample, TTemp[SP-2], TTemp[SP-1]);
  destroy_tuple(TTemp[--SP]);
  destroy_tuple(TTemp[--SP]);

  /*copy_dict (DLSample, [], [], DLSampleTargets)*/
  create_tuple(&TTemp[SP++],0);
  create_tuple(&TTemp[SP++],0);
  destroy_tuple(hv_DLSampleTargets);
  /***/T_copy_dict(hv_DLSample, TTemp[SP-2], TTemp[SP-1], &hv_DLSampleTargets);
  destroy_tuple(TTemp[--SP]);
  destroy_tuple(TTemp[--SP]);

  /*gen_dl_ocr_detection_gt_chars (DLSampleTargets, DLSample, ScaleWidth, ScaleHeight, WordsCharsMapping)*/
  V_destroy_vector(hvec_WordsCharsMapping);
  /***/gen_dl_ocr_detection_gt_chars(hv_DLSampleTargets, hv_DLSample, hv_ScaleWidth, 
      hv_ScaleHeight, &hvec_WordsCharsMapping);

  /*Generate target maps from WordRegions and CharBoxes.*/
  /*gen_dl_ocr_detection_gt_score_map (TargetText, DLSampleTargets, BoxCutoff, RenderCutoff, ScoreMapsWidth, ScoreMapsHeight)*/
  clear_obj(ho_TargetText);
  /***/gen_dl_ocr_detection_gt_score_map(&ho_TargetText, hv_DLSampleTargets, hv_BoxCutoff, 
      hv_RenderCutoff, hv_ScoreMapsWidth, hv_ScoreMapsHeight);

  /*gen_dl_ocr_detection_gt_link_map (TargetLink, ScoreMapsWidth, ScoreMapsHeight, DLSampleTargets, WordsCharsMapping, Alpha)*/
  clear_obj(ho_TargetLink);
  /***/gen_dl_ocr_detection_gt_link_map(&ho_TargetLink, hv_ScoreMapsWidth, hv_ScoreMapsHeight, 
      hv_DLSampleTargets, hvec_WordsCharsMapping, hv_Alpha);

  /*gen_dl_ocr_detection_gt_orientation_map (TargetOrientation, ScoreMapsWidth, ScoreMapsHeight, DLSampleTargets)*/
  clear_obj(ho_TargetOrientation);
  /***/gen_dl_ocr_detection_gt_orientation_map(&ho_TargetOrientation, hv_ScoreMapsWidth, 
      hv_ScoreMapsHeight, hv_DLSampleTargets);

  /*Generate weight maps from WordRegions and CharBoxes.*/
  /*gen_dl_ocr_detection_weight_score_map (TargetWeightText, ScoreMapsWidth, ScoreMapsHeight, DLSampleTargets, BoxCutoff, WSWeightRenderThreshold, Confidence)*/
  clear_obj(ho_TargetWeightText);
  /***/gen_dl_ocr_detection_weight_score_map(&ho_TargetWeightText, hv_ScoreMapsWidth, 
      hv_ScoreMapsHeight, hv_DLSampleTargets, hv_BoxCutoff, hv_WSWeightRenderThreshold, 
      hv_Confidence);

  /*gen_dl_ocr_detection_weight_link_map (TargetLink, TargetWeightText, TargetWeightLink, LinkZeroWeightRadius)*/
  clear_obj(ho_TargetWeightLink);
  /***/gen_dl_ocr_detection_weight_link_map(ho_TargetLink, ho_TargetWeightText, &ho_TargetWeightLink, 
      hv_LinkZeroWeightRadius);

  /*mult_image (TargetText, TargetWeightText, WeightedCharScore, 1, 0)*/
  clear_obj(ho_WeightedCharScore);
  /***/mult_image(ho_TargetText, ho_TargetWeightText, &ho_WeightedCharScore, 1, 0);

  /*gen_dl_ocr_detection_weight_orientation_map (WeightedCharScore, TargetWeightOrientation, DLSampleTargets)*/
  clear_obj(ho_TargetWeightOrientation);
  /***/gen_dl_ocr_detection_weight_orientation_map(ho_WeightedCharScore, &ho_TargetWeightOrientation, 
      hv_DLSampleTargets);

  /*Take account of the image domain in DLSampleOriginal.*/
  /*get_domain (__get_dict_object( DLSampleOriginal, ['image']), OriginalDomain)*/
  create_tuple_s(&TTemp[SP++],"image");
  T_get_dict_object(&OTemp[SPO++],hv_DLSampleOriginal,TTemp[SP-1]);
  destroy_tuple(TTemp[SP-1]);
  SP--;
  clear_obj(ho_OriginalDomain);
  /***/get_domain(OTemp[SPO-1], &ho_OriginalDomain);
  clear_obj(OTemp[--SPO]);

  /*area_center (OriginalDomain, OriginalDomainArea, _, _)*/
  destroy_tuple(hv_OriginalDomainArea);
  destroy_tuple(hv__);
  /***/T_area_center(ho_OriginalDomain, &hv_OriginalDomainArea, &hv__, &(CExpDummyOCvar[0]));
  destroy_tuple(CExpDummyOCvar[0]);

  /*get_image_size (__get_dict_object( DLSampleOriginal, ['image']), OriginalWidth, OriginalHeight)*/
  create_tuple_s(&TTemp[SP++],"image");
  T_get_dict_object(&OTemp[SPO++],hv_DLSampleOriginal,TTemp[SP-1]);
  destroy_tuple(TTemp[SP-1]);
  SP--;
  destroy_tuple(hv_OriginalWidth);
  destroy_tuple(hv_OriginalHeight);
  /***/T_get_image_size(OTemp[SPO-1], &hv_OriginalWidth, &hv_OriginalHeight);
  clear_obj(OTemp[--SPO]);

  /*IsOriginalDomainFull := OriginalDomainArea == OriginalWidth * OriginalHeight*/
  T_tuple_mult(hv_OriginalWidth,hv_OriginalHeight,&TTemp[SP++]);
  T_tuple_equal(hv_OriginalDomainArea,TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-1]=TTemp[SP];
  destroy_tuple(hv_IsOriginalDomainFull);
  hv_IsOriginalDomainFull=TTemp[--SP];

  /*========== if (not IsOriginalDomainFull) ==========*/
  T_tuple_not(hv_IsOriginalDomainFull,&TTemp[SP++]);
  if(get_i(TTemp[SP-1],0))
  {
    /*Calculate the domain weight.*/
    /*gen_image_const (Image, 'real', OriginalWidth, OriginalHeight)*/
    create_tuple_s(&TTemp[SP++],"real");
    clear_obj(ho_Image);
    /***/T_gen_image_const(&ho_Image, TTemp[SP-1], hv_OriginalWidth, hv_OriginalHeight);
    destroy_tuple(TTemp[--SP]);

    /*change_domain (Image, OriginalDomain, Image)*/
    /***/change_domain(ho_Image, ho_OriginalDomain, &(OTemp[SPO]));
    SPO++;
    clear_obj(ho_Image);
    ho_Image = OTemp[--SPO];

    /*zoom_image_size (Image, DomainWeight, ScoreMapsWidth, ScoreMapsHeight, 'constant')*/
    create_tuple_s(&TTemp[SP++],"constant");
    clear_obj(ho_DomainWeight);
    /***/T_zoom_image_size(ho_Image, &ho_DomainWeight, hv_ScoreMapsWidth, hv_ScoreMapsHeight, 
        TTemp[SP-1]);
    destroy_tuple(TTemp[--SP]);

    /*get_domain (DomainWeight, Domain)*/
    clear_obj(ho_Domain);
    /***/get_domain(ho_DomainWeight, &ho_Domain);

    /*full_domain (DomainWeight, DomainWeight)*/
    /***/full_domain(ho_DomainWeight, &(OTemp[SPO]));
    SPO++;
    clear_obj(ho_DomainWeight);
    ho_DomainWeight = OTemp[--SPO];

    /*overpaint_region (DomainWeight, DomainWeight, 0.0, 'fill')*/
    /***/overpaint_region(ho_DomainWeight, ho_DomainWeight, 0.0, "fill");

    /*overpaint_region (DomainWeight, Domain, 1.0, 'fill')*/
    /***/overpaint_region(ho_DomainWeight, ho_Domain, 1.0, "fill");

    /*Apply the domain weight.*/
    /*mult_image (DomainWeight, TargetText, TargetText, 1, 0)*/
    /***/mult_image(ho_DomainWeight, ho_TargetText, &(OTemp[SPO]), 1, 0);
    SPO++;
    clear_obj(ho_TargetText);
    ho_TargetText = OTemp[--SPO];

    /*mult_image (DomainWeight, TargetLink, TargetLink, 1, 0)*/
    /***/mult_image(ho_DomainWeight, ho_TargetLink, &(OTemp[SPO]), 1, 0);
    SPO++;
    clear_obj(ho_TargetLink);
    ho_TargetLink = OTemp[--SPO];

    /*mult_image (DomainWeight, TargetWeightText, TargetWeightText, 1, 0)*/
    /***/mult_image(ho_DomainWeight, ho_TargetWeightText, &(OTemp[SPO]), 1, 0);
    SPO++;
    clear_obj(ho_TargetWeightText);
    ho_TargetWeightText = OTemp[--SPO];

    /*mult_image (DomainWeight, TargetWeightLink, TargetWeightLink, 1, 0)*/
    /***/mult_image(ho_DomainWeight, ho_TargetWeightLink, &(OTemp[SPO]), 1, 0);
    SPO++;
    clear_obj(ho_TargetWeightLink);
    ho_TargetWeightLink = OTemp[--SPO];

    /*gen_empty_obj (TargetOrientationOut)*/
    clear_obj(ho_TargetOrientationOut);
    /***/gen_empty_obj(&ho_TargetOrientationOut);

    /*gen_empty_obj (TargetWeightOrientationOut)*/
    clear_obj(ho_TargetWeightOrientationOut);
    /***/gen_empty_obj(&ho_TargetWeightOrientationOut);

    /*========== for ChannelIdx := 1 to 2 by 1 ==========*/
    create_tuple_i(&TTemp[SP++],2);
    create_tuple_i(&TTemp[SP++],1);
    create_tuple_i(&TTemp[SP++],1);
    T_tuple_greater(TTemp[SP-1],TTemp[SP-3],&TTemp[SP]);
    SP++;
    T_tuple_equal(TTemp[SP-2],TTemp[SP-4],&TTemp[SP]);
    if(get_i(TTemp[SP],0) ||
       (!((( get_i(TTemp[SP-1],0)) && (get_d(TTemp[SP-3],0)>0)) ||
          ((!get_i(TTemp[SP-1],0)) && (get_d(TTemp[SP-3],0)<0)))))
    {
     destroy_tuple(TTemp[SP--]);
     destroy_tuple(TTemp[SP]);
     T_tuple_sub(TTemp[SP-1],TTemp[SP-2],&TTemp[SP]);
     destroy_tuple(hv_ChannelIdx);
     copy_tuple(TTemp[SP],&hv_ChannelIdx);
     destroy_tuple(TTemp[SP--]);
     destroy_tuple(TTemp[SP]);
     for(;;)
     {
     T_tuple_add(hv_ChannelIdx,TTemp[SP-1],&TTemp[SP]);
     destroy_tuple(hv_ChannelIdx);
     copy_tuple(TTemp[SP],&hv_ChannelIdx);
     destroy_tuple(TTemp[SP]);
     if(get_d(TTemp[SP-1],0)<0)
      T_tuple_less(hv_ChannelIdx,TTemp[SP-2],&TTemp[SP]);
     else
      T_tuple_greater(hv_ChannelIdx,TTemp[SP-2],&TTemp[SP]);
     if(get_i(TTemp[SP],0)) break;
     destroy_tuple(TTemp[SP]);
     /*========== for ==========*/

      /*access_channel (TargetOrientation, TargetOrientationChannel, ChannelIdx)*/
      clear_obj(ho_TargetOrientationChannel);
      /***/T_access_channel(ho_TargetOrientation, &ho_TargetOrientationChannel, hv_ChannelIdx);

      /*access_channel (TargetWeightOrientation, TargetWeightOrientationChannel, ChannelIdx)*/
      clear_obj(ho_TargetWeightOrientationChannel);
      /***/T_access_channel(ho_TargetWeightOrientation, &ho_TargetWeightOrientationChannel, 
          hv_ChannelIdx);

      /*mult_image (DomainWeight, TargetOrientationChannel, TargetOrientationChannel, 1, 0)*/
      /***/mult_image(ho_DomainWeight, ho_TargetOrientationChannel, &(OTemp[SPO]), 
          1, 0);
      SPO++;
      clear_obj(ho_TargetOrientationChannel);
      ho_TargetOrientationChannel = OTemp[--SPO];

      /*mult_image (DomainWeight, TargetWeightOrientationChannel, TargetWeightOrientationChannel, 1, 0)*/
      /***/mult_image(ho_DomainWeight, ho_TargetWeightOrientationChannel, &(OTemp[SPO]), 
          1, 0);
      SPO++;
      clear_obj(ho_TargetWeightOrientationChannel);
      ho_TargetWeightOrientationChannel = OTemp[--SPO];

      /*append_channel (TargetOrientationOut, TargetOrientationChannel, TargetOrientationOut)*/
      /***/append_channel(ho_TargetOrientationOut, ho_TargetOrientationChannel, &(OTemp[SPO])
          );
      SPO++;
      clear_obj(ho_TargetOrientationOut);
      ho_TargetOrientationOut = OTemp[--SPO];

      /*append_channel (TargetWeightOrientationOut, TargetWeightOrientationChannel, TargetWeightOrientationOut)*/
      /***/append_channel(ho_TargetWeightOrientationOut, ho_TargetWeightOrientationChannel, 
          &(OTemp[SPO]));
      SPO++;
      clear_obj(ho_TargetWeightOrientationOut);
      ho_TargetWeightOrientationOut = OTemp[--SPO];

     }
     destroy_tuple(TTemp[SP--]);
     destroy_tuple(TTemp[SP--]);
     destroy_tuple(TTemp[SP]);
    }
    else
    {
     destroy_tuple(TTemp[SP--]);
     destroy_tuple(TTemp[SP--]);
     destroy_tuple(TTemp[SP--]);
     destroy_tuple(TTemp[SP--]);
     destroy_tuple(TTemp[SP]);
    }/*========== end for ========*/

    /*TargetOrientation := TargetOrientationOut*/
    clear_obj(ho_TargetOrientation);
    copy_obj(ho_TargetOrientationOut,&ho_TargetOrientation,1,-1);

    /*TargetWeightOrientation := TargetWeightOrientationOut*/
    clear_obj(ho_TargetWeightOrientation);
    copy_obj(ho_TargetWeightOrientationOut,&ho_TargetWeightOrientation,1,-1);

  }
  destroy_tuple(TTemp[--SP]);
  /*========== end if ==========*/
  /*Set targets in output sample.*/
  /*set_dict_object (TargetText, DLSampleOriginal, ['target_text'])*/
  create_tuple_s(&TTemp[SP++],"target_text");
  /***/T_set_dict_object(ho_TargetText, hv_DLSampleOriginal, TTemp[SP-1]);
  destroy_tuple(TTemp[--SP]);

  /*set_dict_object (TargetLink, DLSampleOriginal, ['target_link'])*/
  create_tuple_s(&TTemp[SP++],"target_link");
  /***/T_set_dict_object(ho_TargetLink, hv_DLSampleOriginal, TTemp[SP-1]);
  destroy_tuple(TTemp[--SP]);

  /*set_dict_object (TargetOrientation, DLSampleOriginal, ['target_orientation'])*/
  create_tuple_s(&TTemp[SP++],"target_orientation");
  /***/T_set_dict_object(ho_TargetOrientation, hv_DLSampleOriginal, TTemp[SP-1]);
  destroy_tuple(TTemp[--SP]);

  /*set_dict_object (TargetWeightText, DLSampleOriginal, ['target_weight_text'])*/
  create_tuple_s(&TTemp[SP++],"target_weight_text");
  /***/T_set_dict_object(ho_TargetWeightText, hv_DLSampleOriginal, TTemp[SP-1]);
  destroy_tuple(TTemp[--SP]);

  /*set_dict_object (TargetWeightLink, DLSampleOriginal, ['target_weight_link'])*/
  create_tuple_s(&TTemp[SP++],"target_weight_link");
  /***/T_set_dict_object(ho_TargetWeightLink, hv_DLSampleOriginal, TTemp[SP-1]);
  destroy_tuple(TTemp[--SP]);

  /*set_dict_object (TargetWeightOrientation, DLSampleOriginal, ['target_weight_orientation'])*/
  create_tuple_s(&TTemp[SP++],"target_weight_orientation");
  /***/T_set_dict_object(ho_TargetWeightOrientation, hv_DLSampleOriginal, TTemp[SP-1]);
  destroy_tuple(TTemp[--SP]);


  /****************************************************/
  /******************     End procedure   *************/
  /****************************************************/

}

/* Chapter: OCR / Deep OCR*/
/* Short Description: Generate link score map weight for ocr detection training. */
void gen_dl_ocr_detection_weight_link_map (Hobject ho_LinkMap, Hobject ho_TargetWeight, 
    Hobject *ho_TargetWeightLink, Htuple hv_LinkZeroWeightRadius)
{


  /* Stack for temporary tuples */
  Htuple   TTemp[100];
  int      SP=0;
  /* Stack for temporary objects */
  Hobject  OTemp[20] = {0};
  int      SPO=0;
  /* Stack for temporary tuple vectors */
  Hvector  TVTemp[100] = {0};
  int      SPTV=0;

  /* Local iconic variables */
  Hobject  ho_LinkRegion, ho_RegionDilation, ho_RegionComplement;
  Hobject  ho_RegionUnion, ho_RegionBorder;

  /* Local control variables */
  Htuple  hv_Width, hv_Height;

  /* Initialize iconic variables */
  gen_empty_obj(&ho_LinkRegion);
  gen_empty_obj(&ho_RegionDilation);
  gen_empty_obj(&ho_RegionComplement);
  gen_empty_obj(&ho_RegionUnion);
  gen_empty_obj(&ho_RegionBorder);
  gen_empty_obj(&(*ho_TargetWeightLink));

  /* Initialize control variables */
  create_tuple(&hv_Width,0);
  create_tuple(&hv_Height,0);

  /****************************************************/
  /******************   Begin procedure   *************/
  /****************************************************/

  /*========== if (LinkZeroWeightRadius > 0) ==========*/
  create_tuple_i(&TTemp[SP++],0);
  T_tuple_greater(hv_LinkZeroWeightRadius,TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-1]=TTemp[SP];
  if(get_i(TTemp[SP-1],0))
  {
    /*Set zero weight around the link regions.*/
    /*threshold (LinkMap, LinkRegion, 0.01, 'max')*/
    create_tuple_d(&TTemp[SP++],0.01);
    create_tuple_s(&TTemp[SP++],"max");
    clear_obj(ho_LinkRegion);
    /***/T_threshold(ho_LinkMap, &ho_LinkRegion, TTemp[SP-2], TTemp[SP-1]);
    destroy_tuple(TTemp[--SP]);
    destroy_tuple(TTemp[--SP]);

    /*dilation_circle (LinkRegion, RegionDilation, LinkZeroWeightRadius)*/
    clear_obj(ho_RegionDilation);
    /***/T_dilation_circle(ho_LinkRegion, &ho_RegionDilation, hv_LinkZeroWeightRadius);

    /*complement (RegionDilation, RegionComplement)*/
    clear_obj(ho_RegionComplement);
    /***/complement(ho_RegionDilation, &ho_RegionComplement);

    /*get_image_size (TargetWeight, Width, Height)*/
    destroy_tuple(hv_Width);
    destroy_tuple(hv_Height);
    /***/T_get_image_size(ho_TargetWeight, &hv_Width, &hv_Height);

    /*clip_region (RegionComplement, RegionComplement, 0, 0, Height - 1, Width - 1)*/
    create_tuple_i(&TTemp[SP++],0);
    create_tuple_i(&TTemp[SP++],0);
    create_tuple_i(&TTemp[SP++],1);
    T_tuple_sub(hv_Height,TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    create_tuple_i(&TTemp[SP++],1);
    T_tuple_sub(hv_Width,TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    /***/T_clip_region(ho_RegionComplement, &(OTemp[SPO]), TTemp[SP-4], TTemp[SP-3], 
        TTemp[SP-2], TTemp[SP-1]);
    SPO++;
    clear_obj(ho_RegionComplement);
    ho_RegionComplement = OTemp[--SPO];
    destroy_tuple(TTemp[--SP]);
    destroy_tuple(TTemp[--SP]);
    destroy_tuple(TTemp[--SP]);
    destroy_tuple(TTemp[--SP]);

    /*union2 (LinkRegion, RegionComplement, RegionUnion)*/
    clear_obj(ho_RegionUnion);
    /***/union2(ho_LinkRegion, ho_RegionComplement, &ho_RegionUnion);

    /*complement (RegionUnion, RegionBorder)*/
    clear_obj(ho_RegionBorder);
    /***/complement(ho_RegionUnion, &ho_RegionBorder);

    /*paint_region (RegionBorder, TargetWeight, TargetWeightLink, 0, 'fill')*/
    clear_obj((*ho_TargetWeightLink));
    /***/paint_region(ho_RegionBorder, ho_TargetWeight, &(*ho_TargetWeightLink), 
        0, "fill");

  }
  else
  {
    /*Just copy the original weight map.*/
    /*copy_obj (TargetWeight, TargetWeightLink, 1, 1)*/
    clear_obj((*ho_TargetWeightLink));
    /***/copy_obj(ho_TargetWeight, &(*ho_TargetWeightLink), 1, 1);

  }
  destroy_tuple(TTemp[--SP]);
  /*========== end if ==========*/
  /*========== return ==========*/

  /* Clear temporary tuple stack */
  while (SP > 0)
    destroy_tuple(TTemp[--SP]);
  /* Clear temporary tuple vectors stack*/
  while (SPTV > 0)
    V_destroy_vector(TVTemp[--SPTV]);
  /* Clear local iconic variables */
  clear_obj(ho_LinkRegion);
  clear_obj(ho_RegionDilation);
  clear_obj(ho_RegionComplement);
  clear_obj(ho_RegionUnion);
  clear_obj(ho_RegionBorder);

  /* Clear local control variables */
  destroy_tuple(hv_Width);
  destroy_tuple(hv_Height);

  return;

  /****************************************************/
  /******************     End procedure   *************/
  /****************************************************/

}

/* Chapter: OCR / Deep OCR*/
/* Short Description: Generate orientation score map weight for ocr detection training. */
void gen_dl_ocr_detection_weight_orientation_map (Hobject ho_InitialWeight, Hobject *ho_OrientationTargetWeight, 
    Htuple hv_DLSample)
{


  /* Stack for temporary tuples */
  Htuple   TTemp[100];
  int      SP=0;
  /* Stack for temporary objects */
  Hobject  OTemp[20] = {0};
  int      SPO=0;
  /* Stack for temporary tuple vectors */
  Hvector  TVTemp[100] = {0};
  int      SPTV=0;

  /* Local iconic variables */
  Hobject  ho_CharRegions, ho_CharRegion, ho_BackgroundRegion;

  /* Local control variables */
  Htuple  hv_Indices;

  /* Initialize iconic variables */
  gen_empty_obj(&ho_CharRegions);
  gen_empty_obj(&ho_CharRegion);
  gen_empty_obj(&ho_BackgroundRegion);
  gen_empty_obj(&(*ho_OrientationTargetWeight));

  /* Initialize control variables */
  create_tuple(&hv_Indices,0);

  /****************************************************/
  /******************   Begin procedure   *************/
  /****************************************************/

  /*Inside the valid regions, the inital weight is set to the initial weight.*/
  /*copy_image (InitialWeight, OrientationTargetWeight)*/
  clear_obj((*ho_OrientationTargetWeight));
  /***/copy_image(ho_InitialWeight, &(*ho_OrientationTargetWeight));

  /*full_domain (OrientationTargetWeight, OrientationTargetWeight)*/
  /***/full_domain((*ho_OrientationTargetWeight), &(OTemp[SPO]));
  SPO++;
  clear_obj((*ho_OrientationTargetWeight));
  (*ho_OrientationTargetWeight) = OTemp[--SPO];

  /*Set orientation weight to 0 outside the valid regions.*/
  /*========== if (|__get_dict_tuple( DLSample, ['bbox_label_id'])| > 0) ==========*/
  create_tuple_s(&TTemp[SP++],"bbox_label_id");
  T_get_dict_tuple(hv_DLSample,TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-1]=TTemp[SP];
  T_tuple_length(TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-1]=TTemp[SP];
  create_tuple_i(&TTemp[SP++],0);
  T_tuple_greater(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-2]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-2]=TTemp[SP];
  SP--;
  if(get_i(TTemp[SP-1],0))
  {
    /*Process char boxes*/
    /*tuple_find (__get_dict_tuple( DLSample, ['bbox_label_id']), 1, Indices)*/
    create_tuple_s(&TTemp[SP++],"bbox_label_id");
    T_get_dict_tuple(hv_DLSample,TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    create_tuple_i(&TTemp[SP++],1);
    destroy_tuple(hv_Indices);
    /***/T_tuple_find(TTemp[SP-2], TTemp[SP-1], &hv_Indices);
    destroy_tuple(TTemp[--SP]);
    destroy_tuple(TTemp[--SP]);

    /*========== if (Indices != -1) ==========*/
    create_tuple_i(&TTemp[SP++],-1);
    T_tuple_not_equal(hv_Indices,TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    if(get_i(TTemp[SP-1],0))
    {
      /*gen_rectangle2 (CharRegions, __get_dict_tuple( DLSample, ['bbox_row'])[Indices], __get_dict_tuple( DLSample, ['bbox_col'])[Indices], __get_dict_tuple( DLSample, ['bbox_phi'])[Indices], __get_dict_tuple( DLSample, ['bbox_length1'])[Indices], __get_dict_tuple( DLSample, ['bbox_length2'])[Indices])*/
      create_tuple_s(&TTemp[SP++],"bbox_row");
      T_get_dict_tuple(hv_DLSample,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      T_tuple_select(TTemp[SP-1],hv_Indices,&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      create_tuple_s(&TTemp[SP++],"bbox_col");
      T_get_dict_tuple(hv_DLSample,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      T_tuple_select(TTemp[SP-1],hv_Indices,&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      create_tuple_s(&TTemp[SP++],"bbox_phi");
      T_get_dict_tuple(hv_DLSample,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      T_tuple_select(TTemp[SP-1],hv_Indices,&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      create_tuple_s(&TTemp[SP++],"bbox_length1");
      T_get_dict_tuple(hv_DLSample,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      T_tuple_select(TTemp[SP-1],hv_Indices,&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      create_tuple_s(&TTemp[SP++],"bbox_length2");
      T_get_dict_tuple(hv_DLSample,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      T_tuple_select(TTemp[SP-1],hv_Indices,&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      clear_obj(ho_CharRegions);
      /***/T_gen_rectangle2(&ho_CharRegions, TTemp[SP-5], TTemp[SP-4], TTemp[SP-3], 
          TTemp[SP-2], TTemp[SP-1]);
      destroy_tuple(TTemp[--SP]);
      destroy_tuple(TTemp[--SP]);
      destroy_tuple(TTemp[--SP]);
      destroy_tuple(TTemp[--SP]);
      destroy_tuple(TTemp[--SP]);

      /*union1 (CharRegions, CharRegion)*/
      clear_obj(ho_CharRegion);
      /***/union1(ho_CharRegions, &ho_CharRegion);

      /*complement (CharRegion, BackgroundRegion)*/
      clear_obj(ho_BackgroundRegion);
      /***/complement(ho_CharRegion, &ho_BackgroundRegion);

      /*overpaint_region (OrientationTargetWeight, BackgroundRegion, 0, 'fill')*/
      /***/overpaint_region((*ho_OrientationTargetWeight), ho_BackgroundRegion, 0, 
          "fill");

    }
    destroy_tuple(TTemp[--SP]);
    /*========== end if ==========*/
  }
  destroy_tuple(TTemp[--SP]);
  /*========== end if ==========*/
  /*We need two channels: for Sin and Cos*/
  /*compose2 (OrientationTargetWeight, OrientationTargetWeight, OrientationTargetWeight)*/
  /***/compose2((*ho_OrientationTargetWeight), (*ho_OrientationTargetWeight), &(OTemp[SPO])
      );
  SPO++;
  clear_obj((*ho_OrientationTargetWeight));
  (*ho_OrientationTargetWeight) = OTemp[--SPO];

  /*========== return ==========*/

  /* Clear temporary tuple stack */
  while (SP > 0)
    destroy_tuple(TTemp[--SP]);
  /* Clear temporary tuple vectors stack*/
  while (SPTV > 0)
    V_destroy_vector(TVTemp[--SPTV]);
  /* Clear local iconic variables */
  clear_obj(ho_CharRegions);
  clear_obj(ho_CharRegion);
  clear_obj(ho_BackgroundRegion);

  /* Clear local control variables */
  destroy_tuple(hv_Indices);

  return;

  /****************************************************/
  /******************     End procedure   *************/
  /****************************************************/

}

/* Chapter: OCR / Deep OCR*/
/* Short Description: Generate text score map weight for ocr detection training. */
void gen_dl_ocr_detection_weight_score_map (Hobject *ho_TargetWeightText, Htuple hv_ImageWidth, 
    Htuple hv_ImageHeight, Htuple hv_DLSample, Htuple hv_BoxCutoff, Htuple hv_WSWeightRenderThreshold, 
    Htuple hv_Confidence)
{

  /* Stack for temporary tuples */
  Htuple   TTemp[100];
  int      SP=0;
  /* Stack for temporary tuple vectors */
  Hvector  TVTemp[100] = {0};
  int      SPTV=0;

  /* Local iconic variables */
  Hobject  ho_IgnoreRegion, ho_WordRegion, ho_WordRegionDilated;

  /* Local control variables */
  Htuple  hv_Indices, hv_WordIndex, hv_SigmaL2;
  Htuple  hv_WordLength2Ext, hv_DilationRadius;

  /* Initialize iconic variables */
  gen_empty_obj(&ho_IgnoreRegion);
  gen_empty_obj(&ho_WordRegion);
  gen_empty_obj(&ho_WordRegionDilated);
  gen_empty_obj(&(*ho_TargetWeightText));

  /* Initialize control variables */
  create_tuple(&hv_Indices,0);
  create_tuple(&hv_WordIndex,0);
  create_tuple(&hv_SigmaL2,0);
  create_tuple(&hv_WordLength2Ext,0);
  create_tuple(&hv_DilationRadius,0);

  /****************************************************/
  /******************   Begin procedure   *************/
  /****************************************************/

  /*gen_image_const (TargetWeightText, 'real', ImageWidth, ImageHeight)*/
  create_tuple_s(&TTemp[SP++],"real");
  clear_obj((*ho_TargetWeightText));
  /***/T_gen_image_const(&(*ho_TargetWeightText), TTemp[SP-1], hv_ImageWidth, hv_ImageHeight);
  destroy_tuple(TTemp[--SP]);

  /*overpaint_region (TargetWeightText, TargetWeightText, 1.0, 'fill')*/
  /***/overpaint_region((*ho_TargetWeightText), (*ho_TargetWeightText), 1.0, "fill");

  /*========== if (|__get_dict_tuple( DLSample, ['bbox_label_id'])| > 0) ==========*/
  create_tuple_s(&TTemp[SP++],"bbox_label_id");
  T_get_dict_tuple(hv_DLSample,TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-1]=TTemp[SP];
  T_tuple_length(TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-1]=TTemp[SP];
  create_tuple_i(&TTemp[SP++],0);
  T_tuple_greater(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-2]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-2]=TTemp[SP];
  SP--;
  if(get_i(TTemp[SP-1],0))
  {
    /*Process ignore boxes*/
    /*tuple_find (__get_dict_tuple( DLSample, ['bbox_label_id']), 2, Indices)*/
    create_tuple_s(&TTemp[SP++],"bbox_label_id");
    T_get_dict_tuple(hv_DLSample,TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    create_tuple_i(&TTemp[SP++],2);
    destroy_tuple(hv_Indices);
    /***/T_tuple_find(TTemp[SP-2], TTemp[SP-1], &hv_Indices);
    destroy_tuple(TTemp[--SP]);
    destroy_tuple(TTemp[--SP]);

    /*========== if (Indices != -1) ==========*/
    create_tuple_i(&TTemp[SP++],-1);
    T_tuple_not_equal(hv_Indices,TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    if(get_i(TTemp[SP-1],0))
    {
      /*gen_rectangle2 (IgnoreRegion, __get_dict_tuple( DLSample, ['bbox_row'])[Indices], __get_dict_tuple( DLSample, ['bbox_col'])[Indices], __get_dict_tuple( DLSample, ['bbox_phi'])[Indices], __get_dict_tuple( DLSample, ['bbox_length1'])[Indices], __get_dict_tuple( DLSample, ['bbox_length2'])[Indices])*/
      create_tuple_s(&TTemp[SP++],"bbox_row");
      T_get_dict_tuple(hv_DLSample,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      T_tuple_select(TTemp[SP-1],hv_Indices,&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      create_tuple_s(&TTemp[SP++],"bbox_col");
      T_get_dict_tuple(hv_DLSample,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      T_tuple_select(TTemp[SP-1],hv_Indices,&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      create_tuple_s(&TTemp[SP++],"bbox_phi");
      T_get_dict_tuple(hv_DLSample,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      T_tuple_select(TTemp[SP-1],hv_Indices,&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      create_tuple_s(&TTemp[SP++],"bbox_length1");
      T_get_dict_tuple(hv_DLSample,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      T_tuple_select(TTemp[SP-1],hv_Indices,&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      create_tuple_s(&TTemp[SP++],"bbox_length2");
      T_get_dict_tuple(hv_DLSample,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      T_tuple_select(TTemp[SP-1],hv_Indices,&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      clear_obj(ho_IgnoreRegion);
      /***/T_gen_rectangle2(&ho_IgnoreRegion, TTemp[SP-5], TTemp[SP-4], TTemp[SP-3], 
          TTemp[SP-2], TTemp[SP-1]);
      destroy_tuple(TTemp[--SP]);
      destroy_tuple(TTemp[--SP]);
      destroy_tuple(TTemp[--SP]);
      destroy_tuple(TTemp[--SP]);
      destroy_tuple(TTemp[--SP]);

      /*overpaint_region (TargetWeightText, IgnoreRegion, 0.0, 'fill')*/
      /***/overpaint_region((*ho_TargetWeightText), ho_IgnoreRegion, 0.0, "fill");

    }
    destroy_tuple(TTemp[--SP]);
    /*========== end if ==========*/
    /*========== for WordIndex := 0 to |__get_dict_tuple( DLSample, ['bbox_label_id'])| - 1 by 1 ==========*/
    create_tuple_s(&TTemp[SP++],"bbox_label_id");
    T_get_dict_tuple(hv_DLSample,TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    T_tuple_length(TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    create_tuple_i(&TTemp[SP++],1);
    T_tuple_sub(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-2]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-2]=TTemp[SP];
    SP--;
    create_tuple_i(&TTemp[SP++],1);
    create_tuple_i(&TTemp[SP++],0);
    T_tuple_greater(TTemp[SP-1],TTemp[SP-3],&TTemp[SP]);
    SP++;
    T_tuple_equal(TTemp[SP-2],TTemp[SP-4],&TTemp[SP]);
    if(get_i(TTemp[SP],0) ||
       (!((( get_i(TTemp[SP-1],0)) && (get_d(TTemp[SP-3],0)>0)) ||
          ((!get_i(TTemp[SP-1],0)) && (get_d(TTemp[SP-3],0)<0)))))
    {
     destroy_tuple(TTemp[SP--]);
     destroy_tuple(TTemp[SP]);
     T_tuple_sub(TTemp[SP-1],TTemp[SP-2],&TTemp[SP]);
     destroy_tuple(hv_WordIndex);
     copy_tuple(TTemp[SP],&hv_WordIndex);
     destroy_tuple(TTemp[SP--]);
     destroy_tuple(TTemp[SP]);
     for(;;)
     {
     T_tuple_add(hv_WordIndex,TTemp[SP-1],&TTemp[SP]);
     destroy_tuple(hv_WordIndex);
     copy_tuple(TTemp[SP],&hv_WordIndex);
     destroy_tuple(TTemp[SP]);
     if(get_d(TTemp[SP-1],0)<0)
      T_tuple_less(hv_WordIndex,TTemp[SP-2],&TTemp[SP]);
     else
      T_tuple_greater(hv_WordIndex,TTemp[SP-2],&TTemp[SP]);
     if(get_i(TTemp[SP],0)) break;
     destroy_tuple(TTemp[SP]);
     /*========== for ==========*/

      /*For each word box*/
      /*========== if (__get_dict_tuple( DLSample, ['bbox_label_id'])[WordIndex] == 0) ==========*/
      create_tuple_s(&TTemp[SP++],"bbox_label_id");
      T_get_dict_tuple(hv_DLSample,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      T_tuple_select(TTemp[SP-1],hv_WordIndex,&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      create_tuple_i(&TTemp[SP++],0);
      T_tuple_equal(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-2]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-2]=TTemp[SP];
      SP--;
      if(get_i(TTemp[SP-1],0))
      {
        /*========== if (not (BoxCutoff == 0 or WSWeightRenderThreshold == 0)) ==========*/
        create_tuple_i(&TTemp[SP++],0);
        T_tuple_equal(hv_BoxCutoff,TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-1]=TTemp[SP];
        create_tuple_i(&TTemp[SP++],0);
        T_tuple_equal(hv_WSWeightRenderThreshold,TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-1]=TTemp[SP];
        T_tuple_or(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-2]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-2]=TTemp[SP];
        SP--;
        T_tuple_not(TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-1]=TTemp[SP];
        if(get_i(TTemp[SP-1],0))
        {
          /*SigmaL2 := __get_dict_tuple( DLSample, ['bbox_length2'])[WordIndex] * sqrt(-0.5 / log(BoxCutoff))*/
          create_tuple_s(&TTemp[SP++],"bbox_length2");
          T_get_dict_tuple(hv_DLSample,TTemp[SP-1],&TTemp[SP]);
          destroy_tuple(TTemp[SP-1]);
          TTemp[SP-1]=TTemp[SP];
          T_tuple_select(TTemp[SP-1],hv_WordIndex,&TTemp[SP]);
          destroy_tuple(TTemp[SP-1]);
          TTemp[SP-1]=TTemp[SP];
          create_tuple_d(&TTemp[SP++],-0.5);
          T_tuple_log(hv_BoxCutoff,&TTemp[SP++]);
          T_tuple_div(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
          destroy_tuple(TTemp[SP-2]);
          destroy_tuple(TTemp[SP-1]);
          TTemp[SP-2]=TTemp[SP];
          SP--;
          T_tuple_sqrt(TTemp[SP-1],&TTemp[SP]);
          destroy_tuple(TTemp[SP-1]);
          TTemp[SP-1]=TTemp[SP];
          T_tuple_mult(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
          destroy_tuple(TTemp[SP-2]);
          destroy_tuple(TTemp[SP-1]);
          TTemp[SP-2]=TTemp[SP];
          SP--;
          destroy_tuple(hv_SigmaL2);
          hv_SigmaL2=TTemp[--SP];

          /*WordLength2Ext := SigmaL2 * sqrt(-2 * log(WSWeightRenderThreshold))*/
          create_tuple_i(&TTemp[SP++],-2);
          T_tuple_log(hv_WSWeightRenderThreshold,&TTemp[SP++]);
          T_tuple_mult(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
          destroy_tuple(TTemp[SP-2]);
          destroy_tuple(TTemp[SP-1]);
          TTemp[SP-2]=TTemp[SP];
          SP--;
          T_tuple_sqrt(TTemp[SP-1],&TTemp[SP]);
          destroy_tuple(TTemp[SP-1]);
          TTemp[SP-1]=TTemp[SP];
          T_tuple_mult(hv_SigmaL2,TTemp[SP-1],&TTemp[SP]);
          destroy_tuple(TTemp[SP-1]);
          TTemp[SP-1]=TTemp[SP];
          destroy_tuple(hv_WordLength2Ext);
          hv_WordLength2Ext=TTemp[--SP];

          /*DilationRadius := WordLength2Ext - __get_dict_tuple( DLSample, ['bbox_length2'])[WordIndex]*/
          create_tuple_s(&TTemp[SP++],"bbox_length2");
          T_get_dict_tuple(hv_DLSample,TTemp[SP-1],&TTemp[SP]);
          destroy_tuple(TTemp[SP-1]);
          TTemp[SP-1]=TTemp[SP];
          T_tuple_select(TTemp[SP-1],hv_WordIndex,&TTemp[SP]);
          destroy_tuple(TTemp[SP-1]);
          TTemp[SP-1]=TTemp[SP];
          T_tuple_sub(hv_WordLength2Ext,TTemp[SP-1],&TTemp[SP]);
          destroy_tuple(TTemp[SP-1]);
          TTemp[SP-1]=TTemp[SP];
          destroy_tuple(hv_DilationRadius);
          hv_DilationRadius=TTemp[--SP];

        }
        else
        {
          /*DilationRadius := 0*/
          reuse_tuple_i(&hv_DilationRadius,0);

        }
        destroy_tuple(TTemp[--SP]);
        /*========== end if ==========*/
        /*gen_rectangle2 (WordRegion, __get_dict_tuple( DLSample, ['bbox_row'])[WordIndex], __get_dict_tuple( DLSample, ['bbox_col'])[WordIndex], __get_dict_tuple( DLSample, ['bbox_phi'])[WordIndex], __get_dict_tuple( DLSample, ['bbox_length1'])[WordIndex], __get_dict_tuple( DLSample, ['bbox_length2'])[WordIndex])*/
        create_tuple_s(&TTemp[SP++],"bbox_row");
        T_get_dict_tuple(hv_DLSample,TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-1]=TTemp[SP];
        T_tuple_select(TTemp[SP-1],hv_WordIndex,&TTemp[SP]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-1]=TTemp[SP];
        create_tuple_s(&TTemp[SP++],"bbox_col");
        T_get_dict_tuple(hv_DLSample,TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-1]=TTemp[SP];
        T_tuple_select(TTemp[SP-1],hv_WordIndex,&TTemp[SP]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-1]=TTemp[SP];
        create_tuple_s(&TTemp[SP++],"bbox_phi");
        T_get_dict_tuple(hv_DLSample,TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-1]=TTemp[SP];
        T_tuple_select(TTemp[SP-1],hv_WordIndex,&TTemp[SP]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-1]=TTemp[SP];
        create_tuple_s(&TTemp[SP++],"bbox_length1");
        T_get_dict_tuple(hv_DLSample,TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-1]=TTemp[SP];
        T_tuple_select(TTemp[SP-1],hv_WordIndex,&TTemp[SP]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-1]=TTemp[SP];
        create_tuple_s(&TTemp[SP++],"bbox_length2");
        T_get_dict_tuple(hv_DLSample,TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-1]=TTemp[SP];
        T_tuple_select(TTemp[SP-1],hv_WordIndex,&TTemp[SP]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-1]=TTemp[SP];
        clear_obj(ho_WordRegion);
        /***/T_gen_rectangle2(&ho_WordRegion, TTemp[SP-5], TTemp[SP-4], TTemp[SP-3], 
            TTemp[SP-2], TTemp[SP-1]);
        destroy_tuple(TTemp[--SP]);
        destroy_tuple(TTemp[--SP]);
        destroy_tuple(TTemp[--SP]);
        destroy_tuple(TTemp[--SP]);
        destroy_tuple(TTemp[--SP]);

        /*Slightly enlarge the weight region to suppress halos at the box borders.*/
        /*========== if (DilationRadius >= 0.5) ==========*/
        create_tuple_d(&TTemp[SP++],0.5);
        T_tuple_greater_equal(hv_DilationRadius,TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-1]=TTemp[SP];
        if(get_i(TTemp[SP-1],0))
        {
          /*dilation_circle (WordRegion, WordRegionDilated, DilationRadius)*/
          clear_obj(ho_WordRegionDilated);
          /***/T_dilation_circle(ho_WordRegion, &ho_WordRegionDilated, hv_DilationRadius);

        }
        else
        {
          /*WordRegionDilated := WordRegion*/
          clear_obj(ho_WordRegionDilated);
          copy_obj(ho_WordRegion,&ho_WordRegionDilated,1,-1);

        }
        destroy_tuple(TTemp[--SP]);
        /*========== end if ==========*/
        /*Set the confidence as weight for the word region.*/
        /*overpaint_region (TargetWeightText, WordRegionDilated, Confidence, 'fill')*/
        create_tuple_s(&TTemp[SP++],"fill");
        /***/T_overpaint_region((*ho_TargetWeightText), ho_WordRegionDilated, hv_Confidence, 
            TTemp[SP-1]);
        destroy_tuple(TTemp[--SP]);

      }
      destroy_tuple(TTemp[--SP]);
      /*========== end if ==========*/
     }
     destroy_tuple(TTemp[SP--]);
     destroy_tuple(TTemp[SP--]);
     destroy_tuple(TTemp[SP]);
    }
    else
    {
     destroy_tuple(TTemp[SP--]);
     destroy_tuple(TTemp[SP--]);
     destroy_tuple(TTemp[SP--]);
     destroy_tuple(TTemp[SP--]);
     destroy_tuple(TTemp[SP]);
    }/*========== end for ========*/

  }
  destroy_tuple(TTemp[--SP]);
  /*========== end if ==========*/
  /*========== return ==========*/

  /* Clear temporary tuple stack */
  while (SP > 0)
    destroy_tuple(TTemp[--SP]);
  /* Clear temporary tuple vectors stack*/
  while (SPTV > 0)
    V_destroy_vector(TVTemp[--SPTV]);
  /* Clear local iconic variables */
  clear_obj(ho_IgnoreRegion);
  clear_obj(ho_WordRegion);
  clear_obj(ho_WordRegionDilated);

  /* Clear local control variables */
  destroy_tuple(hv_Indices);
  destroy_tuple(hv_WordIndex);
  destroy_tuple(hv_SigmaL2);
  destroy_tuple(hv_WordLength2Ext);
  destroy_tuple(hv_DilationRadius);

  return;

  /****************************************************/
  /******************     End procedure   *************/
  /****************************************************/

}

/* Chapter: Deep Learning / Model*/
/* Short Description: Store the given images in a tuple of dictionaries DLSamples. */
void gen_dl_samples_from_images (Hobject ho_Images, Htuple *hv_DLSampleBatch)
{

  /* Stack for temporary tuples */
  Htuple   TTemp[100];
  int      SP=0;
  /* Stack for temporary tuple vectors */
  Hvector  TVTemp[100] = {0};
  int      SPTV=0;

  /* Local iconic variables */
  Hobject  ho_Image;

  /* Local control variables */
  Htuple  hv_NumImages, hv_ImageIndex, hv_DLSample;

  /* Initialize iconic variables */
  gen_empty_obj(&ho_Image);

  /* Initialize control variables */
  create_tuple(&hv_NumImages,0);
  create_tuple(&hv_ImageIndex,0);
  create_tuple(&hv_DLSample,0);
  create_tuple(&(*hv_DLSampleBatch),0);

  /****************************************************/
  /******************   Begin procedure   *************/
  /****************************************************/

  /**/
  /*This procedure creates DLSampleBatch, a tuple*/
  /*containing a dictionary DLSample*/
  /*for every image given in Images.*/
  /**/
  /*Initialize output tuple.*/
  /*count_obj (Images, NumImages)*/
  destroy_tuple(hv_NumImages);
  /***/T_count_obj(ho_Images, &hv_NumImages);

  /*DLSampleBatch := gen_tuple_const(NumImages,-1)*/
  create_tuple_i(&TTemp[SP++],-1);
  T_tuple_gen_const(hv_NumImages,TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-1]=TTemp[SP];
  destroy_tuple((*hv_DLSampleBatch));
  (*hv_DLSampleBatch)=TTemp[--SP];

  /**/
  /*Loop through all given images.*/
  /*========== for ImageIndex := 0 to NumImages - 1 by 1 ==========*/
  create_tuple_i(&TTemp[SP++],1);
  T_tuple_sub(hv_NumImages,TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-1]=TTemp[SP];
  create_tuple_i(&TTemp[SP++],1);
  create_tuple_i(&TTemp[SP++],0);
  T_tuple_greater(TTemp[SP-1],TTemp[SP-3],&TTemp[SP]);
  SP++;
  T_tuple_equal(TTemp[SP-2],TTemp[SP-4],&TTemp[SP]);
  if(get_i(TTemp[SP],0) ||
     (!((( get_i(TTemp[SP-1],0)) && (get_d(TTemp[SP-3],0)>0)) ||
        ((!get_i(TTemp[SP-1],0)) && (get_d(TTemp[SP-3],0)<0)))))
  {
   destroy_tuple(TTemp[SP--]);
   destroy_tuple(TTemp[SP]);
   T_tuple_sub(TTemp[SP-1],TTemp[SP-2],&TTemp[SP]);
   destroy_tuple(hv_ImageIndex);
   copy_tuple(TTemp[SP],&hv_ImageIndex);
   destroy_tuple(TTemp[SP--]);
   destroy_tuple(TTemp[SP]);
   for(;;)
   {
   T_tuple_add(hv_ImageIndex,TTemp[SP-1],&TTemp[SP]);
   destroy_tuple(hv_ImageIndex);
   copy_tuple(TTemp[SP],&hv_ImageIndex);
   destroy_tuple(TTemp[SP]);
   if(get_d(TTemp[SP-1],0)<0)
    T_tuple_less(hv_ImageIndex,TTemp[SP-2],&TTemp[SP]);
   else
    T_tuple_greater(hv_ImageIndex,TTemp[SP-2],&TTemp[SP]);
   if(get_i(TTemp[SP],0)) break;
   destroy_tuple(TTemp[SP]);
   /*========== for ==========*/

    /*select_obj (Images, Image, ImageIndex + 1)*/
    create_tuple_i(&TTemp[SP++],1);
    T_tuple_add(hv_ImageIndex,TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    clear_obj(ho_Image);
    /***/T_select_obj(ho_Images, &ho_Image, TTemp[SP-1]);
    destroy_tuple(TTemp[--SP]);

    /*Create DLSample from image.*/
    /*create_dict (DLSample)*/
    destroy_tuple(hv_DLSample);
    /***/T_create_dict(&hv_DLSample);

    /*set_dict_object (Image, DLSample, 'image')*/
    create_tuple_s(&TTemp[SP++],"image");
    /***/T_set_dict_object(ho_Image, hv_DLSample, TTemp[SP-1]);
    destroy_tuple(TTemp[--SP]);

    /**/
    /*Collect the DLSamples.*/
    /*DLSampleBatch[ImageIndex] := DLSample*/
    replace_elements(&(*hv_DLSampleBatch),&hv_ImageIndex,&hv_DLSample);
   }
   destroy_tuple(TTemp[SP--]);
   destroy_tuple(TTemp[SP--]);
   destroy_tuple(TTemp[SP]);
  }
  else
  {
   destroy_tuple(TTemp[SP--]);
   destroy_tuple(TTemp[SP--]);
   destroy_tuple(TTemp[SP--]);
   destroy_tuple(TTemp[SP--]);
   destroy_tuple(TTemp[SP]);
  }/*========== end for ========*/

  /*========== return ==========*/

  /* Clear temporary tuple stack */
  while (SP > 0)
    destroy_tuple(TTemp[--SP]);
  /* Clear temporary tuple vectors stack*/
  while (SPTV > 0)
    V_destroy_vector(TVTemp[--SPTV]);
  /* Clear local iconic variables */
  clear_obj(ho_Image);

  /* Clear local control variables */
  destroy_tuple(hv_NumImages);
  destroy_tuple(hv_ImageIndex);
  destroy_tuple(hv_DLSample);

  return;

  /****************************************************/
  /******************     End procedure   *************/
  /****************************************************/

}

/* Chapter: OCR / Deep OCR*/
/* Short Description: Generate a word to characters mapping. */
void gen_words_chars_mapping (Htuple hv_DLSample, Hvector/*{eTupleVector,Dim=1}*/ *hvec_WordsCharsMapping)
{

  /* Stack for temporary tuples */
  Htuple   TTemp[100];
  int      SP=0;
  /* Stack for temporary tuple vectors */
  Hvector  TVTemp[100] = {0};
  int      SPTV=0;

  /* Local iconic variables */

  /* Local control variables */
  Htuple  hv_WordsIndices, hv_CharsIndices, hv_WordLengths;
  Htuple  hv_WordArea, hv_CharArea, hv_CharAreaThreshold;
  Htuple  hv_WordIndex, hv_AreaIntersection, hv_CIsInsideW;
  Htuple  hv_CIndex;

  /* Initialize control variables */
  create_tuple(&hv_WordsIndices,0);
  create_tuple(&hv_CharsIndices,0);
  create_tuple(&hv_WordLengths,0);
  create_tuple(&hv_WordArea,0);
  create_tuple(&hv_CharArea,0);
  create_tuple(&hv_CharAreaThreshold,0);
  create_tuple(&hv_WordIndex,0);
  create_tuple(&hv_AreaIntersection,0);
  create_tuple(&hv_CIsInsideW,0);
  create_tuple(&hv_CIndex,0);
  V_create_tuple_vector(1,&(*hvec_WordsCharsMapping));

  /****************************************************/
  /******************   Begin procedure   *************/
  /****************************************************/

  /*Procedure to generate the mapping: gen_words_chars_mapping*/
  /*========== if (|__get_dict_tuple( DLSample, ['bbox_label_id'])| > 0) ==========*/
  create_tuple_s(&TTemp[SP++],"bbox_label_id");
  T_get_dict_tuple(hv_DLSample,TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-1]=TTemp[SP];
  T_tuple_length(TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-1]=TTemp[SP];
  create_tuple_i(&TTemp[SP++],0);
  T_tuple_greater(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-2]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-2]=TTemp[SP];
  SP--;
  if(get_i(TTemp[SP-1],0))
  {
    /*tuple_find (__get_dict_tuple( DLSample, ['bbox_label_id']), 0, WordsIndices)*/
    create_tuple_s(&TTemp[SP++],"bbox_label_id");
    T_get_dict_tuple(hv_DLSample,TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    create_tuple_i(&TTemp[SP++],0);
    destroy_tuple(hv_WordsIndices);
    /***/T_tuple_find(TTemp[SP-2], TTemp[SP-1], &hv_WordsIndices);
    destroy_tuple(TTemp[--SP]);
    destroy_tuple(TTemp[--SP]);

    /*tuple_find (__get_dict_tuple( DLSample, ['bbox_label_id']), 1, CharsIndices)*/
    create_tuple_s(&TTemp[SP++],"bbox_label_id");
    T_get_dict_tuple(hv_DLSample,TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    create_tuple_i(&TTemp[SP++],1);
    destroy_tuple(hv_CharsIndices);
    /***/T_tuple_find(TTemp[SP-2], TTemp[SP-1], &hv_CharsIndices);
    destroy_tuple(TTemp[--SP]);
    destroy_tuple(TTemp[--SP]);

    /*========== if (CharsIndices != -1 and WordsIndices != -1) ==========*/
    create_tuple_i(&TTemp[SP++],-1);
    T_tuple_not_equal(hv_CharsIndices,TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    create_tuple_i(&TTemp[SP++],-1);
    T_tuple_not_equal(hv_WordsIndices,TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    T_tuple_and(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-2]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-2]=TTemp[SP];
    SP--;
    if(get_i(TTemp[SP-1],0))
    {
      /*WordLengths := strlen(__get_dict_tuple( DLSample, ['word'])[WordsIndices])*/
      create_tuple_s(&TTemp[SP++],"word");
      T_get_dict_tuple(hv_DLSample,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      T_tuple_select(TTemp[SP-1],hv_WordsIndices,&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      T_tuple_strlen(TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      destroy_tuple(hv_WordLengths);
      hv_WordLengths=TTemp[--SP];

      /*Init vector.*/
      /*WordsCharsMapping.at(|__get_dict_tuple( DLSample, ['bbox_label_id'])|-1) := []*/
      create_tuple(&TTemp[SP++],0);
      create_tuple(&TTemp[SP++],1);
      create_tuple_s(&TTemp[SP++],"bbox_label_id");
      T_get_dict_tuple(hv_DLSample,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      T_tuple_length(TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      create_tuple_i(&TTemp[SP++],1);
      T_tuple_sub(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-2]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-2]=TTemp[SP];
      SP--;
      set_i(TTemp[SP-2],get_i(TTemp[SP-1],0),0);
      destroy_tuple(TTemp[--SP]);
      V_set_vector_tuple((*hvec_WordsCharsMapping),TTemp[SP-1],TTemp[SP-2]);
      destroy_tuple(TTemp[--SP]);
      destroy_tuple(TTemp[--SP]);
      /*WordArea := 4 * __get_dict_tuple( DLSample, ['bbox_length1'])[WordsIndices] * __get_dict_tuple( DLSample, ['bbox_length2'])[WordsIndices]*/
      create_tuple_i(&TTemp[SP++],4);
      create_tuple_s(&TTemp[SP++],"bbox_length1");
      T_get_dict_tuple(hv_DLSample,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      T_tuple_select(TTemp[SP-1],hv_WordsIndices,&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      T_tuple_mult(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-2]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-2]=TTemp[SP];
      SP--;
      create_tuple_s(&TTemp[SP++],"bbox_length2");
      T_get_dict_tuple(hv_DLSample,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      T_tuple_select(TTemp[SP-1],hv_WordsIndices,&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      T_tuple_mult(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-2]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-2]=TTemp[SP];
      SP--;
      destroy_tuple(hv_WordArea);
      hv_WordArea=TTemp[--SP];

      /*CharArea := 4 * __get_dict_tuple( DLSample, ['bbox_length1'])[CharsIndices] * __get_dict_tuple( DLSample, ['bbox_length2'])[CharsIndices]*/
      create_tuple_i(&TTemp[SP++],4);
      create_tuple_s(&TTemp[SP++],"bbox_length1");
      T_get_dict_tuple(hv_DLSample,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      T_tuple_select(TTemp[SP-1],hv_CharsIndices,&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      T_tuple_mult(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-2]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-2]=TTemp[SP];
      SP--;
      create_tuple_s(&TTemp[SP++],"bbox_length2");
      T_get_dict_tuple(hv_DLSample,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      T_tuple_select(TTemp[SP-1],hv_CharsIndices,&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      T_tuple_mult(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-2]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-2]=TTemp[SP];
      SP--;
      destroy_tuple(hv_CharArea);
      hv_CharArea=TTemp[--SP];

      /*TODO: This threshold is quite arbitrary and not stable.*/
      /*CharAreaThreshold := CharArea * 0.8*/
      create_tuple_d(&TTemp[SP++],0.8);
      T_tuple_mult(hv_CharArea,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      destroy_tuple(hv_CharAreaThreshold);
      hv_CharAreaThreshold=TTemp[--SP];

      /*========== for WordIndex := 0 to |WordsIndices| - 1 by 1 ==========*/
      T_tuple_length(hv_WordsIndices,&TTemp[SP++]);
      create_tuple_i(&TTemp[SP++],1);
      T_tuple_sub(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-2]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-2]=TTemp[SP];
      SP--;
      create_tuple_i(&TTemp[SP++],1);
      create_tuple_i(&TTemp[SP++],0);
      T_tuple_greater(TTemp[SP-1],TTemp[SP-3],&TTemp[SP]);
      SP++;
      T_tuple_equal(TTemp[SP-2],TTemp[SP-4],&TTemp[SP]);
      if(get_i(TTemp[SP],0) ||
         (!((( get_i(TTemp[SP-1],0)) && (get_d(TTemp[SP-3],0)>0)) ||
            ((!get_i(TTemp[SP-1],0)) && (get_d(TTemp[SP-3],0)<0)))))
      {
       destroy_tuple(TTemp[SP--]);
       destroy_tuple(TTemp[SP]);
       T_tuple_sub(TTemp[SP-1],TTemp[SP-2],&TTemp[SP]);
       destroy_tuple(hv_WordIndex);
       copy_tuple(TTemp[SP],&hv_WordIndex);
       destroy_tuple(TTemp[SP--]);
       destroy_tuple(TTemp[SP]);
       for(;;)
       {
       T_tuple_add(hv_WordIndex,TTemp[SP-1],&TTemp[SP]);
       destroy_tuple(hv_WordIndex);
       copy_tuple(TTemp[SP],&hv_WordIndex);
       destroy_tuple(TTemp[SP]);
       if(get_d(TTemp[SP-1],0)<0)
        T_tuple_less(hv_WordIndex,TTemp[SP-2],&TTemp[SP]);
       else
        T_tuple_greater(hv_WordIndex,TTemp[SP-2],&TTemp[SP]);
       if(get_i(TTemp[SP],0)) break;
       destroy_tuple(TTemp[SP]);
       /*========== for ==========*/

        /*========== if (WordLengths[WordIndex] != 0) ==========*/
        T_tuple_select(hv_WordLengths,hv_WordIndex,&TTemp[SP++]);
        create_tuple_i(&TTemp[SP++],0);
        T_tuple_not_equal(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-2]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-2]=TTemp[SP];
        SP--;
        if(get_i(TTemp[SP-1],0))
        {
          /*area_intersection_rectangle2 (__get_dict_tuple( DLSample, ['bbox_row'])[WordsIndices[WordIndex]], __get_dict_tuple( DLSample, ['bbox_col'])[WordsIndices[WordIndex]], __get_dict_tuple( DLSample, ['bbox_phi'])[WordsIndices[WordIndex]], __get_dict_tuple( DLSample, ['bbox_length1'])[WordsIndices[WordIndex]], __get_dict_tuple( DLSample, ['bbox_length2'])[WordsIndices[WordIndex]], __get_dict_tuple( DLSample, ['bbox_row'])[CharsIndices], __get_dict_tuple( DLSample, ['bbox_col'])[CharsIndices], __get_dict_tuple( DLSample, ['bbox_phi'])[CharsIndices], __get_dict_tuple( DLSample, ['bbox_length1'])[CharsIndices], __get_dict_tuple( DLSample, ['bbox_length2'])[CharsIndices], AreaIntersection)*/
          create_tuple_s(&TTemp[SP++],"bbox_row");
          T_get_dict_tuple(hv_DLSample,TTemp[SP-1],&TTemp[SP]);
          destroy_tuple(TTemp[SP-1]);
          TTemp[SP-1]=TTemp[SP];
          T_tuple_select(hv_WordsIndices,hv_WordIndex,&TTemp[SP++]);
          T_tuple_select(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
          destroy_tuple(TTemp[SP-2]);
          destroy_tuple(TTemp[SP-1]);
          TTemp[SP-2]=TTemp[SP];
          SP--;
          create_tuple_s(&TTemp[SP++],"bbox_col");
          T_get_dict_tuple(hv_DLSample,TTemp[SP-1],&TTemp[SP]);
          destroy_tuple(TTemp[SP-1]);
          TTemp[SP-1]=TTemp[SP];
          T_tuple_select(hv_WordsIndices,hv_WordIndex,&TTemp[SP++]);
          T_tuple_select(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
          destroy_tuple(TTemp[SP-2]);
          destroy_tuple(TTemp[SP-1]);
          TTemp[SP-2]=TTemp[SP];
          SP--;
          create_tuple_s(&TTemp[SP++],"bbox_phi");
          T_get_dict_tuple(hv_DLSample,TTemp[SP-1],&TTemp[SP]);
          destroy_tuple(TTemp[SP-1]);
          TTemp[SP-1]=TTemp[SP];
          T_tuple_select(hv_WordsIndices,hv_WordIndex,&TTemp[SP++]);
          T_tuple_select(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
          destroy_tuple(TTemp[SP-2]);
          destroy_tuple(TTemp[SP-1]);
          TTemp[SP-2]=TTemp[SP];
          SP--;
          create_tuple_s(&TTemp[SP++],"bbox_length1");
          T_get_dict_tuple(hv_DLSample,TTemp[SP-1],&TTemp[SP]);
          destroy_tuple(TTemp[SP-1]);
          TTemp[SP-1]=TTemp[SP];
          T_tuple_select(hv_WordsIndices,hv_WordIndex,&TTemp[SP++]);
          T_tuple_select(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
          destroy_tuple(TTemp[SP-2]);
          destroy_tuple(TTemp[SP-1]);
          TTemp[SP-2]=TTemp[SP];
          SP--;
          create_tuple_s(&TTemp[SP++],"bbox_length2");
          T_get_dict_tuple(hv_DLSample,TTemp[SP-1],&TTemp[SP]);
          destroy_tuple(TTemp[SP-1]);
          TTemp[SP-1]=TTemp[SP];
          T_tuple_select(hv_WordsIndices,hv_WordIndex,&TTemp[SP++]);
          T_tuple_select(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
          destroy_tuple(TTemp[SP-2]);
          destroy_tuple(TTemp[SP-1]);
          TTemp[SP-2]=TTemp[SP];
          SP--;
          create_tuple_s(&TTemp[SP++],"bbox_row");
          T_get_dict_tuple(hv_DLSample,TTemp[SP-1],&TTemp[SP]);
          destroy_tuple(TTemp[SP-1]);
          TTemp[SP-1]=TTemp[SP];
          T_tuple_select(TTemp[SP-1],hv_CharsIndices,&TTemp[SP]);
          destroy_tuple(TTemp[SP-1]);
          TTemp[SP-1]=TTemp[SP];
          create_tuple_s(&TTemp[SP++],"bbox_col");
          T_get_dict_tuple(hv_DLSample,TTemp[SP-1],&TTemp[SP]);
          destroy_tuple(TTemp[SP-1]);
          TTemp[SP-1]=TTemp[SP];
          T_tuple_select(TTemp[SP-1],hv_CharsIndices,&TTemp[SP]);
          destroy_tuple(TTemp[SP-1]);
          TTemp[SP-1]=TTemp[SP];
          create_tuple_s(&TTemp[SP++],"bbox_phi");
          T_get_dict_tuple(hv_DLSample,TTemp[SP-1],&TTemp[SP]);
          destroy_tuple(TTemp[SP-1]);
          TTemp[SP-1]=TTemp[SP];
          T_tuple_select(TTemp[SP-1],hv_CharsIndices,&TTemp[SP]);
          destroy_tuple(TTemp[SP-1]);
          TTemp[SP-1]=TTemp[SP];
          create_tuple_s(&TTemp[SP++],"bbox_length1");
          T_get_dict_tuple(hv_DLSample,TTemp[SP-1],&TTemp[SP]);
          destroy_tuple(TTemp[SP-1]);
          TTemp[SP-1]=TTemp[SP];
          T_tuple_select(TTemp[SP-1],hv_CharsIndices,&TTemp[SP]);
          destroy_tuple(TTemp[SP-1]);
          TTemp[SP-1]=TTemp[SP];
          create_tuple_s(&TTemp[SP++],"bbox_length2");
          T_get_dict_tuple(hv_DLSample,TTemp[SP-1],&TTemp[SP]);
          destroy_tuple(TTemp[SP-1]);
          TTemp[SP-1]=TTemp[SP];
          T_tuple_select(TTemp[SP-1],hv_CharsIndices,&TTemp[SP]);
          destroy_tuple(TTemp[SP-1]);
          TTemp[SP-1]=TTemp[SP];
          destroy_tuple(hv_AreaIntersection);
          /***/T_area_intersection_rectangle2(TTemp[SP-10], TTemp[SP-9], TTemp[SP-8], 
              TTemp[SP-7], TTemp[SP-6], TTemp[SP-5], TTemp[SP-4], TTemp[SP-3], TTemp[SP-2], 
              TTemp[SP-1], &hv_AreaIntersection);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(TTemp[--SP]);

          /*CIsInsideW := AreaIntersection [>] CharAreaThreshold*/
          T_tuple_greater_elem(hv_AreaIntersection,hv_CharAreaThreshold,&TTemp[SP++]);
          destroy_tuple(hv_CIsInsideW);
          hv_CIsInsideW=TTemp[--SP];

          /*CIndex := find(CIsInsideW,1)*/
          create_tuple_i(&TTemp[SP++],1);
          T_tuple_find(hv_CIsInsideW,TTemp[SP-1],&TTemp[SP]);
          destroy_tuple(TTemp[SP-1]);
          TTemp[SP-1]=TTemp[SP];
          destroy_tuple(hv_CIndex);
          hv_CIndex=TTemp[--SP];

          /*========== if (CIndex != -1) ==========*/
          create_tuple_i(&TTemp[SP++],-1);
          T_tuple_not_equal(hv_CIndex,TTemp[SP-1],&TTemp[SP]);
          destroy_tuple(TTemp[SP-1]);
          TTemp[SP-1]=TTemp[SP];
          if(get_i(TTemp[SP-1],0))
          {
            /*WordsCharsMapping.at(WordsIndices[WordIndex]) := CharsIndices[CIndex]*/
            T_tuple_select(hv_CharsIndices,hv_CIndex,&TTemp[SP++]);
            create_tuple(&TTemp[SP++],1);
            T_tuple_select(hv_WordsIndices,hv_WordIndex,&TTemp[SP++]);
            set_i(TTemp[SP-2],get_i(TTemp[SP-1],0),0);
            destroy_tuple(TTemp[--SP]);
            V_set_vector_tuple((*hvec_WordsCharsMapping),TTemp[SP-1],TTemp[SP-2]);
            destroy_tuple(TTemp[--SP]);
            destroy_tuple(TTemp[--SP]);
          }
          destroy_tuple(TTemp[--SP]);
          /*========== end if ==========*/
        }
        else
        {
          /* throw(...); only in hdevelop*/
        }
        destroy_tuple(TTemp[--SP]);
        /*========== end if ==========*/
       }
       destroy_tuple(TTemp[SP--]);
       destroy_tuple(TTemp[SP--]);
       destroy_tuple(TTemp[SP]);
      }
      else
      {
       destroy_tuple(TTemp[SP--]);
       destroy_tuple(TTemp[SP--]);
       destroy_tuple(TTemp[SP--]);
       destroy_tuple(TTemp[SP--]);
       destroy_tuple(TTemp[SP]);
      }/*========== end for ========*/

    }
    destroy_tuple(TTemp[--SP]);
    /*========== end if ==========*/
  }
  destroy_tuple(TTemp[--SP]);
  /*========== end if ==========*/
  /*========== return ==========*/

  /* Clear temporary tuple stack */
  while (SP > 0)
    destroy_tuple(TTemp[--SP]);
  /* Clear temporary tuple vectors stack*/
  while (SPTV > 0)
    V_destroy_vector(TVTemp[--SPTV]);
  /* Clear local control variables */
  destroy_tuple(hv_WordsIndices);
  destroy_tuple(hv_CharsIndices);
  destroy_tuple(hv_WordLengths);
  destroy_tuple(hv_WordArea);
  destroy_tuple(hv_CharArea);
  destroy_tuple(hv_CharAreaThreshold);
  destroy_tuple(hv_WordIndex);
  destroy_tuple(hv_AreaIntersection);
  destroy_tuple(hv_CIsInsideW);
  destroy_tuple(hv_CIndex);

  return;

  /****************************************************/
  /******************     End procedure   *************/
  /****************************************************/

}

/* Chapter: Deep Learning / Anomaly Detection and Global Context Anomaly Detection*/
/* Short Description: Get the ground truth anomaly label and label ID. */
void get_anomaly_ground_truth_label (Htuple hv_SampleKeys, Htuple hv_DLSample, Htuple *hv_AnomalyLabelGroundTruth, 
    Htuple *hv_AnomalyLabelIDGroundTruth)
{

  /* Stack for temporary tuples */
  Htuple   TTemp[100];
  int      SP=0;
  /* Stack for temporary tuple vectors */
  Hvector  TVTemp[100] = {0};
  int      SPTV=0;

  /* Initialize control variables */
  create_tuple(&(*hv_AnomalyLabelGroundTruth),0);
  create_tuple(&(*hv_AnomalyLabelIDGroundTruth),0);

  /****************************************************/
  /******************   Begin procedure   *************/
  /****************************************************/

  /**/
  /*This procedure returns the anomaly ground truth label.*/
  /**/
  /*========== if (find(SampleKeys,'anomaly_label') != -1) ==========*/
  create_tuple_s(&TTemp[SP++],"anomaly_label");
  T_tuple_find(hv_SampleKeys,TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-1]=TTemp[SP];
  create_tuple_i(&TTemp[SP++],-1);
  T_tuple_not_equal(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-2]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-2]=TTemp[SP];
  SP--;
  if(get_i(TTemp[SP-1],0))
  {
    /*get_dict_tuple (DLSample, 'anomaly_label', AnomalyLabelGroundTruth)*/
    create_tuple_s(&TTemp[SP++],"anomaly_label");
    destroy_tuple((*hv_AnomalyLabelGroundTruth));
    /***/T_get_dict_tuple(hv_DLSample, TTemp[SP-1], &(*hv_AnomalyLabelGroundTruth));
    destroy_tuple(TTemp[--SP]);

  }
  else
  {
    /* throw(...); only in hdevelop*/
  }
  destroy_tuple(TTemp[--SP]);
  /*========== end if ==========*/
  /*========== if (find(SampleKeys,'anomaly_label_id') != -1) ==========*/
  create_tuple_s(&TTemp[SP++],"anomaly_label_id");
  T_tuple_find(hv_SampleKeys,TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-1]=TTemp[SP];
  create_tuple_i(&TTemp[SP++],-1);
  T_tuple_not_equal(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-2]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-2]=TTemp[SP];
  SP--;
  if(get_i(TTemp[SP-1],0))
  {
    /*get_dict_tuple (DLSample, 'anomaly_label_id', AnomalyLabelIDGroundTruth)*/
    create_tuple_s(&TTemp[SP++],"anomaly_label_id");
    destroy_tuple((*hv_AnomalyLabelIDGroundTruth));
    /***/T_get_dict_tuple(hv_DLSample, TTemp[SP-1], &(*hv_AnomalyLabelIDGroundTruth));
    destroy_tuple(TTemp[--SP]);

  }
  else
  {
    /* throw(...); only in hdevelop*/
  }
  destroy_tuple(TTemp[--SP]);
  /*========== end if ==========*/
  /**/
  /*========== return ==========*/

  /* Clear temporary tuple stack */
  while (SP > 0)
    destroy_tuple(TTemp[--SP]);
  /* Clear temporary tuple vectors stack*/
  while (SPTV > 0)
    V_destroy_vector(TVTemp[--SPTV]);
  return;

  /****************************************************/
  /******************     End procedure   *************/
  /****************************************************/

}

/* Chapter: Deep Learning / Anomaly Detection and Global Context Anomaly Detection*/
/* Short Description: Get the anomaly results out of DLResult and apply thresholds (if specified). */
void get_anomaly_result (Hobject *ho_AnomalyImage, Hobject *ho_AnomalyRegion, Htuple hv_DLResult, 
    Htuple hv_AnomalyClassThreshold, Htuple hv_AnomalyRegionThreshold, Htuple hv_AnomalyResultPostfix, 
    Htuple *hv_AnomalyScore, Htuple *hv_AnomalyClassID, Htuple *hv_AnomalyClassThresholdDisplay, 
    Htuple *hv_AnomalyRegionThresholdDisplay)
{

  /* Stack for temporary tuples */
  Htuple   TTemp[100];
  int      SP=0;
  /* Stack for temporary tuple vectors */
  Hvector  TVTemp[100] = {0};
  int      SPTV=0;

  /* Local iconic variables */

  /* Local control variables */
  Htuple  hv_AnomalyImageKey, hv_AnomalyScoreKey;
  Htuple  hv_AnomalyRegionKey, hv_AnomalyClassIdKey, hv_ErrorMsgPostfix;
  Htuple  hv_ResultKeys;

  /* Initialize iconic variables */
  gen_empty_obj(&(*ho_AnomalyImage));
  gen_empty_obj(&(*ho_AnomalyRegion));

  /* Initialize control variables */
  create_tuple(&hv_AnomalyImageKey,0);
  create_tuple(&hv_AnomalyScoreKey,0);
  create_tuple(&hv_AnomalyRegionKey,0);
  create_tuple(&hv_AnomalyClassIdKey,0);
  create_tuple(&hv_ErrorMsgPostfix,0);
  create_tuple(&hv_ResultKeys,0);
  create_tuple(&(*hv_AnomalyScore),0);
  create_tuple(&(*hv_AnomalyClassID),0);
  create_tuple(&(*hv_AnomalyClassThresholdDisplay),0);
  create_tuple(&(*hv_AnomalyRegionThresholdDisplay),0);

  /****************************************************/
  /******************   Begin procedure   *************/
  /****************************************************/

  /**/
  /*This procedure returns the inference results in DLResult which are*/
  /*the anomaly image and the anomaly score. It also returns the*/
  /*classification of the anomaly score and segmentation of anomalous*/
  /*pixels in the anomaly image by applying the specified thresholds if*/
  /*given. Otherwise the results from DLResult are used.*/
  /**/
  /**/
  /*AnomalyImageKey := 'anomaly_image' + AnomalyResultPostfix*/
  create_tuple_s(&TTemp[SP++],"anomaly_image");
  T_tuple_add(TTemp[SP-1],hv_AnomalyResultPostfix,&TTemp[SP]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-1]=TTemp[SP];
  destroy_tuple(hv_AnomalyImageKey);
  hv_AnomalyImageKey=TTemp[--SP];

  /*AnomalyScoreKey := 'anomaly_score' + AnomalyResultPostfix*/
  create_tuple_s(&TTemp[SP++],"anomaly_score");
  T_tuple_add(TTemp[SP-1],hv_AnomalyResultPostfix,&TTemp[SP]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-1]=TTemp[SP];
  destroy_tuple(hv_AnomalyScoreKey);
  hv_AnomalyScoreKey=TTemp[--SP];

  /*AnomalyRegionKey := 'anomaly_region' + AnomalyResultPostfix*/
  create_tuple_s(&TTemp[SP++],"anomaly_region");
  T_tuple_add(TTemp[SP-1],hv_AnomalyResultPostfix,&TTemp[SP]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-1]=TTemp[SP];
  destroy_tuple(hv_AnomalyRegionKey);
  hv_AnomalyRegionKey=TTemp[--SP];

  /*AnomalyClassIdKey := 'anomaly_class_id' + AnomalyResultPostfix*/
  create_tuple_s(&TTemp[SP++],"anomaly_class_id");
  T_tuple_add(TTemp[SP-1],hv_AnomalyResultPostfix,&TTemp[SP]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-1]=TTemp[SP];
  destroy_tuple(hv_AnomalyClassIdKey);
  hv_AnomalyClassIdKey=TTemp[--SP];

  /**/
  /*tuple_regexp_replace (AnomalyResultPostfix, '_', ' ', ErrorMsgPostfix)*/
  create_tuple_s(&TTemp[SP++],"_");
  create_tuple_s(&TTemp[SP++]," ");
  destroy_tuple(hv_ErrorMsgPostfix);
  /***/T_tuple_regexp_replace(hv_AnomalyResultPostfix, TTemp[SP-2], TTemp[SP-1], 
      &hv_ErrorMsgPostfix);
  destroy_tuple(TTemp[--SP]);
  destroy_tuple(TTemp[--SP]);

  /**/
  /*get_dict_param (DLResult, 'keys', [], ResultKeys)*/
  create_tuple_s(&TTemp[SP++],"keys");
  create_tuple(&TTemp[SP++],0);
  destroy_tuple(hv_ResultKeys);
  /***/T_get_dict_param(hv_DLResult, TTemp[SP-2], TTemp[SP-1], &hv_ResultKeys);
  destroy_tuple(TTemp[--SP]);
  destroy_tuple(TTemp[--SP]);

  /*========== if (ResultKeys == []) ==========*/
  create_tuple(&TTemp[SP++],0);
  T_tuple_equal(hv_ResultKeys,TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-1]=TTemp[SP];
  if(get_i(TTemp[SP-1],0))
  {
    /* throw(...); only in hdevelop*/
  }
  destroy_tuple(TTemp[--SP]);
  /*========== end if ==========*/
  /**/
  /*========== if (find_first(ResultKeys,AnomalyImageKey) != -1) ==========*/
  T_tuple_find_first(hv_ResultKeys,hv_AnomalyImageKey,&TTemp[SP++]);
  create_tuple_i(&TTemp[SP++],-1);
  T_tuple_not_equal(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-2]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-2]=TTemp[SP];
  SP--;
  if(get_i(TTemp[SP-1],0))
  {
    /*get_dict_object (AnomalyImage, DLResult, AnomalyImageKey)*/
    clear_obj((*ho_AnomalyImage));
    /***/T_get_dict_object(&(*ho_AnomalyImage), hv_DLResult, hv_AnomalyImageKey);

  }
  else
  {
    /* throw(...); only in hdevelop*/
  }
  destroy_tuple(TTemp[--SP]);
  /*========== end if ==========*/
  /**/
  /*========== if (find_first(ResultKeys,AnomalyScoreKey) != -1) ==========*/
  T_tuple_find_first(hv_ResultKeys,hv_AnomalyScoreKey,&TTemp[SP++]);
  create_tuple_i(&TTemp[SP++],-1);
  T_tuple_not_equal(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-2]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-2]=TTemp[SP];
  SP--;
  if(get_i(TTemp[SP-1],0))
  {
    /*get_dict_tuple (DLResult, AnomalyScoreKey, AnomalyScore)*/
    destroy_tuple((*hv_AnomalyScore));
    /***/T_get_dict_tuple(hv_DLResult, hv_AnomalyScoreKey, &(*hv_AnomalyScore));

  }
  else
  {
    /* throw(...); only in hdevelop*/
  }
  destroy_tuple(TTemp[--SP]);
  /*========== end if ==========*/
  /**/
  /*AnomalyRegionThresholdDisplay := -1*/
  reuse_tuple_i(&(*hv_AnomalyRegionThresholdDisplay),-1);

  /*========== if (AnomalyRegionThreshold != -1) ==========*/
  create_tuple_i(&TTemp[SP++],-1);
  T_tuple_not_equal(hv_AnomalyRegionThreshold,TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-1]=TTemp[SP];
  if(get_i(TTemp[SP-1],0))
  {
    /*Apply threshold for segmentation result.*/
    /*========== if (|AnomalyRegionThreshold| != 1) ==========*/
    T_tuple_length(hv_AnomalyRegionThreshold,&TTemp[SP++]);
    create_tuple_i(&TTemp[SP++],1);
    T_tuple_not_equal(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-2]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-2]=TTemp[SP];
    SP--;
    if(get_i(TTemp[SP-1],0))
    {
      /* throw(...); only in hdevelop*/
    }
    destroy_tuple(TTemp[--SP]);
    /*========== end if ==========*/
    /*threshold (AnomalyImage, AnomalyRegion, AnomalyRegionThreshold, 'max')*/
    create_tuple_s(&TTemp[SP++],"max");
    clear_obj((*ho_AnomalyRegion));
    /***/T_threshold((*ho_AnomalyImage), &(*ho_AnomalyRegion), hv_AnomalyRegionThreshold, 
        TTemp[SP-1]);
    destroy_tuple(TTemp[--SP]);

    /*AnomalyRegionThresholdDisplay := AnomalyRegionThreshold*/
    destroy_tuple((*hv_AnomalyRegionThresholdDisplay));
    copy_tuple(hv_AnomalyRegionThreshold,&(*hv_AnomalyRegionThresholdDisplay));

  }
  else
  {
    /*If no threshold is given, use the threshold and resulting anomaly region out of DLResult.*/
    /*========== if (find_first(ResultKeys,AnomalyRegionKey) != -1) ==========*/
    T_tuple_find_first(hv_ResultKeys,hv_AnomalyRegionKey,&TTemp[SP++]);
    create_tuple_i(&TTemp[SP++],-1);
    T_tuple_not_equal(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-2]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-2]=TTemp[SP];
    SP--;
    if(get_i(TTemp[SP-1],0))
    {
      /*get_dict_object (AnomalyRegion, DLResult, AnomalyRegionKey)*/
      clear_obj((*ho_AnomalyRegion));
      /***/T_get_dict_object(&(*ho_AnomalyRegion), hv_DLResult, hv_AnomalyRegionKey);

    }
    else
    {
      /*gen_empty_obj (AnomalyRegion)*/
      clear_obj((*ho_AnomalyRegion));
      /***/gen_empty_obj(&(*ho_AnomalyRegion));

    }
    destroy_tuple(TTemp[--SP]);
    /*========== end if ==========*/
    /*========== if (find(ResultKeys,'anomaly_segmentation_threshold') != -1) ==========*/
    create_tuple_s(&TTemp[SP++],"anomaly_segmentation_threshold");
    T_tuple_find(hv_ResultKeys,TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    create_tuple_i(&TTemp[SP++],-1);
    T_tuple_not_equal(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-2]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-2]=TTemp[SP];
    SP--;
    if(get_i(TTemp[SP-1],0))
    {
      /*get_dict_tuple (DLResult, 'anomaly_segmentation_threshold', AnomalyRegionThresholdDisplay)*/
      create_tuple_s(&TTemp[SP++],"anomaly_segmentation_threshold");
      destroy_tuple((*hv_AnomalyRegionThresholdDisplay));
      /***/T_get_dict_tuple(hv_DLResult, TTemp[SP-1], &(*hv_AnomalyRegionThresholdDisplay));
      destroy_tuple(TTemp[--SP]);

    }
    destroy_tuple(TTemp[--SP]);
    /*========== end if ==========*/
  }
  destroy_tuple(TTemp[--SP]);
  /*========== end if ==========*/
  /**/
  /*AnomalyClassThresholdDisplay := -1*/
  reuse_tuple_i(&(*hv_AnomalyClassThresholdDisplay),-1);

  /*AnomalyClassID := -1*/
  reuse_tuple_i(&(*hv_AnomalyClassID),-1);

  /*========== if (AnomalyClassThreshold != -1) ==========*/
  create_tuple_i(&TTemp[SP++],-1);
  T_tuple_not_equal(hv_AnomalyClassThreshold,TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-1]=TTemp[SP];
  if(get_i(TTemp[SP-1],0))
  {
    /*Apply threshold for classification result.*/
    /*========== if (|AnomalyClassThreshold| != 1) ==========*/
    T_tuple_length(hv_AnomalyClassThreshold,&TTemp[SP++]);
    create_tuple_i(&TTemp[SP++],1);
    T_tuple_not_equal(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-2]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-2]=TTemp[SP];
    SP--;
    if(get_i(TTemp[SP-1],0))
    {
      /* throw(...); only in hdevelop*/
    }
    destroy_tuple(TTemp[--SP]);
    /*========== end if ==========*/
    /*========== if (AnomalyScore < AnomalyClassThreshold) ==========*/
    T_tuple_less((*hv_AnomalyScore),hv_AnomalyClassThreshold,&TTemp[SP++]);
    if(get_i(TTemp[SP-1],0))
    {
      /*AnomalyClassID := 0*/
      reuse_tuple_i(&(*hv_AnomalyClassID),0);

    }
    else
    {
      /*AnomalyClassID := 1*/
      reuse_tuple_i(&(*hv_AnomalyClassID),1);

    }
    destroy_tuple(TTemp[--SP]);
    /*========== end if ==========*/
    /*AnomalyClassThresholdDisplay := AnomalyClassThreshold*/
    destroy_tuple((*hv_AnomalyClassThresholdDisplay));
    copy_tuple(hv_AnomalyClassThreshold,&(*hv_AnomalyClassThresholdDisplay));

  }
  else
  {
    /*If no threshold is given, use the threshold and resulting class id out of DLResult.*/
    /*========== if (find_first(ResultKeys,AnomalyClassIdKey) != -1) ==========*/
    T_tuple_find_first(hv_ResultKeys,hv_AnomalyClassIdKey,&TTemp[SP++]);
    create_tuple_i(&TTemp[SP++],-1);
    T_tuple_not_equal(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-2]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-2]=TTemp[SP];
    SP--;
    if(get_i(TTemp[SP-1],0))
    {
      /*get_dict_tuple (DLResult, AnomalyClassIdKey, AnomalyClassID)*/
      destroy_tuple((*hv_AnomalyClassID));
      /***/T_get_dict_tuple(hv_DLResult, hv_AnomalyClassIdKey, &(*hv_AnomalyClassID));

    }
    else
    {
      /*AnomalyClassID := -1*/
      reuse_tuple_i(&(*hv_AnomalyClassID),-1);

    }
    destroy_tuple(TTemp[--SP]);
    /*========== end if ==========*/
    /*========== if (find(ResultKeys,'anomaly_classification_threshold') != -1) ==========*/
    create_tuple_s(&TTemp[SP++],"anomaly_classification_threshold");
    T_tuple_find(hv_ResultKeys,TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    create_tuple_i(&TTemp[SP++],-1);
    T_tuple_not_equal(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-2]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-2]=TTemp[SP];
    SP--;
    if(get_i(TTemp[SP-1],0))
    {
      /*get_dict_tuple (DLResult, 'anomaly_classification_threshold', AnomalyClassThresholdDisplay)*/
      create_tuple_s(&TTemp[SP++],"anomaly_classification_threshold");
      destroy_tuple((*hv_AnomalyClassThresholdDisplay));
      /***/T_get_dict_tuple(hv_DLResult, TTemp[SP-1], &(*hv_AnomalyClassThresholdDisplay));
      destroy_tuple(TTemp[--SP]);

    }
    destroy_tuple(TTemp[--SP]);
    /*========== end if ==========*/
  }
  destroy_tuple(TTemp[--SP]);
  /*========== end if ==========*/
  /**/
  /*========== return ==========*/

  /* Clear temporary tuple stack */
  while (SP > 0)
    destroy_tuple(TTemp[--SP]);
  /* Clear temporary tuple vectors stack*/
  while (SPTV > 0)
    V_destroy_vector(TVTemp[--SPTV]);
  /* Clear local control variables */
  destroy_tuple(hv_AnomalyImageKey);
  destroy_tuple(hv_AnomalyScoreKey);
  destroy_tuple(hv_AnomalyRegionKey);
  destroy_tuple(hv_AnomalyClassIdKey);
  destroy_tuple(hv_ErrorMsgPostfix);
  destroy_tuple(hv_ResultKeys);

  return;

  /****************************************************/
  /******************     End procedure   *************/
  /****************************************************/

}

/* Chapter: Graphics / Window*/
/* Short Description: Get the next child window that can be used for visualization. */
void get_child_window (Htuple hv_HeightImage, Htuple hv_Font, Htuple hv_FontSize, 
    Htuple hv_Text, Htuple hv_PrevWindowCoordinates, Htuple hv_WindowHandleDict, 
    Htuple hv_WindowHandleKey, Htuple *hv_WindowImageRatio, Htuple *hv_PrevWindowCoordinatesOut)
{

  /* Stack for temporary tuples */
  Htuple   TTemp[100];
  int      SP=0;
  /* Stack for temporary tuple vectors */
  Hvector  TVTemp[100] = {0};
  int      SPTV=0;

  /* Local iconic variables */

  /* Local control variables */
  Htuple  hv_OpenNewWindow, hv_WindowHandles, hv_ParentWindowHandle;
  Htuple  hv_ChildWindowHandle, hv_Exception, hv_MetaInfo;
  Htuple  hv_WindowRow, hv_WindowColumn, hv_WindowWidth, hv_WindowHeight;

  /* Initialize control variables */
  create_tuple(&hv_OpenNewWindow,0);
  create_tuple(&hv_WindowHandles,0);
  create_tuple(&hv_ParentWindowHandle,0);
  create_tuple(&hv_ChildWindowHandle,0);
  create_tuple(&hv_Exception,0);
  create_tuple(&hv_MetaInfo,0);
  create_tuple(&hv_WindowRow,0);
  create_tuple(&hv_WindowColumn,0);
  create_tuple(&hv_WindowWidth,0);
  create_tuple(&hv_WindowHeight,0);
  create_tuple(&(*hv_WindowImageRatio),0);
  create_tuple(&(*hv_PrevWindowCoordinatesOut),0);

  /****************************************************/
  /******************   Begin procedure   *************/
  /****************************************************/

  /**/
  /*This procedure returns the next child window that*/
  /*is used for visualization. If ReuseWindows is true*/
  /*and WindowHandleList is suitable, the window handles*/
  /*that are passed over are used. Else, this procedure*/
  /*opens a new window, either next to the last ones, or*/
  /*in a new row.*/
  /**/
  /*First, check if the requested window is already available.*/
  /*OpenNewWindow := false*/
  reuse_tuple_i(&hv_OpenNewWindow,0);

  /* try(...); only in hdevelop*/
    /*get_dict_tuple (WindowHandleDict, WindowHandleKey, WindowHandles)*/
    destroy_tuple(hv_WindowHandles);
    /***/T_get_dict_tuple(hv_WindowHandleDict, hv_WindowHandleKey, &hv_WindowHandles);

    /*ParentWindowHandle := WindowHandles[0]*/
    create_tuple_i(&TTemp[SP++],0);
    T_tuple_select(hv_WindowHandles,TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    destroy_tuple(hv_ParentWindowHandle);
    hv_ParentWindowHandle=TTemp[--SP];

    /*ChildWindowHandle := WindowHandles[1]*/
    create_tuple_i(&TTemp[SP++],1);
    T_tuple_select(hv_WindowHandles,TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    destroy_tuple(hv_ChildWindowHandle);
    hv_ChildWindowHandle=TTemp[--SP];

    /*Check if window handle is valid.*/
    /* try(...); only in hdevelop*/
      /*flush_buffer (ChildWindowHandle)*/
      /***/T_flush_buffer(hv_ChildWindowHandle);

    /* catch(...); only in hdevelop*/
      /*Since there is something wrong with the current window, create a new one.*/
      /* assign(...); only in hdevelop*/
    /* endtry(...); only in hdevelop*/
  /* catch(...); only in hdevelop*/
    /* assign(...); only in hdevelop*/
  /* endtry(...); only in hdevelop*/
  /**/
  /*Get next child window.*/
  /*========== if (not OpenNewWindow) ==========*/
  T_tuple_not(hv_OpenNewWindow,&TTemp[SP++]);
  if(get_i(TTemp[SP-1],0))
  {
    /**/
    /*If possible, reuse existing window handles.*/
    hdev_window_stack_set_active(hv_ChildWindowHandle);
    if (hdev_window_stack_is_open())
    {
      Htuple active_win;
      create_tuple(&active_win,0);
      hdev_window_stack_get_active(&active_win);
      /*dev_clear_window ()*/
      /***/T_clear_window(active_win);
      destroy_tuple(active_win);
    }
    /*set_display_font (ChildWindowHandle, FontSize, Font, 'true', 'false')*/
    create_tuple_s(&TTemp[SP++],"true");
    create_tuple_s(&TTemp[SP++],"false");
    /***/set_display_font(hv_ChildWindowHandle, hv_FontSize, hv_Font, TTemp[SP-2], 
        TTemp[SP-1]);
    destroy_tuple(TTemp[--SP]);
    destroy_tuple(TTemp[--SP]);

    /**/
    /*get_dict_tuple (WindowHandleDict, 'meta_information', MetaInfo)*/
    create_tuple_s(&TTemp[SP++],"meta_information");
    destroy_tuple(hv_MetaInfo);
    /***/T_get_dict_tuple(hv_WindowHandleDict, TTemp[SP-1], &hv_MetaInfo);
    destroy_tuple(TTemp[--SP]);

    /**/
    /*Get previous window coordinates.*/
    /*get_window_extents (ParentWindowHandle, WindowRow, WindowColumn, WindowWidth, WindowHeight)*/
    destroy_tuple(hv_WindowRow);
    destroy_tuple(hv_WindowColumn);
    destroy_tuple(hv_WindowWidth);
    destroy_tuple(hv_WindowHeight);
    /***/T_get_window_extents(hv_ParentWindowHandle, &hv_WindowRow, &hv_WindowColumn, 
        &hv_WindowWidth, &hv_WindowHeight);

    /*WindowImageRatio := WindowHeight / (HeightImage * 1.0)*/
    create_tuple_d(&TTemp[SP++],1.0);
    T_tuple_mult(hv_HeightImage,TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    T_tuple_div(hv_WindowHeight,TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    destroy_tuple((*hv_WindowImageRatio));
    (*hv_WindowImageRatio)=TTemp[--SP];

    /**/
    /* try(...); only in hdevelop*/
      /**/
      /*Get WindowImageRatio from parent window.*/
      /*get_dict_tuple (MetaInfo, WindowHandleKey + '_window_image_ratio_height', WindowImageRatio)*/
      create_tuple_s(&TTemp[SP++],"_window_image_ratio_height");
      T_tuple_add(hv_WindowHandleKey,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      destroy_tuple((*hv_WindowImageRatio));
      /***/T_get_dict_tuple(hv_MetaInfo, TTemp[SP-1], &(*hv_WindowImageRatio));
      destroy_tuple(TTemp[--SP]);

      /**/
      /*Get previous window coordinates.*/
      /*get_dict_tuple (MetaInfo, WindowHandleKey + '_child_window_coordinates', PrevWindowCoordinatesOut)*/
      create_tuple_s(&TTemp[SP++],"_child_window_coordinates");
      T_tuple_add(hv_WindowHandleKey,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      destroy_tuple((*hv_PrevWindowCoordinatesOut));
      /***/T_get_dict_tuple(hv_MetaInfo, TTemp[SP-1], &(*hv_PrevWindowCoordinatesOut));
      destroy_tuple(TTemp[--SP]);

    /* catch(...); only in hdevelop*/
      /**/
      /*Set WindowImageRatio from parent window.*/
      /* get_window_extents(...); only in hdevelop*/
      /* assign(...); only in hdevelop*/
      /**/
      /*Set previous window coordinates.*/
      /* assign_at(...); only in hdevelop*/
      /* assign_at(...); only in hdevelop*/
      /* assign_at(...); only in hdevelop*/
      /* assign_at(...); only in hdevelop*/
    /* endtry(...); only in hdevelop*/
  }
  else
  {
    /**/
    /*Open a new child window.*/
    /*open_child_window (ParentWindowHandle, Font, FontSize, Text, PrevWindowCoordinates, WindowHandleDict, WindowHandleKey, ChildWindowHandle, PrevWindowCoordinatesOut)*/
    destroy_tuple(hv_ChildWindowHandle);
    destroy_tuple((*hv_PrevWindowCoordinatesOut));
    /***/open_child_window(hv_ParentWindowHandle, hv_Font, hv_FontSize, hv_Text, 
        hv_PrevWindowCoordinates, hv_WindowHandleDict, hv_WindowHandleKey, &hv_ChildWindowHandle, 
        &(*hv_PrevWindowCoordinatesOut));

    /*set_window_param (ChildWindowHandle, 'flush', 'false')*/
    create_tuple_s(&TTemp[SP++],"flush");
    create_tuple_s(&TTemp[SP++],"false");
    /***/T_set_window_param(hv_ChildWindowHandle, TTemp[SP-2], TTemp[SP-1]);
    destroy_tuple(TTemp[--SP]);
    destroy_tuple(TTemp[--SP]);

    /*set_dict_tuple (WindowHandleDict, WindowHandleKey, [ParentWindowHandle,ChildWindowHandle])*/
    T_tuple_concat(hv_ParentWindowHandle,hv_ChildWindowHandle,&TTemp[SP++]);
    /***/T_set_dict_tuple(hv_WindowHandleDict, hv_WindowHandleKey, TTemp[SP-1]);
    destroy_tuple(TTemp[--SP]);

  }
  destroy_tuple(TTemp[--SP]);
  /*========== end if ==========*/
  /**/
  /*========== return ==========*/

  /* Clear temporary tuple stack */
  while (SP > 0)
    destroy_tuple(TTemp[--SP]);
  /* Clear temporary tuple vectors stack*/
  while (SPTV > 0)
    V_destroy_vector(TVTemp[--SPTV]);
  /* Clear local control variables */
  destroy_tuple(hv_OpenNewWindow);
  destroy_tuple(hv_WindowHandles);
  destroy_tuple(hv_ParentWindowHandle);
  destroy_tuple(hv_ChildWindowHandle);
  destroy_tuple(hv_Exception);
  destroy_tuple(hv_MetaInfo);
  destroy_tuple(hv_WindowRow);
  destroy_tuple(hv_WindowColumn);
  destroy_tuple(hv_WindowWidth);
  destroy_tuple(hv_WindowHeight);

  return;

  /****************************************************/
  /******************     End procedure   *************/
  /****************************************************/

}

/* Chapter: Deep Learning / Classification*/
/* Short Description: Get the ground truth classification label id. */
void get_classification_ground_truth (Htuple hv_SampleKeys, Htuple hv_DLSample, Htuple *hv_ClassificationLabelIDGroundTruth)
{

  /* Stack for temporary tuples */
  Htuple   TTemp[100];
  int      SP=0;
  /* Stack for temporary tuple vectors */
  Hvector  TVTemp[100] = {0};
  int      SPTV=0;

  /* Initialize control variables */
  create_tuple(&(*hv_ClassificationLabelIDGroundTruth),0);

  /****************************************************/
  /******************   Begin procedure   *************/
  /****************************************************/

  /**/
  /*This procedure returns the classification ground truth label ID.*/
  /**/
  /*========== if (find(SampleKeys,'image_label_id') != -1) ==========*/
  create_tuple_s(&TTemp[SP++],"image_label_id");
  T_tuple_find(hv_SampleKeys,TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-1]=TTemp[SP];
  create_tuple_i(&TTemp[SP++],-1);
  T_tuple_not_equal(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-2]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-2]=TTemp[SP];
  SP--;
  if(get_i(TTemp[SP-1],0))
  {
    /*get_dict_tuple (DLSample, 'image_label_id', ClassificationLabelIDGroundTruth)*/
    create_tuple_s(&TTemp[SP++],"image_label_id");
    destroy_tuple((*hv_ClassificationLabelIDGroundTruth));
    /***/T_get_dict_tuple(hv_DLSample, TTemp[SP-1], &(*hv_ClassificationLabelIDGroundTruth));
    destroy_tuple(TTemp[--SP]);

  }
  else
  {
  destroy_tuple(TTemp[--SP]);
  /*========== elseif (find(SampleKeys,'image_label_ids') != -1) ==========*/

  create_tuple_s(&TTemp[SP++],"image_label_ids");
  T_tuple_find(hv_SampleKeys,TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-1]=TTemp[SP];
  create_tuple_i(&TTemp[SP++],-1);
  T_tuple_not_equal(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-2]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-2]=TTemp[SP];
  SP--;
  if(get_i(TTemp[SP-1],0))
  {
    /*get_dict_tuple (DLSample, 'image_label_ids', ClassificationLabelIDGroundTruth)*/
    create_tuple_s(&TTemp[SP++],"image_label_ids");
    destroy_tuple((*hv_ClassificationLabelIDGroundTruth));
    /***/T_get_dict_tuple(hv_DLSample, TTemp[SP-1], &(*hv_ClassificationLabelIDGroundTruth));
    destroy_tuple(TTemp[--SP]);

  }
  else
  {
    /* throw(...); only in hdevelop*/
  }
  }
  destroy_tuple(TTemp[--SP]);
  /*========== end if ==========*/
  /**/
  /*========== return ==========*/

  /* Clear temporary tuple stack */
  while (SP > 0)
    destroy_tuple(TTemp[--SP]);
  /* Clear temporary tuple vectors stack*/
  while (SPTV > 0)
    V_destroy_vector(TVTemp[--SPTV]);
  return;

  /****************************************************/
  /******************     End procedure   *************/
  /****************************************************/

}

/* Chapter: Deep Learning / Classification*/
/* Short Description: Get the predicted classification class ID. */
void get_classification_result (Htuple hv_ResultKeys, Htuple hv_DLResult, Htuple *hv_ClassificationClassID)
{

  /* Stack for temporary tuples */
  Htuple   TTemp[100];
  int      SP=0;
  /* Stack for temporary tuple vectors */
  Hvector  TVTemp[100] = {0};
  int      SPTV=0;

  /* Local iconic variables */

  /* Initialize control variables */
  create_tuple(&(*hv_ClassificationClassID),0);

  /****************************************************/
  /******************   Begin procedure   *************/
  /****************************************************/

  /**/
  /*This procedure returns the predicted classification class ID.*/
  /**/
  /*========== if (find(ResultKeys,'classification_class_ids') != -1) ==========*/
  create_tuple_s(&TTemp[SP++],"classification_class_ids");
  T_tuple_find(hv_ResultKeys,TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-1]=TTemp[SP];
  create_tuple_i(&TTemp[SP++],-1);
  T_tuple_not_equal(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-2]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-2]=TTemp[SP];
  SP--;
  if(get_i(TTemp[SP-1],0))
  {
    /*get_dict_tuple (DLResult, 'classification_class_ids', ClassificationClassID)*/
    create_tuple_s(&TTemp[SP++],"classification_class_ids");
    destroy_tuple((*hv_ClassificationClassID));
    /***/T_get_dict_tuple(hv_DLResult, TTemp[SP-1], &(*hv_ClassificationClassID));
    destroy_tuple(TTemp[--SP]);

    /*========== if (|ClassificationClassID| > 0) ==========*/
    T_tuple_length((*hv_ClassificationClassID),&TTemp[SP++]);
    create_tuple_i(&TTemp[SP++],0);
    T_tuple_greater(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-2]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-2]=TTemp[SP];
    SP--;
    if(get_i(TTemp[SP-1],0))
    {
      /*ClassificationClassID := ClassificationClassID[0]*/
      copy_tuple((*hv_ClassificationClassID),&TTemp[SP++]);
      create_tuple_i(&TTemp[SP++],0);
      T_tuple_select(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-2]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-2]=TTemp[SP];
      SP--;
      destroy_tuple((*hv_ClassificationClassID));
      (*hv_ClassificationClassID)=TTemp[--SP];

    }
    destroy_tuple(TTemp[--SP]);
    /*========== end if ==========*/
  }
  else
  {
  destroy_tuple(TTemp[--SP]);
  /*========== elseif (find(ResultKeys,'selected_class_ids') != -1) ==========*/

  create_tuple_s(&TTemp[SP++],"selected_class_ids");
  T_tuple_find(hv_ResultKeys,TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-1]=TTemp[SP];
  create_tuple_i(&TTemp[SP++],-1);
  T_tuple_not_equal(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-2]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-2]=TTemp[SP];
  SP--;
  if(get_i(TTemp[SP-1],0))
  {
    /*get_dict_tuple (DLResult, 'selected_class_ids', ClassificationClassID)*/
    create_tuple_s(&TTemp[SP++],"selected_class_ids");
    destroy_tuple((*hv_ClassificationClassID));
    /***/T_get_dict_tuple(hv_DLResult, TTemp[SP-1], &(*hv_ClassificationClassID));
    destroy_tuple(TTemp[--SP]);

  }
  else
  {
    /* throw(...); only in hdevelop*/
  }
  }
  destroy_tuple(TTemp[--SP]);
  /*========== end if ==========*/
  /**/
  /*========== return ==========*/

  /* Clear temporary tuple stack */
  while (SP > 0)
    destroy_tuple(TTemp[--SP]);
  /* Clear temporary tuple vectors stack*/
  while (SPTV > 0)
    V_destroy_vector(TVTemp[--SPTV]);
  return;

  /****************************************************/
  /******************     End procedure   *************/
  /****************************************************/

}

/* Chapter: Deep Learning / Semantic Segmentation and Edge Extraction*/
/* Short Description: Get the confidences of the segmentation result. */
void get_confidence_image (Hobject *ho_ImageConfidence, Htuple hv_ResultKeys, Htuple hv_DLResult)
{

  /* Stack for temporary tuples */
  Htuple   TTemp[100];
  int      SP=0;
  /* Stack for temporary tuple vectors */
  Hvector  TVTemp[100] = {0};
  int      SPTV=0;

  /* Initialize iconic variables */
  gen_empty_obj(&(*ho_ImageConfidence));

  /****************************************************/
  /******************   Begin procedure   *************/
  /****************************************************/

  /**/
  /*This procedure returns confidences of the segmentation result.*/
  /**/
  /*========== if (find(ResultKeys,'segmentation_confidence') != -1) ==========*/
  create_tuple_s(&TTemp[SP++],"segmentation_confidence");
  T_tuple_find(hv_ResultKeys,TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-1]=TTemp[SP];
  create_tuple_i(&TTemp[SP++],-1);
  T_tuple_not_equal(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-2]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-2]=TTemp[SP];
  SP--;
  if(get_i(TTemp[SP-1],0))
  {
    /*get_dict_object (ImageConfidence, DLResult, 'segmentation_confidence')*/
    create_tuple_s(&TTemp[SP++],"segmentation_confidence");
    clear_obj((*ho_ImageConfidence));
    /***/T_get_dict_object(&(*ho_ImageConfidence), hv_DLResult, TTemp[SP-1]);
    destroy_tuple(TTemp[--SP]);

  }
  else
  {
  destroy_tuple(TTemp[--SP]);
  /*========== elseif (find(ResultKeys,'segmentation_confidences') != -1) ==========*/

  create_tuple_s(&TTemp[SP++],"segmentation_confidences");
  T_tuple_find(hv_ResultKeys,TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-1]=TTemp[SP];
  create_tuple_i(&TTemp[SP++],-1);
  T_tuple_not_equal(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-2]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-2]=TTemp[SP];
  SP--;
  if(get_i(TTemp[SP-1],0))
  {
    /*get_dict_object (ImageConfidence, DLResult, 'segmentation_confidences')*/
    create_tuple_s(&TTemp[SP++],"segmentation_confidences");
    clear_obj((*ho_ImageConfidence));
    /***/T_get_dict_object(&(*ho_ImageConfidence), hv_DLResult, TTemp[SP-1]);
    destroy_tuple(TTemp[--SP]);

  }
  else
  {
    /* throw(...); only in hdevelop*/
  }
  }
  destroy_tuple(TTemp[--SP]);
  /*========== end if ==========*/
  /*========== return ==========*/

  /* Clear temporary tuple stack */
  while (SP > 0)
    destroy_tuple(TTemp[--SP]);
  /* Clear temporary tuple vectors stack*/
  while (SPTV > 0)
    V_destroy_vector(TVTemp[--SPTV]);
  return;

  /****************************************************/
  /******************     End procedure   *************/
  /****************************************************/

}

/* Chapter: Deep Learning / Model*/
/* Short Description: Generate NumColors distinct colors */
void get_distinct_colors (Htuple hv_NumColors, Htuple hv_Random, Htuple hv_StartColor, 
    Htuple hv_EndColor, Htuple *hv_Colors)
{

    /* Stack for temporary tuples */
    Htuple   TTemp[100];
    int      SP=0;
    /* Stack for temporary tuple vectors */
    Hvector  TVTemp[100] = {0};
    int      SPTV=0;

    /* Local iconic variables */
    Hobject  ho_HLSImageH, ho_HLSImageL, ho_HLSImageS;
    Hobject  ho_ImageR, ho_ImageG, ho_ImageB;

    /* Local control variables */
    Htuple  hv_IsString, hv_Hue, hv_Lightness, hv_Saturation;
    Htuple  hv_Rows, hv_Columns, hv_Red, hv_Green, hv_Blue;

    /* Local copy input parameter variables */
    Htuple   hv_EndColor_COPY_INP_TMP;
    Htuple   hv_Random_COPY_INP_TMP;


    /* Initialize iconic variables */
    gen_empty_obj(&ho_HLSImageH);
    gen_empty_obj(&ho_HLSImageL);
    gen_empty_obj(&ho_HLSImageS);
    gen_empty_obj(&ho_ImageR);
    gen_empty_obj(&ho_ImageG);
    gen_empty_obj(&ho_ImageB);

    /* Initialize control variables */
    create_tuple(&hv_IsString,0);
    create_tuple(&hv_Hue,0);
    create_tuple(&hv_Lightness,0);
    create_tuple(&hv_Saturation,0);
    create_tuple(&hv_Rows,0);
    create_tuple(&hv_Columns,0);
    create_tuple(&hv_Red,0);
    create_tuple(&hv_Green,0);
    create_tuple(&hv_Blue,0);
    create_tuple(&(*hv_Colors),0);
    copy_tuple(hv_EndColor,&hv_EndColor_COPY_INP_TMP);
    copy_tuple(hv_Random,&hv_Random_COPY_INP_TMP);

    /****************************************************/
    /******************   Begin procedure   *************/
    /****************************************************/

  /**/
  /*We get distinct color-values first in HLS color-space.*/
  /*Assumes hue [0, EndColor), lightness [0, 1), saturation [0, 1).*/
  /**/
  /*Parameter checks.*/
  /*NumColors.*/
  /*========== if (NumColors < 1) ==========*/
  create_tuple_i(&TTemp[SP++],1);
  T_tuple_less(hv_NumColors,TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-1]=TTemp[SP];
  if(get_i(TTemp[SP-1],0))
  {
    /* throw(...); only in hdevelop*/
  }
  destroy_tuple(TTemp[--SP]);
  /*========== end if ==========*/
  /*========== if (not is_int(NumColors)) ==========*/
  T_tuple_is_int(hv_NumColors,&TTemp[SP++]);
  T_tuple_not(TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-1]=TTemp[SP];
  if(get_i(TTemp[SP-1],0))
  {
    /* throw(...); only in hdevelop*/
  }
  destroy_tuple(TTemp[--SP]);
  /*========== end if ==========*/
  /*========== if (|NumColors| != 1) ==========*/
  T_tuple_length(hv_NumColors,&TTemp[SP++]);
  create_tuple_i(&TTemp[SP++],1);
  T_tuple_not_equal(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-2]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-2]=TTemp[SP];
  SP--;
  if(get_i(TTemp[SP-1],0))
  {
    /* throw(...); only in hdevelop*/
  }
  destroy_tuple(TTemp[--SP]);
  /*========== end if ==========*/
  /*Random.*/
  /*========== if (Random != 0 and Random != 1) ==========*/
  create_tuple_i(&TTemp[SP++],0);
  T_tuple_not_equal(hv_Random_COPY_INP_TMP,TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-1]=TTemp[SP];
  create_tuple_i(&TTemp[SP++],1);
  T_tuple_not_equal(hv_Random_COPY_INP_TMP,TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-1]=TTemp[SP];
  T_tuple_and(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-2]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-2]=TTemp[SP];
  SP--;
  if(get_i(TTemp[SP-1],0))
  {
    /*tuple_is_string (Random, IsString)*/
    destroy_tuple(hv_IsString);
    /***/T_tuple_is_string(hv_Random_COPY_INP_TMP, &hv_IsString);

    /*========== if (IsString) ==========*/
    copy_tuple(hv_IsString,&TTemp[SP++]);
    if(get_i(TTemp[SP-1],0))
    {
      /*Random := Random == 'true' or 'false'*/
      copy_tuple(hv_Random_COPY_INP_TMP,&TTemp[SP++]);
      create_tuple_s(&TTemp[SP++],"true");
      T_tuple_equal(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-2]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-2]=TTemp[SP];
      SP--;
      create_tuple_s(&TTemp[SP++],"false");
      T_tuple_or(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-2]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-2]=TTemp[SP];
      SP--;
      destroy_tuple(hv_Random_COPY_INP_TMP);
      hv_Random_COPY_INP_TMP=TTemp[--SP];

    }
    else
    {
      /* throw(...); only in hdevelop*/
    }
    destroy_tuple(TTemp[--SP]);
    /*========== end if ==========*/
  }
  destroy_tuple(TTemp[--SP]);
  /*========== end if ==========*/
  /*StartColor.*/
  /*========== if (|StartColor| != 1) ==========*/
  T_tuple_length(hv_StartColor,&TTemp[SP++]);
  create_tuple_i(&TTemp[SP++],1);
  T_tuple_not_equal(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-2]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-2]=TTemp[SP];
  SP--;
  if(get_i(TTemp[SP-1],0))
  {
    /* throw(...); only in hdevelop*/
  }
  destroy_tuple(TTemp[--SP]);
  /*========== end if ==========*/
  /*========== if (StartColor < 0 or StartColor > 255) ==========*/
  create_tuple_i(&TTemp[SP++],0);
  T_tuple_less(hv_StartColor,TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-1]=TTemp[SP];
  create_tuple_i(&TTemp[SP++],255);
  T_tuple_greater(hv_StartColor,TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-1]=TTemp[SP];
  T_tuple_or(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-2]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-2]=TTemp[SP];
  SP--;
  if(get_i(TTemp[SP-1],0))
  {
    /* throw(...); only in hdevelop*/
  }
  destroy_tuple(TTemp[--SP]);
  /*========== end if ==========*/
  /*========== if (not is_int(StartColor)) ==========*/
  T_tuple_is_int(hv_StartColor,&TTemp[SP++]);
  T_tuple_not(TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-1]=TTemp[SP];
  if(get_i(TTemp[SP-1],0))
  {
    /* throw(...); only in hdevelop*/
  }
  destroy_tuple(TTemp[--SP]);
  /*========== end if ==========*/
  /*EndColor.*/
  /*========== if (|EndColor| != 1) ==========*/
  T_tuple_length(hv_EndColor_COPY_INP_TMP,&TTemp[SP++]);
  create_tuple_i(&TTemp[SP++],1);
  T_tuple_not_equal(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-2]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-2]=TTemp[SP];
  SP--;
  if(get_i(TTemp[SP-1],0))
  {
    /* throw(...); only in hdevelop*/
  }
  destroy_tuple(TTemp[--SP]);
  /*========== end if ==========*/
  /*========== if (EndColor < 0 or EndColor > 255) ==========*/
  create_tuple_i(&TTemp[SP++],0);
  T_tuple_less(hv_EndColor_COPY_INP_TMP,TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-1]=TTemp[SP];
  create_tuple_i(&TTemp[SP++],255);
  T_tuple_greater(hv_EndColor_COPY_INP_TMP,TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-1]=TTemp[SP];
  T_tuple_or(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-2]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-2]=TTemp[SP];
  SP--;
  if(get_i(TTemp[SP-1],0))
  {
    /* throw(...); only in hdevelop*/
  }
  destroy_tuple(TTemp[--SP]);
  /*========== end if ==========*/
  /*========== if (not is_int(EndColor)) ==========*/
  T_tuple_is_int(hv_EndColor_COPY_INP_TMP,&TTemp[SP++]);
  T_tuple_not(TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-1]=TTemp[SP];
  if(get_i(TTemp[SP-1],0))
  {
    /* throw(...); only in hdevelop*/
  }
  destroy_tuple(TTemp[--SP]);
  /*========== end if ==========*/
  /**/
  /*Color generation.*/
  /*========== if (StartColor > EndColor) ==========*/
  T_tuple_greater(hv_StartColor,hv_EndColor_COPY_INP_TMP,&TTemp[SP++]);
  if(get_i(TTemp[SP-1],0))
  {
    /*EndColor := EndColor + 255*/
    create_tuple_i(&TTemp[SP++],255);
    T_tuple_add(hv_EndColor_COPY_INP_TMP,TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(hv_EndColor_COPY_INP_TMP);
    hv_EndColor_COPY_INP_TMP=TTemp[SP];
    destroy_tuple(TTemp[--SP]);

  }
  destroy_tuple(TTemp[--SP]);
  /*========== end if ==========*/
  /*========== if (NumColors != 1) ==========*/
  create_tuple_i(&TTemp[SP++],1);
  T_tuple_not_equal(hv_NumColors,TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-1]=TTemp[SP];
  if(get_i(TTemp[SP-1],0))
  {
    /*Hue := (StartColor + int((EndColor - StartColor) * real([0:NumColors - 1]) / real(NumColors - 1))) % 255*/
    T_tuple_sub(hv_EndColor_COPY_INP_TMP,hv_StartColor,&TTemp[SP++]);
    create_tuple_i(&TTemp[SP++],0);
    create_tuple_i(&TTemp[SP++],1);
    T_tuple_sub(hv_NumColors,TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    create_tuple_i(&TTemp[SP++],1);
    T_tuple_gen_sequence(TTemp[SP-3],TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    destroy_tuple(TTemp[SP-2]);
    destroy_tuple(TTemp[SP-3]);
    TTemp[SP-3]=TTemp[SP];
    SP=SP-2;
    T_tuple_real(TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    T_tuple_mult(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-2]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-2]=TTemp[SP];
    SP--;
    create_tuple_i(&TTemp[SP++],1);
    T_tuple_sub(hv_NumColors,TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    T_tuple_real(TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    T_tuple_div(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-2]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-2]=TTemp[SP];
    SP--;
    T_tuple_int(TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    T_tuple_add(hv_StartColor,TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    create_tuple_i(&TTemp[SP++],255);
    T_tuple_mod(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-2]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-2]=TTemp[SP];
    SP--;
    destroy_tuple(hv_Hue);
    hv_Hue=TTemp[--SP];

  }
  else
  {
    /*Hue := mean([StartColor,EndColor])*/
    T_tuple_concat(hv_StartColor,hv_EndColor_COPY_INP_TMP,&TTemp[SP++]);
    T_tuple_mean(TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    destroy_tuple(hv_Hue);
    hv_Hue=TTemp[--SP];

  }
  destroy_tuple(TTemp[--SP]);
  /*========== end if ==========*/
  /*========== if (Random) ==========*/
  copy_tuple(hv_Random_COPY_INP_TMP,&TTemp[SP++]);
  if(get_i(TTemp[SP-1],0))
  {
    /*Hue := Hue[sort_index(rand(NumColors))]*/
    copy_tuple(hv_Hue,&TTemp[SP++]);
    T_tuple_rand(hv_NumColors,&TTemp[SP++]);
    T_tuple_sort_index(TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    T_tuple_select(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-2]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-2]=TTemp[SP];
    SP--;
    destroy_tuple(hv_Hue);
    hv_Hue=TTemp[--SP];

    /*Lightness := int((5.0 + rand(NumColors)) * 255.0 / 10.0)*/
    create_tuple_d(&TTemp[SP++],5.0);
    T_tuple_rand(hv_NumColors,&TTemp[SP++]);
    T_tuple_add(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-2]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-2]=TTemp[SP];
    SP--;
    create_tuple_d(&TTemp[SP++],255.0);
    T_tuple_mult(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-2]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-2]=TTemp[SP];
    SP--;
    create_tuple_d(&TTemp[SP++],10.0);
    T_tuple_div(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-2]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-2]=TTemp[SP];
    SP--;
    T_tuple_int(TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    destroy_tuple(hv_Lightness);
    hv_Lightness=TTemp[--SP];

    /*Saturation := int((9.0 + rand(NumColors)) * 255.0 / 10.0)*/
    create_tuple_d(&TTemp[SP++],9.0);
    T_tuple_rand(hv_NumColors,&TTemp[SP++]);
    T_tuple_add(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-2]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-2]=TTemp[SP];
    SP--;
    create_tuple_d(&TTemp[SP++],255.0);
    T_tuple_mult(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-2]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-2]=TTemp[SP];
    SP--;
    create_tuple_d(&TTemp[SP++],10.0);
    T_tuple_div(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-2]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-2]=TTemp[SP];
    SP--;
    T_tuple_int(TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    destroy_tuple(hv_Saturation);
    hv_Saturation=TTemp[--SP];

  }
  else
  {
    /*Lightness := int(gen_tuple_const(NumColors,0.55) * 255.0)*/
    create_tuple_d(&TTemp[SP++],0.55);
    T_tuple_gen_const(hv_NumColors,TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    create_tuple_d(&TTemp[SP++],255.0);
    T_tuple_mult(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-2]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-2]=TTemp[SP];
    SP--;
    T_tuple_int(TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    destroy_tuple(hv_Lightness);
    hv_Lightness=TTemp[--SP];

    /*Saturation := int(gen_tuple_const(NumColors,0.95) * 255.0)*/
    create_tuple_d(&TTemp[SP++],0.95);
    T_tuple_gen_const(hv_NumColors,TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    create_tuple_d(&TTemp[SP++],255.0);
    T_tuple_mult(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-2]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-2]=TTemp[SP];
    SP--;
    T_tuple_int(TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    destroy_tuple(hv_Saturation);
    hv_Saturation=TTemp[--SP];

  }
  destroy_tuple(TTemp[--SP]);
  /*========== end if ==========*/
  /**/
  /*Write colors to a 3-channel image in order to transform easier.*/
  /*gen_image_const (HLSImageH, 'byte', 1, NumColors)*/
  create_tuple_s(&TTemp[SP++],"byte");
  create_tuple_i(&TTemp[SP++],1);
  clear_obj(ho_HLSImageH);
  /***/T_gen_image_const(&ho_HLSImageH, TTemp[SP-2], TTemp[SP-1], hv_NumColors);
  destroy_tuple(TTemp[--SP]);
  destroy_tuple(TTemp[--SP]);

  /*gen_image_const (HLSImageL, 'byte', 1, NumColors)*/
  create_tuple_s(&TTemp[SP++],"byte");
  create_tuple_i(&TTemp[SP++],1);
  clear_obj(ho_HLSImageL);
  /***/T_gen_image_const(&ho_HLSImageL, TTemp[SP-2], TTemp[SP-1], hv_NumColors);
  destroy_tuple(TTemp[--SP]);
  destroy_tuple(TTemp[--SP]);

  /*gen_image_const (HLSImageS, 'byte', 1, NumColors)*/
  create_tuple_s(&TTemp[SP++],"byte");
  create_tuple_i(&TTemp[SP++],1);
  clear_obj(ho_HLSImageS);
  /***/T_gen_image_const(&ho_HLSImageS, TTemp[SP-2], TTemp[SP-1], hv_NumColors);
  destroy_tuple(TTemp[--SP]);
  destroy_tuple(TTemp[--SP]);

  /*get_region_points (HLSImageH, Rows, Columns)*/
  destroy_tuple(hv_Rows);
  destroy_tuple(hv_Columns);
  /***/T_get_region_points(ho_HLSImageH, &hv_Rows, &hv_Columns);

  /*set_grayval (HLSImageH, Rows, Columns, Hue)*/
  /***/T_set_grayval(ho_HLSImageH, hv_Rows, hv_Columns, hv_Hue);

  /*set_grayval (HLSImageL, Rows, Columns, Lightness)*/
  /***/T_set_grayval(ho_HLSImageL, hv_Rows, hv_Columns, hv_Lightness);

  /*set_grayval (HLSImageS, Rows, Columns, Saturation)*/
  /***/T_set_grayval(ho_HLSImageS, hv_Rows, hv_Columns, hv_Saturation);

  /**/
  /*Convert from HLS to RGB.*/
  /*trans_to_rgb (HLSImageH, HLSImageL, HLSImageS, ImageR, ImageG, ImageB, 'hls')*/
  clear_obj(ho_ImageR);
  clear_obj(ho_ImageG);
  clear_obj(ho_ImageB);
  /***/trans_to_rgb(ho_HLSImageH, ho_HLSImageL, ho_HLSImageS, &ho_ImageR, &ho_ImageG, 
      &ho_ImageB, "hls");

  /**/
  /*Get RGB-values and transform to Hex.*/
  /*get_grayval (ImageR, Rows, Columns, Red)*/
  destroy_tuple(hv_Red);
  /***/T_get_grayval(ho_ImageR, hv_Rows, hv_Columns, &hv_Red);

  /*get_grayval (ImageG, Rows, Columns, Green)*/
  destroy_tuple(hv_Green);
  /***/T_get_grayval(ho_ImageG, hv_Rows, hv_Columns, &hv_Green);

  /*get_grayval (ImageB, Rows, Columns, Blue)*/
  destroy_tuple(hv_Blue);
  /***/T_get_grayval(ho_ImageB, hv_Rows, hv_Columns, &hv_Blue);

  /*Colors := '#' + Red$'02x' + Green$'02x' + Blue$'02x'*/
  create_tuple_s(&TTemp[SP++],"#");
  create_tuple_s(&TTemp[SP++],"02x");
  T_tuple_string(hv_Red,TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-1]=TTemp[SP];
  T_tuple_add(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-2]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-2]=TTemp[SP];
  SP--;
  create_tuple_s(&TTemp[SP++],"02x");
  T_tuple_string(hv_Green,TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-1]=TTemp[SP];
  T_tuple_add(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-2]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-2]=TTemp[SP];
  SP--;
  create_tuple_s(&TTemp[SP++],"02x");
  T_tuple_string(hv_Blue,TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-1]=TTemp[SP];
  T_tuple_add(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-2]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-2]=TTemp[SP];
  SP--;
  destroy_tuple((*hv_Colors));
  (*hv_Colors)=TTemp[--SP];

  /*========== return ==========*/

  /* Clear temporary tuple stack */
  while (SP > 0)
    destroy_tuple(TTemp[--SP]);
  /* Clear temporary tuple vectors stack*/
  while (SPTV > 0)
    V_destroy_vector(TVTemp[--SPTV]);
  /* Clear local iconic variables */
  clear_obj(ho_HLSImageH);
  clear_obj(ho_HLSImageL);
  clear_obj(ho_HLSImageS);
  clear_obj(ho_ImageR);
  clear_obj(ho_ImageG);
  clear_obj(ho_ImageB);

  /* Clear local control variables */
  destroy_tuple(hv_IsString);
  destroy_tuple(hv_Hue);
  destroy_tuple(hv_Lightness);
  destroy_tuple(hv_Saturation);
  destroy_tuple(hv_Rows);
  destroy_tuple(hv_Columns);
  destroy_tuple(hv_Red);
  destroy_tuple(hv_Green);
  destroy_tuple(hv_Blue);
  destroy_tuple(hv_EndColor_COPY_INP_TMP);
  destroy_tuple(hv_Random_COPY_INP_TMP);

  return;
  /**/

  /****************************************************/
  /******************     End procedure   *************/
  /****************************************************/

}

/* Chapter: Deep Learning / Model*/
/* Short Description: Generate certain colors for different ClassNames */
void get_dl_class_colors (Htuple hv_ClassNames, Htuple hv_AdditionalGreenClassNames, 
    Htuple *hv_Colors)
{

  /* Stack for temporary tuples */
  Htuple   TTemp[100];
  int      SP=0;
  /* Stack for temporary tuple vectors */
  Hvector  TVTemp[100] = {0};
  int      SPTV=0;

  /* Local iconic variables */

  /* Local control variables */
  Htuple  hv_NumColors, hv_ColorsRainbow, hv_ClassNamesGood;
  Htuple  hv_IndexFind, hv_GoodIdx, hv_CurrentColor, hv_GreenIdx;

  /* Initialize control variables */
  create_tuple(&hv_NumColors,0);
  create_tuple(&hv_ColorsRainbow,0);
  create_tuple(&hv_ClassNamesGood,0);
  create_tuple(&hv_IndexFind,0);
  create_tuple(&hv_GoodIdx,0);
  create_tuple(&hv_CurrentColor,0);
  create_tuple(&hv_GreenIdx,0);
  create_tuple(&(*hv_Colors),0);

  /****************************************************/
  /******************   Begin procedure   *************/
  /****************************************************/

  /**/
  /*This procedure returns for each class a certain color.*/
  /**/
  /*Define distinct colors for the classes.*/
  /*NumColors := |ClassNames|*/
  T_tuple_length(hv_ClassNames,&TTemp[SP++]);
  destroy_tuple(hv_NumColors);
  hv_NumColors=TTemp[--SP];

  /*Get distinct colors without randomness makes neighboring colors look very similar.*/
  /*We use a workaround to get deterministic colors where subsequent colors are distinguishable.*/
  /*get_distinct_colors (NumColors, false, 0, 200, ColorsRainbow)*/
  create_tuple_i(&TTemp[SP++],0);
  create_tuple_i(&TTemp[SP++],0);
  create_tuple_i(&TTemp[SP++],200);
  destroy_tuple(hv_ColorsRainbow);
  /***/get_distinct_colors(hv_NumColors, TTemp[SP-3], TTemp[SP-2], TTemp[SP-1], &hv_ColorsRainbow);
  destroy_tuple(TTemp[--SP]);
  destroy_tuple(TTemp[--SP]);
  destroy_tuple(TTemp[--SP]);

  /*tuple_inverse (ColorsRainbow, ColorsRainbow)*/
  copy_tuple(hv_ColorsRainbow,&TTemp[SP++]);
  destroy_tuple(hv_ColorsRainbow);
  /***/T_tuple_inverse(TTemp[SP-1], &hv_ColorsRainbow);
  destroy_tuple(TTemp[--SP]);

  /*make_neighboring_colors_distinguishable (ColorsRainbow, Colors)*/
  destroy_tuple((*hv_Colors));
  /***/make_neighboring_colors_distinguishable(hv_ColorsRainbow, &(*hv_Colors));

  /*If a class 'OK','ok', 'good' or 'GOOD' or a class specified in AdditionalGreenClassNames is present set this class to green.*/
  /*Only the first occurrence found is set to a green shade.*/
  /*tuple_union (['good', 'GOOD', 'ok', 'OK'], AdditionalGreenClassNames, ClassNamesGood)*/
  create_tuple(&TTemp[SP++],4);
  set_s(TTemp[SP-1],"good",0);
  set_s(TTemp[SP-1],"GOOD",1);
  set_s(TTemp[SP-1],"ok",2);
  set_s(TTemp[SP-1],"OK",3);
  destroy_tuple(hv_ClassNamesGood);
  /***/T_tuple_union(TTemp[SP-1], hv_AdditionalGreenClassNames, &hv_ClassNamesGood);
  destroy_tuple(TTemp[--SP]);

  /*========== for IndexFind := 0 to |ClassNamesGood| - 1 by 1 ==========*/
  T_tuple_length(hv_ClassNamesGood,&TTemp[SP++]);
  create_tuple_i(&TTemp[SP++],1);
  T_tuple_sub(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-2]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-2]=TTemp[SP];
  SP--;
  create_tuple_i(&TTemp[SP++],1);
  create_tuple_i(&TTemp[SP++],0);
  T_tuple_greater(TTemp[SP-1],TTemp[SP-3],&TTemp[SP]);
  SP++;
  T_tuple_equal(TTemp[SP-2],TTemp[SP-4],&TTemp[SP]);
  if(get_i(TTemp[SP],0) ||
     (!((( get_i(TTemp[SP-1],0)) && (get_d(TTemp[SP-3],0)>0)) ||
        ((!get_i(TTemp[SP-1],0)) && (get_d(TTemp[SP-3],0)<0)))))
  {
   destroy_tuple(TTemp[SP--]);
   destroy_tuple(TTemp[SP]);
   T_tuple_sub(TTemp[SP-1],TTemp[SP-2],&TTemp[SP]);
   destroy_tuple(hv_IndexFind);
   copy_tuple(TTemp[SP],&hv_IndexFind);
   destroy_tuple(TTemp[SP--]);
   destroy_tuple(TTemp[SP]);
   for(;;)
   {
   T_tuple_add(hv_IndexFind,TTemp[SP-1],&TTemp[SP]);
   destroy_tuple(hv_IndexFind);
   copy_tuple(TTemp[SP],&hv_IndexFind);
   destroy_tuple(TTemp[SP]);
   if(get_d(TTemp[SP-1],0)<0)
    T_tuple_less(hv_IndexFind,TTemp[SP-2],&TTemp[SP]);
   else
    T_tuple_greater(hv_IndexFind,TTemp[SP-2],&TTemp[SP]);
   if(get_i(TTemp[SP],0)) break;
   destroy_tuple(TTemp[SP]);
   /*========== for ==========*/

    /*GoodIdx := find_first(ClassNames,ClassNamesGood[IndexFind])*/
    T_tuple_select(hv_ClassNamesGood,hv_IndexFind,&TTemp[SP++]);
    T_tuple_find_first(hv_ClassNames,TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    destroy_tuple(hv_GoodIdx);
    hv_GoodIdx=TTemp[--SP];

    /*========== if (GoodIdx != -1 and |ClassNames| <= 8) ==========*/
    create_tuple_i(&TTemp[SP++],-1);
    T_tuple_not_equal(hv_GoodIdx,TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    T_tuple_length(hv_ClassNames,&TTemp[SP++]);
    create_tuple_i(&TTemp[SP++],8);
    T_tuple_less_equal(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-2]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-2]=TTemp[SP];
    SP--;
    T_tuple_and(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-2]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-2]=TTemp[SP];
    SP--;
    if(get_i(TTemp[SP-1],0))
    {
      /*If number of classes is <= 8, swap color with a green color.*/
      /*CurrentColor := Colors[GoodIdx]*/
      T_tuple_select((*hv_Colors),hv_GoodIdx,&TTemp[SP++]);
      destroy_tuple(hv_CurrentColor);
      hv_CurrentColor=TTemp[--SP];

      /*GreenIdx := floor(|ClassNames| / 2.0)*/
      T_tuple_length(hv_ClassNames,&TTemp[SP++]);
      create_tuple_d(&TTemp[SP++],2.0);
      T_tuple_div(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-2]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-2]=TTemp[SP];
      SP--;
      T_tuple_floor(TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      destroy_tuple(hv_GreenIdx);
      hv_GreenIdx=TTemp[--SP];

      /*Set to pure green.*/
      /*Colors[GoodIdx] := '#00ff00'*/
      create_tuple_s(&TTemp[SP++],"#00ff00");
      replace_elements(&(*hv_Colors),&hv_GoodIdx,&TTemp[SP-1]);
      destroy_tuple(TTemp[--SP]);
      /*Write original color to a green entry.*/
      /*Colors[GreenIdx] := CurrentColor*/
      replace_elements(&(*hv_Colors),&hv_GreenIdx,&hv_CurrentColor);
      /*break*/
      destroy_tuple(TTemp[--SP]);
      create_tuple(&TTemp[SP],0);
      break;
    }
    else
    {
    destroy_tuple(TTemp[--SP]);
    /*========== elseif (GoodIdx != -1 and |ClassNames| > 8) ==========*/

    create_tuple_i(&TTemp[SP++],-1);
    T_tuple_not_equal(hv_GoodIdx,TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    T_tuple_length(hv_ClassNames,&TTemp[SP++]);
    create_tuple_i(&TTemp[SP++],8);
    T_tuple_greater(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-2]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-2]=TTemp[SP];
    SP--;
    T_tuple_and(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-2]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-2]=TTemp[SP];
    SP--;
    if(get_i(TTemp[SP-1],0))
    {
      /*If number of classes is larger than 8, set the respective color to green.*/
      /*Colors[GoodIdx] := '#00ff00'*/
      create_tuple_s(&TTemp[SP++],"#00ff00");
      replace_elements(&(*hv_Colors),&hv_GoodIdx,&TTemp[SP-1]);
      destroy_tuple(TTemp[--SP]);
      /*break*/
      destroy_tuple(TTemp[--SP]);
      create_tuple(&TTemp[SP],0);
      break;
    }
    }
    destroy_tuple(TTemp[--SP]);
    /*========== end if ==========*/
   }
   destroy_tuple(TTemp[SP--]);
   destroy_tuple(TTemp[SP--]);
   destroy_tuple(TTemp[SP]);
  }
  else
  {
   destroy_tuple(TTemp[SP--]);
   destroy_tuple(TTemp[SP--]);
   destroy_tuple(TTemp[SP--]);
   destroy_tuple(TTemp[SP--]);
   destroy_tuple(TTemp[SP]);
  }/*========== end for ========*/

  /*========== return ==========*/

  /* Clear temporary tuple stack */
  while (SP > 0)
    destroy_tuple(TTemp[--SP]);
  /* Clear temporary tuple vectors stack*/
  while (SPTV > 0)
    V_destroy_vector(TVTemp[--SPTV]);
  /* Clear local control variables */
  destroy_tuple(hv_NumColors);
  destroy_tuple(hv_ColorsRainbow);
  destroy_tuple(hv_ClassNamesGood);
  destroy_tuple(hv_IndexFind);
  destroy_tuple(hv_GoodIdx);
  destroy_tuple(hv_CurrentColor);
  destroy_tuple(hv_GreenIdx);

  return;

  /****************************************************/
  /******************     End procedure   *************/
  /****************************************************/

}

/* Chapter: Deep Learning / Model*/
/* Short Description: Get an image of a sample with a certain key. */
void get_dl_sample_image (Hobject *ho_Image, Htuple hv_SampleKeys, Htuple hv_DLSample, 
    Htuple hv_Key)
{

  /* Stack for temporary tuples */
  Htuple   TTemp[100];
  int      SP=0;
  /* Stack for temporary tuple vectors */
  Hvector  TVTemp[100] = {0};
  int      SPTV=0;

  /* Initialize iconic variables */
  gen_empty_obj(&(*ho_Image));

  /****************************************************/
  /******************   Begin procedure   *************/
  /****************************************************/

  /*This procedure returns an image with key Key of a sample.*/
  /**/
  /*========== if (find(SampleKeys,Key) != -1) ==========*/
  T_tuple_find(hv_SampleKeys,hv_Key,&TTemp[SP++]);
  create_tuple_i(&TTemp[SP++],-1);
  T_tuple_not_equal(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-2]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-2]=TTemp[SP];
  SP--;
  if(get_i(TTemp[SP-1],0))
  {
    /*get_dict_object (Image, DLSample, Key)*/
    clear_obj((*ho_Image));
    /***/T_get_dict_object(&(*ho_Image), hv_DLSample, hv_Key);

  }
  else
  {
    /* throw(...); only in hdevelop*/
  }
  destroy_tuple(TTemp[--SP]);
  /*========== end if ==========*/
  /*========== return ==========*/

  /* Clear temporary tuple stack */
  while (SP > 0)
    destroy_tuple(TTemp[--SP]);
  /* Clear temporary tuple vectors stack*/
  while (SPTV > 0)
    V_destroy_vector(TVTemp[--SPTV]);
  return;

  /****************************************************/
  /******************     End procedure   *************/
  /****************************************************/

}

/* Chapter: 3D Matching / 3D Gripping Point Detection*/
/* Short Description: Extract gripping points from a dictionary. */
void get_gripping_points_from_dict (Htuple hv_DLResult, Htuple *hv_Rows, Htuple *hv_Columns)
{

  /* Stack for temporary tuples */
  Htuple   TTemp[100];
  int      SP=0;
  /* Stack for temporary tuple vectors */
  Hvector  TVTemp[100] = {0};
  int      SPTV=0;

  /* Local iconic variables */

  /* Local control variables */
  Htuple  hv_KeyExists, hv_GrippingPoints, hv_NumberOfResults;
  Htuple  hv_IndexGrippingPointsPoint, hv_GrippingPointCoordDict;

  /* Initialize control variables */
  create_tuple(&hv_KeyExists,0);
  create_tuple(&hv_GrippingPoints,0);
  create_tuple(&hv_NumberOfResults,0);
  create_tuple(&hv_IndexGrippingPointsPoint,0);
  create_tuple(&hv_GrippingPointCoordDict,0);
  create_tuple(&(*hv_Rows),0);
  create_tuple(&(*hv_Columns),0);

  /****************************************************/
  /******************   Begin procedure   *************/
  /****************************************************/

  /*========== if (DLResult == []) ==========*/
  create_tuple(&TTemp[SP++],0);
  T_tuple_equal(hv_DLResult,TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-1]=TTemp[SP];
  if(get_i(TTemp[SP-1],0))
  {
    /* throw(...); only in hdevelop*/
  }
  destroy_tuple(TTemp[--SP]);
  /*========== end if ==========*/
  /*get_dict_param (DLResult, 'key_exists', 'gripping_points', KeyExists)*/
  create_tuple_s(&TTemp[SP++],"key_exists");
  create_tuple_s(&TTemp[SP++],"gripping_points");
  destroy_tuple(hv_KeyExists);
  /***/T_get_dict_param(hv_DLResult, TTemp[SP-2], TTemp[SP-1], &hv_KeyExists);
  destroy_tuple(TTemp[--SP]);
  destroy_tuple(TTemp[--SP]);

  /*========== if (KeyExists) ==========*/
  copy_tuple(hv_KeyExists,&TTemp[SP++]);
  if(get_i(TTemp[SP-1],0))
  {
    /*get_dict_tuple (DLResult, 'gripping_points', GrippingPoints)*/
    create_tuple_s(&TTemp[SP++],"gripping_points");
    destroy_tuple(hv_GrippingPoints);
    /***/T_get_dict_tuple(hv_DLResult, TTemp[SP-1], &hv_GrippingPoints);
    destroy_tuple(TTemp[--SP]);

  }
  else
  {
    /* throw(...); only in hdevelop*/
  }
  destroy_tuple(TTemp[--SP]);
  /*========== end if ==========*/
  /*NumberOfResults := |GrippingPoints|*/
  T_tuple_length(hv_GrippingPoints,&TTemp[SP++]);
  destroy_tuple(hv_NumberOfResults);
  hv_NumberOfResults=TTemp[--SP];

  /*tuple_gen_const (NumberOfResults, 0, Rows)*/
  create_tuple_i(&TTemp[SP++],0);
  destroy_tuple((*hv_Rows));
  /***/T_tuple_gen_const(hv_NumberOfResults, TTemp[SP-1], &(*hv_Rows));
  destroy_tuple(TTemp[--SP]);

  /*tuple_gen_const (NumberOfResults, 0, Columns)*/
  create_tuple_i(&TTemp[SP++],0);
  destroy_tuple((*hv_Columns));
  /***/T_tuple_gen_const(hv_NumberOfResults, TTemp[SP-1], &(*hv_Columns));
  destroy_tuple(TTemp[--SP]);

  /*========== for IndexGrippingPointsPoint := 0 to |GrippingPoints| - 1 by 1 ==========*/
  T_tuple_length(hv_GrippingPoints,&TTemp[SP++]);
  create_tuple_i(&TTemp[SP++],1);
  T_tuple_sub(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-2]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-2]=TTemp[SP];
  SP--;
  create_tuple_i(&TTemp[SP++],1);
  create_tuple_i(&TTemp[SP++],0);
  T_tuple_greater(TTemp[SP-1],TTemp[SP-3],&TTemp[SP]);
  SP++;
  T_tuple_equal(TTemp[SP-2],TTemp[SP-4],&TTemp[SP]);
  if(get_i(TTemp[SP],0) ||
     (!((( get_i(TTemp[SP-1],0)) && (get_d(TTemp[SP-3],0)>0)) ||
        ((!get_i(TTemp[SP-1],0)) && (get_d(TTemp[SP-3],0)<0)))))
  {
   destroy_tuple(TTemp[SP--]);
   destroy_tuple(TTemp[SP]);
   T_tuple_sub(TTemp[SP-1],TTemp[SP-2],&TTemp[SP]);
   destroy_tuple(hv_IndexGrippingPointsPoint);
   copy_tuple(TTemp[SP],&hv_IndexGrippingPointsPoint);
   destroy_tuple(TTemp[SP--]);
   destroy_tuple(TTemp[SP]);
   for(;;)
   {
   T_tuple_add(hv_IndexGrippingPointsPoint,TTemp[SP-1],&TTemp[SP]);
   destroy_tuple(hv_IndexGrippingPointsPoint);
   copy_tuple(TTemp[SP],&hv_IndexGrippingPointsPoint);
   destroy_tuple(TTemp[SP]);
   if(get_d(TTemp[SP-1],0)<0)
    T_tuple_less(hv_IndexGrippingPointsPoint,TTemp[SP-2],&TTemp[SP]);
   else
    T_tuple_greater(hv_IndexGrippingPointsPoint,TTemp[SP-2],&TTemp[SP]);
   if(get_i(TTemp[SP],0)) break;
   destroy_tuple(TTemp[SP]);
   /*========== for ==========*/

    /*GrippingPointCoordDict := GrippingPoints[IndexGrippingPointsPoint]*/
    T_tuple_select(hv_GrippingPoints,hv_IndexGrippingPointsPoint,&TTemp[SP++]);
    destroy_tuple(hv_GrippingPointCoordDict);
    hv_GrippingPointCoordDict=TTemp[--SP];

    /*Rows[IndexGrippingPointsPoint] := __get_dict_tuple( GrippingPointCoordDict, ['row'])*/
    create_tuple_s(&TTemp[SP++],"row");
    T_get_dict_tuple(hv_GrippingPointCoordDict,TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    replace_elements(&(*hv_Rows),&hv_IndexGrippingPointsPoint,&TTemp[SP-1]);
    destroy_tuple(TTemp[--SP]);
    /*Columns[IndexGrippingPointsPoint] := __get_dict_tuple( GrippingPointCoordDict, ['column'])*/
    create_tuple_s(&TTemp[SP++],"column");
    T_get_dict_tuple(hv_GrippingPointCoordDict,TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    replace_elements(&(*hv_Columns),&hv_IndexGrippingPointsPoint,&TTemp[SP-1]);
    destroy_tuple(TTemp[--SP]);
   }
   destroy_tuple(TTemp[SP--]);
   destroy_tuple(TTemp[SP--]);
   destroy_tuple(TTemp[SP]);
  }
  else
  {
   destroy_tuple(TTemp[SP--]);
   destroy_tuple(TTemp[SP--]);
   destroy_tuple(TTemp[SP--]);
   destroy_tuple(TTemp[SP--]);
   destroy_tuple(TTemp[SP]);
  }/*========== end for ========*/

  /*========== return ==========*/

  /* Clear temporary tuple stack */
  while (SP > 0)
    destroy_tuple(TTemp[--SP]);
  /* Clear temporary tuple vectors stack*/
  while (SPTV > 0)
    V_destroy_vector(TVTemp[--SPTV]);
  /* Clear local control variables */
  destroy_tuple(hv_KeyExists);
  destroy_tuple(hv_GrippingPoints);
  destroy_tuple(hv_NumberOfResults);
  destroy_tuple(hv_IndexGrippingPointsPoint);
  destroy_tuple(hv_GrippingPointCoordDict);

  return;

  /****************************************************/
  /******************     End procedure   *************/
  /****************************************************/

}

/* Chapter: Graphics / Window*/
/* Short Description: Get the next window that can be used for visualization. */
void get_next_window (Htuple hv_Font, Htuple hv_FontSize, Htuple hv_ShowBottomDesc, 
    Htuple hv_WidthImage, Htuple hv_HeightImage, Htuple hv_MapColorBarWidth, Htuple hv_ScaleWindows, 
    Htuple hv_ThresholdWidth, Htuple hv_PrevWindowCoordinates, Htuple hv_WindowHandleDict, 
    Htuple hv_WindowHandleKey, Htuple *hv_CurrentWindowHandle, Htuple *hv_WindowImageRatioHeight, 
    Htuple *hv_PrevWindowCoordinatesOut)
{

  /* Stack for temporary tuples */
  Htuple   TTemp[100];
  int      SP=0;
  /* Stack for temporary tuple vectors */
  Hvector  TVTemp[100] = {0};
  int      SPTV=0;

  /* Local iconic variables */

  /* Local control variables */
  Htuple  hv_OpenNewWindow, hv_WindowHandles, hv_Value;
  Htuple  hv_Exception, hv_Ascent, hv_Descent, hv__, hv_NumLines;
  Htuple  hv_MarginBottom, hv_WindowImageRatioWidth, hv_SetPartRow2;
  Htuple  hv_SetPartColumn2, hv_MetaInfo;

  /* Array for temporary output ctrl variables */
  Htuple  CExpDummyOCvar[4];

  /* Initialize control variables */
  create_tuple(&hv_OpenNewWindow,0);
  create_tuple(&hv_WindowHandles,0);
  create_tuple(&hv_Value,0);
  create_tuple(&hv_Exception,0);
  create_tuple(&hv_Ascent,0);
  create_tuple(&hv_Descent,0);
  create_tuple(&hv__,0);
  create_tuple(&hv_NumLines,0);
  create_tuple(&hv_MarginBottom,0);
  create_tuple(&hv_WindowImageRatioWidth,0);
  create_tuple(&hv_SetPartRow2,0);
  create_tuple(&hv_SetPartColumn2,0);
  create_tuple(&hv_MetaInfo,0);
  create_tuple(&(*hv_CurrentWindowHandle),0);
  create_tuple(&(*hv_WindowImageRatioHeight),0);
  create_tuple(&(*hv_PrevWindowCoordinatesOut),0);

  /****************************************************/
  /******************   Begin procedure   *************/
  /****************************************************/

  /**/
  /*This procedure returns the next window that*/
  /*is used for visualization. If ReuseWindows is true*/
  /*and WindowHandleList is suitable, the window handles*/
  /*that are passed over are used. Else, this procedure*/
  /*opens a new window, either next to the last ones, or*/
  /*in a new row.*/
  /**/
  /*First, check if the requested window is already available.*/
  /*OpenNewWindow := false*/
  reuse_tuple_i(&hv_OpenNewWindow,0);

  /* try(...); only in hdevelop*/
    /*get_dict_tuple (WindowHandleDict, WindowHandleKey, WindowHandles)*/
    destroy_tuple(hv_WindowHandles);
    /***/T_get_dict_tuple(hv_WindowHandleDict, hv_WindowHandleKey, &hv_WindowHandles);

    /*CurrentWindowHandle := WindowHandles[0]*/
    create_tuple_i(&TTemp[SP++],0);
    T_tuple_select(hv_WindowHandles,TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    destroy_tuple((*hv_CurrentWindowHandle));
    (*hv_CurrentWindowHandle)=TTemp[--SP];

    /*Check if window handle is valid.*/
    /* try(...); only in hdevelop*/
      /*get_window_param (CurrentWindowHandle, 'flush', Value)*/
      create_tuple_s(&TTemp[SP++],"flush");
      destroy_tuple(hv_Value);
      /***/T_get_window_param((*hv_CurrentWindowHandle), TTemp[SP-1], &hv_Value);
      destroy_tuple(TTemp[--SP]);

    /* catch(...); only in hdevelop*/
      /*If there is something wrong with the current window, create a new one.*/
      /* assign(...); only in hdevelop*/
      /* remove_dict_key(...); only in hdevelop*/
    /* endtry(...); only in hdevelop*/
  /* catch(...); only in hdevelop*/
    /* assign(...); only in hdevelop*/
  /* endtry(...); only in hdevelop*/
  /**/
  /*Get next window.*/
  /*========== if (not OpenNewWindow) ==========*/
  T_tuple_not(hv_OpenNewWindow,&TTemp[SP++]);
  if(get_i(TTemp[SP-1],0))
  {
    /**/
    /*If possible, reuse existing window handles.*/
    hdev_window_stack_set_active((*hv_CurrentWindowHandle));
    if (hdev_window_stack_is_open())
    {
      Htuple active_win;
      create_tuple(&active_win,0);
      hdev_window_stack_get_active(&active_win);
      /*dev_clear_window ()*/
      /***/T_clear_window(active_win);
      destroy_tuple(active_win);
    }
    /*set_display_font (CurrentWindowHandle, FontSize, Font, 'true', 'false')*/
    create_tuple_s(&TTemp[SP++],"true");
    create_tuple_s(&TTemp[SP++],"false");
    /***/set_display_font((*hv_CurrentWindowHandle), hv_FontSize, hv_Font, TTemp[SP-2], 
        TTemp[SP-1]);
    destroy_tuple(TTemp[--SP]);
    destroy_tuple(TTemp[--SP]);

    /**/
    /*Calculate MarginBottom.*/
    /*========== if (ShowBottomDesc) ==========*/
    copy_tuple(hv_ShowBottomDesc,&TTemp[SP++]);
    if(get_i(TTemp[SP-1],0))
    {
      /*get_string_extents (CurrentWindowHandle, 'test_string', Ascent, Descent, _, _)*/
      create_tuple_s(&TTemp[SP++],"test_string");
      destroy_tuple(hv_Ascent);
      destroy_tuple(hv_Descent);
      destroy_tuple(hv__);
      /***/T_get_string_extents((*hv_CurrentWindowHandle), TTemp[SP-1], &hv_Ascent, 
          &hv_Descent, &hv__, &(CExpDummyOCvar[0]));
      destroy_tuple(TTemp[--SP]);
      destroy_tuple(CExpDummyOCvar[0]);

      /*NumLines := ShowBottomDesc*/
      destroy_tuple(hv_NumLines);
      copy_tuple(hv_ShowBottomDesc,&hv_NumLines);

      /*MarginBottom := NumLines * (Ascent + Descent) + 2 * 12*/
      T_tuple_add(hv_Ascent,hv_Descent,&TTemp[SP++]);
      T_tuple_mult(hv_NumLines,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      create_tuple_i(&TTemp[SP++],2);
      create_tuple_i(&TTemp[SP++],12);
      T_tuple_mult(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-2]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-2]=TTemp[SP];
      SP--;
      T_tuple_add(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-2]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-2]=TTemp[SP];
      SP--;
      destroy_tuple(hv_MarginBottom);
      hv_MarginBottom=TTemp[--SP];

    }
    else
    {
      /*MarginBottom := 0*/
      reuse_tuple_i(&hv_MarginBottom,0);

    }
    destroy_tuple(TTemp[--SP]);
    /*========== end if ==========*/
    /**/
    /*Get and set meta information for current window.*/
    /*update_window_meta_information (CurrentWindowHandle, WidthImage, HeightImage, 0, 0, MapColorBarWidth, MarginBottom, WindowImageRatioHeight, WindowImageRatioWidth, SetPartRow2, SetPartColumn2, PrevWindowCoordinatesOut)*/
    create_tuple_i(&TTemp[SP++],0);
    create_tuple_i(&TTemp[SP++],0);
    destroy_tuple((*hv_WindowImageRatioHeight));
    destroy_tuple(hv_WindowImageRatioWidth);
    destroy_tuple(hv_SetPartRow2);
    destroy_tuple(hv_SetPartColumn2);
    destroy_tuple((*hv_PrevWindowCoordinatesOut));
    /***/update_window_meta_information((*hv_CurrentWindowHandle), hv_WidthImage, 
        hv_HeightImage, TTemp[SP-2], TTemp[SP-1], hv_MapColorBarWidth, hv_MarginBottom, 
        &(*hv_WindowImageRatioHeight), &hv_WindowImageRatioWidth, &hv_SetPartRow2, 
        &hv_SetPartColumn2, &(*hv_PrevWindowCoordinatesOut));
    destroy_tuple(TTemp[--SP]);
    destroy_tuple(TTemp[--SP]);

    /**/
    /*Update meta information.*/
    /*get_dict_tuple (WindowHandleDict, 'meta_information', MetaInfo)*/
    create_tuple_s(&TTemp[SP++],"meta_information");
    destroy_tuple(hv_MetaInfo);
    /***/T_get_dict_tuple(hv_WindowHandleDict, TTemp[SP-1], &hv_MetaInfo);
    destroy_tuple(TTemp[--SP]);

    /*set_dict_tuple (MetaInfo, WindowHandleKey + '_window_image_ratio_height', WindowImageRatioHeight)*/
    create_tuple_s(&TTemp[SP++],"_window_image_ratio_height");
    T_tuple_add(hv_WindowHandleKey,TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    /***/T_set_dict_tuple(hv_MetaInfo, TTemp[SP-1], (*hv_WindowImageRatioHeight));
    destroy_tuple(TTemp[--SP]);

    /*set_dict_tuple (MetaInfo, WindowHandleKey + '_window_image_ratio_width', WindowImageRatioWidth)*/
    create_tuple_s(&TTemp[SP++],"_window_image_ratio_width");
    T_tuple_add(hv_WindowHandleKey,TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    /***/T_set_dict_tuple(hv_MetaInfo, TTemp[SP-1], hv_WindowImageRatioWidth);
    destroy_tuple(TTemp[--SP]);

    /*set_dict_tuple (MetaInfo, WindowHandleKey + '_set_part_row2', SetPartRow2)*/
    create_tuple_s(&TTemp[SP++],"_set_part_row2");
    T_tuple_add(hv_WindowHandleKey,TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    /***/T_set_dict_tuple(hv_MetaInfo, TTemp[SP-1], hv_SetPartRow2);
    destroy_tuple(TTemp[--SP]);

    /*set_dict_tuple (MetaInfo, WindowHandleKey + '_set_part_column2', SetPartColumn2)*/
    create_tuple_s(&TTemp[SP++],"_set_part_column2");
    T_tuple_add(hv_WindowHandleKey,TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    /***/T_set_dict_tuple(hv_MetaInfo, TTemp[SP-1], hv_SetPartColumn2);
    destroy_tuple(TTemp[--SP]);

    /*set_dict_tuple (MetaInfo, WindowHandleKey + '_margin_bottom', MarginBottom)*/
    create_tuple_s(&TTemp[SP++],"_margin_bottom");
    T_tuple_add(hv_WindowHandleKey,TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    /***/T_set_dict_tuple(hv_MetaInfo, TTemp[SP-1], hv_MarginBottom);
    destroy_tuple(TTemp[--SP]);

    /*set_dict_tuple (MetaInfo, WindowHandleKey + '_map_color_bar_with', MapColorBarWidth)*/
    create_tuple_s(&TTemp[SP++],"_map_color_bar_with");
    T_tuple_add(hv_WindowHandleKey,TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    /***/T_set_dict_tuple(hv_MetaInfo, TTemp[SP-1], hv_MapColorBarWidth);
    destroy_tuple(TTemp[--SP]);

    /*set_dict_tuple (MetaInfo, WindowHandleKey + '_window_coordinates', PrevWindowCoordinatesOut)*/
    create_tuple_s(&TTemp[SP++],"_window_coordinates");
    T_tuple_add(hv_WindowHandleKey,TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    /***/T_set_dict_tuple(hv_MetaInfo, TTemp[SP-1], (*hv_PrevWindowCoordinatesOut));
    destroy_tuple(TTemp[--SP]);

  }
  else
  {
    /**/
    /*Open a new window.*/
    /*open_next_window (Font, FontSize, ShowBottomDesc, WidthImage, HeightImage, MapColorBarWidth, ScaleWindows, ThresholdWidth, PrevWindowCoordinates, WindowHandleDict, WindowHandleKey, CurrentWindowHandle, WindowImageRatioHeight, PrevWindowCoordinatesOut)*/
    destroy_tuple((*hv_CurrentWindowHandle));
    destroy_tuple((*hv_WindowImageRatioHeight));
    destroy_tuple((*hv_PrevWindowCoordinatesOut));
    /***/open_next_window(hv_Font, hv_FontSize, hv_ShowBottomDesc, hv_WidthImage, 
        hv_HeightImage, hv_MapColorBarWidth, hv_ScaleWindows, hv_ThresholdWidth, 
        hv_PrevWindowCoordinates, hv_WindowHandleDict, hv_WindowHandleKey, &(*hv_CurrentWindowHandle), 
        &(*hv_WindowImageRatioHeight), &(*hv_PrevWindowCoordinatesOut));

    /*set_window_param (CurrentWindowHandle, 'flush', 'false')*/
    create_tuple_s(&TTemp[SP++],"flush");
    create_tuple_s(&TTemp[SP++],"false");
    /***/T_set_window_param((*hv_CurrentWindowHandle), TTemp[SP-2], TTemp[SP-1]);
    destroy_tuple(TTemp[--SP]);
    destroy_tuple(TTemp[--SP]);

  }
  destroy_tuple(TTemp[--SP]);
  /*========== end if ==========*/
  /**/
  /*========== return ==========*/

  /* Clear temporary tuple stack */
  while (SP > 0)
    destroy_tuple(TTemp[--SP]);
  /* Clear temporary tuple vectors stack*/
  while (SPTV > 0)
    V_destroy_vector(TVTemp[--SPTV]);
  /* Clear local control variables */
  destroy_tuple(hv_OpenNewWindow);
  destroy_tuple(hv_WindowHandles);
  destroy_tuple(hv_Value);
  destroy_tuple(hv_Exception);
  destroy_tuple(hv_Ascent);
  destroy_tuple(hv_Descent);
  destroy_tuple(hv__);
  destroy_tuple(hv_NumLines);
  destroy_tuple(hv_MarginBottom);
  destroy_tuple(hv_WindowImageRatioWidth);
  destroy_tuple(hv_SetPartRow2);
  destroy_tuple(hv_SetPartColumn2);
  destroy_tuple(hv_MetaInfo);

  return;

  /****************************************************/
  /******************     End procedure   *************/
  /****************************************************/

}

/* Chapter: Deep Learning / Semantic Segmentation and Edge Extraction*/
/* Short Description: Get the ground truth segmentation image. */
void get_segmentation_image_ground_truth (Hobject *ho_SegmentationImagGroundTruth, 
    Htuple hv_SampleKeys, Htuple hv_DLSample)
{

  /* Stack for temporary tuples */
  Htuple   TTemp[100];
  int      SP=0;
  /* Stack for temporary tuple vectors */
  Hvector  TVTemp[100] = {0};
  int      SPTV=0;

  /* Initialize iconic variables */
  gen_empty_obj(&(*ho_SegmentationImagGroundTruth));

  /****************************************************/
  /******************   Begin procedure   *************/
  /****************************************************/

  /**/
  /*This procedure returns the ground truth segmentation image.*/
  /**/
  /*========== if (find(SampleKeys,'segmentation_image') != -1) ==========*/
  create_tuple_s(&TTemp[SP++],"segmentation_image");
  T_tuple_find(hv_SampleKeys,TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-1]=TTemp[SP];
  create_tuple_i(&TTemp[SP++],-1);
  T_tuple_not_equal(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-2]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-2]=TTemp[SP];
  SP--;
  if(get_i(TTemp[SP-1],0))
  {
    /*get_dict_object (SegmentationImagGroundTruth, DLSample, 'segmentation_image')*/
    create_tuple_s(&TTemp[SP++],"segmentation_image");
    clear_obj((*ho_SegmentationImagGroundTruth));
    /***/T_get_dict_object(&(*ho_SegmentationImagGroundTruth), hv_DLSample, TTemp[SP-1]);
    destroy_tuple(TTemp[--SP]);

  }
  else
  {
    /* throw(...); only in hdevelop*/
  }
  destroy_tuple(TTemp[--SP]);
  /*========== end if ==========*/
  /*========== return ==========*/

  /* Clear temporary tuple stack */
  while (SP > 0)
    destroy_tuple(TTemp[--SP]);
  /* Clear temporary tuple vectors stack*/
  while (SPTV > 0)
    V_destroy_vector(TVTemp[--SPTV]);
  return;

  /****************************************************/
  /******************     End procedure   *************/
  /****************************************************/

}

/* Chapter: Deep Learning / Semantic Segmentation and Edge Extraction*/
/* Short Description: Get the predicted segmentation result image. */
void get_segmentation_image_result (Hobject *ho_SegmentationImageResult, Htuple hv_ResultKeys, 
    Htuple hv_DLResult)
{

  /* Stack for temporary tuples */
  Htuple   TTemp[100];
  int      SP=0;
  /* Stack for temporary tuple vectors */
  Hvector  TVTemp[100] = {0};
  int      SPTV=0;

  /* Initialize iconic variables */
  gen_empty_obj(&(*ho_SegmentationImageResult));

  /****************************************************/
  /******************   Begin procedure   *************/
  /****************************************************/

  /**/
  /*This procedure returns the predicted segmentation result image.*/
  /**/
  /*========== if (find(ResultKeys,'segmentation_image') != -1) ==========*/
  create_tuple_s(&TTemp[SP++],"segmentation_image");
  T_tuple_find(hv_ResultKeys,TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-1]=TTemp[SP];
  create_tuple_i(&TTemp[SP++],-1);
  T_tuple_not_equal(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-2]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-2]=TTemp[SP];
  SP--;
  if(get_i(TTemp[SP-1],0))
  {
    /*get_dict_object (SegmentationImageResult, DLResult, 'segmentation_image')*/
    create_tuple_s(&TTemp[SP++],"segmentation_image");
    clear_obj((*ho_SegmentationImageResult));
    /***/T_get_dict_object(&(*ho_SegmentationImageResult), hv_DLResult, TTemp[SP-1]);
    destroy_tuple(TTemp[--SP]);

  }
  else
  {
    /* throw(...); only in hdevelop*/
  }
  destroy_tuple(TTemp[--SP]);
  /*========== end if ==========*/
  /*========== return ==========*/

  /* Clear temporary tuple stack */
  while (SP > 0)
    destroy_tuple(TTemp[--SP]);
  /* Clear temporary tuple vectors stack*/
  while (SPTV > 0)
    V_destroy_vector(TVTemp[--SPTV]);
  return;

  /****************************************************/
  /******************     End procedure   *************/
  /****************************************************/

}

/* Chapter: Deep Learning / Semantic Segmentation and Edge Extraction*/
/* Short Description: Get the weight image of a sample. */
void get_weight_image (Hobject *ho_ImageWeight, Htuple hv_SampleKeys, Htuple hv_DLSample)
{

  /* Stack for temporary tuples */
  Htuple   TTemp[100];
  int      SP=0;
  /* Stack for temporary tuple vectors */
  Hvector  TVTemp[100] = {0};
  int      SPTV=0;

  /* Initialize iconic variables */
  gen_empty_obj(&(*ho_ImageWeight));

  /****************************************************/
  /******************   Begin procedure   *************/
  /****************************************************/

  /**/
  /*This procedure returns the segmentation weight image of a sample.*/
  /**/
  /*========== if (find(SampleKeys,'weight_image') != -1) ==========*/
  create_tuple_s(&TTemp[SP++],"weight_image");
  T_tuple_find(hv_SampleKeys,TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-1]=TTemp[SP];
  create_tuple_i(&TTemp[SP++],-1);
  T_tuple_not_equal(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-2]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-2]=TTemp[SP];
  SP--;
  if(get_i(TTemp[SP-1],0))
  {
    /*get_dict_object (ImageWeight, DLSample, 'weight_image')*/
    create_tuple_s(&TTemp[SP++],"weight_image");
    clear_obj((*ho_ImageWeight));
    /***/T_get_dict_object(&(*ho_ImageWeight), hv_DLSample, TTemp[SP-1]);
    destroy_tuple(TTemp[--SP]);

  }
  else
  {
    /* throw(...); only in hdevelop*/
  }
  destroy_tuple(TTemp[--SP]);
  /*========== end if ==========*/
  /*========== return ==========*/

  /* Clear temporary tuple stack */
  while (SP > 0)
    destroy_tuple(TTemp[--SP]);
  /* Clear temporary tuple vectors stack*/
  while (SPTV > 0)
    V_destroy_vector(TVTemp[--SPTV]);
  return;

  /****************************************************/
  /******************     End procedure   *************/
  /****************************************************/

}

/* Chapter: Deep Learning / Model*/
/* Short Description: Shuffle the input colors in a deterministic way */
void make_neighboring_colors_distinguishable (Htuple hv_ColorsRainbow, Htuple *hv_Colors)
{

  /* Stack for temporary tuples */
  Htuple   TTemp[100];
  int      SP=0;
  /* Stack for temporary tuple vectors */
  Hvector  TVTemp[100] = {0};
  int      SPTV=0;

  /* Local iconic variables */

  /* Local control variables */
  Htuple  hv_NumColors, hv_NumChunks, hv_NumLeftOver;
  Htuple  hv_ColorsPerChunk, hv_StartIdx, hv_S, hv_EndIdx;
  Htuple  hv_IdxsLeft, hv_IdxsRight;

  /* Initialize control variables */
  create_tuple(&hv_NumColors,0);
  create_tuple(&hv_NumChunks,0);
  create_tuple(&hv_NumLeftOver,0);
  create_tuple(&hv_ColorsPerChunk,0);
  create_tuple(&hv_StartIdx,0);
  create_tuple(&hv_S,0);
  create_tuple(&hv_EndIdx,0);
  create_tuple(&hv_IdxsLeft,0);
  create_tuple(&hv_IdxsRight,0);
  create_tuple(&(*hv_Colors),0);

  /****************************************************/
  /******************   Begin procedure   *************/
  /****************************************************/

  /**/
  /*Shuffle the input colors in a deterministic way*/
  /*to make adjacent colors more distinguishable.*/
  /*Neighboring colors from the input are distributed to every NumChunks*/
  /*position in the output.*/
  /*Depending on the number of colors, increase NumChunks.*/
  /*NumColors := |ColorsRainbow|*/
  T_tuple_length(hv_ColorsRainbow,&TTemp[SP++]);
  destroy_tuple(hv_NumColors);
  hv_NumColors=TTemp[--SP];

  /*========== if (NumColors >= 8) ==========*/
  create_tuple_i(&TTemp[SP++],8);
  T_tuple_greater_equal(hv_NumColors,TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-1]=TTemp[SP];
  if(get_i(TTemp[SP-1],0))
  {
    /*NumChunks := 3*/
    reuse_tuple_i(&hv_NumChunks,3);

    /*========== if (NumColors >= 40) ==========*/
    create_tuple_i(&TTemp[SP++],40);
    T_tuple_greater_equal(hv_NumColors,TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    if(get_i(TTemp[SP-1],0))
    {
      /*NumChunks := 6*/
      reuse_tuple_i(&hv_NumChunks,6);

    }
    else
    {
    destroy_tuple(TTemp[--SP]);
    /*========== elseif (NumColors >= 20) ==========*/

    create_tuple_i(&TTemp[SP++],20);
    T_tuple_greater_equal(hv_NumColors,TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    if(get_i(TTemp[SP-1],0))
    {
      /*NumChunks := 4*/
      reuse_tuple_i(&hv_NumChunks,4);

    }
    }
    destroy_tuple(TTemp[--SP]);
    /*========== end if ==========*/
    /*Colors := gen_tuple_const(NumColors,-1)*/
    create_tuple_i(&TTemp[SP++],-1);
    T_tuple_gen_const(hv_NumColors,TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    destroy_tuple((*hv_Colors));
    (*hv_Colors)=TTemp[--SP];

    /*Check if the Number of Colors is dividable by NumChunks.*/
    /*NumLeftOver := NumColors % NumChunks*/
    T_tuple_mod(hv_NumColors,hv_NumChunks,&TTemp[SP++]);
    destroy_tuple(hv_NumLeftOver);
    hv_NumLeftOver=TTemp[--SP];

    /*ColorsPerChunk := int(NumColors / NumChunks)*/
    T_tuple_div(hv_NumColors,hv_NumChunks,&TTemp[SP++]);
    T_tuple_int(TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    destroy_tuple(hv_ColorsPerChunk);
    hv_ColorsPerChunk=TTemp[--SP];

    /*StartIdx := 0*/
    reuse_tuple_i(&hv_StartIdx,0);

    /*========== for S := 0 to NumChunks - 1 by 1 ==========*/
    create_tuple_i(&TTemp[SP++],1);
    T_tuple_sub(hv_NumChunks,TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    create_tuple_i(&TTemp[SP++],1);
    create_tuple_i(&TTemp[SP++],0);
    T_tuple_greater(TTemp[SP-1],TTemp[SP-3],&TTemp[SP]);
    SP++;
    T_tuple_equal(TTemp[SP-2],TTemp[SP-4],&TTemp[SP]);
    if(get_i(TTemp[SP],0) ||
       (!((( get_i(TTemp[SP-1],0)) && (get_d(TTemp[SP-3],0)>0)) ||
          ((!get_i(TTemp[SP-1],0)) && (get_d(TTemp[SP-3],0)<0)))))
    {
     destroy_tuple(TTemp[SP--]);
     destroy_tuple(TTemp[SP]);
     T_tuple_sub(TTemp[SP-1],TTemp[SP-2],&TTemp[SP]);
     destroy_tuple(hv_S);
     copy_tuple(TTemp[SP],&hv_S);
     destroy_tuple(TTemp[SP--]);
     destroy_tuple(TTemp[SP]);
     for(;;)
     {
     T_tuple_add(hv_S,TTemp[SP-1],&TTemp[SP]);
     destroy_tuple(hv_S);
     copy_tuple(TTemp[SP],&hv_S);
     destroy_tuple(TTemp[SP]);
     if(get_d(TTemp[SP-1],0)<0)
      T_tuple_less(hv_S,TTemp[SP-2],&TTemp[SP]);
     else
      T_tuple_greater(hv_S,TTemp[SP-2],&TTemp[SP]);
     if(get_i(TTemp[SP],0)) break;
     destroy_tuple(TTemp[SP]);
     /*========== for ==========*/

      /*EndIdx := StartIdx + ColorsPerChunk - 1*/
      T_tuple_add(hv_StartIdx,hv_ColorsPerChunk,&TTemp[SP++]);
      create_tuple_i(&TTemp[SP++],1);
      T_tuple_sub(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-2]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-2]=TTemp[SP];
      SP--;
      destroy_tuple(hv_EndIdx);
      hv_EndIdx=TTemp[--SP];

      /*========== if (S < NumLeftOver) ==========*/
      T_tuple_less(hv_S,hv_NumLeftOver,&TTemp[SP++]);
      if(get_i(TTemp[SP-1],0))
      {
        /*EndIdx := EndIdx + 1*/
        create_tuple_i(&TTemp[SP++],1);
        T_tuple_add(hv_EndIdx,TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(hv_EndIdx);
        hv_EndIdx=TTemp[SP];
        destroy_tuple(TTemp[--SP]);

      }
      destroy_tuple(TTemp[--SP]);
      /*========== end if ==========*/
      /*IdxsLeft := [S:NumChunks:NumColors - 1]*/
      create_tuple_i(&TTemp[SP++],1);
      T_tuple_sub(hv_NumColors,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      T_tuple_gen_sequence(hv_S,TTemp[SP-1],hv_NumChunks,&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      destroy_tuple(hv_IdxsLeft);
      hv_IdxsLeft=TTemp[--SP];

      /*IdxsRight := [StartIdx:EndIdx]*/
      create_tuple_i(&TTemp[SP++],1);
      T_tuple_gen_sequence(hv_StartIdx,hv_EndIdx,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      destroy_tuple(hv_IdxsRight);
      hv_IdxsRight=TTemp[--SP];

      /*Colors[S:NumChunks:NumColors - 1] := ColorsRainbow[StartIdx:EndIdx]*/
      create_tuple_i(&TTemp[SP++],1);
      T_tuple_sub(hv_NumColors,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      T_tuple_gen_sequence(hv_S,TTemp[SP-1],hv_NumChunks,&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      T_tuple_select_range(hv_ColorsRainbow,hv_StartIdx,hv_EndIdx,&TTemp[SP++]);
      replace_elements(&(*hv_Colors),&TTemp[SP-2],&TTemp[SP-1]);
      destroy_tuple(TTemp[--SP]);
      destroy_tuple(TTemp[--SP]);
      /*StartIdx := EndIdx + 1*/
      create_tuple_i(&TTemp[SP++],1);
      T_tuple_add(hv_EndIdx,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      destroy_tuple(hv_StartIdx);
      hv_StartIdx=TTemp[--SP];

     }
     destroy_tuple(TTemp[SP--]);
     destroy_tuple(TTemp[SP--]);
     destroy_tuple(TTemp[SP]);
    }
    else
    {
     destroy_tuple(TTemp[SP--]);
     destroy_tuple(TTemp[SP--]);
     destroy_tuple(TTemp[SP--]);
     destroy_tuple(TTemp[SP--]);
     destroy_tuple(TTemp[SP]);
    }/*========== end for ========*/

  }
  else
  {
    /*Colors := ColorsRainbow*/
    destroy_tuple((*hv_Colors));
    copy_tuple(hv_ColorsRainbow,&(*hv_Colors));

  }
  destroy_tuple(TTemp[--SP]);
  /*========== end if ==========*/
  /*========== return ==========*/

  /* Clear temporary tuple stack */
  while (SP > 0)
    destroy_tuple(TTemp[--SP]);
  /* Clear temporary tuple vectors stack*/
  while (SPTV > 0)
    V_destroy_vector(TVTemp[--SPTV]);
  /* Clear local control variables */
  destroy_tuple(hv_NumColors);
  destroy_tuple(hv_NumChunks);
  destroy_tuple(hv_NumLeftOver);
  destroy_tuple(hv_ColorsPerChunk);
  destroy_tuple(hv_StartIdx);
  destroy_tuple(hv_S);
  destroy_tuple(hv_EndIdx);
  destroy_tuple(hv_IdxsLeft);
  destroy_tuple(hv_IdxsRight);

  return;

  /****************************************************/
  /******************     End procedure   *************/
  /****************************************************/

}

/* Chapter: Graphics / Window*/
/* Short Description: Open a window next to the given WindowHandleFather.  */
void open_child_window (Htuple hv_WindowHandleFather, Htuple hv_Font, Htuple hv_FontSize, 
    Htuple hv_Text, Htuple hv_PrevWindowCoordinates, Htuple hv_WindowHandleDict, 
    Htuple hv_WindowHandleKey, Htuple *hv_WindowHandleChild, Htuple *hv_PrevWindowCoordinatesOut)
{

  /* Stack for temporary tuples */
  Htuple   TTemp[100];
  int      SP=0;
  /* Stack for temporary tuple vectors */
  Hvector  TVTemp[100] = {0};
  int      SPTV=0;

  /* Local iconic variables */

  /* Local control variables */
  Htuple  hv_StringWidth, hv_IndexText, hv__, hv_TextWidth;
  Htuple  hv_WindowRow, hv_WindowColumn, hv_WindowWidth, hv_WindowHeight;
  Htuple  hv_MetaInfo;

  /* Array for temporary output ctrl variables */
  Htuple  CExpDummyOCvar[3];

  /* Initialize control variables */
  create_tuple(&hv_StringWidth,0);
  create_tuple(&hv_IndexText,0);
  create_tuple(&hv__,0);
  create_tuple(&hv_TextWidth,0);
  create_tuple(&hv_WindowRow,0);
  create_tuple(&hv_WindowColumn,0);
  create_tuple(&hv_WindowWidth,0);
  create_tuple(&hv_WindowHeight,0);
  create_tuple(&hv_MetaInfo,0);
  create_tuple(&(*hv_WindowHandleChild),0);
  create_tuple(&(*hv_PrevWindowCoordinatesOut),0);

  /****************************************************/
  /******************   Begin procedure   *************/
  /****************************************************/

  /**/
  /*This procedure opens a window next to the given WindowHandleFather.*/
  /**/
  /*Get the maximum width of the text to be displayed.*/
  /*The width should be at least 200.*/
  /*StringWidth := 150*/
  reuse_tuple_i(&hv_StringWidth,150);

  /*========== for IndexText := 0 to |Text| - 1 by 1 ==========*/
  T_tuple_length(hv_Text,&TTemp[SP++]);
  create_tuple_i(&TTemp[SP++],1);
  T_tuple_sub(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-2]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-2]=TTemp[SP];
  SP--;
  create_tuple_i(&TTemp[SP++],1);
  create_tuple_i(&TTemp[SP++],0);
  T_tuple_greater(TTemp[SP-1],TTemp[SP-3],&TTemp[SP]);
  SP++;
  T_tuple_equal(TTemp[SP-2],TTemp[SP-4],&TTemp[SP]);
  if(get_i(TTemp[SP],0) ||
     (!((( get_i(TTemp[SP-1],0)) && (get_d(TTemp[SP-3],0)>0)) ||
        ((!get_i(TTemp[SP-1],0)) && (get_d(TTemp[SP-3],0)<0)))))
  {
   destroy_tuple(TTemp[SP--]);
   destroy_tuple(TTemp[SP]);
   T_tuple_sub(TTemp[SP-1],TTemp[SP-2],&TTemp[SP]);
   destroy_tuple(hv_IndexText);
   copy_tuple(TTemp[SP],&hv_IndexText);
   destroy_tuple(TTemp[SP--]);
   destroy_tuple(TTemp[SP]);
   for(;;)
   {
   T_tuple_add(hv_IndexText,TTemp[SP-1],&TTemp[SP]);
   destroy_tuple(hv_IndexText);
   copy_tuple(TTemp[SP],&hv_IndexText);
   destroy_tuple(TTemp[SP]);
   if(get_d(TTemp[SP-1],0)<0)
    T_tuple_less(hv_IndexText,TTemp[SP-2],&TTemp[SP]);
   else
    T_tuple_greater(hv_IndexText,TTemp[SP-2],&TTemp[SP]);
   if(get_i(TTemp[SP],0)) break;
   destroy_tuple(TTemp[SP]);
   /*========== for ==========*/

    /*get_string_extents (WindowHandleFather, Text[IndexText], _, _, TextWidth, _)*/
    T_tuple_select(hv_Text,hv_IndexText,&TTemp[SP++]);
    destroy_tuple(hv__);
    destroy_tuple(hv_TextWidth);
    /***/T_get_string_extents(hv_WindowHandleFather, TTemp[SP-1], &hv__, &(CExpDummyOCvar[0]), 
        &hv_TextWidth, &(CExpDummyOCvar[1]));
    destroy_tuple(TTemp[--SP]);
    destroy_tuple(CExpDummyOCvar[0]);
    destroy_tuple(CExpDummyOCvar[1]);

    /*StringWidth := max2(StringWidth,TextWidth)*/
    copy_tuple(hv_StringWidth,&TTemp[SP++]);
    T_tuple_max2(TTemp[SP-1],hv_TextWidth,&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    destroy_tuple(hv_StringWidth);
    hv_StringWidth=TTemp[--SP];

   }
   destroy_tuple(TTemp[SP--]);
   destroy_tuple(TTemp[SP--]);
   destroy_tuple(TTemp[SP]);
  }
  else
  {
   destroy_tuple(TTemp[SP--]);
   destroy_tuple(TTemp[SP--]);
   destroy_tuple(TTemp[SP--]);
   destroy_tuple(TTemp[SP--]);
   destroy_tuple(TTemp[SP]);
  }/*========== end for ========*/

  /**/
  /*Define window coordinates.*/
  /*WindowRow := PrevWindowCoordinates[0]*/
  create_tuple_i(&TTemp[SP++],0);
  T_tuple_select(hv_PrevWindowCoordinates,TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-1]=TTemp[SP];
  destroy_tuple(hv_WindowRow);
  hv_WindowRow=TTemp[--SP];

  /*WindowColumn := PrevWindowCoordinates[1] + PrevWindowCoordinates[2] + 5*/
  create_tuple_i(&TTemp[SP++],1);
  T_tuple_select(hv_PrevWindowCoordinates,TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-1]=TTemp[SP];
  create_tuple_i(&TTemp[SP++],2);
  T_tuple_select(hv_PrevWindowCoordinates,TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-1]=TTemp[SP];
  T_tuple_add(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-2]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-2]=TTemp[SP];
  SP--;
  create_tuple_i(&TTemp[SP++],5);
  T_tuple_add(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-2]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-2]=TTemp[SP];
  SP--;
  destroy_tuple(hv_WindowColumn);
  hv_WindowColumn=TTemp[--SP];

  /*WindowWidth := StringWidth + 2 * 12.0*/
  create_tuple_i(&TTemp[SP++],2);
  create_tuple_d(&TTemp[SP++],12.0);
  T_tuple_mult(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-2]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-2]=TTemp[SP];
  SP--;
  T_tuple_add(hv_StringWidth,TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-1]=TTemp[SP];
  destroy_tuple(hv_WindowWidth);
  hv_WindowWidth=TTemp[--SP];

  /*WindowHeight := PrevWindowCoordinates[3]*/
  create_tuple_i(&TTemp[SP++],3);
  T_tuple_select(hv_PrevWindowCoordinates,TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-1]=TTemp[SP];
  destroy_tuple(hv_WindowHeight);
  hv_WindowHeight=TTemp[--SP];

  /**/
  /*dev_open_window (WindowRow, WindowColumn, WindowWidth, WindowHeight, 'black', WindowHandleChild)*/
  create_tuple_s(&TTemp[SP++],"black");
  create_tuple_s(&TTemp[SP++],"background_color");
  T_set_window_attr(TTemp[SP-1],TTemp[SP-2]);
  destroy_tuple(TTemp[--SP]);
  destroy_tuple(TTemp[--SP]);
  create_tuple_i(&TTemp[SP++],0);
  create_tuple_s(&TTemp[SP++],"visible");
  create_tuple_s(&TTemp[SP++],"");
  destroy_tuple((*hv_WindowHandleChild));
  /***/T_open_window(hv_WindowRow,hv_WindowColumn,hv_WindowWidth,hv_WindowHeight,TTemp[SP-3],TTemp[SP-2],TTemp[SP-1],&(*hv_WindowHandleChild));
  destroy_tuple(TTemp[--SP]);
  destroy_tuple(TTemp[--SP]);
  destroy_tuple(TTemp[--SP]);
  hdev_window_stack_push((*hv_WindowHandleChild));

  /*set_display_font (WindowHandleChild, FontSize, Font, 'true', 'false')*/
  create_tuple_s(&TTemp[SP++],"true");
  create_tuple_s(&TTemp[SP++],"false");
  /***/set_display_font((*hv_WindowHandleChild), hv_FontSize, hv_Font, TTemp[SP-2], 
      TTemp[SP-1]);
  destroy_tuple(TTemp[--SP]);
  destroy_tuple(TTemp[--SP]);

  /**/
  /*Return the coordinates of the new window.*/
  /*PrevWindowCoordinatesOut := [WindowRow,WindowColumn,WindowWidth,WindowHeight]*/
  T_tuple_concat(hv_WindowRow,hv_WindowColumn,&TTemp[SP++]);
  T_tuple_concat(TTemp[SP-1],hv_WindowWidth,&TTemp[SP]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-1]=TTemp[SP];
  T_tuple_concat(TTemp[SP-1],hv_WindowHeight,&TTemp[SP]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-1]=TTemp[SP];
  destroy_tuple((*hv_PrevWindowCoordinatesOut));
  (*hv_PrevWindowCoordinatesOut)=TTemp[--SP];

  /**/
  /*Set some meta information about the new child window handle.*/
  /*get_dict_tuple (WindowHandleDict, 'meta_information', MetaInfo)*/
  create_tuple_s(&TTemp[SP++],"meta_information");
  destroy_tuple(hv_MetaInfo);
  /***/T_get_dict_tuple(hv_WindowHandleDict, TTemp[SP-1], &hv_MetaInfo);
  destroy_tuple(TTemp[--SP]);

  /*set_dict_tuple (MetaInfo, WindowHandleKey + '_child_window_coordinates', PrevWindowCoordinatesOut)*/
  create_tuple_s(&TTemp[SP++],"_child_window_coordinates");
  T_tuple_add(hv_WindowHandleKey,TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-1]=TTemp[SP];
  /***/T_set_dict_tuple(hv_MetaInfo, TTemp[SP-1], (*hv_PrevWindowCoordinatesOut));
  destroy_tuple(TTemp[--SP]);

  /*set_dict_tuple (WindowHandleDict, 'meta_information', MetaInfo)*/
  create_tuple_s(&TTemp[SP++],"meta_information");
  /***/T_set_dict_tuple(hv_WindowHandleDict, TTemp[SP-1], hv_MetaInfo);
  destroy_tuple(TTemp[--SP]);

  /**/
  /*========== return ==========*/

  /* Clear temporary tuple stack */
  while (SP > 0)
    destroy_tuple(TTemp[--SP]);
  /* Clear temporary tuple vectors stack*/
  while (SPTV > 0)
    V_destroy_vector(TVTemp[--SPTV]);
  /* Clear local control variables */
  destroy_tuple(hv_StringWidth);
  destroy_tuple(hv_IndexText);
  destroy_tuple(hv__);
  destroy_tuple(hv_TextWidth);
  destroy_tuple(hv_WindowRow);
  destroy_tuple(hv_WindowColumn);
  destroy_tuple(hv_WindowWidth);
  destroy_tuple(hv_WindowHeight);
  destroy_tuple(hv_MetaInfo);

  return;

  /****************************************************/
  /******************     End procedure   *************/
  /****************************************************/

}

/* Chapter: Graphics / Window*/
/* Short Description: Open a new window, either next to the last ones, or in a new row. */
void open_next_window (Htuple hv_Font, Htuple hv_FontSize, Htuple hv_ShowBottomDesc, 
    Htuple hv_WidthImage, Htuple hv_HeightImage, Htuple hv_MapColorBarWidth, Htuple hv_ScaleWindows, 
    Htuple hv_ThresholdWidth, Htuple hv_PrevWindowCoordinates, Htuple hv_WindowHandleDict, 
    Htuple hv_WindowHandleKey, Htuple *hv_WindowHandleNew, Htuple *hv_WindowImageRatioHeight, 
    Htuple *hv_PrevWindowCoordinatesOut)
{

  /* Stack for temporary tuples */
  Htuple   TTemp[100];
  int      SP=0;
  /* Stack for temporary tuple vectors */
  Hvector  TVTemp[100] = {0};
  int      SPTV=0;

  /* Local iconic variables */

  /* Local control variables */
  Htuple  hv_PrevWindowRow, hv_PrevWindowColumn;
  Htuple  hv_PrevWindowWidth, hv_PrevWindowHeight, hv_WindowRow;
  Htuple  hv_WindowColumn, hv_Ascent, hv_Descent, hv__, hv_NumLines;
  Htuple  hv_MarginBottom, hv_WindowWidth, hv_WindowHeight;
  Htuple  hv_WindowImageRatioWidth, hv_SetPartRow2, hv_SetPartColumn2;
  Htuple  hv_MetaInfo;

  /* Array for temporary output ctrl variables */
  Htuple  CExpDummyOCvar[4];

  /* Initialize control variables */
  create_tuple(&hv_PrevWindowRow,0);
  create_tuple(&hv_PrevWindowColumn,0);
  create_tuple(&hv_PrevWindowWidth,0);
  create_tuple(&hv_PrevWindowHeight,0);
  create_tuple(&hv_WindowRow,0);
  create_tuple(&hv_WindowColumn,0);
  create_tuple(&hv_Ascent,0);
  create_tuple(&hv_Descent,0);
  create_tuple(&hv__,0);
  create_tuple(&hv_NumLines,0);
  create_tuple(&hv_MarginBottom,0);
  create_tuple(&hv_WindowWidth,0);
  create_tuple(&hv_WindowHeight,0);
  create_tuple(&hv_WindowImageRatioWidth,0);
  create_tuple(&hv_SetPartRow2,0);
  create_tuple(&hv_SetPartColumn2,0);
  create_tuple(&hv_MetaInfo,0);
  create_tuple(&(*hv_WindowHandleNew),0);
  create_tuple(&(*hv_WindowImageRatioHeight),0);
  create_tuple(&(*hv_PrevWindowCoordinatesOut),0);

  /****************************************************/
  /******************   Begin procedure   *************/
  /****************************************************/

  /**/
  /*This procedure opens a new window, either next to*/
  /*the last ones, or in a new row.*/
  /**/
  /*Get coordinates of previous window.*/
  /*PrevWindowRow := PrevWindowCoordinates[0]*/
  create_tuple_i(&TTemp[SP++],0);
  T_tuple_select(hv_PrevWindowCoordinates,TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-1]=TTemp[SP];
  destroy_tuple(hv_PrevWindowRow);
  hv_PrevWindowRow=TTemp[--SP];

  /*PrevWindowColumn := PrevWindowCoordinates[1]*/
  create_tuple_i(&TTemp[SP++],1);
  T_tuple_select(hv_PrevWindowCoordinates,TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-1]=TTemp[SP];
  destroy_tuple(hv_PrevWindowColumn);
  hv_PrevWindowColumn=TTemp[--SP];

  /*PrevWindowWidth := PrevWindowCoordinates[2]*/
  create_tuple_i(&TTemp[SP++],2);
  T_tuple_select(hv_PrevWindowCoordinates,TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-1]=TTemp[SP];
  destroy_tuple(hv_PrevWindowWidth);
  hv_PrevWindowWidth=TTemp[--SP];

  /*PrevWindowHeight := PrevWindowCoordinates[3]*/
  create_tuple_i(&TTemp[SP++],3);
  T_tuple_select(hv_PrevWindowCoordinates,TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-1]=TTemp[SP];
  destroy_tuple(hv_PrevWindowHeight);
  hv_PrevWindowHeight=TTemp[--SP];

  /**/
  /*========== if (PrevWindowColumn + PrevWindowWidth > ThresholdWidth) ==========*/
  T_tuple_add(hv_PrevWindowColumn,hv_PrevWindowWidth,&TTemp[SP++]);
  T_tuple_greater(TTemp[SP-1],hv_ThresholdWidth,&TTemp[SP]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-1]=TTemp[SP];
  if(get_i(TTemp[SP-1],0))
  {
    /*Open window in new row.*/
    /*WindowRow := PrevWindowRow + PrevWindowHeight + 55*/
    T_tuple_add(hv_PrevWindowRow,hv_PrevWindowHeight,&TTemp[SP++]);
    create_tuple_i(&TTemp[SP++],55);
    T_tuple_add(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-2]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-2]=TTemp[SP];
    SP--;
    destroy_tuple(hv_WindowRow);
    hv_WindowRow=TTemp[--SP];

    /*WindowColumn := 0*/
    reuse_tuple_i(&hv_WindowColumn,0);

  }
  else
  {
    /*Open window in same row.*/
    /*WindowRow := PrevWindowRow*/
    destroy_tuple(hv_WindowRow);
    copy_tuple(hv_PrevWindowRow,&hv_WindowRow);

    /*WindowColumn := PrevWindowColumn + PrevWindowWidth*/
    T_tuple_add(hv_PrevWindowColumn,hv_PrevWindowWidth,&TTemp[SP++]);
    destroy_tuple(hv_WindowColumn);
    hv_WindowColumn=TTemp[--SP];

    /*========== if (WindowColumn != 0) ==========*/
    create_tuple_i(&TTemp[SP++],0);
    T_tuple_not_equal(hv_WindowColumn,TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    if(get_i(TTemp[SP-1],0))
    {
      /*WindowColumn := WindowColumn + 5*/
      create_tuple_i(&TTemp[SP++],5);
      T_tuple_add(hv_WindowColumn,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(hv_WindowColumn);
      hv_WindowColumn=TTemp[SP];
      destroy_tuple(TTemp[--SP]);

    }
    destroy_tuple(TTemp[--SP]);
    /*========== end if ==========*/
  }
  destroy_tuple(TTemp[--SP]);
  /*========== end if ==========*/
  /**/
  /*dev_open_window_fit_size (WindowRow, WindowColumn, WidthImage, HeightImage, [500, 800] * ScaleWindows, [400, 600] * ScaleWindows, WindowHandleNew)*/
  create_tuple(&TTemp[SP++],2);
  set_i(TTemp[SP-1],500  ,0);
  set_i(TTemp[SP-1],800  ,1);
  T_tuple_mult(TTemp[SP-1],hv_ScaleWindows,&TTemp[SP]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-1]=TTemp[SP];
  create_tuple(&TTemp[SP++],2);
  set_i(TTemp[SP-1],400  ,0);
  set_i(TTemp[SP-1],600  ,1);
  T_tuple_mult(TTemp[SP-1],hv_ScaleWindows,&TTemp[SP]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-1]=TTemp[SP];
  destroy_tuple((*hv_WindowHandleNew));
  /***/dev_open_window_fit_size(hv_WindowRow, hv_WindowColumn, hv_WidthImage, hv_HeightImage, 
      TTemp[SP-2], TTemp[SP-1], &(*hv_WindowHandleNew));
  destroy_tuple(TTemp[--SP]);
  destroy_tuple(TTemp[--SP]);

  /*set_display_font (WindowHandleNew, FontSize, Font, 'true', 'false')*/
  create_tuple_s(&TTemp[SP++],"true");
  create_tuple_s(&TTemp[SP++],"false");
  /***/set_display_font((*hv_WindowHandleNew), hv_FontSize, hv_Font, TTemp[SP-2], 
      TTemp[SP-1]);
  destroy_tuple(TTemp[--SP]);
  destroy_tuple(TTemp[--SP]);

  /**/
  /*Add MarginBottom and MapColorBarWidth to window.*/
  /*========== if (ShowBottomDesc) ==========*/
  copy_tuple(hv_ShowBottomDesc,&TTemp[SP++]);
  if(get_i(TTemp[SP-1],0))
  {
    /*get_string_extents (WindowHandleNew, 'Test_string', Ascent, Descent, _, _)*/
    create_tuple_s(&TTemp[SP++],"Test_string");
    destroy_tuple(hv_Ascent);
    destroy_tuple(hv_Descent);
    destroy_tuple(hv__);
    /***/T_get_string_extents((*hv_WindowHandleNew), TTemp[SP-1], &hv_Ascent, &hv_Descent, 
        &hv__, &(CExpDummyOCvar[0]));
    destroy_tuple(TTemp[--SP]);
    destroy_tuple(CExpDummyOCvar[0]);

    /*NumLines := ShowBottomDesc*/
    destroy_tuple(hv_NumLines);
    copy_tuple(hv_ShowBottomDesc,&hv_NumLines);

    /*MarginBottom := NumLines * (Ascent + Descent) + 2 * 12*/
    T_tuple_add(hv_Ascent,hv_Descent,&TTemp[SP++]);
    T_tuple_mult(hv_NumLines,TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    create_tuple_i(&TTemp[SP++],2);
    create_tuple_i(&TTemp[SP++],12);
    T_tuple_mult(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-2]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-2]=TTemp[SP];
    SP--;
    T_tuple_add(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-2]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-2]=TTemp[SP];
    SP--;
    destroy_tuple(hv_MarginBottom);
    hv_MarginBottom=TTemp[--SP];

  }
  else
  {
    /*MarginBottom := 0*/
    reuse_tuple_i(&hv_MarginBottom,0);

  }
  destroy_tuple(TTemp[--SP]);
  /*========== end if ==========*/
  /*get_window_extents (WindowHandleNew, _, _, WindowWidth, WindowHeight)*/
  destroy_tuple(hv__);
  destroy_tuple(hv_WindowWidth);
  destroy_tuple(hv_WindowHeight);
  /***/T_get_window_extents((*hv_WindowHandleNew), &hv__, &(CExpDummyOCvar[0]), &hv_WindowWidth, 
      &hv_WindowHeight);
  destroy_tuple(CExpDummyOCvar[0]);

  if (hdev_window_stack_is_open())
  {
    Htuple active_win;
    create_tuple(&active_win,0);
    hdev_window_stack_get_active(&active_win);
    /*dev_set_window_extents (WindowRow, WindowColumn, WindowWidth + MapColorBarWidth, WindowHeight + MarginBottom)*/
    T_tuple_add(hv_WindowWidth,hv_MapColorBarWidth,&TTemp[SP++]);
    T_tuple_add(hv_WindowHeight,hv_MarginBottom,&TTemp[SP++]);
    /***/T_set_window_extents(active_win,hv_WindowRow, hv_WindowColumn, TTemp[SP-2], 
        TTemp[SP-1]);
    destroy_tuple(TTemp[--SP]);
    destroy_tuple(TTemp[--SP]);
    destroy_tuple(active_win);
  }
  /**/
  /*Get and set meta information of new window handle.*/
  /*update_window_meta_information (WindowHandleNew, WidthImage, HeightImage, WindowRow, WindowColumn, MapColorBarWidth, MarginBottom, WindowImageRatioHeight, WindowImageRatioWidth, SetPartRow2, SetPartColumn2, PrevWindowCoordinatesOut)*/
  destroy_tuple((*hv_WindowImageRatioHeight));
  destroy_tuple(hv_WindowImageRatioWidth);
  destroy_tuple(hv_SetPartRow2);
  destroy_tuple(hv_SetPartColumn2);
  destroy_tuple((*hv_PrevWindowCoordinatesOut));
  /***/update_window_meta_information((*hv_WindowHandleNew), hv_WidthImage, hv_HeightImage, 
      hv_WindowRow, hv_WindowColumn, hv_MapColorBarWidth, hv_MarginBottom, &(*hv_WindowImageRatioHeight), 
      &hv_WindowImageRatioWidth, &hv_SetPartRow2, &hv_SetPartColumn2, &(*hv_PrevWindowCoordinatesOut));

  /**/
  /*Set window handle and some meta information about the new window handle.*/
  /*set_dict_tuple (WindowHandleDict, WindowHandleKey, WindowHandleNew)*/
  /***/T_set_dict_tuple(hv_WindowHandleDict, hv_WindowHandleKey, (*hv_WindowHandleNew));

  /*get_dict_tuple (WindowHandleDict, 'meta_information', MetaInfo)*/
  create_tuple_s(&TTemp[SP++],"meta_information");
  destroy_tuple(hv_MetaInfo);
  /***/T_get_dict_tuple(hv_WindowHandleDict, TTemp[SP-1], &hv_MetaInfo);
  destroy_tuple(TTemp[--SP]);

  /*set_dict_tuple (MetaInfo, WindowHandleKey + '_window_image_ratio_height', WindowImageRatioHeight)*/
  create_tuple_s(&TTemp[SP++],"_window_image_ratio_height");
  T_tuple_add(hv_WindowHandleKey,TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-1]=TTemp[SP];
  /***/T_set_dict_tuple(hv_MetaInfo, TTemp[SP-1], (*hv_WindowImageRatioHeight));
  destroy_tuple(TTemp[--SP]);

  /*set_dict_tuple (MetaInfo, WindowHandleKey + '_window_image_ratio_width', WindowImageRatioWidth)*/
  create_tuple_s(&TTemp[SP++],"_window_image_ratio_width");
  T_tuple_add(hv_WindowHandleKey,TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-1]=TTemp[SP];
  /***/T_set_dict_tuple(hv_MetaInfo, TTemp[SP-1], hv_WindowImageRatioWidth);
  destroy_tuple(TTemp[--SP]);

  /*set_dict_tuple (MetaInfo, WindowHandleKey + '_set_part_row2', SetPartRow2)*/
  create_tuple_s(&TTemp[SP++],"_set_part_row2");
  T_tuple_add(hv_WindowHandleKey,TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-1]=TTemp[SP];
  /***/T_set_dict_tuple(hv_MetaInfo, TTemp[SP-1], hv_SetPartRow2);
  destroy_tuple(TTemp[--SP]);

  /*set_dict_tuple (MetaInfo, WindowHandleKey + '_set_part_column2', SetPartColumn2)*/
  create_tuple_s(&TTemp[SP++],"_set_part_column2");
  T_tuple_add(hv_WindowHandleKey,TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-1]=TTemp[SP];
  /***/T_set_dict_tuple(hv_MetaInfo, TTemp[SP-1], hv_SetPartColumn2);
  destroy_tuple(TTemp[--SP]);

  /*set_dict_tuple (MetaInfo, WindowHandleKey + '_margin_bottom', MarginBottom)*/
  create_tuple_s(&TTemp[SP++],"_margin_bottom");
  T_tuple_add(hv_WindowHandleKey,TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-1]=TTemp[SP];
  /***/T_set_dict_tuple(hv_MetaInfo, TTemp[SP-1], hv_MarginBottom);
  destroy_tuple(TTemp[--SP]);

  /*set_dict_tuple (MetaInfo, WindowHandleKey + '_map_color_bar_with', MapColorBarWidth)*/
  create_tuple_s(&TTemp[SP++],"_map_color_bar_with");
  T_tuple_add(hv_WindowHandleKey,TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-1]=TTemp[SP];
  /***/T_set_dict_tuple(hv_MetaInfo, TTemp[SP-1], hv_MapColorBarWidth);
  destroy_tuple(TTemp[--SP]);

  /*set_dict_tuple (MetaInfo, WindowHandleKey + '_window_coordinates', PrevWindowCoordinatesOut)*/
  create_tuple_s(&TTemp[SP++],"_window_coordinates");
  T_tuple_add(hv_WindowHandleKey,TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-1]=TTemp[SP];
  /***/T_set_dict_tuple(hv_MetaInfo, TTemp[SP-1], (*hv_PrevWindowCoordinatesOut));
  destroy_tuple(TTemp[--SP]);

  /*set_dict_tuple (WindowHandleDict, 'meta_information', MetaInfo)*/
  create_tuple_s(&TTemp[SP++],"meta_information");
  /***/T_set_dict_tuple(hv_WindowHandleDict, TTemp[SP-1], hv_MetaInfo);
  destroy_tuple(TTemp[--SP]);

  /**/
  /*========== return ==========*/

  /* Clear temporary tuple stack */
  while (SP > 0)
    destroy_tuple(TTemp[--SP]);
  /* Clear temporary tuple vectors stack*/
  while (SPTV > 0)
    V_destroy_vector(TVTemp[--SPTV]);
  /* Clear local control variables */
  destroy_tuple(hv_PrevWindowRow);
  destroy_tuple(hv_PrevWindowColumn);
  destroy_tuple(hv_PrevWindowWidth);
  destroy_tuple(hv_PrevWindowHeight);
  destroy_tuple(hv_WindowRow);
  destroy_tuple(hv_WindowColumn);
  destroy_tuple(hv_Ascent);
  destroy_tuple(hv_Descent);
  destroy_tuple(hv__);
  destroy_tuple(hv_NumLines);
  destroy_tuple(hv_MarginBottom);
  destroy_tuple(hv_WindowWidth);
  destroy_tuple(hv_WindowHeight);
  destroy_tuple(hv_WindowImageRatioWidth);
  destroy_tuple(hv_SetPartRow2);
  destroy_tuple(hv_SetPartColumn2);
  destroy_tuple(hv_MetaInfo);

  return;

  /****************************************************/
  /******************     End procedure   *************/
  /****************************************************/

}

/* Chapter: Deep Learning / Model*/
/* Short Description: Preprocess 3D data for deep-learning-based training and inference. */
void preprocess_dl_model_3d_data (Htuple hv_DLSample, Htuple hv_DLPreprocessParam)
{

  /* Stack for temporary tuples */
  Htuple   TTemp[100];
  int      SP=0;
  /* Stack for temporary objects */
  Hobject  OTemp[100] = {0};
  int      SPO=0;
  /* Stack for temporary tuple vectors */
  Hvector  TVTemp[100] = {0};
  int      SPTV=0;
  /* Stack for temporary object vectors */
  Hvector  OVTemp[100] = {0};
  int      SPOV=0;

  /* Local iconic variables */
  Hobject  ho_ImageZ, ho_Domain, ho_Region, ho_ImageReduced;
  Hobject  ho_DomainComplement, ho_ImageX, ho_ImageY, ho_ImageXYZ;
  Hobject  ho_NXImage, ho_NYImage, ho_NZImage, ho_MultiChannelImage;
  Hobject  ho___Tmp_Obj_0;

  /* Local control variables */
  Htuple  hv_HasNormals, hv_XYZKeys, hv_HasXYZ;
  Htuple  hv_HasX, hv_HasY, hv_HasZ, hv_HasFullXYZ, hv_NumChannels;
  Htuple  hv_Type, hv_Index, hv_Key, hv_ZMinMaxExist, hv_GrayvalOutsideInit;
  Htuple  hv_NormalSizeExists, hv_NormalWidth, hv_NormalHeight;
  Htuple  hv_WidthZ, hv_HeightZ, hv_ZoomNormals, hv_Width;
  Htuple  hv_Height, hv_ScaleWidth, hv_ScaleHeight, hv_XIndex;
  Htuple  hv_YIndex;

  /* Initialize iconic variables */
  gen_empty_obj(&ho_ImageZ);
  gen_empty_obj(&ho_Domain);
  gen_empty_obj(&ho_Region);
  gen_empty_obj(&ho_ImageReduced);
  gen_empty_obj(&ho_DomainComplement);
  gen_empty_obj(&ho_ImageX);
  gen_empty_obj(&ho_ImageY);
  gen_empty_obj(&ho_ImageXYZ);
  gen_empty_obj(&ho_NXImage);
  gen_empty_obj(&ho_NYImage);
  gen_empty_obj(&ho_NZImage);
  gen_empty_obj(&ho_MultiChannelImage);
  gen_empty_obj(&ho___Tmp_Obj_0);

  /* Initialize control variables */
  create_tuple(&hv_HasNormals,0);
  create_tuple(&hv_XYZKeys,0);
  create_tuple(&hv_HasXYZ,0);
  create_tuple(&hv_HasX,0);
  create_tuple(&hv_HasY,0);
  create_tuple(&hv_HasZ,0);
  create_tuple(&hv_HasFullXYZ,0);
  create_tuple(&hv_NumChannels,0);
  create_tuple(&hv_Type,0);
  create_tuple(&hv_Index,0);
  create_tuple(&hv_Key,0);
  create_tuple(&hv_ZMinMaxExist,0);
  create_tuple(&hv_GrayvalOutsideInit,0);
  create_tuple(&hv_NormalSizeExists,0);
  create_tuple(&hv_NormalWidth,0);
  create_tuple(&hv_NormalHeight,0);
  create_tuple(&hv_WidthZ,0);
  create_tuple(&hv_HeightZ,0);
  create_tuple(&hv_ZoomNormals,0);
  create_tuple(&hv_Width,0);
  create_tuple(&hv_Height,0);
  create_tuple(&hv_ScaleWidth,0);
  create_tuple(&hv_ScaleHeight,0);
  create_tuple(&hv_XIndex,0);
  create_tuple(&hv_YIndex,0);

  /****************************************************/
  /******************   Begin procedure   *************/
  /****************************************************/

  /**/
  /*This procedure preprocesses 3D data of a DLSample.*/
  /**/
  /*Check presence of inputs in DLSample.*/
  /**/
  /*get_dict_param (DLSample, 'key_exists', 'normals', HasNormals)*/
  create_tuple_s(&TTemp[SP++],"key_exists");
  create_tuple_s(&TTemp[SP++],"normals");
  destroy_tuple(hv_HasNormals);
  /***/T_get_dict_param(hv_DLSample, TTemp[SP-2], TTemp[SP-1], &hv_HasNormals);
  destroy_tuple(TTemp[--SP]);
  destroy_tuple(TTemp[--SP]);

  /*XYZKeys := ['x', 'y', 'z']*/
  create_tuple(&TTemp[SP++],3);
  set_s(TTemp[SP-1],"x",0);
  set_s(TTemp[SP-1],"y",1);
  set_s(TTemp[SP-1],"z",2);
  destroy_tuple(hv_XYZKeys);
  hv_XYZKeys=TTemp[--SP];

  /*get_dict_param (DLSample, 'key_exists', XYZKeys, HasXYZ)*/
  create_tuple_s(&TTemp[SP++],"key_exists");
  destroy_tuple(hv_HasXYZ);
  /***/T_get_dict_param(hv_DLSample, TTemp[SP-1], hv_XYZKeys, &hv_HasXYZ);
  destroy_tuple(TTemp[--SP]);

  /*HasX := HasXYZ[0]*/
  create_tuple_i(&TTemp[SP++],0);
  T_tuple_select(hv_HasXYZ,TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-1]=TTemp[SP];
  destroy_tuple(hv_HasX);
  hv_HasX=TTemp[--SP];

  /*HasY := HasXYZ[1]*/
  create_tuple_i(&TTemp[SP++],1);
  T_tuple_select(hv_HasXYZ,TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-1]=TTemp[SP];
  destroy_tuple(hv_HasY);
  hv_HasY=TTemp[--SP];

  /*HasZ := HasXYZ[2]*/
  create_tuple_i(&TTemp[SP++],2);
  T_tuple_select(hv_HasXYZ,TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-1]=TTemp[SP];
  destroy_tuple(hv_HasZ);
  hv_HasZ=TTemp[--SP];

  /*tuple_min (HasXYZ, HasFullXYZ)*/
  destroy_tuple(hv_HasFullXYZ);
  /***/T_tuple_min(hv_HasXYZ, &hv_HasFullXYZ);

  /*========== if (not HasNormals) ==========*/
  T_tuple_not(hv_HasNormals,&TTemp[SP++]);
  if(get_i(TTemp[SP-1],0))
  {
    /*XYZ are required because normals would need to be computed.*/
    /*========== if (not HasFullXYZ) ==========*/
    T_tuple_not(hv_HasFullXYZ,&TTemp[SP++]);
    if(get_i(TTemp[SP-1],0))
    {
      /* throw(...); only in hdevelop*/
    }
    destroy_tuple(TTemp[--SP]);
    /*========== end if ==========*/
  }
  else
  {
    /*At least Z is required if normals are given.*/
    /*========== if (not HasZ) ==========*/
    T_tuple_not(hv_HasZ,&TTemp[SP++]);
    if(get_i(TTemp[SP-1],0))
    {
      /* throw(...); only in hdevelop*/
    }
    destroy_tuple(TTemp[--SP]);
    /*========== end if ==========*/
    /*count_channels (__get_dict_object( DLSample, ['normals']), NumChannels)*/
    create_tuple_s(&TTemp[SP++],"normals");
    T_get_dict_object(&OTemp[SPO++],hv_DLSample,TTemp[SP-1]);
    destroy_tuple(TTemp[SP-1]);
    SP--;
    destroy_tuple(hv_NumChannels);
    /***/T_count_channels(OTemp[SPO-1], &hv_NumChannels);
    clear_obj(OTemp[--SPO]);

    /*========== if (NumChannels != 3) ==========*/
    create_tuple_i(&TTemp[SP++],3);
    T_tuple_not_equal(hv_NumChannels,TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    if(get_i(TTemp[SP-1],0))
    {
      /* throw(...); only in hdevelop*/
    }
    destroy_tuple(TTemp[--SP]);
    /*========== end if ==========*/
    /*get_image_type (__get_dict_object( DLSample, ['normals']), Type)*/
    create_tuple_s(&TTemp[SP++],"normals");
    T_get_dict_object(&OTemp[SPO++],hv_DLSample,TTemp[SP-1]);
    destroy_tuple(TTemp[SP-1]);
    SP--;
    destroy_tuple(hv_Type);
    /***/T_get_image_type(OTemp[SPO-1], &hv_Type);
    clear_obj(OTemp[--SPO]);

    /*========== if (Type != 'real') ==========*/
    create_tuple_s(&TTemp[SP++],"real");
    T_tuple_not_equal(hv_Type,TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    if(get_i(TTemp[SP-1],0))
    {
      /* throw(...); only in hdevelop*/
    }
    destroy_tuple(TTemp[--SP]);
    /*========== end if ==========*/
  }
  destroy_tuple(TTemp[--SP]);
  /*========== end if ==========*/
  /*========== for Index := 0 to |HasXYZ| - 1 by 1 ==========*/
  T_tuple_length(hv_HasXYZ,&TTemp[SP++]);
  create_tuple_i(&TTemp[SP++],1);
  T_tuple_sub(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-2]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-2]=TTemp[SP];
  SP--;
  create_tuple_i(&TTemp[SP++],1);
  create_tuple_i(&TTemp[SP++],0);
  T_tuple_greater(TTemp[SP-1],TTemp[SP-3],&TTemp[SP]);
  SP++;
  T_tuple_equal(TTemp[SP-2],TTemp[SP-4],&TTemp[SP]);
  if(get_i(TTemp[SP],0) ||
     (!((( get_i(TTemp[SP-1],0)) && (get_d(TTemp[SP-3],0)>0)) ||
        ((!get_i(TTemp[SP-1],0)) && (get_d(TTemp[SP-3],0)<0)))))
  {
   destroy_tuple(TTemp[SP--]);
   destroy_tuple(TTemp[SP]);
   T_tuple_sub(TTemp[SP-1],TTemp[SP-2],&TTemp[SP]);
   destroy_tuple(hv_Index);
   copy_tuple(TTemp[SP],&hv_Index);
   destroy_tuple(TTemp[SP--]);
   destroy_tuple(TTemp[SP]);
   for(;;)
   {
   T_tuple_add(hv_Index,TTemp[SP-1],&TTemp[SP]);
   destroy_tuple(hv_Index);
   copy_tuple(TTemp[SP],&hv_Index);
   destroy_tuple(TTemp[SP]);
   if(get_d(TTemp[SP-1],0)<0)
    T_tuple_less(hv_Index,TTemp[SP-2],&TTemp[SP]);
   else
    T_tuple_greater(hv_Index,TTemp[SP-2],&TTemp[SP]);
   if(get_i(TTemp[SP],0)) break;
   destroy_tuple(TTemp[SP]);
   /*========== for ==========*/

    /*========== if (HasXYZ[Index]) ==========*/
    T_tuple_select(hv_HasXYZ,hv_Index,&TTemp[SP++]);
    if(get_i(TTemp[SP-1],0))
    {
      /*Key := XYZKeys[Index]*/
      T_tuple_select(hv_XYZKeys,hv_Index,&TTemp[SP++]);
      destroy_tuple(hv_Key);
      hv_Key=TTemp[--SP];

      /*count_channels (__get_dict_object( DLSample, Key), NumChannels)*/
      T_get_dict_object(&OTemp[SPO++],hv_DLSample,hv_Key);
      destroy_tuple(hv_NumChannels);
      /***/T_count_channels(OTemp[SPO-1], &hv_NumChannels);
      clear_obj(OTemp[--SPO]);

      /*========== if (NumChannels != 1) ==========*/
      create_tuple_i(&TTemp[SP++],1);
      T_tuple_not_equal(hv_NumChannels,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      if(get_i(TTemp[SP-1],0))
      {
        /* throw(...); only in hdevelop*/
      }
      destroy_tuple(TTemp[--SP]);
      /*========== end if ==========*/
      /*get_image_type (__get_dict_object( DLSample, Key), Type)*/
      T_get_dict_object(&OTemp[SPO++],hv_DLSample,hv_Key);
      destroy_tuple(hv_Type);
      /***/T_get_image_type(OTemp[SPO-1], &hv_Type);
      clear_obj(OTemp[--SPO]);

      /*========== if (Type != 'real') ==========*/
      create_tuple_s(&TTemp[SP++],"real");
      T_tuple_not_equal(hv_Type,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      if(get_i(TTemp[SP-1],0))
      {
        /* throw(...); only in hdevelop*/
      }
      destroy_tuple(TTemp[--SP]);
      /*========== end if ==========*/
    }
    destroy_tuple(TTemp[--SP]);
    /*========== end if ==========*/
   }
   destroy_tuple(TTemp[SP--]);
   destroy_tuple(TTemp[SP--]);
   destroy_tuple(TTemp[SP]);
  }
  else
  {
   destroy_tuple(TTemp[SP--]);
   destroy_tuple(TTemp[SP--]);
   destroy_tuple(TTemp[SP--]);
   destroy_tuple(TTemp[SP--]);
   destroy_tuple(TTemp[SP]);
  }/*========== end for ========*/

  /**/
  /*ImageZ := __get_dict_object( DLSample, ['z'])*/
  create_tuple_s(&TTemp[SP++],"z");
  T_get_dict_object(&OTemp[SPO++],hv_DLSample,TTemp[SP-1]);
  destroy_tuple(TTemp[SP-1]);
  SP--;
  clear_obj(ho_ImageZ);
  ho_ImageZ=OTemp[--SPO];

  /*get_domain (ImageZ, Domain)*/
  clear_obj(ho_Domain);
  /***/get_domain(ho_ImageZ, &ho_Domain);

  /*Reduce Z domain to user-defined min/max values for Z.*/
  /*get_dict_param (DLPreprocessParam, 'key_exists', ['min_z', 'max_z'], ZMinMaxExist)*/
  create_tuple_s(&TTemp[SP++],"key_exists");
  create_tuple(&TTemp[SP++],2);
  set_s(TTemp[SP-1],"min_z",0);
  set_s(TTemp[SP-1],"max_z",1);
  destroy_tuple(hv_ZMinMaxExist);
  /***/T_get_dict_param(hv_DLPreprocessParam, TTemp[SP-2], TTemp[SP-1], &hv_ZMinMaxExist);
  destroy_tuple(TTemp[--SP]);
  destroy_tuple(TTemp[--SP]);

  /*========== if (ZMinMaxExist[0]) ==========*/
  create_tuple_i(&TTemp[SP++],0);
  T_tuple_select(hv_ZMinMaxExist,TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-1]=TTemp[SP];
  if(get_i(TTemp[SP-1],0))
  {
    /*threshold (ImageZ, Region, 'min', __get_dict_tuple( DLPreprocessParam, ['min_z']))*/
    create_tuple_s(&TTemp[SP++],"min");
    create_tuple_s(&TTemp[SP++],"min_z");
    T_get_dict_tuple(hv_DLPreprocessParam,TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    clear_obj(ho_Region);
    /***/T_threshold(ho_ImageZ, &ho_Region, TTemp[SP-2], TTemp[SP-1]);
    destroy_tuple(TTemp[--SP]);
    destroy_tuple(TTemp[--SP]);

    /*difference (Domain, Region, Domain)*/
    /***/difference(ho_Domain, ho_Region, &(OTemp[SPO]));
    SPO++;
    clear_obj(ho_Domain);
    ho_Domain = OTemp[--SPO];

  }
  destroy_tuple(TTemp[--SP]);
  /*========== end if ==========*/
  /*========== if (ZMinMaxExist[1]) ==========*/
  create_tuple_i(&TTemp[SP++],1);
  T_tuple_select(hv_ZMinMaxExist,TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-1]=TTemp[SP];
  if(get_i(TTemp[SP-1],0))
  {
    /*threshold (ImageZ, Region, __get_dict_tuple( DLPreprocessParam, ['max_z']), 'max')*/
    create_tuple_s(&TTemp[SP++],"max_z");
    T_get_dict_tuple(hv_DLPreprocessParam,TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    create_tuple_s(&TTemp[SP++],"max");
    clear_obj(ho_Region);
    /***/T_threshold(ho_ImageZ, &ho_Region, TTemp[SP-2], TTemp[SP-1]);
    destroy_tuple(TTemp[--SP]);
    destroy_tuple(TTemp[--SP]);

    /*difference (Domain, Region, Domain)*/
    /***/difference(ho_Domain, ho_Region, &(OTemp[SPO]));
    SPO++;
    clear_obj(ho_Domain);
    ho_Domain = OTemp[--SPO];

  }
  destroy_tuple(TTemp[--SP]);
  /*========== end if ==========*/
  /*Reduce domain because it might have changed*/
  /*========== if (max(ZMinMaxExist)) ==========*/
  T_tuple_max(hv_ZMinMaxExist,&TTemp[SP++]);
  if(get_i(TTemp[SP-1],0))
  {
    /*reduce_domain (ImageZ, Domain, ImageReduced)*/
    clear_obj(ho_ImageReduced);
    /***/reduce_domain(ho_ImageZ, ho_Domain, &ho_ImageReduced);

  }
  destroy_tuple(TTemp[--SP]);
  /*========== end if ==========*/
  /*complement (Domain, DomainComplement)*/
  clear_obj(ho_DomainComplement);
  /***/complement(ho_Domain, &ho_DomainComplement);

  /**/
  /*Before we zoom any 3D images we want to set all pixels outside of the domain to*/
  /*an invalid value.*/
  /*GrayvalOutsideInit := 0*/
  reuse_tuple_i(&hv_GrayvalOutsideInit,0);


  /*========== if (HasFullXYZ) ==========*/
  copy_tuple(hv_HasFullXYZ,&TTemp[SP++]);
  if(get_i(TTemp[SP-1],0))
  {
    /*ImageX := __get_dict_object( DLSample, ['x'])*/
    create_tuple_s(&TTemp[SP++],"x");
    T_get_dict_object(&OTemp[SPO++],hv_DLSample,TTemp[SP-1]);
    destroy_tuple(TTemp[SP-1]);
    SP--;
    clear_obj(ho_ImageX);
    ho_ImageX=OTemp[--SPO];

    /*ImageY := __get_dict_object( DLSample, ['y'])*/
    create_tuple_s(&TTemp[SP++],"y");
    T_get_dict_object(&OTemp[SPO++],hv_DLSample,TTemp[SP-1]);
    destroy_tuple(TTemp[SP-1]);
    SP--;
    clear_obj(ho_ImageY);
    ho_ImageY=OTemp[--SPO];

    /*ImageZ := __get_dict_object( DLSample, ['z'])*/
    create_tuple_s(&TTemp[SP++],"z");
    T_get_dict_object(&OTemp[SPO++],hv_DLSample,TTemp[SP-1]);
    destroy_tuple(TTemp[SP-1]);
    SP--;
    clear_obj(ho_ImageZ);
    ho_ImageZ=OTemp[--SPO];


    /*full_domain (ImageX, ImageX)*/
    /***/full_domain(ho_ImageX, &(OTemp[SPO]));
    SPO++;
    clear_obj(ho_ImageX);
    ho_ImageX = OTemp[--SPO];

    /*full_domain (ImageY, ImageY)*/
    /***/full_domain(ho_ImageY, &(OTemp[SPO]));
    SPO++;
    clear_obj(ho_ImageY);
    ho_ImageY = OTemp[--SPO];

    /*full_domain (ImageZ, ImageZ)*/
    /***/full_domain(ho_ImageZ, &(OTemp[SPO]));
    SPO++;
    clear_obj(ho_ImageZ);
    ho_ImageZ = OTemp[--SPO];


    /*overpaint_region (ImageX, DomainComplement, GrayvalOutsideInit, 'fill')*/
    create_tuple_s(&TTemp[SP++],"fill");
    /***/T_overpaint_region(ho_ImageX, ho_DomainComplement, hv_GrayvalOutsideInit, 
        TTemp[SP-1]);
    destroy_tuple(TTemp[--SP]);

    /*overpaint_region (ImageY, DomainComplement, GrayvalOutsideInit, 'fill')*/
    create_tuple_s(&TTemp[SP++],"fill");
    /***/T_overpaint_region(ho_ImageY, ho_DomainComplement, hv_GrayvalOutsideInit, 
        TTemp[SP-1]);
    destroy_tuple(TTemp[--SP]);

    /*overpaint_region (ImageZ, DomainComplement, GrayvalOutsideInit, 'fill')*/
    create_tuple_s(&TTemp[SP++],"fill");
    /***/T_overpaint_region(ho_ImageZ, ho_DomainComplement, hv_GrayvalOutsideInit, 
        TTemp[SP-1]);
    destroy_tuple(TTemp[--SP]);


    /*reduce_domain (ImageX, Domain, ImageX)*/
    /***/reduce_domain(ho_ImageX, ho_Domain, &(OTemp[SPO]));
    SPO++;
    clear_obj(ho_ImageX);
    ho_ImageX = OTemp[--SPO];

    /*reduce_domain (ImageY, Domain, ImageY)*/
    /***/reduce_domain(ho_ImageY, ho_Domain, &(OTemp[SPO]));
    SPO++;
    clear_obj(ho_ImageY);
    ho_ImageY = OTemp[--SPO];

    /*reduce_domain (ImageZ, Domain, ImageZ)*/
    /***/reduce_domain(ho_ImageZ, ho_Domain, &(OTemp[SPO]));
    SPO++;
    clear_obj(ho_ImageZ);
    ho_ImageZ = OTemp[--SPO];


    /*========== if (not HasNormals) ==========*/
    T_tuple_not(hv_HasNormals,&TTemp[SP++]);
    if(get_i(TTemp[SP-1],0))
    {
      /*Get optional user-defined resolution of normal computation.*/
      /*get_dict_param (DLPreprocessParam, 'key_exists', ['normal_image_width', 'normal_image_height'], NormalSizeExists)*/
      create_tuple_s(&TTemp[SP++],"key_exists");
      create_tuple(&TTemp[SP++],2);
      set_s(TTemp[SP-1],"normal_image_width",0);
      set_s(TTemp[SP-1],"normal_image_height",1);
      destroy_tuple(hv_NormalSizeExists);
      /***/T_get_dict_param(hv_DLPreprocessParam, TTemp[SP-2], TTemp[SP-1], &hv_NormalSizeExists);
      destroy_tuple(TTemp[--SP]);
      destroy_tuple(TTemp[--SP]);

      /*========== if (not NormalSizeExists[0]) ==========*/
      create_tuple_i(&TTemp[SP++],0);
      T_tuple_select(hv_NormalSizeExists,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      T_tuple_not(TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      if(get_i(TTemp[SP-1],0))
      {
        /*NormalWidth := int(__get_dict_tuple( DLPreprocessParam, ['image_width']) * 1.5)*/
        create_tuple_s(&TTemp[SP++],"image_width");
        T_get_dict_tuple(hv_DLPreprocessParam,TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-1]=TTemp[SP];
        create_tuple_d(&TTemp[SP++],1.5);
        T_tuple_mult(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-2]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-2]=TTemp[SP];
        SP--;
        T_tuple_int(TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-1]=TTemp[SP];
        destroy_tuple(hv_NormalWidth);
        hv_NormalWidth=TTemp[--SP];

      }
      else
      {
        /*NormalWidth := __get_dict_tuple( DLPreprocessParam, ['normal_image_width'])*/
        create_tuple_s(&TTemp[SP++],"normal_image_width");
        T_get_dict_tuple(hv_DLPreprocessParam,TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-1]=TTemp[SP];
        destroy_tuple(hv_NormalWidth);
        hv_NormalWidth=TTemp[--SP];

      }
      destroy_tuple(TTemp[--SP]);
      /*========== end if ==========*/
      /*========== if (not NormalSizeExists[1]) ==========*/
      create_tuple_i(&TTemp[SP++],1);
      T_tuple_select(hv_NormalSizeExists,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      T_tuple_not(TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      if(get_i(TTemp[SP-1],0))
      {
        /*NormalHeight := int(__get_dict_tuple( DLPreprocessParam, ['image_height']) * 1.5)*/
        create_tuple_s(&TTemp[SP++],"image_height");
        T_get_dict_tuple(hv_DLPreprocessParam,TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-1]=TTemp[SP];
        create_tuple_d(&TTemp[SP++],1.5);
        T_tuple_mult(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-2]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-2]=TTemp[SP];
        SP--;
        T_tuple_int(TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-1]=TTemp[SP];
        destroy_tuple(hv_NormalHeight);
        hv_NormalHeight=TTemp[--SP];

      }
      else
      {
        /*NormalHeight := __get_dict_tuple( DLPreprocessParam, ['normal_image_height'])*/
        create_tuple_s(&TTemp[SP++],"normal_image_height");
        T_get_dict_tuple(hv_DLPreprocessParam,TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-1]=TTemp[SP];
        destroy_tuple(hv_NormalHeight);
        hv_NormalHeight=TTemp[--SP];

      }
      destroy_tuple(TTemp[--SP]);
      /*========== end if ==========*/

      /*get_image_size (ImageZ, WidthZ, HeightZ)*/
      destroy_tuple(hv_WidthZ);
      destroy_tuple(hv_HeightZ);
      /***/T_get_image_size(ho_ImageZ, &hv_WidthZ, &hv_HeightZ);

      /*ZoomNormals := NormalWidth != WidthZ or NormalHeight != HeightZ*/
      T_tuple_not_equal(hv_NormalWidth,hv_WidthZ,&TTemp[SP++]);
      T_tuple_not_equal(hv_NormalHeight,hv_HeightZ,&TTemp[SP++]);
      T_tuple_or(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-2]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-2]=TTemp[SP];
      SP--;
      destroy_tuple(hv_ZoomNormals);
      hv_ZoomNormals=TTemp[--SP];


      /*========== if (ZoomNormals) ==========*/
      copy_tuple(hv_ZoomNormals,&TTemp[SP++]);
      if(get_i(TTemp[SP-1],0))
      {
        /*compose3 (ImageX, ImageY, ImageZ, ImageXYZ)*/
        clear_obj(ho_ImageXYZ);
        /***/compose3(ho_ImageX, ho_ImageY, ho_ImageZ, &ho_ImageXYZ);

        /*get_image_size (ImageXYZ, Width, Height)*/
        destroy_tuple(hv_Width);
        destroy_tuple(hv_Height);
        /***/T_get_image_size(ho_ImageXYZ, &hv_Width, &hv_Height);

        /*zoom_image_size (ImageXYZ, ImageXYZ, NormalWidth, NormalHeight, 'nearest_neighbor')*/
        create_tuple_s(&TTemp[SP++],"nearest_neighbor");
        /***/T_zoom_image_size(ho_ImageXYZ, &(OTemp[SPO]), hv_NormalWidth, hv_NormalHeight, 
            TTemp[SP-1]);
        SPO++;
        clear_obj(ho_ImageXYZ);
        ho_ImageXYZ = OTemp[--SPO];
        destroy_tuple(TTemp[--SP]);

        /*access_channel (ImageXYZ, ImageX, 1)*/
        clear_obj(ho_ImageX);
        /***/access_channel(ho_ImageXYZ, &ho_ImageX, 1);

        /*access_channel (ImageXYZ, ImageY, 2)*/
        clear_obj(ho_ImageY);
        /***/access_channel(ho_ImageXYZ, &ho_ImageY, 2);

        /*access_channel (ImageXYZ, ImageZ, 3)*/
        clear_obj(ho_ImageZ);
        /***/access_channel(ho_ImageXYZ, &ho_ImageZ, 3);

        /*ScaleWidth := NormalWidth / real(Width)*/
        T_tuple_real(hv_Width,&TTemp[SP++]);
        T_tuple_div(hv_NormalWidth,TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-1]=TTemp[SP];
        destroy_tuple(hv_ScaleWidth);
        hv_ScaleWidth=TTemp[--SP];

        /*ScaleHeight := NormalHeight / real(Height)*/
        T_tuple_real(hv_Height,&TTemp[SP++]);
        T_tuple_div(hv_NormalHeight,TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-1]=TTemp[SP];
        destroy_tuple(hv_ScaleHeight);
        hv_ScaleHeight=TTemp[--SP];

        /*zoom_region (Domain, Domain, ScaleWidth, ScaleHeight)*/
        /***/T_zoom_region(ho_Domain, &(OTemp[SPO]), hv_ScaleWidth, hv_ScaleHeight);
        SPO++;
        clear_obj(ho_Domain);
        ho_Domain = OTemp[--SPO];

        /*remove_invalid_3d_pixels (ImageX, ImageY, ImageZ, Domain, Domain, GrayvalOutsideInit)*/
        /***/remove_invalid_3d_pixels(ho_ImageX, ho_ImageY, ho_ImageZ, ho_Domain, 
            &(OTemp[SPO]), hv_GrayvalOutsideInit);
        SPO++;
        clear_obj(ho_Domain);
        ho_Domain = OTemp[--SPO];

        /*complement (Domain, DomainComplement)*/
        clear_obj(ho_DomainComplement);
        /***/complement(ho_Domain, &ho_DomainComplement);

      }
      destroy_tuple(TTemp[--SP]);
      /*========== end if ==========*/

      /*compute_normals_xyz (ImageX, ImageY, ImageZ, NXImage, NYImage, NZImage, true)*/
      create_tuple_i(&TTemp[SP++],1);
      clear_obj(ho_NXImage);
      clear_obj(ho_NYImage);
      clear_obj(ho_NZImage);
      /***/compute_normals_xyz(ho_ImageX, ho_ImageY, ho_ImageZ, &ho_NXImage, &ho_NYImage, 
          &ho_NZImage, TTemp[SP-1]);
      destroy_tuple(TTemp[--SP]);

    }
    else
    {
      /*access_channel (__get_dict_object( DLSample, ['normals']), NXImage, 1)*/
      create_tuple_s(&TTemp[SP++],"normals");
      T_get_dict_object(&OTemp[SPO++],hv_DLSample,TTemp[SP-1]);
      destroy_tuple(TTemp[SP-1]);
      SP--;
      clear_obj(ho_NXImage);
      /***/access_channel(OTemp[SPO-1], &ho_NXImage, 1);
      clear_obj(OTemp[--SPO]);

      /*access_channel (__get_dict_object( DLSample, ['normals']), NYImage, 2)*/
      create_tuple_s(&TTemp[SP++],"normals");
      T_get_dict_object(&OTemp[SPO++],hv_DLSample,TTemp[SP-1]);
      destroy_tuple(TTemp[SP-1]);
      SP--;
      clear_obj(ho_NYImage);
      /***/access_channel(OTemp[SPO-1], &ho_NYImage, 2);
      clear_obj(OTemp[--SPO]);

      /*access_channel (__get_dict_object( DLSample, ['normals']), NZImage, 3)*/
      create_tuple_s(&TTemp[SP++],"normals");
      T_get_dict_object(&OTemp[SPO++],hv_DLSample,TTemp[SP-1]);
      destroy_tuple(TTemp[SP-1]);
      SP--;
      clear_obj(ho_NZImage);
      /***/access_channel(OTemp[SPO-1], &ho_NZImage, 3);
      clear_obj(OTemp[--SPO]);

    }
    destroy_tuple(TTemp[--SP]);
    /*========== end if ==========*/
  }
  else
  {
    /*gen_empty_obj (ImageX)*/
    clear_obj(ho_ImageX);
    /***/gen_empty_obj(&ho_ImageX);

    /*gen_empty_obj (ImageY)*/
    clear_obj(ho_ImageY);
    /***/gen_empty_obj(&ho_ImageY);


    /*access_channel (__get_dict_object( DLSample, ['normals']), NXImage, 1)*/
    create_tuple_s(&TTemp[SP++],"normals");
    T_get_dict_object(&OTemp[SPO++],hv_DLSample,TTemp[SP-1]);
    destroy_tuple(TTemp[SP-1]);
    SP--;
    clear_obj(ho_NXImage);
    /***/access_channel(OTemp[SPO-1], &ho_NXImage, 1);
    clear_obj(OTemp[--SPO]);

    /*access_channel (__get_dict_object( DLSample, ['normals']), NYImage, 2)*/
    create_tuple_s(&TTemp[SP++],"normals");
    T_get_dict_object(&OTemp[SPO++],hv_DLSample,TTemp[SP-1]);
    destroy_tuple(TTemp[SP-1]);
    SP--;
    clear_obj(ho_NYImage);
    /***/access_channel(OTemp[SPO-1], &ho_NYImage, 2);
    clear_obj(OTemp[--SPO]);

    /*access_channel (__get_dict_object( DLSample, ['normals']), NZImage, 3)*/
    create_tuple_s(&TTemp[SP++],"normals");
    T_get_dict_object(&OTemp[SPO++],hv_DLSample,TTemp[SP-1]);
    destroy_tuple(TTemp[SP-1]);
    SP--;
    clear_obj(ho_NZImage);
    /***/access_channel(OTemp[SPO-1], &ho_NZImage, 3);
    clear_obj(OTemp[--SPO]);

  }
  destroy_tuple(TTemp[--SP]);
  /*========== end if ==========*/

  /*full_domain (ImageZ, ImageZ)*/
  /***/full_domain(ho_ImageZ, &(OTemp[SPO]));
  SPO++;
  clear_obj(ho_ImageZ);
  ho_ImageZ = OTemp[--SPO];


  /*full_domain (NXImage, NXImage)*/
  /***/full_domain(ho_NXImage, &(OTemp[SPO]));
  SPO++;
  clear_obj(ho_NXImage);
  ho_NXImage = OTemp[--SPO];

  /*full_domain (NYImage, NYImage)*/
  /***/full_domain(ho_NYImage, &(OTemp[SPO]));
  SPO++;
  clear_obj(ho_NYImage);
  ho_NYImage = OTemp[--SPO];

  /*full_domain (NZImage, NZImage)*/
  /***/full_domain(ho_NZImage, &(OTemp[SPO]));
  SPO++;
  clear_obj(ho_NZImage);
  ho_NZImage = OTemp[--SPO];


  /*full_domain does not change the pixels outside of the existing domain.*/
  /*Hence we have to set a specific value*/
  /*overpaint_region (NXImage, DomainComplement, GrayvalOutsideInit, 'fill')*/
  create_tuple_s(&TTemp[SP++],"fill");
  /***/T_overpaint_region(ho_NXImage, ho_DomainComplement, hv_GrayvalOutsideInit, 
      TTemp[SP-1]);
  destroy_tuple(TTemp[--SP]);

  /*overpaint_region (NYImage, DomainComplement, GrayvalOutsideInit, 'fill')*/
  create_tuple_s(&TTemp[SP++],"fill");
  /***/T_overpaint_region(ho_NYImage, ho_DomainComplement, hv_GrayvalOutsideInit, 
      TTemp[SP-1]);
  destroy_tuple(TTemp[--SP]);

  /*overpaint_region (NZImage, DomainComplement, GrayvalOutsideInit, 'fill')*/
  create_tuple_s(&TTemp[SP++],"fill");
  /***/T_overpaint_region(ho_NZImage, ho_DomainComplement, hv_GrayvalOutsideInit, 
      TTemp[SP-1]);
  destroy_tuple(TTemp[--SP]);

  /*overpaint_region (ImageZ, DomainComplement, GrayvalOutsideInit, 'fill')*/
  create_tuple_s(&TTemp[SP++],"fill");
  /***/T_overpaint_region(ho_ImageZ, ho_DomainComplement, hv_GrayvalOutsideInit, 
      TTemp[SP-1]);
  destroy_tuple(TTemp[--SP]);


  /*compose4 (NXImage, NYImage, NZImage, ImageZ, MultiChannelImage)*/
  clear_obj(ho_MultiChannelImage);
  /***/compose4(ho_NXImage, ho_NYImage, ho_NZImage, ho_ImageZ, &ho_MultiChannelImage
      );


  /*count_obj (ImageX, HasX)*/
  destroy_tuple(hv_HasX);
  /***/T_count_obj(ho_ImageX, &hv_HasX);

  /*========== if (HasX) ==========*/
  copy_tuple(hv_HasX,&TTemp[SP++]);
  if(get_i(TTemp[SP-1],0))
  {
    /*full_domain (ImageX, ImageX)*/
    /***/full_domain(ho_ImageX, &(OTemp[SPO]));
    SPO++;
    clear_obj(ho_ImageX);
    ho_ImageX = OTemp[--SPO];

    /*append_channel (MultiChannelImage, ImageX, MultiChannelImage)*/
    /***/append_channel(ho_MultiChannelImage, ho_ImageX, &(OTemp[SPO]));
    SPO++;
    clear_obj(ho_MultiChannelImage);
    ho_MultiChannelImage = OTemp[--SPO];

    /*count_channels (MultiChannelImage, XIndex)*/
    destroy_tuple(hv_XIndex);
    /***/T_count_channels(ho_MultiChannelImage, &hv_XIndex);

  }
  destroy_tuple(TTemp[--SP]);
  /*========== end if ==========*/
  /*count_obj (ImageY, HasY)*/
  destroy_tuple(hv_HasY);
  /***/T_count_obj(ho_ImageY, &hv_HasY);

  /*========== if (HasY) ==========*/
  copy_tuple(hv_HasY,&TTemp[SP++]);
  if(get_i(TTemp[SP-1],0))
  {
    /*full_domain (ImageY, ImageY)*/
    /***/full_domain(ho_ImageY, &(OTemp[SPO]));
    SPO++;
    clear_obj(ho_ImageY);
    ho_ImageY = OTemp[--SPO];

    /*append_channel (MultiChannelImage, ImageY, MultiChannelImage)*/
    /***/append_channel(ho_MultiChannelImage, ho_ImageY, &(OTemp[SPO]));
    SPO++;
    clear_obj(ho_MultiChannelImage);
    ho_MultiChannelImage = OTemp[--SPO];

    /*count_channels (MultiChannelImage, YIndex)*/
    destroy_tuple(hv_YIndex);
    /***/T_count_channels(ho_MultiChannelImage, &hv_YIndex);

  }
  destroy_tuple(TTemp[--SP]);
  /*========== end if ==========*/
  /*get_image_size (MultiChannelImage, Width, Height)*/
  destroy_tuple(hv_Width);
  destroy_tuple(hv_Height);
  /***/T_get_image_size(ho_MultiChannelImage, &hv_Width, &hv_Height);

  /*zoom_image_size (MultiChannelImage, MultiChannelImage, __get_dict_tuple( DLPreprocessParam, ['image_width']), __get_dict_tuple( DLPreprocessParam, ['image_height']), 'nearest_neighbor')*/
  create_tuple_s(&TTemp[SP++],"image_width");
  T_get_dict_tuple(hv_DLPreprocessParam,TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-1]=TTemp[SP];
  create_tuple_s(&TTemp[SP++],"image_height");
  T_get_dict_tuple(hv_DLPreprocessParam,TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-1]=TTemp[SP];
  create_tuple_s(&TTemp[SP++],"nearest_neighbor");
  /***/T_zoom_image_size(ho_MultiChannelImage, &(OTemp[SPO]), TTemp[SP-3], TTemp[SP-2], 
      TTemp[SP-1]);
  SPO++;
  clear_obj(ho_MultiChannelImage);
  ho_MultiChannelImage = OTemp[--SPO];
  destroy_tuple(TTemp[--SP]);
  destroy_tuple(TTemp[--SP]);
  destroy_tuple(TTemp[--SP]);


  /*decompose4 (MultiChannelImage, NXImage, NYImage, NZImage, ImageZ)*/
  clear_obj(ho_NXImage);
  clear_obj(ho_NYImage);
  clear_obj(ho_NZImage);
  clear_obj(ho_ImageZ);
  /***/decompose4(ho_MultiChannelImage, &ho_NXImage, &ho_NYImage, &ho_NZImage, &ho_ImageZ
      );

  /*========== if (HasX) ==========*/
  copy_tuple(hv_HasX,&TTemp[SP++]);
  if(get_i(TTemp[SP-1],0))
  {
    /*access_channel (MultiChannelImage, ImageX, XIndex)*/
    clear_obj(ho_ImageX);
    /***/T_access_channel(ho_MultiChannelImage, &ho_ImageX, hv_XIndex);

  }
  destroy_tuple(TTemp[--SP]);
  /*========== end if ==========*/
  /*========== if (HasY) ==========*/
  copy_tuple(hv_HasY,&TTemp[SP++]);
  if(get_i(TTemp[SP-1],0))
  {
    /*access_channel (MultiChannelImage, ImageY, YIndex)*/
    clear_obj(ho_ImageY);
    /***/T_access_channel(ho_MultiChannelImage, &ho_ImageY, hv_YIndex);

  }
  destroy_tuple(TTemp[--SP]);
  /*========== end if ==========*/


  /*Zoom the domain*/
  /*ScaleWidth := __get_dict_tuple( DLPreprocessParam, ['image_width']) / real(Width)*/
  create_tuple_s(&TTemp[SP++],"image_width");
  T_get_dict_tuple(hv_DLPreprocessParam,TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-1]=TTemp[SP];
  T_tuple_real(hv_Width,&TTemp[SP++]);
  T_tuple_div(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-2]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-2]=TTemp[SP];
  SP--;
  destroy_tuple(hv_ScaleWidth);
  hv_ScaleWidth=TTemp[--SP];

  /*ScaleHeight := __get_dict_tuple( DLPreprocessParam, ['image_height']) / real(Height)*/
  create_tuple_s(&TTemp[SP++],"image_height");
  T_get_dict_tuple(hv_DLPreprocessParam,TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-1]=TTemp[SP];
  T_tuple_real(hv_Height,&TTemp[SP++]);
  T_tuple_div(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-2]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-2]=TTemp[SP];
  SP--;
  destroy_tuple(hv_ScaleHeight);
  hv_ScaleHeight=TTemp[--SP];

  /*zoom_region (Domain, Domain, ScaleWidth, ScaleHeight)*/
  /***/T_zoom_region(ho_Domain, &(OTemp[SPO]), hv_ScaleWidth, hv_ScaleHeight);
  SPO++;
  clear_obj(ho_Domain);
  ho_Domain = OTemp[--SPO];

  /*remove_invalid_3d_pixels (NXImage, NYImage, NZImage, Domain, Domain, GrayvalOutsideInit)*/
  /***/remove_invalid_3d_pixels(ho_NXImage, ho_NYImage, ho_NZImage, ho_Domain, &(OTemp[SPO]), 
      hv_GrayvalOutsideInit);
  SPO++;
  clear_obj(ho_Domain);
  ho_Domain = OTemp[--SPO];


  /*reduce_domain (ImageX, Domain, ImageX)*/
  /***/reduce_domain(ho_ImageX, ho_Domain, &(OTemp[SPO]));
  SPO++;
  clear_obj(ho_ImageX);
  ho_ImageX = OTemp[--SPO];

  /*reduce_domain (ImageY, Domain, ImageY)*/
  /***/reduce_domain(ho_ImageY, ho_Domain, &(OTemp[SPO]));
  SPO++;
  clear_obj(ho_ImageY);
  ho_ImageY = OTemp[--SPO];

  /*reduce_domain (ImageZ, Domain, ImageZ)*/
  /***/reduce_domain(ho_ImageZ, ho_Domain, &(OTemp[SPO]));
  SPO++;
  clear_obj(ho_ImageZ);
  ho_ImageZ = OTemp[--SPO];

  /*compose3 (NXImage, NYImage, NZImage, __Tmp_Obj_0)*/
  clear_obj(ho___Tmp_Obj_0);
  /***/compose3(ho_NXImage, ho_NYImage, ho_NZImage, &ho___Tmp_Obj_0);

  /*set_dict_object (__Tmp_Obj_0, DLSample, ['normals'])*/
  create_tuple_s(&TTemp[SP++],"normals");
  /***/T_set_dict_object(ho___Tmp_Obj_0, hv_DLSample, TTemp[SP-1]);
  destroy_tuple(TTemp[--SP]);

  /*reduce_domain (__get_dict_object( DLSample, ['normals']), Domain, __Tmp_Obj_0)*/
  create_tuple_s(&TTemp[SP++],"normals");
  T_get_dict_object(&OTemp[SPO++],hv_DLSample,TTemp[SP-1]);
  destroy_tuple(TTemp[SP-1]);
  SP--;
  clear_obj(ho___Tmp_Obj_0);
  /***/reduce_domain(OTemp[SPO-1], ho_Domain, &ho___Tmp_Obj_0);
  clear_obj(OTemp[--SPO]);

  /*set_dict_object (__Tmp_Obj_0, DLSample, ['normals'])*/
  create_tuple_s(&TTemp[SP++],"normals");
  /***/T_set_dict_object(ho___Tmp_Obj_0, hv_DLSample, TTemp[SP-1]);
  destroy_tuple(TTemp[--SP]);


  /*Overwrite preprocessed 3D data*/
  /*========== if (HasX) ==========*/
  copy_tuple(hv_HasX,&TTemp[SP++]);
  if(get_i(TTemp[SP-1],0))
  {
    /*set_dict_object (ImageX, DLSample, ['x'])*/
    create_tuple_s(&TTemp[SP++],"x");
    /***/T_set_dict_object(ho_ImageX, hv_DLSample, TTemp[SP-1]);
    destroy_tuple(TTemp[--SP]);

  }
  destroy_tuple(TTemp[--SP]);
  /*========== end if ==========*/
  /*========== if (HasY) ==========*/
  copy_tuple(hv_HasY,&TTemp[SP++]);
  if(get_i(TTemp[SP-1],0))
  {
    /*set_dict_object (ImageY, DLSample, ['y'])*/
    create_tuple_s(&TTemp[SP++],"y");
    /***/T_set_dict_object(ho_ImageY, hv_DLSample, TTemp[SP-1]);
    destroy_tuple(TTemp[--SP]);

  }
  destroy_tuple(TTemp[--SP]);
  /*========== end if ==========*/
  /*========== if (HasZ) ==========*/
  copy_tuple(hv_HasZ,&TTemp[SP++]);
  if(get_i(TTemp[SP-1],0))
  {
    /*set_dict_object (ImageZ, DLSample, ['z'])*/
    create_tuple_s(&TTemp[SP++],"z");
    /***/T_set_dict_object(ho_ImageZ, hv_DLSample, TTemp[SP-1]);
    destroy_tuple(TTemp[--SP]);

  }
  destroy_tuple(TTemp[--SP]);
  /*========== end if ==========*/

  /*========== return ==========*/

  /* Clear temporary tuple stack */
  while (SP > 0)
    destroy_tuple(TTemp[--SP]);
  /* Clear temporary object stack */
  while (SPO > 0)
    clear_obj(OTemp[--SPO]);
  /* Clear temporary tuple vectors stack*/
  while (SPTV > 0)
    V_destroy_vector(TVTemp[--SPTV]);
  /* Clear temporary object vectors stack */
  while (SPOV > 0)
    V_destroy_vector(OVTemp[--SPOV]);
  /* Clear local iconic variables */
  clear_obj(ho_ImageZ);
  clear_obj(ho_Domain);
  clear_obj(ho_Region);
  clear_obj(ho_ImageReduced);
  clear_obj(ho_DomainComplement);
  clear_obj(ho_ImageX);
  clear_obj(ho_ImageY);
  clear_obj(ho_ImageXYZ);
  clear_obj(ho_NXImage);
  clear_obj(ho_NYImage);
  clear_obj(ho_NZImage);
  clear_obj(ho_MultiChannelImage);
  clear_obj(ho___Tmp_Obj_0);

  /* Clear local control variables */
  destroy_tuple(hv_HasNormals);
  destroy_tuple(hv_XYZKeys);
  destroy_tuple(hv_HasXYZ);
  destroy_tuple(hv_HasX);
  destroy_tuple(hv_HasY);
  destroy_tuple(hv_HasZ);
  destroy_tuple(hv_HasFullXYZ);
  destroy_tuple(hv_NumChannels);
  destroy_tuple(hv_Type);
  destroy_tuple(hv_Index);
  destroy_tuple(hv_Key);
  destroy_tuple(hv_ZMinMaxExist);
  destroy_tuple(hv_GrayvalOutsideInit);
  destroy_tuple(hv_NormalSizeExists);
  destroy_tuple(hv_NormalWidth);
  destroy_tuple(hv_NormalHeight);
  destroy_tuple(hv_WidthZ);
  destroy_tuple(hv_HeightZ);
  destroy_tuple(hv_ZoomNormals);
  destroy_tuple(hv_Width);
  destroy_tuple(hv_Height);
  destroy_tuple(hv_ScaleWidth);
  destroy_tuple(hv_ScaleHeight);
  destroy_tuple(hv_XIndex);
  destroy_tuple(hv_YIndex);

  return;

  /****************************************************/
  /******************     End procedure   *************/
  /****************************************************/

}

/* Chapter: Deep Learning / Model*/
/* Short Description: Preprocess anomaly images for evaluation and visualization of deep-learning-based anomaly detection or Global Context Anomaly Detection. */
void preprocess_dl_model_anomaly (Hobject ho_AnomalyImages, Hobject *ho_AnomalyImagesPreprocessed, 
    Htuple hv_DLPreprocessParam)
{


  /* Stack for temporary tuples */
  Htuple   TTemp[100];
  int      SP=0;
  /* Stack for temporary objects */
  Hobject  OTemp[20] = {0};
  int      SPO=0;
  /* Stack for temporary tuple vectors */
  Hvector  TVTemp[100] = {0};
  int      SPTV=0;

  /* Local iconic variables */

  /* Local control variables */
  Htuple  hv_ImageWidth, hv_ImageHeight, hv_ImageRangeMin;
  Htuple  hv_ImageRangeMax, hv_DomainHandling, hv_ModelType;
  Htuple  hv_ImageNumChannels, hv_Min, hv_Max, hv_Range, hv_ImageWidthInput;
  Htuple  hv_ImageHeightInput, hv_EqualWidth, hv_EqualHeight;
  Htuple  hv_Type, hv_NumMatches, hv_NumImages, hv_EqualByte;
  Htuple  hv_NumChannelsAllImages, hv_ImageNumChannelsTuple;
  Htuple  hv_IndicesWrongChannels;

  /* Local copy input parameter variables */
  Hobject  ho_AnomalyImages_COPY_INP_TMP;


  /* Initialize iconic variables */
  gen_empty_obj(&(*ho_AnomalyImagesPreprocessed));
  copy_obj(ho_AnomalyImages,&ho_AnomalyImages_COPY_INP_TMP,1,-1);

  /* Initialize control variables */
  create_tuple(&hv_ImageWidth,0);
  create_tuple(&hv_ImageHeight,0);
  create_tuple(&hv_ImageRangeMin,0);
  create_tuple(&hv_ImageRangeMax,0);
  create_tuple(&hv_DomainHandling,0);
  create_tuple(&hv_ModelType,0);
  create_tuple(&hv_ImageNumChannels,0);
  create_tuple(&hv_Min,0);
  create_tuple(&hv_Max,0);
  create_tuple(&hv_Range,0);
  create_tuple(&hv_ImageWidthInput,0);
  create_tuple(&hv_ImageHeightInput,0);
  create_tuple(&hv_EqualWidth,0);
  create_tuple(&hv_EqualHeight,0);
  create_tuple(&hv_Type,0);
  create_tuple(&hv_NumMatches,0);
  create_tuple(&hv_NumImages,0);
  create_tuple(&hv_EqualByte,0);
  create_tuple(&hv_NumChannelsAllImages,0);
  create_tuple(&hv_ImageNumChannelsTuple,0);
  create_tuple(&hv_IndicesWrongChannels,0);

  /****************************************************/
  /******************   Begin procedure   *************/
  /****************************************************/

  /**/
  /*This procedure preprocesses the anomaly images given by AnomalyImages*/
  /*according to the parameters in the dictionary DLPreprocessParam.*/
  /*Note that depending on the images,*/
  /*additional preprocessing steps might be beneficial.*/
  /**/
  /*Check the validity of the preprocessing parameters.*/
  /*check_dl_preprocess_param (DLPreprocessParam)*/
  /***/check_dl_preprocess_param(hv_DLPreprocessParam);

  /**/
  /*Get the preprocessing parameters.*/
  /*get_dict_tuple (DLPreprocessParam, 'image_width', ImageWidth)*/
  create_tuple_s(&TTemp[SP++],"image_width");
  destroy_tuple(hv_ImageWidth);
  /***/T_get_dict_tuple(hv_DLPreprocessParam, TTemp[SP-1], &hv_ImageWidth);
  destroy_tuple(TTemp[--SP]);

  /*get_dict_tuple (DLPreprocessParam, 'image_height', ImageHeight)*/
  create_tuple_s(&TTemp[SP++],"image_height");
  destroy_tuple(hv_ImageHeight);
  /***/T_get_dict_tuple(hv_DLPreprocessParam, TTemp[SP-1], &hv_ImageHeight);
  destroy_tuple(TTemp[--SP]);

  /*get_dict_tuple (DLPreprocessParam, 'image_range_min', ImageRangeMin)*/
  create_tuple_s(&TTemp[SP++],"image_range_min");
  destroy_tuple(hv_ImageRangeMin);
  /***/T_get_dict_tuple(hv_DLPreprocessParam, TTemp[SP-1], &hv_ImageRangeMin);
  destroy_tuple(TTemp[--SP]);

  /*get_dict_tuple (DLPreprocessParam, 'image_range_max', ImageRangeMax)*/
  create_tuple_s(&TTemp[SP++],"image_range_max");
  destroy_tuple(hv_ImageRangeMax);
  /***/T_get_dict_tuple(hv_DLPreprocessParam, TTemp[SP-1], &hv_ImageRangeMax);
  destroy_tuple(TTemp[--SP]);

  /*get_dict_tuple (DLPreprocessParam, 'domain_handling', DomainHandling)*/
  create_tuple_s(&TTemp[SP++],"domain_handling");
  destroy_tuple(hv_DomainHandling);
  /***/T_get_dict_tuple(hv_DLPreprocessParam, TTemp[SP-1], &hv_DomainHandling);
  destroy_tuple(TTemp[--SP]);

  /*get_dict_tuple (DLPreprocessParam, 'model_type', ModelType)*/
  create_tuple_s(&TTemp[SP++],"model_type");
  destroy_tuple(hv_ModelType);
  /***/T_get_dict_tuple(hv_DLPreprocessParam, TTemp[SP-1], &hv_ModelType);
  destroy_tuple(TTemp[--SP]);

  /**/
  /*ImageNumChannels := 1*/
  reuse_tuple_i(&hv_ImageNumChannels,1);

  /**/
  /*Preprocess the images.*/
  /**/
  /*========== if (DomainHandling == 'full_domain') ==========*/
  create_tuple_s(&TTemp[SP++],"full_domain");
  T_tuple_equal(hv_DomainHandling,TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-1]=TTemp[SP];
  if(get_i(TTemp[SP-1],0))
  {
    /*full_domain (AnomalyImages, AnomalyImages)*/
    /***/full_domain(ho_AnomalyImages_COPY_INP_TMP, &(OTemp[SPO]));
    SPO++;
    clear_obj(ho_AnomalyImages_COPY_INP_TMP);
    ho_AnomalyImages_COPY_INP_TMP = OTemp[--SPO];

  }
  else
  {
  destroy_tuple(TTemp[--SP]);
  /*========== elseif (DomainHandling == 'crop_domain') ==========*/

  create_tuple_s(&TTemp[SP++],"crop_domain");
  T_tuple_equal(hv_DomainHandling,TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-1]=TTemp[SP];
  if(get_i(TTemp[SP-1],0))
  {
    /*crop_domain (AnomalyImages, AnomalyImages)*/
    /***/crop_domain(ho_AnomalyImages_COPY_INP_TMP, &(OTemp[SPO]));
    SPO++;
    clear_obj(ho_AnomalyImages_COPY_INP_TMP);
    ho_AnomalyImages_COPY_INP_TMP = OTemp[--SPO];

  }
  else
  {
  destroy_tuple(TTemp[--SP]);
  /*========== elseif (DomainHandling == 'keep_domain' and ModelType == 'anomaly_detection') ==========*/

  create_tuple_s(&TTemp[SP++],"keep_domain");
  T_tuple_equal(hv_DomainHandling,TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-1]=TTemp[SP];
  create_tuple_s(&TTemp[SP++],"anomaly_detection");
  T_tuple_equal(hv_ModelType,TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-1]=TTemp[SP];
  T_tuple_and(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-2]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-2]=TTemp[SP];
  SP--;
  if(get_i(TTemp[SP-1],0))
  {
    /*The option 'keep_domain' is only supported for models of 'type' = 'anomaly_detection'*/
  }
  else
  {
    /* throw(...); only in hdevelop*/
  }
  }
  }
  destroy_tuple(TTemp[--SP]);
  /*========== end if ==========*/
  /**/
  /*min_max_gray (AnomalyImages, AnomalyImages, 0, Min, Max, Range)*/
  create_tuple_i(&TTemp[SP++],0);
  destroy_tuple(hv_Min);
  destroy_tuple(hv_Max);
  destroy_tuple(hv_Range);
  /***/T_min_max_gray(ho_AnomalyImages_COPY_INP_TMP, ho_AnomalyImages_COPY_INP_TMP, 
      TTemp[SP-1], &hv_Min, &hv_Max, &hv_Range);
  destroy_tuple(TTemp[--SP]);

  /*========== if (Min < 0.0) ==========*/
  create_tuple_d(&TTemp[SP++],0.0);
  T_tuple_less(hv_Min,TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-1]=TTemp[SP];
  if(get_i(TTemp[SP-1],0))
  {
    /* throw(...); only in hdevelop*/
  }
  destroy_tuple(TTemp[--SP]);
  /*========== end if ==========*/
  /**/
  /*Zoom images only if they have a different size than the specified size.*/
  /*get_image_size (AnomalyImages, ImageWidthInput, ImageHeightInput)*/
  destroy_tuple(hv_ImageWidthInput);
  destroy_tuple(hv_ImageHeightInput);
  /***/T_get_image_size(ho_AnomalyImages_COPY_INP_TMP, &hv_ImageWidthInput, &hv_ImageHeightInput);

  /*EqualWidth := ImageWidth [==] ImageWidthInput*/
  T_tuple_equal_elem(hv_ImageWidth,hv_ImageWidthInput,&TTemp[SP++]);
  destroy_tuple(hv_EqualWidth);
  hv_EqualWidth=TTemp[--SP];

  /*EqualHeight := ImageHeight [==] ImageHeightInput*/
  T_tuple_equal_elem(hv_ImageHeight,hv_ImageHeightInput,&TTemp[SP++]);
  destroy_tuple(hv_EqualHeight);
  hv_EqualHeight=TTemp[--SP];

  /*========== if (min(EqualWidth) == 0 or min(EqualHeight) == 0) ==========*/
  T_tuple_min(hv_EqualWidth,&TTemp[SP++]);
  create_tuple_i(&TTemp[SP++],0);
  T_tuple_equal(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-2]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-2]=TTemp[SP];
  SP--;
  T_tuple_min(hv_EqualHeight,&TTemp[SP++]);
  create_tuple_i(&TTemp[SP++],0);
  T_tuple_equal(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-2]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-2]=TTemp[SP];
  SP--;
  T_tuple_or(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-2]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-2]=TTemp[SP];
  SP--;
  if(get_i(TTemp[SP-1],0))
  {
    /*zoom_image_size (AnomalyImages, AnomalyImages, ImageWidth, ImageHeight, 'nearest_neighbor')*/
    create_tuple_s(&TTemp[SP++],"nearest_neighbor");
    /***/T_zoom_image_size(ho_AnomalyImages_COPY_INP_TMP, &(OTemp[SPO]), hv_ImageWidth, 
        hv_ImageHeight, TTemp[SP-1]);
    SPO++;
    clear_obj(ho_AnomalyImages_COPY_INP_TMP);
    ho_AnomalyImages_COPY_INP_TMP = OTemp[--SPO];
    destroy_tuple(TTemp[--SP]);

  }
  destroy_tuple(TTemp[--SP]);
  /*========== end if ==========*/
  /**/
  /*Check the type of the input images.*/
  /*get_image_type (AnomalyImages, Type)*/
  destroy_tuple(hv_Type);
  /***/T_get_image_type(ho_AnomalyImages_COPY_INP_TMP, &hv_Type);

  /*tuple_regexp_test (Type, 'byte|real', NumMatches)*/
  create_tuple_s(&TTemp[SP++],"byte|real");
  destroy_tuple(hv_NumMatches);
  /***/T_tuple_regexp_test(hv_Type, TTemp[SP-1], &hv_NumMatches);
  destroy_tuple(TTemp[--SP]);

  /*count_obj (AnomalyImages, NumImages)*/
  destroy_tuple(hv_NumImages);
  /***/T_count_obj(ho_AnomalyImages_COPY_INP_TMP, &hv_NumImages);

  /*========== if (NumMatches != NumImages) ==========*/
  T_tuple_not_equal(hv_NumMatches,hv_NumImages,&TTemp[SP++]);
  if(get_i(TTemp[SP-1],0))
  {
    /* throw(...); only in hdevelop*/
  }
  destroy_tuple(TTemp[--SP]);
  /*========== end if ==========*/
  /**/
  /*If the type is 'byte', convert it to 'real' and scale it.*/
  /*The gray value scaling does not work on 'byte' images.*/
  /*For 'real' images it is assumed that the range is already correct.*/
  /*EqualByte := Type [==] 'byte'*/
  create_tuple_s(&TTemp[SP++],"byte");
  T_tuple_equal_elem(hv_Type,TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-1]=TTemp[SP];
  destroy_tuple(hv_EqualByte);
  hv_EqualByte=TTemp[--SP];

  /*========== if (max(EqualByte) == 1) ==========*/
  T_tuple_max(hv_EqualByte,&TTemp[SP++]);
  create_tuple_i(&TTemp[SP++],1);
  T_tuple_equal(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-2]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-2]=TTemp[SP];
  SP--;
  if(get_i(TTemp[SP-1],0))
  {
    /*========== if (min(EqualByte) == 0) ==========*/
    T_tuple_min(hv_EqualByte,&TTemp[SP++]);
    create_tuple_i(&TTemp[SP++],0);
    T_tuple_equal(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-2]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-2]=TTemp[SP];
    SP--;
    if(get_i(TTemp[SP-1],0))
    {
      /* throw(...); only in hdevelop*/
    }
    destroy_tuple(TTemp[--SP]);
    /*========== end if ==========*/
    /*Convert the image type from 'byte' to 'real',*/
    /*because the model expects 'real' images.*/
    /*convert_image_type (AnomalyImages, AnomalyImages, 'real')*/
    /***/convert_image_type(ho_AnomalyImages_COPY_INP_TMP, &(OTemp[SPO]), "real");
    SPO++;
    clear_obj(ho_AnomalyImages_COPY_INP_TMP);
    ho_AnomalyImages_COPY_INP_TMP = OTemp[--SPO];

  }
  destroy_tuple(TTemp[--SP]);
  /*========== end if ==========*/
  /**/
  /*Check the number of channels.*/
  /*count_obj (AnomalyImages, NumImages)*/
  destroy_tuple(hv_NumImages);
  /***/T_count_obj(ho_AnomalyImages_COPY_INP_TMP, &hv_NumImages);

  /*Check all images for number of channels.*/
  /*count_channels (AnomalyImages, NumChannelsAllImages)*/
  destroy_tuple(hv_NumChannelsAllImages);
  /***/T_count_channels(ho_AnomalyImages_COPY_INP_TMP, &hv_NumChannelsAllImages);

  /*tuple_gen_const (NumImages, ImageNumChannels, ImageNumChannelsTuple)*/
  destroy_tuple(hv_ImageNumChannelsTuple);
  /***/T_tuple_gen_const(hv_NumImages, hv_ImageNumChannels, &hv_ImageNumChannelsTuple);

  /*tuple_find (NumChannelsAllImages [!=] ImageNumChannelsTuple, 1, IndicesWrongChannels)*/
  T_tuple_not_equal_elem(hv_NumChannelsAllImages,hv_ImageNumChannelsTuple,&TTemp[SP++]);
  create_tuple_i(&TTemp[SP++],1);
  destroy_tuple(hv_IndicesWrongChannels);
  /***/T_tuple_find(TTemp[SP-2], TTemp[SP-1], &hv_IndicesWrongChannels);
  destroy_tuple(TTemp[--SP]);
  destroy_tuple(TTemp[--SP]);

  /**/
  /*Check for anomaly image channels.*/
  /*Only single channel images are accepted.*/
  /*========== if (IndicesWrongChannels != -1) ==========*/
  create_tuple_i(&TTemp[SP++],-1);
  T_tuple_not_equal(hv_IndicesWrongChannels,TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-1]=TTemp[SP];
  if(get_i(TTemp[SP-1],0))
  {
    /* throw(...); only in hdevelop*/
  }
  destroy_tuple(TTemp[--SP]);
  /*========== end if ==========*/
  /**/
  /*Write preprocessed image to output variable.*/
  /*AnomalyImagesPreprocessed := AnomalyImages*/
  clear_obj((*ho_AnomalyImagesPreprocessed));
  copy_obj(ho_AnomalyImages_COPY_INP_TMP,&(*ho_AnomalyImagesPreprocessed),1,-1);

  /**/
  /*========== return ==========*/

  /* Clear temporary tuple stack */
  while (SP > 0)
    destroy_tuple(TTemp[--SP]);
  /* Clear temporary tuple vectors stack*/
  while (SPTV > 0)
    V_destroy_vector(TVTemp[--SPTV]);
  /* Clear local iconic variables */
  clear_obj(ho_AnomalyImages_COPY_INP_TMP);

  /* Clear local control variables */
  destroy_tuple(hv_ImageWidth);
  destroy_tuple(hv_ImageHeight);
  destroy_tuple(hv_ImageRangeMin);
  destroy_tuple(hv_ImageRangeMax);
  destroy_tuple(hv_DomainHandling);
  destroy_tuple(hv_ModelType);
  destroy_tuple(hv_ImageNumChannels);
  destroy_tuple(hv_Min);
  destroy_tuple(hv_Max);
  destroy_tuple(hv_Range);
  destroy_tuple(hv_ImageWidthInput);
  destroy_tuple(hv_ImageHeightInput);
  destroy_tuple(hv_EqualWidth);
  destroy_tuple(hv_EqualHeight);
  destroy_tuple(hv_Type);
  destroy_tuple(hv_NumMatches);
  destroy_tuple(hv_NumImages);
  destroy_tuple(hv_EqualByte);
  destroy_tuple(hv_NumChannelsAllImages);
  destroy_tuple(hv_ImageNumChannelsTuple);
  destroy_tuple(hv_IndicesWrongChannels);

  return;

  /****************************************************/
  /******************     End procedure   *************/
  /****************************************************/

}

/* Chapter: Deep Learning / Model*/
/* Short Description: Preprocess the provided DLSample image for augmentation purposes. */
void preprocess_dl_model_augmentation_data (Htuple hv_DLSample, Htuple hv_DLPreprocessParam)
{

  /* Stack for temporary tuples */
  Htuple   TTemp[100];
  int      SP=0;
  /* Stack for temporary objects */
  Hobject  OTemp[100] = {0};
  int      SPO=0;
  /* Stack for temporary tuple vectors */
  Hvector  TVTemp[100] = {0};
  int      SPTV=0;
  /* Stack for temporary object vectors */
  Hvector  OVTemp[100] = {0};
  int      SPOV=0;

  /* Local iconic variables */
  Hobject  ho_InputImage, ho_ImageHighRes;

  /* Local control variables */
  Htuple  hv_ImageWidth, hv_ImageHeight, hv_ImageNumChannels;
  Htuple  hv_ModelType, hv_AugmentationKeyExists, hv_ImageKeyExists;
  Htuple  hv_NumImages, hv_NumChannels, hv_ImageType, hv_InputImageWidth;
  Htuple  hv_InputImageHeight, hv_InputImageWidthHeightRatio;
  Htuple  hv_ZoomHeight, hv_ZoomWidth, hv_HasPadding, hv_ZoomFactorWidth;
  Htuple  hv_ZoomFactorHeight, hv_UseZoomImage, hv_DLSampleHighRes;
  Htuple  hv_DLPreprocessParamHighRes, hv___Tmp_Ctrl_Dict_Init_0;
  Htuple  hv___Tmp_Ctrl_Dict_Init_1, hv___Tmp_Ctrl_Dict_Init_2;

  /* Initialize iconic variables */
  gen_empty_obj(&ho_InputImage);
  gen_empty_obj(&ho_ImageHighRes);

  /* Initialize control variables */
  create_tuple(&hv_ImageWidth,0);
  create_tuple(&hv_ImageHeight,0);
  create_tuple(&hv_ImageNumChannels,0);
  create_tuple(&hv_ModelType,0);
  create_tuple(&hv_AugmentationKeyExists,0);
  create_tuple(&hv_ImageKeyExists,0);
  create_tuple(&hv_NumImages,0);
  create_tuple(&hv_NumChannels,0);
  create_tuple(&hv_ImageType,0);
  create_tuple(&hv_InputImageWidth,0);
  create_tuple(&hv_InputImageHeight,0);
  create_tuple(&hv_InputImageWidthHeightRatio,0);
  create_tuple(&hv_ZoomHeight,0);
  create_tuple(&hv_ZoomWidth,0);
  create_tuple(&hv_HasPadding,0);
  create_tuple(&hv_ZoomFactorWidth,0);
  create_tuple(&hv_ZoomFactorHeight,0);
  create_tuple(&hv_UseZoomImage,0);
  create_tuple(&hv_DLSampleHighRes,0);
  create_tuple(&hv_DLPreprocessParamHighRes,0);
  create_tuple(&hv___Tmp_Ctrl_Dict_Init_0,0);
  create_tuple(&hv___Tmp_Ctrl_Dict_Init_1,0);
  create_tuple(&hv___Tmp_Ctrl_Dict_Init_2,0);

  /****************************************************/
  /******************   Begin procedure   *************/
  /****************************************************/

  /*This procedure preprocesses the provided DLSample image for augmentation purposes.*/
  /**/
  /*Check the validity of the preprocessing parameters.*/
  /*check_dl_preprocess_param (DLPreprocessParam)*/
  /***/check_dl_preprocess_param(hv_DLPreprocessParam);

  /**/
  /*Get the required preprocessing parameters.*/
  /*ImageWidth := __get_dict_tuple( DLPreprocessParam, ['image_width'])*/
  create_tuple_s(&TTemp[SP++],"image_width");
  T_get_dict_tuple(hv_DLPreprocessParam,TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-1]=TTemp[SP];
  destroy_tuple(hv_ImageWidth);
  hv_ImageWidth=TTemp[--SP];

  /*ImageHeight := __get_dict_tuple( DLPreprocessParam, ['image_height'])*/
  create_tuple_s(&TTemp[SP++],"image_height");
  T_get_dict_tuple(hv_DLPreprocessParam,TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-1]=TTemp[SP];
  destroy_tuple(hv_ImageHeight);
  hv_ImageHeight=TTemp[--SP];

  /*ImageNumChannels := __get_dict_tuple( DLPreprocessParam, ['image_num_channels'])*/
  create_tuple_s(&TTemp[SP++],"image_num_channels");
  T_get_dict_tuple(hv_DLPreprocessParam,TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-1]=TTemp[SP];
  destroy_tuple(hv_ImageNumChannels);
  hv_ImageNumChannels=TTemp[--SP];

  /*ModelType := __get_dict_tuple( DLPreprocessParam, ['model_type'])*/
  create_tuple_s(&TTemp[SP++],"model_type");
  T_get_dict_tuple(hv_DLPreprocessParam,TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-1]=TTemp[SP];
  destroy_tuple(hv_ModelType);
  hv_ModelType=TTemp[--SP];

  /**/
  /*Determine whether the preprocessing is required or not.*/
  /*get_dict_param (DLPreprocessParam, 'key_exists', 'augmentation', AugmentationKeyExists)*/
  create_tuple_s(&TTemp[SP++],"key_exists");
  create_tuple_s(&TTemp[SP++],"augmentation");
  destroy_tuple(hv_AugmentationKeyExists);
  /***/T_get_dict_param(hv_DLPreprocessParam, TTemp[SP-2], TTemp[SP-1], &hv_AugmentationKeyExists);
  destroy_tuple(TTemp[--SP]);
  destroy_tuple(TTemp[--SP]);

  /*========== if (not AugmentationKeyExists) ==========*/
  T_tuple_not(hv_AugmentationKeyExists,&TTemp[SP++]);
  if(get_i(TTemp[SP-1],0))
  {
    /*========== return ==========*/

    /* Clear temporary tuple stack */
    while (SP > 0)
      destroy_tuple(TTemp[--SP]);
    /* Clear temporary object stack */
    while (SPO > 0)
      clear_obj(OTemp[--SPO]);
    /* Clear temporary tuple vectors stack*/
    while (SPTV > 0)
      V_destroy_vector(TVTemp[--SPTV]);
    /* Clear temporary object vectors stack */
    while (SPOV > 0)
      V_destroy_vector(OVTemp[--SPOV]);
    /* Clear local iconic variables */
    clear_obj(ho_InputImage);
    clear_obj(ho_ImageHighRes);

    /* Clear local control variables */
    destroy_tuple(hv_ImageWidth);
    destroy_tuple(hv_ImageHeight);
    destroy_tuple(hv_ImageNumChannels);
    destroy_tuple(hv_ModelType);
    destroy_tuple(hv_AugmentationKeyExists);
    destroy_tuple(hv_ImageKeyExists);
    destroy_tuple(hv_NumImages);
    destroy_tuple(hv_NumChannels);
    destroy_tuple(hv_ImageType);
    destroy_tuple(hv_InputImageWidth);
    destroy_tuple(hv_InputImageHeight);
    destroy_tuple(hv_InputImageWidthHeightRatio);
    destroy_tuple(hv_ZoomHeight);
    destroy_tuple(hv_ZoomWidth);
    destroy_tuple(hv_HasPadding);
    destroy_tuple(hv_ZoomFactorWidth);
    destroy_tuple(hv_ZoomFactorHeight);
    destroy_tuple(hv_UseZoomImage);
    destroy_tuple(hv_DLSampleHighRes);
    destroy_tuple(hv_DLPreprocessParamHighRes);
    destroy_tuple(hv___Tmp_Ctrl_Dict_Init_0);
    destroy_tuple(hv___Tmp_Ctrl_Dict_Init_1);
    destroy_tuple(hv___Tmp_Ctrl_Dict_Init_2);

    return;
  }
  destroy_tuple(TTemp[--SP]);
  /*========== end if ==========*/
  /*create_dict (__Tmp_Ctrl_Dict_Init_0)*/
  destroy_tuple(hv___Tmp_Ctrl_Dict_Init_0);
  /***/T_create_dict(&hv___Tmp_Ctrl_Dict_Init_0);

  /*set_dict_tuple (__Tmp_Ctrl_Dict_Init_0, ['comp'], 'true')*/
  create_tuple_s(&TTemp[SP++],"comp");
  create_tuple_s(&TTemp[SP++],"true");
  /***/T_set_dict_tuple(hv___Tmp_Ctrl_Dict_Init_0, TTemp[SP-2], TTemp[SP-1]);
  destroy_tuple(TTemp[--SP]);
  destroy_tuple(TTemp[--SP]);

  /*========== if (not __test_equal_dict_item([DLPreprocessParam, __Tmp_Ctrl_Dict_Init_0], ['augmentation'], 'comp')) ==========*/
  T_tuple_concat(hv_DLPreprocessParam,hv___Tmp_Ctrl_Dict_Init_0,&TTemp[SP++]);
  create_tuple_s(&TTemp[SP++],"augmentation");
  create_tuple_s(&TTemp[SP++],"comp");
  T_test_equal_dict_item(TTemp[SP-3],TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-3]);
  destroy_tuple(TTemp[SP-2]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-3]=TTemp[SP];
  SP=SP-2;
  T_tuple_not(TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-1]=TTemp[SP];
  if(get_i(TTemp[SP-1],0))
  {
    /*========== return ==========*/

    /* Clear temporary tuple stack */
    while (SP > 0)
      destroy_tuple(TTemp[--SP]);
    /* Clear temporary object stack */
    while (SPO > 0)
      clear_obj(OTemp[--SPO]);
    /* Clear temporary tuple vectors stack*/
    while (SPTV > 0)
      V_destroy_vector(TVTemp[--SPTV]);
    /* Clear temporary object vectors stack */
    while (SPOV > 0)
      V_destroy_vector(OVTemp[--SPOV]);
    /* Clear local iconic variables */
    clear_obj(ho_InputImage);
    clear_obj(ho_ImageHighRes);

    /* Clear local control variables */
    destroy_tuple(hv_ImageWidth);
    destroy_tuple(hv_ImageHeight);
    destroy_tuple(hv_ImageNumChannels);
    destroy_tuple(hv_ModelType);
    destroy_tuple(hv_AugmentationKeyExists);
    destroy_tuple(hv_ImageKeyExists);
    destroy_tuple(hv_NumImages);
    destroy_tuple(hv_NumChannels);
    destroy_tuple(hv_ImageType);
    destroy_tuple(hv_InputImageWidth);
    destroy_tuple(hv_InputImageHeight);
    destroy_tuple(hv_InputImageWidthHeightRatio);
    destroy_tuple(hv_ZoomHeight);
    destroy_tuple(hv_ZoomWidth);
    destroy_tuple(hv_HasPadding);
    destroy_tuple(hv_ZoomFactorWidth);
    destroy_tuple(hv_ZoomFactorHeight);
    destroy_tuple(hv_UseZoomImage);
    destroy_tuple(hv_DLSampleHighRes);
    destroy_tuple(hv_DLPreprocessParamHighRes);
    destroy_tuple(hv___Tmp_Ctrl_Dict_Init_0);
    destroy_tuple(hv___Tmp_Ctrl_Dict_Init_1);
    destroy_tuple(hv___Tmp_Ctrl_Dict_Init_2);

    return;
  }
  destroy_tuple(TTemp[--SP]);
  /*========== end if ==========*/
  /*__Tmp_Ctrl_Dict_Init_0 := constant('HNULL')*/
  create_tuple_s(&TTemp[SP++],"HNULL");
  T_tuple_constant(TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-1]=TTemp[SP];
  destroy_tuple(hv___Tmp_Ctrl_Dict_Init_0);
  hv___Tmp_Ctrl_Dict_Init_0=TTemp[--SP];

  /*========== if (ModelType != 'ocr_detection' and ModelType != 'ocr_recognition') ==========*/
  create_tuple_s(&TTemp[SP++],"ocr_detection");
  T_tuple_not_equal(hv_ModelType,TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-1]=TTemp[SP];
  create_tuple_s(&TTemp[SP++],"ocr_recognition");
  T_tuple_not_equal(hv_ModelType,TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-1]=TTemp[SP];
  T_tuple_and(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-2]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-2]=TTemp[SP];
  SP--;
  if(get_i(TTemp[SP-1],0))
  {
    /*========== return ==========*/

    /* Clear temporary tuple stack */
    while (SP > 0)
      destroy_tuple(TTemp[--SP]);
    /* Clear temporary object stack */
    while (SPO > 0)
      clear_obj(OTemp[--SPO]);
    /* Clear temporary tuple vectors stack*/
    while (SPTV > 0)
      V_destroy_vector(TVTemp[--SPTV]);
    /* Clear temporary object vectors stack */
    while (SPOV > 0)
      V_destroy_vector(OVTemp[--SPOV]);
    /* Clear local iconic variables */
    clear_obj(ho_InputImage);
    clear_obj(ho_ImageHighRes);

    /* Clear local control variables */
    destroy_tuple(hv_ImageWidth);
    destroy_tuple(hv_ImageHeight);
    destroy_tuple(hv_ImageNumChannels);
    destroy_tuple(hv_ModelType);
    destroy_tuple(hv_AugmentationKeyExists);
    destroy_tuple(hv_ImageKeyExists);
    destroy_tuple(hv_NumImages);
    destroy_tuple(hv_NumChannels);
    destroy_tuple(hv_ImageType);
    destroy_tuple(hv_InputImageWidth);
    destroy_tuple(hv_InputImageHeight);
    destroy_tuple(hv_InputImageWidthHeightRatio);
    destroy_tuple(hv_ZoomHeight);
    destroy_tuple(hv_ZoomWidth);
    destroy_tuple(hv_HasPadding);
    destroy_tuple(hv_ZoomFactorWidth);
    destroy_tuple(hv_ZoomFactorHeight);
    destroy_tuple(hv_UseZoomImage);
    destroy_tuple(hv_DLSampleHighRes);
    destroy_tuple(hv_DLPreprocessParamHighRes);
    destroy_tuple(hv___Tmp_Ctrl_Dict_Init_0);
    destroy_tuple(hv___Tmp_Ctrl_Dict_Init_1);
    destroy_tuple(hv___Tmp_Ctrl_Dict_Init_2);

    return;
  }
  destroy_tuple(TTemp[--SP]);
  /*========== end if ==========*/
  /**/
  /*Get the input image and its properties.*/
  /*get_dict_param (DLSample, 'key_exists', 'image', ImageKeyExists)*/
  create_tuple_s(&TTemp[SP++],"key_exists");
  create_tuple_s(&TTemp[SP++],"image");
  destroy_tuple(hv_ImageKeyExists);
  /***/T_get_dict_param(hv_DLSample, TTemp[SP-2], TTemp[SP-1], &hv_ImageKeyExists);
  destroy_tuple(TTemp[--SP]);
  destroy_tuple(TTemp[--SP]);

  /*========== if (not ImageKeyExists) ==========*/
  T_tuple_not(hv_ImageKeyExists,&TTemp[SP++]);
  if(get_i(TTemp[SP-1],0))
  {
    /* throw(...); only in hdevelop*/
  }
  destroy_tuple(TTemp[--SP]);
  /*========== end if ==========*/
  /*InputImage := __get_dict_object( DLSample, ['image'])*/
  create_tuple_s(&TTemp[SP++],"image");
  T_get_dict_object(&OTemp[SPO++],hv_DLSample,TTemp[SP-1]);
  destroy_tuple(TTemp[SP-1]);
  SP--;
  clear_obj(ho_InputImage);
  ho_InputImage=OTemp[--SPO];

  /*count_obj (InputImage, NumImages)*/
  destroy_tuple(hv_NumImages);
  /***/T_count_obj(ho_InputImage, &hv_NumImages);

  /*========== if (NumImages != 1) ==========*/
  create_tuple_i(&TTemp[SP++],1);
  T_tuple_not_equal(hv_NumImages,TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-1]=TTemp[SP];
  if(get_i(TTemp[SP-1],0))
  {
    /* throw(...); only in hdevelop*/
  }
  destroy_tuple(TTemp[--SP]);
  /*========== end if ==========*/
  /*count_channels (InputImage, NumChannels)*/
  destroy_tuple(hv_NumChannels);
  /***/T_count_channels(ho_InputImage, &hv_NumChannels);

  /*get_image_type (InputImage, ImageType)*/
  destroy_tuple(hv_ImageType);
  /***/T_get_image_type(ho_InputImage, &hv_ImageType);

  /*get_image_size (InputImage, InputImageWidth, InputImageHeight)*/
  destroy_tuple(hv_InputImageWidth);
  destroy_tuple(hv_InputImageHeight);
  /***/T_get_image_size(ho_InputImage, &hv_InputImageWidth, &hv_InputImageHeight);

  /**/
  /*Execute model specific preprocessing.*/
  /*========== if (ModelType == 'ocr_recognition') ==========*/
  create_tuple_s(&TTemp[SP++],"ocr_recognition");
  T_tuple_equal(hv_ModelType,TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-1]=TTemp[SP];
  if(get_i(TTemp[SP-1],0))
  {
    /*========== if (ImageNumChannels != 1) ==========*/
    create_tuple_i(&TTemp[SP++],1);
    T_tuple_not_equal(hv_ImageNumChannels,TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    if(get_i(TTemp[SP-1],0))
    {
      /* throw(...); only in hdevelop*/
    }
    destroy_tuple(TTemp[--SP]);
    /*========== end if ==========*/
    /*========== if (regexp_test(ImageType,'byte|real') != 1) ==========*/
    create_tuple_s(&TTemp[SP++],"byte|real");
    T_tuple_regexp_test(hv_ImageType,TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    create_tuple_i(&TTemp[SP++],1);
    T_tuple_not_equal(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-2]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-2]=TTemp[SP];
    SP--;
    if(get_i(TTemp[SP-1],0))
    {
      /* throw(...); only in hdevelop*/
    }
    destroy_tuple(TTemp[--SP]);
    /*========== end if ==========*/
    /*========== if (sum(NumChannels [==] 1 or NumChannels [==] 3) != 1) ==========*/
    create_tuple_i(&TTemp[SP++],1);
    T_tuple_equal_elem(hv_NumChannels,TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    create_tuple_i(&TTemp[SP++],3);
    T_tuple_equal_elem(hv_NumChannels,TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    T_tuple_or(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-2]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-2]=TTemp[SP];
    SP--;
    T_tuple_sum(TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    create_tuple_i(&TTemp[SP++],1);
    T_tuple_not_equal(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-2]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-2]=TTemp[SP];
    SP--;
    if(get_i(TTemp[SP-1],0))
    {
      /* throw(...); only in hdevelop*/
    }
    destroy_tuple(TTemp[--SP]);
    /*========== end if ==========*/
    /**/
    /*full_domain (InputImage, ImageHighRes)*/
    clear_obj(ho_ImageHighRes);
    /***/full_domain(ho_InputImage, &ho_ImageHighRes);

    /*========== if (NumChannels == 3) ==========*/
    create_tuple_i(&TTemp[SP++],3);
    T_tuple_equal(hv_NumChannels,TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    if(get_i(TTemp[SP-1],0))
    {
      /*rgb1_to_gray (ImageHighRes, ImageHighRes)*/
      /***/rgb1_to_gray(ho_ImageHighRes, &(OTemp[SPO]));
      SPO++;
      clear_obj(ho_ImageHighRes);
      ho_ImageHighRes = OTemp[--SPO];

    }
    destroy_tuple(TTemp[--SP]);
    /*========== end if ==========*/
    /*InputImageWidthHeightRatio := InputImageWidth / real(InputImageHeight)*/
    T_tuple_real(hv_InputImageHeight,&TTemp[SP++]);
    T_tuple_div(hv_InputImageWidth,TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    destroy_tuple(hv_InputImageWidthHeightRatio);
    hv_InputImageWidthHeightRatio=TTemp[--SP];

    /*ZoomHeight := min2(InputImageHeight,2 * ImageHeight)*/
    create_tuple_i(&TTemp[SP++],2);
    T_tuple_mult(TTemp[SP-1],hv_ImageHeight,&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    T_tuple_min2(hv_InputImageHeight,TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    destroy_tuple(hv_ZoomHeight);
    hv_ZoomHeight=TTemp[--SP];

    /*ZoomWidth := int(ZoomHeight * InputImageWidthHeightRatio)*/
    T_tuple_mult(hv_ZoomHeight,hv_InputImageWidthHeightRatio,&TTemp[SP++]);
    T_tuple_int(TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    destroy_tuple(hv_ZoomWidth);
    hv_ZoomWidth=TTemp[--SP];

    /*HasPadding := int(ImageHeight * InputImageWidthHeightRatio) < ImageWidth*/
    T_tuple_mult(hv_ImageHeight,hv_InputImageWidthHeightRatio,&TTemp[SP++]);
    T_tuple_int(TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    T_tuple_less(TTemp[SP-1],hv_ImageWidth,&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    destroy_tuple(hv_HasPadding);
    hv_HasPadding=TTemp[--SP];

    /*========== if (ZoomHeight > ImageHeight or HasPadding) ==========*/
    T_tuple_greater(hv_ZoomHeight,hv_ImageHeight,&TTemp[SP++]);
    T_tuple_or(TTemp[SP-1],hv_HasPadding,&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    if(get_i(TTemp[SP-1],0))
    {
      /*zoom_image_size (ImageHighRes, ImageHighRes, ZoomWidth, ZoomHeight, 'constant')*/
      create_tuple_s(&TTemp[SP++],"constant");
      /***/T_zoom_image_size(ho_ImageHighRes, &(OTemp[SPO]), hv_ZoomWidth, hv_ZoomHeight, 
          TTemp[SP-1]);
      SPO++;
      clear_obj(ho_ImageHighRes);
      ho_ImageHighRes = OTemp[--SPO];
      destroy_tuple(TTemp[--SP]);

      /*create_dict (__Tmp_Ctrl_Dict_Init_1)*/
      destroy_tuple(hv___Tmp_Ctrl_Dict_Init_1);
      /***/T_create_dict(&hv___Tmp_Ctrl_Dict_Init_1);

      /*set_dict_tuple (DLSample, ['augmentation_data'], __Tmp_Ctrl_Dict_Init_1)*/
      create_tuple_s(&TTemp[SP++],"augmentation_data");
      /***/T_set_dict_tuple(hv_DLSample, TTemp[SP-1], hv___Tmp_Ctrl_Dict_Init_1);
      destroy_tuple(TTemp[--SP]);

      /*__Tmp_Ctrl_Dict_Init_1 := constant('HNULL')*/
      create_tuple_s(&TTemp[SP++],"HNULL");
      T_tuple_constant(TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      destroy_tuple(hv___Tmp_Ctrl_Dict_Init_1);
      hv___Tmp_Ctrl_Dict_Init_1=TTemp[--SP];

      /*set_dict_object (ImageHighRes, __get_dict_tuple( DLSample, ['augmentation_data']), ['image_high_res'])*/
      create_tuple_s(&TTemp[SP++],"augmentation_data");
      T_get_dict_tuple(hv_DLSample,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      create_tuple_s(&TTemp[SP++],"image_high_res");
      /***/T_set_dict_object(ho_ImageHighRes, TTemp[SP-2], TTemp[SP-1]);
      destroy_tuple(TTemp[--SP]);
      destroy_tuple(TTemp[--SP]);

      /*set_dict_tuple (__get_dict_tuple( DLSample, ['augmentation_data']), ['preprocess_params'], DLPreprocessParam)*/
      create_tuple_s(&TTemp[SP++],"augmentation_data");
      T_get_dict_tuple(hv_DLSample,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      create_tuple_s(&TTemp[SP++],"preprocess_params");
      /***/T_set_dict_tuple(TTemp[SP-2], TTemp[SP-1], hv_DLPreprocessParam);
      destroy_tuple(TTemp[--SP]);
      destroy_tuple(TTemp[--SP]);

    }
    destroy_tuple(TTemp[--SP]);
    /*========== end if ==========*/
  }
  else
  {
  destroy_tuple(TTemp[--SP]);
  /*========== elseif (ModelType == 'ocr_detection') ==========*/

  create_tuple_s(&TTemp[SP++],"ocr_detection");
  T_tuple_equal(hv_ModelType,TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-1]=TTemp[SP];
  if(get_i(TTemp[SP-1],0))
  {
    /*========== if (ImageNumChannels != 3) ==========*/
    create_tuple_i(&TTemp[SP++],3);
    T_tuple_not_equal(hv_ImageNumChannels,TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    if(get_i(TTemp[SP-1],0))
    {
      /* throw(...); only in hdevelop*/
    }
    destroy_tuple(TTemp[--SP]);
    /*========== end if ==========*/
    /*========== if (regexp_test(ImageType,'byte|real') != 1) ==========*/
    create_tuple_s(&TTemp[SP++],"byte|real");
    T_tuple_regexp_test(hv_ImageType,TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    create_tuple_i(&TTemp[SP++],1);
    T_tuple_not_equal(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-2]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-2]=TTemp[SP];
    SP--;
    if(get_i(TTemp[SP-1],0))
    {
      /* throw(...); only in hdevelop*/
    }
    destroy_tuple(TTemp[--SP]);
    /*========== end if ==========*/
    /*========== if (sum(NumChannels [==] 1 or NumChannels [==] 3) != 1) ==========*/
    create_tuple_i(&TTemp[SP++],1);
    T_tuple_equal_elem(hv_NumChannels,TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    create_tuple_i(&TTemp[SP++],3);
    T_tuple_equal_elem(hv_NumChannels,TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    T_tuple_or(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-2]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-2]=TTemp[SP];
    SP--;
    T_tuple_sum(TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    create_tuple_i(&TTemp[SP++],1);
    T_tuple_not_equal(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-2]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-2]=TTemp[SP];
    SP--;
    if(get_i(TTemp[SP-1],0))
    {
      /* throw(...); only in hdevelop*/
    }
    destroy_tuple(TTemp[--SP]);
    /*========== end if ==========*/
    /**/
    /*Calculate aspect-ratio preserving zoom dimensions for high resolution.*/
    /*calculate_dl_image_zoom_factors (InputImageWidth, InputImageHeight, 2 * ImageWidth, 2 * ImageHeight, DLPreprocessParam, ZoomFactorWidth, ZoomFactorHeight)*/
    create_tuple_i(&TTemp[SP++],2);
    T_tuple_mult(TTemp[SP-1],hv_ImageWidth,&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    create_tuple_i(&TTemp[SP++],2);
    T_tuple_mult(TTemp[SP-1],hv_ImageHeight,&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    destroy_tuple(hv_ZoomFactorWidth);
    destroy_tuple(hv_ZoomFactorHeight);
    /***/calculate_dl_image_zoom_factors(hv_InputImageWidth, hv_InputImageHeight, 
        TTemp[SP-2], TTemp[SP-1], hv_DLPreprocessParam, &hv_ZoomFactorWidth, &hv_ZoomFactorHeight);
    destroy_tuple(TTemp[--SP]);
    destroy_tuple(TTemp[--SP]);

    /*ZoomHeight := round(ZoomFactorHeight * InputImageHeight)*/
    T_tuple_mult(hv_ZoomFactorHeight,hv_InputImageHeight,&TTemp[SP++]);
    T_tuple_round(TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    destroy_tuple(hv_ZoomHeight);
    hv_ZoomHeight=TTemp[--SP];

    /*ZoomWidth := round(ZoomFactorWidth * InputImageWidth)*/
    T_tuple_mult(hv_ZoomFactorWidth,hv_InputImageWidth,&TTemp[SP++]);
    T_tuple_round(TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    destroy_tuple(hv_ZoomWidth);
    hv_ZoomWidth=TTemp[--SP];

    /**/
    /*Use the better size for high resolution: 2x resolution size of preprocess image or input image size.*/
    /*UseZoomImage := (ZoomWidth < InputImageWidth) or (ZoomHeight < InputImageHeight)*/
    T_tuple_less(hv_ZoomWidth,hv_InputImageWidth,&TTemp[SP++]);
    T_tuple_less(hv_ZoomHeight,hv_InputImageHeight,&TTemp[SP++]);
    T_tuple_or(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-2]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-2]=TTemp[SP];
    SP--;
    destroy_tuple(hv_UseZoomImage);
    hv_UseZoomImage=TTemp[--SP];

    /*copy_dict (DLSample, [], [], DLSampleHighRes)*/
    create_tuple(&TTemp[SP++],0);
    create_tuple(&TTemp[SP++],0);
    destroy_tuple(hv_DLSampleHighRes);
    /***/T_copy_dict(hv_DLSample, TTemp[SP-2], TTemp[SP-1], &hv_DLSampleHighRes);
    destroy_tuple(TTemp[--SP]);
    destroy_tuple(TTemp[--SP]);

    /*copy_dict (DLPreprocessParam, [], [], DLPreprocessParamHighRes)*/
    create_tuple(&TTemp[SP++],0);
    create_tuple(&TTemp[SP++],0);
    destroy_tuple(hv_DLPreprocessParamHighRes);
    /***/T_copy_dict(hv_DLPreprocessParam, TTemp[SP-2], TTemp[SP-1], &hv_DLPreprocessParamHighRes);
    destroy_tuple(TTemp[--SP]);
    destroy_tuple(TTemp[--SP]);

    /**/
    /*full_domain (InputImage, ImageHighRes)*/
    clear_obj(ho_ImageHighRes);
    /***/full_domain(ho_InputImage, &ho_ImageHighRes);

    /*========== if (UseZoomImage) ==========*/
    copy_tuple(hv_UseZoomImage,&TTemp[SP++]);
    if(get_i(TTemp[SP-1],0))
    {
      /*set_dict_tuple (DLPreprocessParamHighRes, ['image_width'], ZoomWidth)*/
      create_tuple_s(&TTemp[SP++],"image_width");
      /***/T_set_dict_tuple(hv_DLPreprocessParamHighRes, TTemp[SP-1], hv_ZoomWidth);
      destroy_tuple(TTemp[--SP]);

      /*set_dict_tuple (DLPreprocessParamHighRes, ['image_height'], ZoomHeight)*/
      create_tuple_s(&TTemp[SP++],"image_height");
      /***/T_set_dict_tuple(hv_DLPreprocessParamHighRes, TTemp[SP-1], hv_ZoomHeight);
      destroy_tuple(TTemp[--SP]);

      /*preprocess_dl_model_bbox_rect2 (ImageHighRes, DLSampleHighRes, DLPreprocessParamHighRes)*/
      /***/preprocess_dl_model_bbox_rect2(ho_ImageHighRes, hv_DLSampleHighRes, hv_DLPreprocessParamHighRes);

      /*gen_dl_ocr_detection_targets (DLSampleHighRes, DLPreprocessParamHighRes)*/
      /***/gen_dl_ocr_detection_targets(hv_DLSampleHighRes, hv_DLPreprocessParamHighRes);

      /*zoom_image_size (ImageHighRes, ImageHighRes, ZoomWidth, ZoomHeight, 'constant')*/
      create_tuple_s(&TTemp[SP++],"constant");
      /***/T_zoom_image_size(ho_ImageHighRes, &(OTemp[SPO]), hv_ZoomWidth, hv_ZoomHeight, 
          TTemp[SP-1]);
      SPO++;
      clear_obj(ho_ImageHighRes);
      ho_ImageHighRes = OTemp[--SPO];
      destroy_tuple(TTemp[--SP]);

    }
    else
    {
      /*set_dict_tuple (DLPreprocessParamHighRes, ['image_width'], InputImageWidth)*/
      create_tuple_s(&TTemp[SP++],"image_width");
      /***/T_set_dict_tuple(hv_DLPreprocessParamHighRes, TTemp[SP-1], hv_InputImageWidth);
      destroy_tuple(TTemp[--SP]);

      /*set_dict_tuple (DLPreprocessParamHighRes, ['image_height'], InputImageHeight)*/
      create_tuple_s(&TTemp[SP++],"image_height");
      /***/T_set_dict_tuple(hv_DLPreprocessParamHighRes, TTemp[SP-1], hv_InputImageHeight);
      destroy_tuple(TTemp[--SP]);

      /*gen_dl_ocr_detection_targets (DLSampleHighRes, DLPreprocessParamHighRes)*/
      /***/gen_dl_ocr_detection_targets(hv_DLSampleHighRes, hv_DLPreprocessParamHighRes);

    }
    destroy_tuple(TTemp[--SP]);
    /*========== end if ==========*/
    /*set_dict_object (ImageHighRes, DLSampleHighRes, ['image'])*/
    create_tuple_s(&TTemp[SP++],"image");
    /***/T_set_dict_object(ho_ImageHighRes, hv_DLSampleHighRes, TTemp[SP-1]);
    destroy_tuple(TTemp[--SP]);

    /**/
    /*create_dict (__Tmp_Ctrl_Dict_Init_2)*/
    destroy_tuple(hv___Tmp_Ctrl_Dict_Init_2);
    /***/T_create_dict(&hv___Tmp_Ctrl_Dict_Init_2);

    /*set_dict_tuple (DLSample, ['augmentation_data'], __Tmp_Ctrl_Dict_Init_2)*/
    create_tuple_s(&TTemp[SP++],"augmentation_data");
    /***/T_set_dict_tuple(hv_DLSample, TTemp[SP-1], hv___Tmp_Ctrl_Dict_Init_2);
    destroy_tuple(TTemp[--SP]);

    /*__Tmp_Ctrl_Dict_Init_2 := constant('HNULL')*/
    create_tuple_s(&TTemp[SP++],"HNULL");
    T_tuple_constant(TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    destroy_tuple(hv___Tmp_Ctrl_Dict_Init_2);
    hv___Tmp_Ctrl_Dict_Init_2=TTemp[--SP];

    /*set_dict_tuple (__get_dict_tuple( DLSample, ['augmentation_data']), ['sample_high_res'], DLSampleHighRes)*/
    create_tuple_s(&TTemp[SP++],"augmentation_data");
    T_get_dict_tuple(hv_DLSample,TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    create_tuple_s(&TTemp[SP++],"sample_high_res");
    /***/T_set_dict_tuple(TTemp[SP-2], TTemp[SP-1], hv_DLSampleHighRes);
    destroy_tuple(TTemp[--SP]);
    destroy_tuple(TTemp[--SP]);

    /*set_dict_tuple (__get_dict_tuple( DLSample, ['augmentation_data']), ['preprocess_params'], DLPreprocessParam)*/
    create_tuple_s(&TTemp[SP++],"augmentation_data");
    T_get_dict_tuple(hv_DLSample,TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    create_tuple_s(&TTemp[SP++],"preprocess_params");
    /***/T_set_dict_tuple(TTemp[SP-2], TTemp[SP-1], hv_DLPreprocessParam);
    destroy_tuple(TTemp[--SP]);
    destroy_tuple(TTemp[--SP]);

  }
  }
  destroy_tuple(TTemp[--SP]);
  /*========== end if ==========*/
  /**/
  /*========== return ==========*/

  /* Clear temporary tuple stack */
  while (SP > 0)
    destroy_tuple(TTemp[--SP]);
  /* Clear temporary object stack */
  while (SPO > 0)
    clear_obj(OTemp[--SPO]);
  /* Clear temporary tuple vectors stack*/
  while (SPTV > 0)
    V_destroy_vector(TVTemp[--SPTV]);
  /* Clear temporary object vectors stack */
  while (SPOV > 0)
    V_destroy_vector(OVTemp[--SPOV]);
  /* Clear local iconic variables */
  clear_obj(ho_InputImage);
  clear_obj(ho_ImageHighRes);

  /* Clear local control variables */
  destroy_tuple(hv_ImageWidth);
  destroy_tuple(hv_ImageHeight);
  destroy_tuple(hv_ImageNumChannels);
  destroy_tuple(hv_ModelType);
  destroy_tuple(hv_AugmentationKeyExists);
  destroy_tuple(hv_ImageKeyExists);
  destroy_tuple(hv_NumImages);
  destroy_tuple(hv_NumChannels);
  destroy_tuple(hv_ImageType);
  destroy_tuple(hv_InputImageWidth);
  destroy_tuple(hv_InputImageHeight);
  destroy_tuple(hv_InputImageWidthHeightRatio);
  destroy_tuple(hv_ZoomHeight);
  destroy_tuple(hv_ZoomWidth);
  destroy_tuple(hv_HasPadding);
  destroy_tuple(hv_ZoomFactorWidth);
  destroy_tuple(hv_ZoomFactorHeight);
  destroy_tuple(hv_UseZoomImage);
  destroy_tuple(hv_DLSampleHighRes);
  destroy_tuple(hv_DLPreprocessParamHighRes);
  destroy_tuple(hv___Tmp_Ctrl_Dict_Init_0);
  destroy_tuple(hv___Tmp_Ctrl_Dict_Init_1);
  destroy_tuple(hv___Tmp_Ctrl_Dict_Init_2);

  return;

  /****************************************************/
  /******************     End procedure   *************/
  /****************************************************/

}

/* Chapter: Deep Learning / Object Detection and Instance Segmentation*/
/* Short Description: Preprocess the bounding boxes of type 'rectangle1' for a given sample. */
void preprocess_dl_model_bbox_rect1 (Hobject ho_ImageRaw, Htuple hv_DLSample, Htuple hv_DLPreprocessParam)
{


  /* Stack for temporary tuples */
  Htuple   TTemp[100];
  int      SP=0;
  /* Stack for temporary tuple vectors */
  Hvector  TVTemp[100] = {0};
  int      SPTV=0;

  /* Local iconic variables */
  Hobject  ho_DomainRaw;

  /* Local control variables */
  Htuple  hv_ImageWidth, hv_ImageHeight, hv_DomainHandling;
  Htuple  hv_BBoxCol1, hv_BBoxCol2, hv_BBoxRow1, hv_BBoxRow2;
  Htuple  hv_BBoxLabel, hv_Exception, hv_ImageId, hv_ExceptionMessage;
  Htuple  hv_BoxesInvalid, hv_DomainRow1, hv_DomainColumn1;
  Htuple  hv_DomainRow2, hv_DomainColumn2, hv_WidthRaw, hv_HeightRaw;
  Htuple  hv_Row1, hv_Col1, hv_Row2, hv_Col2, hv_MaskDelete;
  Htuple  hv_MaskNewBbox, hv_BBoxCol1New, hv_BBoxCol2New;
  Htuple  hv_BBoxRow1New, hv_BBoxRow2New, hv_BBoxLabelNew;
  Htuple  hv_FactorResampleWidth, hv_FactorResampleHeight;

  /* Initialize iconic variables */
  gen_empty_obj(&ho_DomainRaw);

  /* Initialize control variables */
  create_tuple(&hv_ImageWidth,0);
  create_tuple(&hv_ImageHeight,0);
  create_tuple(&hv_DomainHandling,0);
  create_tuple(&hv_BBoxCol1,0);
  create_tuple(&hv_BBoxCol2,0);
  create_tuple(&hv_BBoxRow1,0);
  create_tuple(&hv_BBoxRow2,0);
  create_tuple(&hv_BBoxLabel,0);
  create_tuple(&hv_Exception,0);
  create_tuple(&hv_ImageId,0);
  create_tuple(&hv_ExceptionMessage,0);
  create_tuple(&hv_BoxesInvalid,0);
  create_tuple(&hv_DomainRow1,0);
  create_tuple(&hv_DomainColumn1,0);
  create_tuple(&hv_DomainRow2,0);
  create_tuple(&hv_DomainColumn2,0);
  create_tuple(&hv_WidthRaw,0);
  create_tuple(&hv_HeightRaw,0);
  create_tuple(&hv_Row1,0);
  create_tuple(&hv_Col1,0);
  create_tuple(&hv_Row2,0);
  create_tuple(&hv_Col2,0);
  create_tuple(&hv_MaskDelete,0);
  create_tuple(&hv_MaskNewBbox,0);
  create_tuple(&hv_BBoxCol1New,0);
  create_tuple(&hv_BBoxCol2New,0);
  create_tuple(&hv_BBoxRow1New,0);
  create_tuple(&hv_BBoxRow2New,0);
  create_tuple(&hv_BBoxLabelNew,0);
  create_tuple(&hv_FactorResampleWidth,0);
  create_tuple(&hv_FactorResampleHeight,0);

  /****************************************************/
  /******************   Begin procedure   *************/
  /****************************************************/

  /**/
  /*This procedure preprocesses the bounding boxes of type 'rectangle1' for a given sample.*/
  /**/
  /*Check the validity of the preprocessing parameters.*/
  /*check_dl_preprocess_param (DLPreprocessParam)*/
  /***/check_dl_preprocess_param(hv_DLPreprocessParam);

  /**/
  /*Get the preprocessing parameters.*/
  /*get_dict_tuple (DLPreprocessParam, 'image_width', ImageWidth)*/
  create_tuple_s(&TTemp[SP++],"image_width");
  destroy_tuple(hv_ImageWidth);
  /***/T_get_dict_tuple(hv_DLPreprocessParam, TTemp[SP-1], &hv_ImageWidth);
  destroy_tuple(TTemp[--SP]);

  /*get_dict_tuple (DLPreprocessParam, 'image_height', ImageHeight)*/
  create_tuple_s(&TTemp[SP++],"image_height");
  destroy_tuple(hv_ImageHeight);
  /***/T_get_dict_tuple(hv_DLPreprocessParam, TTemp[SP-1], &hv_ImageHeight);
  destroy_tuple(TTemp[--SP]);

  /*get_dict_tuple (DLPreprocessParam, 'domain_handling', DomainHandling)*/
  create_tuple_s(&TTemp[SP++],"domain_handling");
  destroy_tuple(hv_DomainHandling);
  /***/T_get_dict_tuple(hv_DLPreprocessParam, TTemp[SP-1], &hv_DomainHandling);
  destroy_tuple(TTemp[--SP]);

  /**/
  /*Get bounding box coordinates and labels.*/
  /* try(...); only in hdevelop*/
    /*get_dict_tuple (DLSample, 'bbox_col1', BBoxCol1)*/
    create_tuple_s(&TTemp[SP++],"bbox_col1");
    destroy_tuple(hv_BBoxCol1);
    /***/T_get_dict_tuple(hv_DLSample, TTemp[SP-1], &hv_BBoxCol1);
    destroy_tuple(TTemp[--SP]);

    /*get_dict_tuple (DLSample, 'bbox_col2', BBoxCol2)*/
    create_tuple_s(&TTemp[SP++],"bbox_col2");
    destroy_tuple(hv_BBoxCol2);
    /***/T_get_dict_tuple(hv_DLSample, TTemp[SP-1], &hv_BBoxCol2);
    destroy_tuple(TTemp[--SP]);

    /*get_dict_tuple (DLSample, 'bbox_row1', BBoxRow1)*/
    create_tuple_s(&TTemp[SP++],"bbox_row1");
    destroy_tuple(hv_BBoxRow1);
    /***/T_get_dict_tuple(hv_DLSample, TTemp[SP-1], &hv_BBoxRow1);
    destroy_tuple(TTemp[--SP]);

    /*get_dict_tuple (DLSample, 'bbox_row2', BBoxRow2)*/
    create_tuple_s(&TTemp[SP++],"bbox_row2");
    destroy_tuple(hv_BBoxRow2);
    /***/T_get_dict_tuple(hv_DLSample, TTemp[SP-1], &hv_BBoxRow2);
    destroy_tuple(TTemp[--SP]);

    /*get_dict_tuple (DLSample, 'bbox_label_id', BBoxLabel)*/
    create_tuple_s(&TTemp[SP++],"bbox_label_id");
    destroy_tuple(hv_BBoxLabel);
    /***/T_get_dict_tuple(hv_DLSample, TTemp[SP-1], &hv_BBoxLabel);
    destroy_tuple(TTemp[--SP]);

  /* catch(...); only in hdevelop*/
    /* get_dict_tuple(...); only in hdevelop*/
    /* if(...); only in hdevelop*/
      /* assign(...); only in hdevelop*/
    /* else(...); only in hdevelop*/
      /* assign(...); only in hdevelop*/
    /* endif(...); only in hdevelop*/
    /* throw(...); only in hdevelop*/
  /* endtry(...); only in hdevelop*/
  /**/
  /*Check that there are no invalid boxes.*/
  /*========== if (|BBoxRow1| > 0) ==========*/
  T_tuple_length(hv_BBoxRow1,&TTemp[SP++]);
  create_tuple_i(&TTemp[SP++],0);
  T_tuple_greater(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-2]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-2]=TTemp[SP];
  SP--;
  if(get_i(TTemp[SP-1],0))
  {
    /*BoxesInvalid := (BBoxRow1 [>=] BBoxRow2) or (BBoxCol1 [>=] BBoxCol2)*/
    T_tuple_greater_equal_elem(hv_BBoxRow1,hv_BBoxRow2,&TTemp[SP++]);
    T_tuple_greater_equal_elem(hv_BBoxCol1,hv_BBoxCol2,&TTemp[SP++]);
    T_tuple_or(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-2]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-2]=TTemp[SP];
    SP--;
    destroy_tuple(hv_BoxesInvalid);
    hv_BoxesInvalid=TTemp[--SP];

    /*========== if (sum(BoxesInvalid) > 0) ==========*/
    T_tuple_sum(hv_BoxesInvalid,&TTemp[SP++]);
    create_tuple_i(&TTemp[SP++],0);
    T_tuple_greater(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-2]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-2]=TTemp[SP];
    SP--;
    if(get_i(TTemp[SP-1],0))
    {
      /*get_dict_tuple (DLSample, 'image_id', ImageId)*/
      create_tuple_s(&TTemp[SP++],"image_id");
      destroy_tuple(hv_ImageId);
      /***/T_get_dict_tuple(hv_DLSample, TTemp[SP-1], &hv_ImageId);
      destroy_tuple(TTemp[--SP]);

      /* throw(...); only in hdevelop*/
    }
    destroy_tuple(TTemp[--SP]);
    /*========== end if ==========*/
  }
  else
  {
    /*There are no bounding boxes, hence nothing to do.*/
    /*========== return ==========*/

    /* Clear temporary tuple stack */
    while (SP > 0)
      destroy_tuple(TTemp[--SP]);
    /* Clear temporary tuple vectors stack*/
    while (SPTV > 0)
      V_destroy_vector(TVTemp[--SPTV]);
    /* Clear local iconic variables */
    clear_obj(ho_DomainRaw);

    /* Clear local control variables */
    destroy_tuple(hv_ImageWidth);
    destroy_tuple(hv_ImageHeight);
    destroy_tuple(hv_DomainHandling);
    destroy_tuple(hv_BBoxCol1);
    destroy_tuple(hv_BBoxCol2);
    destroy_tuple(hv_BBoxRow1);
    destroy_tuple(hv_BBoxRow2);
    destroy_tuple(hv_BBoxLabel);
    destroy_tuple(hv_Exception);
    destroy_tuple(hv_ImageId);
    destroy_tuple(hv_ExceptionMessage);
    destroy_tuple(hv_BoxesInvalid);
    destroy_tuple(hv_DomainRow1);
    destroy_tuple(hv_DomainColumn1);
    destroy_tuple(hv_DomainRow2);
    destroy_tuple(hv_DomainColumn2);
    destroy_tuple(hv_WidthRaw);
    destroy_tuple(hv_HeightRaw);
    destroy_tuple(hv_Row1);
    destroy_tuple(hv_Col1);
    destroy_tuple(hv_Row2);
    destroy_tuple(hv_Col2);
    destroy_tuple(hv_MaskDelete);
    destroy_tuple(hv_MaskNewBbox);
    destroy_tuple(hv_BBoxCol1New);
    destroy_tuple(hv_BBoxCol2New);
    destroy_tuple(hv_BBoxRow1New);
    destroy_tuple(hv_BBoxRow2New);
    destroy_tuple(hv_BBoxLabelNew);
    destroy_tuple(hv_FactorResampleWidth);
    destroy_tuple(hv_FactorResampleHeight);

    return;
  }
  destroy_tuple(TTemp[--SP]);
  /*========== end if ==========*/
  /**/
  /*If the domain is cropped, crop bounding boxes.*/
  /*========== if (DomainHandling == 'crop_domain') ==========*/
  create_tuple_s(&TTemp[SP++],"crop_domain");
  T_tuple_equal(hv_DomainHandling,TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-1]=TTemp[SP];
  if(get_i(TTemp[SP-1],0))
  {
    /**/
    /*Get domain.*/
    /*get_domain (ImageRaw, DomainRaw)*/
    clear_obj(ho_DomainRaw);
    /***/get_domain(ho_ImageRaw, &ho_DomainRaw);

    /**/
    /*Set the size of the raw image to the domain extensions.*/
    /*smallest_rectangle1 (DomainRaw, DomainRow1, DomainColumn1, DomainRow2, DomainColumn2)*/
    destroy_tuple(hv_DomainRow1);
    destroy_tuple(hv_DomainColumn1);
    destroy_tuple(hv_DomainRow2);
    destroy_tuple(hv_DomainColumn2);
    /***/T_smallest_rectangle1(ho_DomainRaw, &hv_DomainRow1, &hv_DomainColumn1, &hv_DomainRow2, 
        &hv_DomainColumn2);

    /*The domain is always given as a pixel-precise region.*/
    /*WidthRaw := DomainColumn2 - DomainColumn1 + 1.0*/
    T_tuple_sub(hv_DomainColumn2,hv_DomainColumn1,&TTemp[SP++]);
    create_tuple_d(&TTemp[SP++],1.0);
    T_tuple_add(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-2]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-2]=TTemp[SP];
    SP--;
    destroy_tuple(hv_WidthRaw);
    hv_WidthRaw=TTemp[--SP];

    /*HeightRaw := DomainRow2 - DomainRow1 + 1.0*/
    T_tuple_sub(hv_DomainRow2,hv_DomainRow1,&TTemp[SP++]);
    create_tuple_d(&TTemp[SP++],1.0);
    T_tuple_add(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-2]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-2]=TTemp[SP];
    SP--;
    destroy_tuple(hv_HeightRaw);
    hv_HeightRaw=TTemp[--SP];

    /**/
    /*Crop the bounding boxes.*/
    /*Row1 := max2(BBoxRow1,DomainRow1 - .5)*/
    create_tuple_d(&TTemp[SP++],.5);
    T_tuple_sub(hv_DomainRow1,TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    T_tuple_max2(hv_BBoxRow1,TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    destroy_tuple(hv_Row1);
    hv_Row1=TTemp[--SP];

    /*Col1 := max2(BBoxCol1,DomainColumn1 - .5)*/
    create_tuple_d(&TTemp[SP++],.5);
    T_tuple_sub(hv_DomainColumn1,TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    T_tuple_max2(hv_BBoxCol1,TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    destroy_tuple(hv_Col1);
    hv_Col1=TTemp[--SP];

    /*Row2 := min2(BBoxRow2,DomainRow2 + .5)*/
    create_tuple_d(&TTemp[SP++],.5);
    T_tuple_add(hv_DomainRow2,TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    T_tuple_min2(hv_BBoxRow2,TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    destroy_tuple(hv_Row2);
    hv_Row2=TTemp[--SP];

    /*Col2 := min2(BBoxCol2,DomainColumn2 + .5)*/
    create_tuple_d(&TTemp[SP++],.5);
    T_tuple_add(hv_DomainColumn2,TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    T_tuple_min2(hv_BBoxCol2,TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    destroy_tuple(hv_Col2);
    hv_Col2=TTemp[--SP];

    /*MaskDelete := (Row1 [>=] Row2) or (Col1 [>=] Col2)*/
    T_tuple_greater_equal_elem(hv_Row1,hv_Row2,&TTemp[SP++]);
    T_tuple_greater_equal_elem(hv_Col1,hv_Col2,&TTemp[SP++]);
    T_tuple_or(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-2]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-2]=TTemp[SP];
    SP--;
    destroy_tuple(hv_MaskDelete);
    hv_MaskDelete=TTemp[--SP];

    /*MaskNewBbox := 1 - MaskDelete*/
    create_tuple_i(&TTemp[SP++],1);
    T_tuple_sub(TTemp[SP-1],hv_MaskDelete,&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    destroy_tuple(hv_MaskNewBbox);
    hv_MaskNewBbox=TTemp[--SP];

    /*Store the preprocessed bounding box entries.*/
    /*BBoxCol1New := select_mask(Col1,MaskNewBbox) - DomainColumn1*/
    T_tuple_select_mask(hv_Col1,hv_MaskNewBbox,&TTemp[SP++]);
    T_tuple_sub(TTemp[SP-1],hv_DomainColumn1,&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    destroy_tuple(hv_BBoxCol1New);
    hv_BBoxCol1New=TTemp[--SP];

    /*BBoxCol2New := select_mask(Col2,MaskNewBbox) - DomainColumn1*/
    T_tuple_select_mask(hv_Col2,hv_MaskNewBbox,&TTemp[SP++]);
    T_tuple_sub(TTemp[SP-1],hv_DomainColumn1,&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    destroy_tuple(hv_BBoxCol2New);
    hv_BBoxCol2New=TTemp[--SP];

    /*BBoxRow1New := select_mask(Row1,MaskNewBbox) - DomainRow1*/
    T_tuple_select_mask(hv_Row1,hv_MaskNewBbox,&TTemp[SP++]);
    T_tuple_sub(TTemp[SP-1],hv_DomainRow1,&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    destroy_tuple(hv_BBoxRow1New);
    hv_BBoxRow1New=TTemp[--SP];

    /*BBoxRow2New := select_mask(Row2,MaskNewBbox) - DomainRow1*/
    T_tuple_select_mask(hv_Row2,hv_MaskNewBbox,&TTemp[SP++]);
    T_tuple_sub(TTemp[SP-1],hv_DomainRow1,&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    destroy_tuple(hv_BBoxRow2New);
    hv_BBoxRow2New=TTemp[--SP];

    /*BBoxLabelNew := select_mask(BBoxLabel,MaskNewBbox)*/
    T_tuple_select_mask(hv_BBoxLabel,hv_MaskNewBbox,&TTemp[SP++]);
    destroy_tuple(hv_BBoxLabelNew);
    hv_BBoxLabelNew=TTemp[--SP];

    /**/
    /*If we remove/select bounding boxes we also need to filter the corresponding*/
    /*instance segmentation masks if they exist.*/
    /*filter_dl_sample_instance_segmentation_masks (DLSample, MaskNewBbox)*/
    /***/filter_dl_sample_instance_segmentation_masks(hv_DLSample, hv_MaskNewBbox);

  }
  else
  {
  destroy_tuple(TTemp[--SP]);
  /*========== elseif (DomainHandling == 'full_domain') ==========*/

  create_tuple_s(&TTemp[SP++],"full_domain");
  T_tuple_equal(hv_DomainHandling,TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-1]=TTemp[SP];
  if(get_i(TTemp[SP-1],0))
  {
    /*If the entire image is used, set the variables accordingly.*/
    /*Get the original size.*/
    /*get_image_size (ImageRaw, WidthRaw, HeightRaw)*/
    destroy_tuple(hv_WidthRaw);
    destroy_tuple(hv_HeightRaw);
    /***/T_get_image_size(ho_ImageRaw, &hv_WidthRaw, &hv_HeightRaw);

    /*Set new coordinates to input coordinates.*/
    /*BBoxCol1New := BBoxCol1*/
    destroy_tuple(hv_BBoxCol1New);
    copy_tuple(hv_BBoxCol1,&hv_BBoxCol1New);

    /*BBoxCol2New := BBoxCol2*/
    destroy_tuple(hv_BBoxCol2New);
    copy_tuple(hv_BBoxCol2,&hv_BBoxCol2New);

    /*BBoxRow1New := BBoxRow1*/
    destroy_tuple(hv_BBoxRow1New);
    copy_tuple(hv_BBoxRow1,&hv_BBoxRow1New);

    /*BBoxRow2New := BBoxRow2*/
    destroy_tuple(hv_BBoxRow2New);
    copy_tuple(hv_BBoxRow2,&hv_BBoxRow2New);

    /*BBoxLabelNew := BBoxLabel*/
    destroy_tuple(hv_BBoxLabelNew);
    copy_tuple(hv_BBoxLabel,&hv_BBoxLabelNew);

  }
  else
  {
    /* throw(...); only in hdevelop*/
  }
  }
  destroy_tuple(TTemp[--SP]);
  /*========== end if ==========*/
  /**/
  /*Rescale the bounding boxes.*/
  /**/
  /*Get required images width and height.*/
  /**/
  /*Only rescale bounding boxes if the required image dimensions are not the raw dimensions.*/
  /*========== if (ImageHeight != HeightRaw or ImageWidth != WidthRaw) ==========*/
  T_tuple_not_equal(hv_ImageHeight,hv_HeightRaw,&TTemp[SP++]);
  T_tuple_not_equal(hv_ImageWidth,hv_WidthRaw,&TTemp[SP++]);
  T_tuple_or(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-2]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-2]=TTemp[SP];
  SP--;
  if(get_i(TTemp[SP-1],0))
  {
    /*Calculate rescaling factor.*/
    /*FactorResampleWidth := real(ImageWidth) / WidthRaw*/
    T_tuple_real(hv_ImageWidth,&TTemp[SP++]);
    T_tuple_div(TTemp[SP-1],hv_WidthRaw,&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    destroy_tuple(hv_FactorResampleWidth);
    hv_FactorResampleWidth=TTemp[--SP];

    /*FactorResampleHeight := real(ImageHeight) / HeightRaw*/
    T_tuple_real(hv_ImageHeight,&TTemp[SP++]);
    T_tuple_div(TTemp[SP-1],hv_HeightRaw,&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    destroy_tuple(hv_FactorResampleHeight);
    hv_FactorResampleHeight=TTemp[--SP];

    /*Rescale the bounding box coordinates.*/
    /*As we use XLD-coordinates we temporarily move the boxes by (.5,.5) for rescaling.*/
    /*Doing so, the center of the XLD-coordinate system (-0.5,-0.5) is used*/
    /*for scaling, hence the scaling is performed w.r.t. the pixel coordinate system.*/
    /*BBoxCol1New := (BBoxCol1New + .5) * FactorResampleWidth - .5*/
    copy_tuple(hv_BBoxCol1New,&TTemp[SP++]);
    create_tuple_d(&TTemp[SP++],.5);
    T_tuple_add(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-2]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-2]=TTemp[SP];
    SP--;
    T_tuple_mult(TTemp[SP-1],hv_FactorResampleWidth,&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    create_tuple_d(&TTemp[SP++],.5);
    T_tuple_sub(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-2]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-2]=TTemp[SP];
    SP--;
    destroy_tuple(hv_BBoxCol1New);
    hv_BBoxCol1New=TTemp[--SP];

    /*BBoxCol2New := (BBoxCol2New + .5) * FactorResampleWidth - .5*/
    copy_tuple(hv_BBoxCol2New,&TTemp[SP++]);
    create_tuple_d(&TTemp[SP++],.5);
    T_tuple_add(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-2]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-2]=TTemp[SP];
    SP--;
    T_tuple_mult(TTemp[SP-1],hv_FactorResampleWidth,&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    create_tuple_d(&TTemp[SP++],.5);
    T_tuple_sub(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-2]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-2]=TTemp[SP];
    SP--;
    destroy_tuple(hv_BBoxCol2New);
    hv_BBoxCol2New=TTemp[--SP];

    /*BBoxRow1New := (BBoxRow1New + .5) * FactorResampleHeight - .5*/
    copy_tuple(hv_BBoxRow1New,&TTemp[SP++]);
    create_tuple_d(&TTemp[SP++],.5);
    T_tuple_add(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-2]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-2]=TTemp[SP];
    SP--;
    T_tuple_mult(TTemp[SP-1],hv_FactorResampleHeight,&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    create_tuple_d(&TTemp[SP++],.5);
    T_tuple_sub(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-2]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-2]=TTemp[SP];
    SP--;
    destroy_tuple(hv_BBoxRow1New);
    hv_BBoxRow1New=TTemp[--SP];

    /*BBoxRow2New := (BBoxRow2New + .5) * FactorResampleHeight - .5*/
    copy_tuple(hv_BBoxRow2New,&TTemp[SP++]);
    create_tuple_d(&TTemp[SP++],.5);
    T_tuple_add(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-2]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-2]=TTemp[SP];
    SP--;
    T_tuple_mult(TTemp[SP-1],hv_FactorResampleHeight,&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    create_tuple_d(&TTemp[SP++],.5);
    T_tuple_sub(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-2]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-2]=TTemp[SP];
    SP--;
    destroy_tuple(hv_BBoxRow2New);
    hv_BBoxRow2New=TTemp[--SP];

    /**/
  }
  destroy_tuple(TTemp[--SP]);
  /*========== end if ==========*/
  /**/
  /*Make a final check and remove bounding boxes that have zero area.*/
  /*========== if (|BBoxRow1New| > 0) ==========*/
  T_tuple_length(hv_BBoxRow1New,&TTemp[SP++]);
  create_tuple_i(&TTemp[SP++],0);
  T_tuple_greater(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-2]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-2]=TTemp[SP];
  SP--;
  if(get_i(TTemp[SP-1],0))
  {
    /*MaskDelete := (BBoxRow1New [>=] BBoxRow2New) or (BBoxCol1New [>=] BBoxCol2New)*/
    T_tuple_greater_equal_elem(hv_BBoxRow1New,hv_BBoxRow2New,&TTemp[SP++]);
    T_tuple_greater_equal_elem(hv_BBoxCol1New,hv_BBoxCol2New,&TTemp[SP++]);
    T_tuple_or(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-2]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-2]=TTemp[SP];
    SP--;
    destroy_tuple(hv_MaskDelete);
    hv_MaskDelete=TTemp[--SP];

    /*BBoxCol1New := select_mask(BBoxCol1New,1 - MaskDelete)*/
    copy_tuple(hv_BBoxCol1New,&TTemp[SP++]);
    create_tuple_i(&TTemp[SP++],1);
    T_tuple_sub(TTemp[SP-1],hv_MaskDelete,&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    T_tuple_select_mask(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-2]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-2]=TTemp[SP];
    SP--;
    destroy_tuple(hv_BBoxCol1New);
    hv_BBoxCol1New=TTemp[--SP];

    /*BBoxCol2New := select_mask(BBoxCol2New,1 - MaskDelete)*/
    copy_tuple(hv_BBoxCol2New,&TTemp[SP++]);
    create_tuple_i(&TTemp[SP++],1);
    T_tuple_sub(TTemp[SP-1],hv_MaskDelete,&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    T_tuple_select_mask(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-2]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-2]=TTemp[SP];
    SP--;
    destroy_tuple(hv_BBoxCol2New);
    hv_BBoxCol2New=TTemp[--SP];

    /*BBoxRow1New := select_mask(BBoxRow1New,1 - MaskDelete)*/
    copy_tuple(hv_BBoxRow1New,&TTemp[SP++]);
    create_tuple_i(&TTemp[SP++],1);
    T_tuple_sub(TTemp[SP-1],hv_MaskDelete,&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    T_tuple_select_mask(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-2]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-2]=TTemp[SP];
    SP--;
    destroy_tuple(hv_BBoxRow1New);
    hv_BBoxRow1New=TTemp[--SP];

    /*BBoxRow2New := select_mask(BBoxRow2New,1 - MaskDelete)*/
    copy_tuple(hv_BBoxRow2New,&TTemp[SP++]);
    create_tuple_i(&TTemp[SP++],1);
    T_tuple_sub(TTemp[SP-1],hv_MaskDelete,&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    T_tuple_select_mask(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-2]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-2]=TTemp[SP];
    SP--;
    destroy_tuple(hv_BBoxRow2New);
    hv_BBoxRow2New=TTemp[--SP];

    /*BBoxLabelNew := select_mask(BBoxLabelNew,1 - MaskDelete)*/
    copy_tuple(hv_BBoxLabelNew,&TTemp[SP++]);
    create_tuple_i(&TTemp[SP++],1);
    T_tuple_sub(TTemp[SP-1],hv_MaskDelete,&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    T_tuple_select_mask(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-2]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-2]=TTemp[SP];
    SP--;
    destroy_tuple(hv_BBoxLabelNew);
    hv_BBoxLabelNew=TTemp[--SP];

    /**/
    /*If we remove/select bounding boxes we also need to filter the corresponding*/
    /*instance segmentation masks if they exist.*/
    /*filter_dl_sample_instance_segmentation_masks (DLSample, 1 - MaskDelete)*/
    create_tuple_i(&TTemp[SP++],1);
    T_tuple_sub(TTemp[SP-1],hv_MaskDelete,&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    /***/filter_dl_sample_instance_segmentation_masks(hv_DLSample, TTemp[SP-1]);
    destroy_tuple(TTemp[--SP]);

  }
  destroy_tuple(TTemp[--SP]);
  /*========== end if ==========*/
  /**/
  /*Set new bounding box coordinates in the dictionary.*/
  /*set_dict_tuple (DLSample, 'bbox_col1', BBoxCol1New)*/
  create_tuple_s(&TTemp[SP++],"bbox_col1");
  /***/T_set_dict_tuple(hv_DLSample, TTemp[SP-1], hv_BBoxCol1New);
  destroy_tuple(TTemp[--SP]);

  /*set_dict_tuple (DLSample, 'bbox_col2', BBoxCol2New)*/
  create_tuple_s(&TTemp[SP++],"bbox_col2");
  /***/T_set_dict_tuple(hv_DLSample, TTemp[SP-1], hv_BBoxCol2New);
  destroy_tuple(TTemp[--SP]);

  /*set_dict_tuple (DLSample, 'bbox_row1', BBoxRow1New)*/
  create_tuple_s(&TTemp[SP++],"bbox_row1");
  /***/T_set_dict_tuple(hv_DLSample, TTemp[SP-1], hv_BBoxRow1New);
  destroy_tuple(TTemp[--SP]);

  /*set_dict_tuple (DLSample, 'bbox_row2', BBoxRow2New)*/
  create_tuple_s(&TTemp[SP++],"bbox_row2");
  /***/T_set_dict_tuple(hv_DLSample, TTemp[SP-1], hv_BBoxRow2New);
  destroy_tuple(TTemp[--SP]);

  /*set_dict_tuple (DLSample, 'bbox_label_id', BBoxLabelNew)*/
  create_tuple_s(&TTemp[SP++],"bbox_label_id");
  /***/T_set_dict_tuple(hv_DLSample, TTemp[SP-1], hv_BBoxLabelNew);
  destroy_tuple(TTemp[--SP]);

  /**/
  /*========== return ==========*/

  /* Clear temporary tuple stack */
  while (SP > 0)
    destroy_tuple(TTemp[--SP]);
  /* Clear temporary tuple vectors stack*/
  while (SPTV > 0)
    V_destroy_vector(TVTemp[--SPTV]);
  /* Clear local iconic variables */
  clear_obj(ho_DomainRaw);

  /* Clear local control variables */
  destroy_tuple(hv_ImageWidth);
  destroy_tuple(hv_ImageHeight);
  destroy_tuple(hv_DomainHandling);
  destroy_tuple(hv_BBoxCol1);
  destroy_tuple(hv_BBoxCol2);
  destroy_tuple(hv_BBoxRow1);
  destroy_tuple(hv_BBoxRow2);
  destroy_tuple(hv_BBoxLabel);
  destroy_tuple(hv_Exception);
  destroy_tuple(hv_ImageId);
  destroy_tuple(hv_ExceptionMessage);
  destroy_tuple(hv_BoxesInvalid);
  destroy_tuple(hv_DomainRow1);
  destroy_tuple(hv_DomainColumn1);
  destroy_tuple(hv_DomainRow2);
  destroy_tuple(hv_DomainColumn2);
  destroy_tuple(hv_WidthRaw);
  destroy_tuple(hv_HeightRaw);
  destroy_tuple(hv_Row1);
  destroy_tuple(hv_Col1);
  destroy_tuple(hv_Row2);
  destroy_tuple(hv_Col2);
  destroy_tuple(hv_MaskDelete);
  destroy_tuple(hv_MaskNewBbox);
  destroy_tuple(hv_BBoxCol1New);
  destroy_tuple(hv_BBoxCol2New);
  destroy_tuple(hv_BBoxRow1New);
  destroy_tuple(hv_BBoxRow2New);
  destroy_tuple(hv_BBoxLabelNew);
  destroy_tuple(hv_FactorResampleWidth);
  destroy_tuple(hv_FactorResampleHeight);

  return;

  /****************************************************/
  /******************     End procedure   *************/
  /****************************************************/

}

/* Chapter: Deep Learning / Object Detection and Instance Segmentation*/
/* Short Description: Preprocess the bounding boxes of type 'rectangle2' for a given sample. */
void preprocess_dl_model_bbox_rect2 (Hobject ho_ImageRaw, Htuple hv_DLSample, Htuple hv_DLPreprocessParam)
{


  /* Stack for temporary tuples */
  Htuple   TTemp[100];
  int      SP=0;
  /* Stack for temporary tuple vectors */
  Hvector  TVTemp[100] = {0};
  int      SPTV=0;

  /* Local iconic variables */
  Hobject  ho_DomainRaw, ho_Rectangle2XLD, ho_Rectangle2XLDSheared;

  /* Local control variables */
  Htuple  hv_ImageWidth, hv_ImageHeight, hv_DomainHandling;
  Htuple  hv_IgnoreDirection, hv_ClassIDsNoOrientation, hv_KeyExists;
  Htuple  hv_BBoxRow, hv_BBoxCol, hv_BBoxLength1, hv_BBoxLength2;
  Htuple  hv_BBoxPhi, hv_BBoxLabel, hv_Exception, hv_ImageId;
  Htuple  hv_ExceptionMessage, hv_BoxesInvalid, hv_DomainRow1;
  Htuple  hv_DomainColumn1, hv_DomainRow2, hv_DomainColumn2;
  Htuple  hv_WidthRaw, hv_HeightRaw, hv_MaskDelete, hv_MaskNewBbox;
  Htuple  hv_BBoxRowNew, hv_BBoxColNew, hv_BBoxLength1New;
  Htuple  hv_BBoxLength2New, hv_BBoxPhiNew, hv_BBoxLabelNew;
  Htuple  hv_ClassIDsNoOrientationIndices, hv_Index, hv_ClassIDsNoOrientationIndicesTmp;
  Htuple  hv_DirectionLength1Row, hv_DirectionLength1Col;
  Htuple  hv_DirectionLength2Row, hv_DirectionLength2Col;
  Htuple  hv_Corner1Row, hv_Corner1Col, hv_Corner2Row, hv_Corner2Col;
  Htuple  hv_FactorResampleWidth, hv_FactorResampleHeight;
  Htuple  hv_BBoxRow1, hv_BBoxCol1, hv_BBoxRow2, hv_BBoxCol2;
  Htuple  hv_BBoxRow3, hv_BBoxCol3, hv_BBoxRow4, hv_BBoxCol4;
  Htuple  hv_BBoxCol1New, hv_BBoxCol2New, hv_BBoxCol3New;
  Htuple  hv_BBoxCol4New, hv_BBoxRow1New, hv_BBoxRow2New;
  Htuple  hv_BBoxRow3New, hv_BBoxRow4New, hv_HomMat2DIdentity;
  Htuple  hv_HomMat2DScale, hv__, hv_BBoxPhiTmp, hv_PhiDelta;
  Htuple  hv_PhiDeltaNegativeIndices, hv_IndicesRot90, hv_IndicesRot180;
  Htuple  hv_IndicesRot270, hv_SwapIndices, hv_Tmp, hv_BBoxPhiNewIndices;
  Htuple  hv_PhiThreshold, hv_PhiToCorrect, hv_NumCorrections;

  /* Array for temporary output ctrl variables */
  Htuple  CExpDummyOCvar[7];

  /* Initialize iconic variables */
  gen_empty_obj(&ho_DomainRaw);
  gen_empty_obj(&ho_Rectangle2XLD);
  gen_empty_obj(&ho_Rectangle2XLDSheared);

  /* Initialize control variables */
  create_tuple(&hv_ImageWidth,0);
  create_tuple(&hv_ImageHeight,0);
  create_tuple(&hv_DomainHandling,0);
  create_tuple(&hv_IgnoreDirection,0);
  create_tuple(&hv_ClassIDsNoOrientation,0);
  create_tuple(&hv_KeyExists,0);
  create_tuple(&hv_BBoxRow,0);
  create_tuple(&hv_BBoxCol,0);
  create_tuple(&hv_BBoxLength1,0);
  create_tuple(&hv_BBoxLength2,0);
  create_tuple(&hv_BBoxPhi,0);
  create_tuple(&hv_BBoxLabel,0);
  create_tuple(&hv_Exception,0);
  create_tuple(&hv_ImageId,0);
  create_tuple(&hv_ExceptionMessage,0);
  create_tuple(&hv_BoxesInvalid,0);
  create_tuple(&hv_DomainRow1,0);
  create_tuple(&hv_DomainColumn1,0);
  create_tuple(&hv_DomainRow2,0);
  create_tuple(&hv_DomainColumn2,0);
  create_tuple(&hv_WidthRaw,0);
  create_tuple(&hv_HeightRaw,0);
  create_tuple(&hv_MaskDelete,0);
  create_tuple(&hv_MaskNewBbox,0);
  create_tuple(&hv_BBoxRowNew,0);
  create_tuple(&hv_BBoxColNew,0);
  create_tuple(&hv_BBoxLength1New,0);
  create_tuple(&hv_BBoxLength2New,0);
  create_tuple(&hv_BBoxPhiNew,0);
  create_tuple(&hv_BBoxLabelNew,0);
  create_tuple(&hv_ClassIDsNoOrientationIndices,0);
  create_tuple(&hv_Index,0);
  create_tuple(&hv_ClassIDsNoOrientationIndicesTmp,0);
  create_tuple(&hv_DirectionLength1Row,0);
  create_tuple(&hv_DirectionLength1Col,0);
  create_tuple(&hv_DirectionLength2Row,0);
  create_tuple(&hv_DirectionLength2Col,0);
  create_tuple(&hv_Corner1Row,0);
  create_tuple(&hv_Corner1Col,0);
  create_tuple(&hv_Corner2Row,0);
  create_tuple(&hv_Corner2Col,0);
  create_tuple(&hv_FactorResampleWidth,0);
  create_tuple(&hv_FactorResampleHeight,0);
  create_tuple(&hv_BBoxRow1,0);
  create_tuple(&hv_BBoxCol1,0);
  create_tuple(&hv_BBoxRow2,0);
  create_tuple(&hv_BBoxCol2,0);
  create_tuple(&hv_BBoxRow3,0);
  create_tuple(&hv_BBoxCol3,0);
  create_tuple(&hv_BBoxRow4,0);
  create_tuple(&hv_BBoxCol4,0);
  create_tuple(&hv_BBoxCol1New,0);
  create_tuple(&hv_BBoxCol2New,0);
  create_tuple(&hv_BBoxCol3New,0);
  create_tuple(&hv_BBoxCol4New,0);
  create_tuple(&hv_BBoxRow1New,0);
  create_tuple(&hv_BBoxRow2New,0);
  create_tuple(&hv_BBoxRow3New,0);
  create_tuple(&hv_BBoxRow4New,0);
  create_tuple(&hv_HomMat2DIdentity,0);
  create_tuple(&hv_HomMat2DScale,0);
  create_tuple(&hv__,0);
  create_tuple(&hv_BBoxPhiTmp,0);
  create_tuple(&hv_PhiDelta,0);
  create_tuple(&hv_PhiDeltaNegativeIndices,0);
  create_tuple(&hv_IndicesRot90,0);
  create_tuple(&hv_IndicesRot180,0);
  create_tuple(&hv_IndicesRot270,0);
  create_tuple(&hv_SwapIndices,0);
  create_tuple(&hv_Tmp,0);
  create_tuple(&hv_BBoxPhiNewIndices,0);
  create_tuple(&hv_PhiThreshold,0);
  create_tuple(&hv_PhiToCorrect,0);
  create_tuple(&hv_NumCorrections,0);

  /****************************************************/
  /******************   Begin procedure   *************/
  /****************************************************/

  /*This procedure preprocesses the bounding boxes of type 'rectangle2' for a given sample.*/
  /**/
  /*check_dl_preprocess_param (DLPreprocessParam)*/
  /***/check_dl_preprocess_param(hv_DLPreprocessParam);

  /**/
  /*Get preprocess parameters.*/
  /*get_dict_tuple (DLPreprocessParam, 'image_width', ImageWidth)*/
  create_tuple_s(&TTemp[SP++],"image_width");
  destroy_tuple(hv_ImageWidth);
  /***/T_get_dict_tuple(hv_DLPreprocessParam, TTemp[SP-1], &hv_ImageWidth);
  destroy_tuple(TTemp[--SP]);

  /*get_dict_tuple (DLPreprocessParam, 'image_height', ImageHeight)*/
  create_tuple_s(&TTemp[SP++],"image_height");
  destroy_tuple(hv_ImageHeight);
  /***/T_get_dict_tuple(hv_DLPreprocessParam, TTemp[SP-1], &hv_ImageHeight);
  destroy_tuple(TTemp[--SP]);

  /*get_dict_tuple (DLPreprocessParam, 'domain_handling', DomainHandling)*/
  create_tuple_s(&TTemp[SP++],"domain_handling");
  destroy_tuple(hv_DomainHandling);
  /***/T_get_dict_tuple(hv_DLPreprocessParam, TTemp[SP-1], &hv_DomainHandling);
  destroy_tuple(TTemp[--SP]);

  /*The keys 'ignore_direction' and 'class_ids_no_orientation' are optional.*/
  /*IgnoreDirection := false*/
  reuse_tuple_i(&hv_IgnoreDirection,0);

  /*ClassIDsNoOrientation := []*/
  create_tuple(&TTemp[SP++],0);
  destroy_tuple(hv_ClassIDsNoOrientation);
  hv_ClassIDsNoOrientation=TTemp[--SP];

  /*get_dict_param (DLPreprocessParam, 'key_exists', ['ignore_direction', 'class_ids_no_orientation'], KeyExists)*/
  create_tuple_s(&TTemp[SP++],"key_exists");
  create_tuple(&TTemp[SP++],2);
  set_s(TTemp[SP-1],"ignore_direction",0);
  set_s(TTemp[SP-1],"class_ids_no_orientation",1);
  destroy_tuple(hv_KeyExists);
  /***/T_get_dict_param(hv_DLPreprocessParam, TTemp[SP-2], TTemp[SP-1], &hv_KeyExists);
  destroy_tuple(TTemp[--SP]);
  destroy_tuple(TTemp[--SP]);

  /*========== if (KeyExists[0]) ==========*/
  create_tuple_i(&TTemp[SP++],0);
  T_tuple_select(hv_KeyExists,TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-1]=TTemp[SP];
  if(get_i(TTemp[SP-1],0))
  {
    /*get_dict_tuple (DLPreprocessParam, 'ignore_direction', IgnoreDirection)*/
    create_tuple_s(&TTemp[SP++],"ignore_direction");
    destroy_tuple(hv_IgnoreDirection);
    /***/T_get_dict_tuple(hv_DLPreprocessParam, TTemp[SP-1], &hv_IgnoreDirection);
    destroy_tuple(TTemp[--SP]);

    /*========== if (IgnoreDirection == 'true') ==========*/
    create_tuple_s(&TTemp[SP++],"true");
    T_tuple_equal(hv_IgnoreDirection,TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    if(get_i(TTemp[SP-1],0))
    {
      /*IgnoreDirection := true*/
      reuse_tuple_i(&hv_IgnoreDirection,1);

    }
    else
    {
    destroy_tuple(TTemp[--SP]);
    /*========== elseif (IgnoreDirection == 'false') ==========*/

    create_tuple_s(&TTemp[SP++],"false");
    T_tuple_equal(hv_IgnoreDirection,TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    if(get_i(TTemp[SP-1],0))
    {
      /*IgnoreDirection := false*/
      reuse_tuple_i(&hv_IgnoreDirection,0);

    }
    }
    destroy_tuple(TTemp[--SP]);
    /*========== end if ==========*/
  }
  destroy_tuple(TTemp[--SP]);
  /*========== end if ==========*/
  /*========== if (KeyExists[1]) ==========*/
  create_tuple_i(&TTemp[SP++],1);
  T_tuple_select(hv_KeyExists,TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-1]=TTemp[SP];
  if(get_i(TTemp[SP-1],0))
  {
    /*get_dict_tuple (DLPreprocessParam, 'class_ids_no_orientation', ClassIDsNoOrientation)*/
    create_tuple_s(&TTemp[SP++],"class_ids_no_orientation");
    destroy_tuple(hv_ClassIDsNoOrientation);
    /***/T_get_dict_tuple(hv_DLPreprocessParam, TTemp[SP-1], &hv_ClassIDsNoOrientation);
    destroy_tuple(TTemp[--SP]);

  }
  destroy_tuple(TTemp[--SP]);
  /*========== end if ==========*/
  /**/
  /*Get bounding box coordinates and labels.*/
  /* try(...); only in hdevelop*/
    /*get_dict_tuple (DLSample, 'bbox_row', BBoxRow)*/
    create_tuple_s(&TTemp[SP++],"bbox_row");
    destroy_tuple(hv_BBoxRow);
    /***/T_get_dict_tuple(hv_DLSample, TTemp[SP-1], &hv_BBoxRow);
    destroy_tuple(TTemp[--SP]);

    /*get_dict_tuple (DLSample, 'bbox_col', BBoxCol)*/
    create_tuple_s(&TTemp[SP++],"bbox_col");
    destroy_tuple(hv_BBoxCol);
    /***/T_get_dict_tuple(hv_DLSample, TTemp[SP-1], &hv_BBoxCol);
    destroy_tuple(TTemp[--SP]);

    /*get_dict_tuple (DLSample, 'bbox_length1', BBoxLength1)*/
    create_tuple_s(&TTemp[SP++],"bbox_length1");
    destroy_tuple(hv_BBoxLength1);
    /***/T_get_dict_tuple(hv_DLSample, TTemp[SP-1], &hv_BBoxLength1);
    destroy_tuple(TTemp[--SP]);

    /*get_dict_tuple (DLSample, 'bbox_length2', BBoxLength2)*/
    create_tuple_s(&TTemp[SP++],"bbox_length2");
    destroy_tuple(hv_BBoxLength2);
    /***/T_get_dict_tuple(hv_DLSample, TTemp[SP-1], &hv_BBoxLength2);
    destroy_tuple(TTemp[--SP]);

    /*get_dict_tuple (DLSample, 'bbox_phi', BBoxPhi)*/
    create_tuple_s(&TTemp[SP++],"bbox_phi");
    destroy_tuple(hv_BBoxPhi);
    /***/T_get_dict_tuple(hv_DLSample, TTemp[SP-1], &hv_BBoxPhi);
    destroy_tuple(TTemp[--SP]);

    /*get_dict_tuple (DLSample, 'bbox_label_id', BBoxLabel)*/
    create_tuple_s(&TTemp[SP++],"bbox_label_id");
    destroy_tuple(hv_BBoxLabel);
    /***/T_get_dict_tuple(hv_DLSample, TTemp[SP-1], &hv_BBoxLabel);
    destroy_tuple(TTemp[--SP]);

  /* catch(...); only in hdevelop*/
    /* get_dict_tuple(...); only in hdevelop*/
    /* if(...); only in hdevelop*/
      /* assign(...); only in hdevelop*/
    /* else(...); only in hdevelop*/
      /* assign(...); only in hdevelop*/
    /* endif(...); only in hdevelop*/
    /* throw(...); only in hdevelop*/
  /* endtry(...); only in hdevelop*/
  /**/
  /*Check that there are no invalid boxes.*/
  /*========== if (|BBoxRow| > 0) ==========*/
  T_tuple_length(hv_BBoxRow,&TTemp[SP++]);
  create_tuple_i(&TTemp[SP++],0);
  T_tuple_greater(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-2]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-2]=TTemp[SP];
  SP--;
  if(get_i(TTemp[SP-1],0))
  {
    /*BoxesInvalid := sum(BBoxLength1 [==] 0) + sum(BBoxLength2 [==] 0)*/
    create_tuple_i(&TTemp[SP++],0);
    T_tuple_equal_elem(hv_BBoxLength1,TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    T_tuple_sum(TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    create_tuple_i(&TTemp[SP++],0);
    T_tuple_equal_elem(hv_BBoxLength2,TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    T_tuple_sum(TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    T_tuple_add(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-2]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-2]=TTemp[SP];
    SP--;
    destroy_tuple(hv_BoxesInvalid);
    hv_BoxesInvalid=TTemp[--SP];

    /*========== if (BoxesInvalid > 0) ==========*/
    create_tuple_i(&TTemp[SP++],0);
    T_tuple_greater(hv_BoxesInvalid,TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    if(get_i(TTemp[SP-1],0))
    {
      /*get_dict_tuple (DLSample, 'image_id', ImageId)*/
      create_tuple_s(&TTemp[SP++],"image_id");
      destroy_tuple(hv_ImageId);
      /***/T_get_dict_tuple(hv_DLSample, TTemp[SP-1], &hv_ImageId);
      destroy_tuple(TTemp[--SP]);

      /* throw(...); only in hdevelop*/
    }
    destroy_tuple(TTemp[--SP]);
    /*========== end if ==========*/
  }
  else
  {
    /*There are no bounding boxes, hence nothing to do.*/
    /*========== return ==========*/

    /* Clear temporary tuple stack */
    while (SP > 0)
      destroy_tuple(TTemp[--SP]);
    /* Clear temporary tuple vectors stack*/
    while (SPTV > 0)
      V_destroy_vector(TVTemp[--SPTV]);
    /* Clear local iconic variables */
    clear_obj(ho_DomainRaw);
    clear_obj(ho_Rectangle2XLD);
    clear_obj(ho_Rectangle2XLDSheared);

    /* Clear local control variables */
    destroy_tuple(hv_ImageWidth);
    destroy_tuple(hv_ImageHeight);
    destroy_tuple(hv_DomainHandling);
    destroy_tuple(hv_IgnoreDirection);
    destroy_tuple(hv_ClassIDsNoOrientation);
    destroy_tuple(hv_KeyExists);
    destroy_tuple(hv_BBoxRow);
    destroy_tuple(hv_BBoxCol);
    destroy_tuple(hv_BBoxLength1);
    destroy_tuple(hv_BBoxLength2);
    destroy_tuple(hv_BBoxPhi);
    destroy_tuple(hv_BBoxLabel);
    destroy_tuple(hv_Exception);
    destroy_tuple(hv_ImageId);
    destroy_tuple(hv_ExceptionMessage);
    destroy_tuple(hv_BoxesInvalid);
    destroy_tuple(hv_DomainRow1);
    destroy_tuple(hv_DomainColumn1);
    destroy_tuple(hv_DomainRow2);
    destroy_tuple(hv_DomainColumn2);
    destroy_tuple(hv_WidthRaw);
    destroy_tuple(hv_HeightRaw);
    destroy_tuple(hv_MaskDelete);
    destroy_tuple(hv_MaskNewBbox);
    destroy_tuple(hv_BBoxRowNew);
    destroy_tuple(hv_BBoxColNew);
    destroy_tuple(hv_BBoxLength1New);
    destroy_tuple(hv_BBoxLength2New);
    destroy_tuple(hv_BBoxPhiNew);
    destroy_tuple(hv_BBoxLabelNew);
    destroy_tuple(hv_ClassIDsNoOrientationIndices);
    destroy_tuple(hv_Index);
    destroy_tuple(hv_ClassIDsNoOrientationIndicesTmp);
    destroy_tuple(hv_DirectionLength1Row);
    destroy_tuple(hv_DirectionLength1Col);
    destroy_tuple(hv_DirectionLength2Row);
    destroy_tuple(hv_DirectionLength2Col);
    destroy_tuple(hv_Corner1Row);
    destroy_tuple(hv_Corner1Col);
    destroy_tuple(hv_Corner2Row);
    destroy_tuple(hv_Corner2Col);
    destroy_tuple(hv_FactorResampleWidth);
    destroy_tuple(hv_FactorResampleHeight);
    destroy_tuple(hv_BBoxRow1);
    destroy_tuple(hv_BBoxCol1);
    destroy_tuple(hv_BBoxRow2);
    destroy_tuple(hv_BBoxCol2);
    destroy_tuple(hv_BBoxRow3);
    destroy_tuple(hv_BBoxCol3);
    destroy_tuple(hv_BBoxRow4);
    destroy_tuple(hv_BBoxCol4);
    destroy_tuple(hv_BBoxCol1New);
    destroy_tuple(hv_BBoxCol2New);
    destroy_tuple(hv_BBoxCol3New);
    destroy_tuple(hv_BBoxCol4New);
    destroy_tuple(hv_BBoxRow1New);
    destroy_tuple(hv_BBoxRow2New);
    destroy_tuple(hv_BBoxRow3New);
    destroy_tuple(hv_BBoxRow4New);
    destroy_tuple(hv_HomMat2DIdentity);
    destroy_tuple(hv_HomMat2DScale);
    destroy_tuple(hv__);
    destroy_tuple(hv_BBoxPhiTmp);
    destroy_tuple(hv_PhiDelta);
    destroy_tuple(hv_PhiDeltaNegativeIndices);
    destroy_tuple(hv_IndicesRot90);
    destroy_tuple(hv_IndicesRot180);
    destroy_tuple(hv_IndicesRot270);
    destroy_tuple(hv_SwapIndices);
    destroy_tuple(hv_Tmp);
    destroy_tuple(hv_BBoxPhiNewIndices);
    destroy_tuple(hv_PhiThreshold);
    destroy_tuple(hv_PhiToCorrect);
    destroy_tuple(hv_NumCorrections);

    return;
  }
  destroy_tuple(TTemp[--SP]);
  /*========== end if ==========*/
  /**/
  /*If the domain is cropped, crop bounding boxes.*/
  /*========== if (DomainHandling == 'crop_domain') ==========*/
  create_tuple_s(&TTemp[SP++],"crop_domain");
  T_tuple_equal(hv_DomainHandling,TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-1]=TTemp[SP];
  if(get_i(TTemp[SP-1],0))
  {
    /**/
    /*Get domain.*/
    /*get_domain (ImageRaw, DomainRaw)*/
    clear_obj(ho_DomainRaw);
    /***/get_domain(ho_ImageRaw, &ho_DomainRaw);

    /**/
    /*Set the size of the raw image to the domain extensions.*/
    /*smallest_rectangle1 (DomainRaw, DomainRow1, DomainColumn1, DomainRow2, DomainColumn2)*/
    destroy_tuple(hv_DomainRow1);
    destroy_tuple(hv_DomainColumn1);
    destroy_tuple(hv_DomainRow2);
    destroy_tuple(hv_DomainColumn2);
    /***/T_smallest_rectangle1(ho_DomainRaw, &hv_DomainRow1, &hv_DomainColumn1, &hv_DomainRow2, 
        &hv_DomainColumn2);

    /*WidthRaw := DomainColumn2 - DomainColumn1 + 1*/
    T_tuple_sub(hv_DomainColumn2,hv_DomainColumn1,&TTemp[SP++]);
    create_tuple_i(&TTemp[SP++],1);
    T_tuple_add(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-2]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-2]=TTemp[SP];
    SP--;
    destroy_tuple(hv_WidthRaw);
    hv_WidthRaw=TTemp[--SP];

    /*HeightRaw := DomainRow2 - DomainRow1 + 1*/
    T_tuple_sub(hv_DomainRow2,hv_DomainRow1,&TTemp[SP++]);
    create_tuple_i(&TTemp[SP++],1);
    T_tuple_add(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-2]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-2]=TTemp[SP];
    SP--;
    destroy_tuple(hv_HeightRaw);
    hv_HeightRaw=TTemp[--SP];

    /**/
    /*Crop the bounding boxes.*/
    /*Remove the boxes with center outside of the domain.*/
    /*MaskDelete := (BBoxRow [<] DomainRow1 or BBoxCol [<] DomainColumn1 or BBoxRow [>] DomainRow2) or (BBoxCol [>] DomainColumn2)*/
    T_tuple_less_elem(hv_BBoxRow,hv_DomainRow1,&TTemp[SP++]);
    T_tuple_less_elem(hv_BBoxCol,hv_DomainColumn1,&TTemp[SP++]);
    T_tuple_or(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-2]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-2]=TTemp[SP];
    SP--;
    T_tuple_greater_elem(hv_BBoxRow,hv_DomainRow2,&TTemp[SP++]);
    T_tuple_or(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-2]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-2]=TTemp[SP];
    SP--;
    T_tuple_greater_elem(hv_BBoxCol,hv_DomainColumn2,&TTemp[SP++]);
    T_tuple_or(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-2]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-2]=TTemp[SP];
    SP--;
    destroy_tuple(hv_MaskDelete);
    hv_MaskDelete=TTemp[--SP];

    /*MaskNewBbox := 1 - MaskDelete*/
    create_tuple_i(&TTemp[SP++],1);
    T_tuple_sub(TTemp[SP-1],hv_MaskDelete,&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    destroy_tuple(hv_MaskNewBbox);
    hv_MaskNewBbox=TTemp[--SP];

    /*Store the preprocessed bounding box entries.*/
    /*BBoxRowNew := select_mask(BBoxRow,MaskNewBbox) - DomainRow1*/
    T_tuple_select_mask(hv_BBoxRow,hv_MaskNewBbox,&TTemp[SP++]);
    T_tuple_sub(TTemp[SP-1],hv_DomainRow1,&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    destroy_tuple(hv_BBoxRowNew);
    hv_BBoxRowNew=TTemp[--SP];

    /*BBoxColNew := select_mask(BBoxCol,MaskNewBbox) - DomainColumn1*/
    T_tuple_select_mask(hv_BBoxCol,hv_MaskNewBbox,&TTemp[SP++]);
    T_tuple_sub(TTemp[SP-1],hv_DomainColumn1,&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    destroy_tuple(hv_BBoxColNew);
    hv_BBoxColNew=TTemp[--SP];

    /*BBoxLength1New := select_mask(BBoxLength1,MaskNewBbox)*/
    T_tuple_select_mask(hv_BBoxLength1,hv_MaskNewBbox,&TTemp[SP++]);
    destroy_tuple(hv_BBoxLength1New);
    hv_BBoxLength1New=TTemp[--SP];

    /*BBoxLength2New := select_mask(BBoxLength2,MaskNewBbox)*/
    T_tuple_select_mask(hv_BBoxLength2,hv_MaskNewBbox,&TTemp[SP++]);
    destroy_tuple(hv_BBoxLength2New);
    hv_BBoxLength2New=TTemp[--SP];

    /*BBoxPhiNew := select_mask(BBoxPhi,MaskNewBbox)*/
    T_tuple_select_mask(hv_BBoxPhi,hv_MaskNewBbox,&TTemp[SP++]);
    destroy_tuple(hv_BBoxPhiNew);
    hv_BBoxPhiNew=TTemp[--SP];

    /*BBoxLabelNew := select_mask(BBoxLabel,MaskNewBbox)*/
    T_tuple_select_mask(hv_BBoxLabel,hv_MaskNewBbox,&TTemp[SP++]);
    destroy_tuple(hv_BBoxLabelNew);
    hv_BBoxLabelNew=TTemp[--SP];

    /**/
    /*If we remove/select bounding boxes we also need to filter the corresponding*/
    /*instance segmentation masks if they exist.*/
    /*filter_dl_sample_instance_segmentation_masks (DLSample, MaskNewBbox)*/
    /***/filter_dl_sample_instance_segmentation_masks(hv_DLSample, hv_MaskNewBbox);

    /**/
  }
  else
  {
  destroy_tuple(TTemp[--SP]);
  /*========== elseif (DomainHandling == 'full_domain') ==========*/

  create_tuple_s(&TTemp[SP++],"full_domain");
  T_tuple_equal(hv_DomainHandling,TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-1]=TTemp[SP];
  if(get_i(TTemp[SP-1],0))
  {
    /*If the entire image is used, set the variables accordingly.*/
    /*Get the original size.*/
    /*get_image_size (ImageRaw, WidthRaw, HeightRaw)*/
    destroy_tuple(hv_WidthRaw);
    destroy_tuple(hv_HeightRaw);
    /***/T_get_image_size(ho_ImageRaw, &hv_WidthRaw, &hv_HeightRaw);

    /*Set new coordinates to input coordinates.*/
    /*BBoxRowNew := BBoxRow*/
    destroy_tuple(hv_BBoxRowNew);
    copy_tuple(hv_BBoxRow,&hv_BBoxRowNew);

    /*BBoxColNew := BBoxCol*/
    destroy_tuple(hv_BBoxColNew);
    copy_tuple(hv_BBoxCol,&hv_BBoxColNew);

    /*BBoxLength1New := BBoxLength1*/
    destroy_tuple(hv_BBoxLength1New);
    copy_tuple(hv_BBoxLength1,&hv_BBoxLength1New);

    /*BBoxLength2New := BBoxLength2*/
    destroy_tuple(hv_BBoxLength2New);
    copy_tuple(hv_BBoxLength2,&hv_BBoxLength2New);

    /*BBoxPhiNew := BBoxPhi*/
    destroy_tuple(hv_BBoxPhiNew);
    copy_tuple(hv_BBoxPhi,&hv_BBoxPhiNew);

    /*BBoxLabelNew := BBoxLabel*/
    destroy_tuple(hv_BBoxLabelNew);
    copy_tuple(hv_BBoxLabel,&hv_BBoxLabelNew);

  }
  else
  {
    /* throw(...); only in hdevelop*/
  }
  }
  destroy_tuple(TTemp[--SP]);
  /*========== end if ==========*/
  /**/
  /*Generate smallest enclosing axis-aligned bounding box for classes in ClassIDsNoOrientation.*/
  /*ClassIDsNoOrientationIndices := []*/
  create_tuple(&TTemp[SP++],0);
  destroy_tuple(hv_ClassIDsNoOrientationIndices);
  hv_ClassIDsNoOrientationIndices=TTemp[--SP];

  /*========== for Index := 0 to |ClassIDsNoOrientation| - 1 by 1 ==========*/
  T_tuple_length(hv_ClassIDsNoOrientation,&TTemp[SP++]);
  create_tuple_i(&TTemp[SP++],1);
  T_tuple_sub(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-2]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-2]=TTemp[SP];
  SP--;
  create_tuple_i(&TTemp[SP++],1);
  create_tuple_i(&TTemp[SP++],0);
  T_tuple_greater(TTemp[SP-1],TTemp[SP-3],&TTemp[SP]);
  SP++;
  T_tuple_equal(TTemp[SP-2],TTemp[SP-4],&TTemp[SP]);
  if(get_i(TTemp[SP],0) ||
     (!((( get_i(TTemp[SP-1],0)) && (get_d(TTemp[SP-3],0)>0)) ||
        ((!get_i(TTemp[SP-1],0)) && (get_d(TTemp[SP-3],0)<0)))))
  {
   destroy_tuple(TTemp[SP--]);
   destroy_tuple(TTemp[SP]);
   T_tuple_sub(TTemp[SP-1],TTemp[SP-2],&TTemp[SP]);
   destroy_tuple(hv_Index);
   copy_tuple(TTemp[SP],&hv_Index);
   destroy_tuple(TTemp[SP--]);
   destroy_tuple(TTemp[SP]);
   for(;;)
   {
   T_tuple_add(hv_Index,TTemp[SP-1],&TTemp[SP]);
   destroy_tuple(hv_Index);
   copy_tuple(TTemp[SP],&hv_Index);
   destroy_tuple(TTemp[SP]);
   if(get_d(TTemp[SP-1],0)<0)
    T_tuple_less(hv_Index,TTemp[SP-2],&TTemp[SP]);
   else
    T_tuple_greater(hv_Index,TTemp[SP-2],&TTemp[SP]);
   if(get_i(TTemp[SP],0)) break;
   destroy_tuple(TTemp[SP]);
   /*========== for ==========*/

    /*ClassIDsNoOrientationIndicesTmp := find(BBoxLabelNew [==] ClassIDsNoOrientation[Index],1)*/
    T_tuple_select(hv_ClassIDsNoOrientation,hv_Index,&TTemp[SP++]);
    T_tuple_equal_elem(hv_BBoxLabelNew,TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    create_tuple_i(&TTemp[SP++],1);
    T_tuple_find(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-2]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-2]=TTemp[SP];
    SP--;
    destroy_tuple(hv_ClassIDsNoOrientationIndicesTmp);
    hv_ClassIDsNoOrientationIndicesTmp=TTemp[--SP];

    /*========== if (ClassIDsNoOrientationIndicesTmp != -1) ==========*/
    create_tuple_i(&TTemp[SP++],-1);
    T_tuple_not_equal(hv_ClassIDsNoOrientationIndicesTmp,TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    if(get_i(TTemp[SP-1],0))
    {
      /*ClassIDsNoOrientationIndices := [ClassIDsNoOrientationIndices,ClassIDsNoOrientationIndicesTmp]*/
      copy_tuple(hv_ClassIDsNoOrientationIndices,&TTemp[SP++]);
      T_tuple_concat(TTemp[SP-1],hv_ClassIDsNoOrientationIndicesTmp,&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      destroy_tuple(hv_ClassIDsNoOrientationIndices);
      hv_ClassIDsNoOrientationIndices=TTemp[--SP];

    }
    destroy_tuple(TTemp[--SP]);
    /*========== end if ==========*/
   }
   destroy_tuple(TTemp[SP--]);
   destroy_tuple(TTemp[SP--]);
   destroy_tuple(TTemp[SP]);
  }
  else
  {
   destroy_tuple(TTemp[SP--]);
   destroy_tuple(TTemp[SP--]);
   destroy_tuple(TTemp[SP--]);
   destroy_tuple(TTemp[SP--]);
   destroy_tuple(TTemp[SP]);
  }/*========== end for ========*/

  /*========== if (|ClassIDsNoOrientationIndices| > 0) ==========*/
  T_tuple_length(hv_ClassIDsNoOrientationIndices,&TTemp[SP++]);
  create_tuple_i(&TTemp[SP++],0);
  T_tuple_greater(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-2]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-2]=TTemp[SP];
  SP--;
  if(get_i(TTemp[SP-1],0))
  {
    /*Calculate length1 and length2 using position of corners.*/
    /*DirectionLength1Row := -sin(BBoxPhiNew[ClassIDsNoOrientationIndices])*/
    T_tuple_select(hv_BBoxPhiNew,hv_ClassIDsNoOrientationIndices,&TTemp[SP++]);
    T_tuple_sin(TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    T_tuple_neg(TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    destroy_tuple(hv_DirectionLength1Row);
    hv_DirectionLength1Row=TTemp[--SP];

    /*DirectionLength1Col := cos(BBoxPhiNew[ClassIDsNoOrientationIndices])*/
    T_tuple_select(hv_BBoxPhiNew,hv_ClassIDsNoOrientationIndices,&TTemp[SP++]);
    T_tuple_cos(TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    destroy_tuple(hv_DirectionLength1Col);
    hv_DirectionLength1Col=TTemp[--SP];

    /*DirectionLength2Row := -DirectionLength1Col*/
    T_tuple_neg(hv_DirectionLength1Col,&TTemp[SP++]);
    destroy_tuple(hv_DirectionLength2Row);
    hv_DirectionLength2Row=TTemp[--SP];

    /*DirectionLength2Col := DirectionLength1Row*/
    destroy_tuple(hv_DirectionLength2Col);
    copy_tuple(hv_DirectionLength1Row,&hv_DirectionLength2Col);

    /*Corner1Row := BBoxLength1New[ClassIDsNoOrientationIndices] * DirectionLength1Row + BBoxLength2New[ClassIDsNoOrientationIndices] * DirectionLength2Row*/
    T_tuple_select(hv_BBoxLength1New,hv_ClassIDsNoOrientationIndices,&TTemp[SP++]);
    T_tuple_mult(TTemp[SP-1],hv_DirectionLength1Row,&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    T_tuple_select(hv_BBoxLength2New,hv_ClassIDsNoOrientationIndices,&TTemp[SP++]);
    T_tuple_mult(TTemp[SP-1],hv_DirectionLength2Row,&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    T_tuple_add(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-2]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-2]=TTemp[SP];
    SP--;
    destroy_tuple(hv_Corner1Row);
    hv_Corner1Row=TTemp[--SP];

    /*Corner1Col := BBoxLength1New[ClassIDsNoOrientationIndices] * DirectionLength1Col + BBoxLength2New[ClassIDsNoOrientationIndices] * DirectionLength2Col*/
    T_tuple_select(hv_BBoxLength1New,hv_ClassIDsNoOrientationIndices,&TTemp[SP++]);
    T_tuple_mult(TTemp[SP-1],hv_DirectionLength1Col,&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    T_tuple_select(hv_BBoxLength2New,hv_ClassIDsNoOrientationIndices,&TTemp[SP++]);
    T_tuple_mult(TTemp[SP-1],hv_DirectionLength2Col,&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    T_tuple_add(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-2]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-2]=TTemp[SP];
    SP--;
    destroy_tuple(hv_Corner1Col);
    hv_Corner1Col=TTemp[--SP];

    /*Corner2Row := BBoxLength1New[ClassIDsNoOrientationIndices] * DirectionLength1Row - BBoxLength2New[ClassIDsNoOrientationIndices] * DirectionLength2Row*/
    T_tuple_select(hv_BBoxLength1New,hv_ClassIDsNoOrientationIndices,&TTemp[SP++]);
    T_tuple_mult(TTemp[SP-1],hv_DirectionLength1Row,&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    T_tuple_select(hv_BBoxLength2New,hv_ClassIDsNoOrientationIndices,&TTemp[SP++]);
    T_tuple_mult(TTemp[SP-1],hv_DirectionLength2Row,&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    T_tuple_sub(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-2]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-2]=TTemp[SP];
    SP--;
    destroy_tuple(hv_Corner2Row);
    hv_Corner2Row=TTemp[--SP];

    /*Corner2Col := BBoxLength1New[ClassIDsNoOrientationIndices] * DirectionLength1Col - BBoxLength2New[ClassIDsNoOrientationIndices] * DirectionLength2Col*/
    T_tuple_select(hv_BBoxLength1New,hv_ClassIDsNoOrientationIndices,&TTemp[SP++]);
    T_tuple_mult(TTemp[SP-1],hv_DirectionLength1Col,&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    T_tuple_select(hv_BBoxLength2New,hv_ClassIDsNoOrientationIndices,&TTemp[SP++]);
    T_tuple_mult(TTemp[SP-1],hv_DirectionLength2Col,&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    T_tuple_sub(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-2]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-2]=TTemp[SP];
    SP--;
    destroy_tuple(hv_Corner2Col);
    hv_Corner2Col=TTemp[--SP];

    /**/
    /*BBoxPhiNew[ClassIDsNoOrientationIndices] := 0.0*/
    create_tuple_d(&TTemp[SP++],0.0);
    replace_elements(&hv_BBoxPhiNew,&hv_ClassIDsNoOrientationIndices,&TTemp[SP-1]);
    destroy_tuple(TTemp[--SP]);
    /*BBoxLength1New[ClassIDsNoOrientationIndices] := max2(abs(Corner1Col),abs(Corner2Col))*/
    T_tuple_abs(hv_Corner1Col,&TTemp[SP++]);
    T_tuple_abs(hv_Corner2Col,&TTemp[SP++]);
    T_tuple_max2(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-2]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-2]=TTemp[SP];
    SP--;
    replace_elements(&hv_BBoxLength1New,&hv_ClassIDsNoOrientationIndices,&TTemp[SP-1]);
    destroy_tuple(TTemp[--SP]);
    /*BBoxLength2New[ClassIDsNoOrientationIndices] := max2(abs(Corner1Row),abs(Corner2Row))*/
    T_tuple_abs(hv_Corner1Row,&TTemp[SP++]);
    T_tuple_abs(hv_Corner2Row,&TTemp[SP++]);
    T_tuple_max2(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-2]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-2]=TTemp[SP];
    SP--;
    replace_elements(&hv_BBoxLength2New,&hv_ClassIDsNoOrientationIndices,&TTemp[SP-1]);
    destroy_tuple(TTemp[--SP]);
  }
  destroy_tuple(TTemp[--SP]);
  /*========== end if ==========*/
  /**/
  /*Rescale bounding boxes.*/
  /**/
  /*Get required images width and height.*/
  /**/
  /*Only rescale bounding boxes if the required image dimensions are not the raw dimensions.*/
  /*========== if (ImageHeight != HeightRaw or ImageWidth != WidthRaw) ==========*/
  T_tuple_not_equal(hv_ImageHeight,hv_HeightRaw,&TTemp[SP++]);
  T_tuple_not_equal(hv_ImageWidth,hv_WidthRaw,&TTemp[SP++]);
  T_tuple_or(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-2]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-2]=TTemp[SP];
  SP--;
  if(get_i(TTemp[SP-1],0))
  {
    /**/
    /*Calculate rescaling factor.*/
    /*calculate_dl_image_zoom_factors (WidthRaw, HeightRaw, ImageWidth, ImageHeight, DLPreprocessParam, FactorResampleWidth, FactorResampleHeight)*/
    destroy_tuple(hv_FactorResampleWidth);
    destroy_tuple(hv_FactorResampleHeight);
    /***/calculate_dl_image_zoom_factors(hv_WidthRaw, hv_HeightRaw, hv_ImageWidth, 
        hv_ImageHeight, hv_DLPreprocessParam, &hv_FactorResampleWidth, &hv_FactorResampleHeight);

    /**/
    /*========== if (FactorResampleHeight != FactorResampleWidth and |BBoxRowNew| > 0) ==========*/
    T_tuple_not_equal(hv_FactorResampleHeight,hv_FactorResampleWidth,&TTemp[SP++]);
    T_tuple_length(hv_BBoxRowNew,&TTemp[SP++]);
    create_tuple_i(&TTemp[SP++],0);
    T_tuple_greater(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-2]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-2]=TTemp[SP];
    SP--;
    T_tuple_and(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-2]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-2]=TTemp[SP];
    SP--;
    if(get_i(TTemp[SP-1],0))
    {
      /*In order to preserve the correct orientation we have to transform the points individually.*/
      /*Get the coordinates of the four corner points.*/
      /*convert_rect2_5to8param (BBoxRowNew, BBoxColNew, BBoxLength1New, BBoxLength2New, BBoxPhiNew, BBoxRow1, BBoxCol1, BBoxRow2, BBoxCol2, BBoxRow3, BBoxCol3, BBoxRow4, BBoxCol4)*/
      destroy_tuple(hv_BBoxRow1);
      destroy_tuple(hv_BBoxCol1);
      destroy_tuple(hv_BBoxRow2);
      destroy_tuple(hv_BBoxCol2);
      destroy_tuple(hv_BBoxRow3);
      destroy_tuple(hv_BBoxCol3);
      destroy_tuple(hv_BBoxRow4);
      destroy_tuple(hv_BBoxCol4);
      /***/convert_rect2_5to8param(hv_BBoxRowNew, hv_BBoxColNew, hv_BBoxLength1New, 
          hv_BBoxLength2New, hv_BBoxPhiNew, &hv_BBoxRow1, &hv_BBoxCol1, &hv_BBoxRow2, 
          &hv_BBoxCol2, &hv_BBoxRow3, &hv_BBoxCol3, &hv_BBoxRow4, &hv_BBoxCol4);

      /**/
      /*Rescale the coordinates.*/
      /*BBoxCol1New := BBoxCol1 * FactorResampleWidth*/
      T_tuple_mult(hv_BBoxCol1,hv_FactorResampleWidth,&TTemp[SP++]);
      destroy_tuple(hv_BBoxCol1New);
      hv_BBoxCol1New=TTemp[--SP];

      /*BBoxCol2New := BBoxCol2 * FactorResampleWidth*/
      T_tuple_mult(hv_BBoxCol2,hv_FactorResampleWidth,&TTemp[SP++]);
      destroy_tuple(hv_BBoxCol2New);
      hv_BBoxCol2New=TTemp[--SP];

      /*BBoxCol3New := BBoxCol3 * FactorResampleWidth*/
      T_tuple_mult(hv_BBoxCol3,hv_FactorResampleWidth,&TTemp[SP++]);
      destroy_tuple(hv_BBoxCol3New);
      hv_BBoxCol3New=TTemp[--SP];

      /*BBoxCol4New := BBoxCol4 * FactorResampleWidth*/
      T_tuple_mult(hv_BBoxCol4,hv_FactorResampleWidth,&TTemp[SP++]);
      destroy_tuple(hv_BBoxCol4New);
      hv_BBoxCol4New=TTemp[--SP];

      /*BBoxRow1New := BBoxRow1 * FactorResampleHeight*/
      T_tuple_mult(hv_BBoxRow1,hv_FactorResampleHeight,&TTemp[SP++]);
      destroy_tuple(hv_BBoxRow1New);
      hv_BBoxRow1New=TTemp[--SP];

      /*BBoxRow2New := BBoxRow2 * FactorResampleHeight*/
      T_tuple_mult(hv_BBoxRow2,hv_FactorResampleHeight,&TTemp[SP++]);
      destroy_tuple(hv_BBoxRow2New);
      hv_BBoxRow2New=TTemp[--SP];

      /*BBoxRow3New := BBoxRow3 * FactorResampleHeight*/
      T_tuple_mult(hv_BBoxRow3,hv_FactorResampleHeight,&TTemp[SP++]);
      destroy_tuple(hv_BBoxRow3New);
      hv_BBoxRow3New=TTemp[--SP];

      /*BBoxRow4New := BBoxRow4 * FactorResampleHeight*/
      T_tuple_mult(hv_BBoxRow4,hv_FactorResampleHeight,&TTemp[SP++]);
      destroy_tuple(hv_BBoxRow4New);
      hv_BBoxRow4New=TTemp[--SP];

      /**/
      /*The rectangles will get sheared, that is why new rectangles have to be found.*/
      /*Generate homography to scale rectangles.*/
      /*hom_mat2d_identity (HomMat2DIdentity)*/
      destroy_tuple(hv_HomMat2DIdentity);
      /***/T_hom_mat2d_identity(&hv_HomMat2DIdentity);

      /*hom_mat2d_scale (HomMat2DIdentity, FactorResampleHeight, FactorResampleWidth, 0, 0, HomMat2DScale)*/
      create_tuple_i(&TTemp[SP++],0);
      create_tuple_i(&TTemp[SP++],0);
      destroy_tuple(hv_HomMat2DScale);
      /***/T_hom_mat2d_scale(hv_HomMat2DIdentity, hv_FactorResampleHeight, hv_FactorResampleWidth, 
          TTemp[SP-2], TTemp[SP-1], &hv_HomMat2DScale);
      destroy_tuple(TTemp[--SP]);
      destroy_tuple(TTemp[--SP]);

      /*Generate XLD contours for the rectangles.*/
      /*gen_rectangle2_contour_xld (Rectangle2XLD, BBoxRowNew, BBoxColNew, BBoxPhiNew, BBoxLength1New, BBoxLength2New)*/
      clear_obj(ho_Rectangle2XLD);
      /***/T_gen_rectangle2_contour_xld(&ho_Rectangle2XLD, hv_BBoxRowNew, hv_BBoxColNew, 
          hv_BBoxPhiNew, hv_BBoxLength1New, hv_BBoxLength2New);

      /*Scale the XLD contours --> results in sheared regions.*/
      /*affine_trans_contour_xld (Rectangle2XLD, Rectangle2XLDSheared, HomMat2DScale)*/
      clear_obj(ho_Rectangle2XLDSheared);
      /***/T_affine_trans_contour_xld(ho_Rectangle2XLD, &ho_Rectangle2XLDSheared, 
          hv_HomMat2DScale);

      /*smallest_rectangle2_xld (Rectangle2XLDSheared, BBoxRowNew, BBoxColNew, BBoxPhiNew, BBoxLength1New, BBoxLength2New)*/
      destroy_tuple(hv_BBoxRowNew);
      destroy_tuple(hv_BBoxColNew);
      destroy_tuple(hv_BBoxPhiNew);
      destroy_tuple(hv_BBoxLength1New);
      destroy_tuple(hv_BBoxLength2New);
      /***/T_smallest_rectangle2_xld(ho_Rectangle2XLDSheared, &hv_BBoxRowNew, &hv_BBoxColNew, 
          &hv_BBoxPhiNew, &hv_BBoxLength1New, &hv_BBoxLength2New);

      /**/
      /*smallest_rectangle2_xld might change the orientation of the bounding box.*/
      /*Hence, take the orientation that is closest to the one obtained out of the 4 corner points.*/
      /*convert_rect2_8to5param (BBoxRow1New, BBoxCol1New, BBoxRow2New, BBoxCol2New, BBoxRow3New, BBoxCol3New, BBoxRow4New, BBoxCol4New, IgnoreDirection, _, _, _, _, BBoxPhiTmp)*/
      destroy_tuple(hv__);
      destroy_tuple(hv_BBoxPhiTmp);
      /***/convert_rect2_8to5param(hv_BBoxRow1New, hv_BBoxCol1New, hv_BBoxRow2New, 
          hv_BBoxCol2New, hv_BBoxRow3New, hv_BBoxCol3New, hv_BBoxRow4New, hv_BBoxCol4New, 
          hv_IgnoreDirection, &hv__, &(CExpDummyOCvar[0]), &(CExpDummyOCvar[1]), 
          &(CExpDummyOCvar[2]), &hv_BBoxPhiTmp);
      destroy_tuple(CExpDummyOCvar[0]);
      destroy_tuple(CExpDummyOCvar[1]);
      destroy_tuple(CExpDummyOCvar[2]);

      /*PhiDelta := fmod(BBoxPhiTmp - BBoxPhiNew,rad(360))*/
      T_tuple_sub(hv_BBoxPhiTmp,hv_BBoxPhiNew,&TTemp[SP++]);
      create_tuple_i(&TTemp[SP++],360);
      T_tuple_rad(TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      T_tuple_fmod(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-2]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-2]=TTemp[SP];
      SP--;
      destroy_tuple(hv_PhiDelta);
      hv_PhiDelta=TTemp[--SP];

      /*Guarantee that angles are positive.*/
      /*PhiDeltaNegativeIndices := find(PhiDelta [<] 0.0,1)*/
      create_tuple_d(&TTemp[SP++],0.0);
      T_tuple_less_elem(hv_PhiDelta,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      create_tuple_i(&TTemp[SP++],1);
      T_tuple_find(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-2]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-2]=TTemp[SP];
      SP--;
      destroy_tuple(hv_PhiDeltaNegativeIndices);
      hv_PhiDeltaNegativeIndices=TTemp[--SP];

      /*========== if (PhiDeltaNegativeIndices != -1) ==========*/
      create_tuple_i(&TTemp[SP++],-1);
      T_tuple_not_equal(hv_PhiDeltaNegativeIndices,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      if(get_i(TTemp[SP-1],0))
      {
        /*PhiDelta[PhiDeltaNegativeIndices] := PhiDelta[PhiDeltaNegativeIndices] + rad(360)*/
        copy_tuple(hv_PhiDelta,&TTemp[SP++]);
        T_tuple_select(TTemp[SP-1],hv_PhiDeltaNegativeIndices,&TTemp[SP]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-1]=TTemp[SP];
        create_tuple_i(&TTemp[SP++],360);
        T_tuple_rad(TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-1]=TTemp[SP];
        T_tuple_add(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-2]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-2]=TTemp[SP];
        SP--;
        replace_elements(&hv_PhiDelta,&hv_PhiDeltaNegativeIndices,&TTemp[SP-1]);
        destroy_tuple(TTemp[--SP]);
      }
      destroy_tuple(TTemp[--SP]);
      /*========== end if ==========*/
      /*IndicesRot90 := find((PhiDelta [>] rad(45)) and (PhiDelta [<=] rad(135)),1)*/
      create_tuple_i(&TTemp[SP++],45);
      T_tuple_rad(TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      T_tuple_greater_elem(hv_PhiDelta,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      create_tuple_i(&TTemp[SP++],135);
      T_tuple_rad(TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      T_tuple_less_equal_elem(hv_PhiDelta,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      T_tuple_and(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-2]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-2]=TTemp[SP];
      SP--;
      create_tuple_i(&TTemp[SP++],1);
      T_tuple_find(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-2]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-2]=TTemp[SP];
      SP--;
      destroy_tuple(hv_IndicesRot90);
      hv_IndicesRot90=TTemp[--SP];

      /*IndicesRot180 := find((PhiDelta [>] rad(135)) and (PhiDelta [<=] rad(225)),1)*/
      create_tuple_i(&TTemp[SP++],135);
      T_tuple_rad(TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      T_tuple_greater_elem(hv_PhiDelta,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      create_tuple_i(&TTemp[SP++],225);
      T_tuple_rad(TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      T_tuple_less_equal_elem(hv_PhiDelta,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      T_tuple_and(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-2]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-2]=TTemp[SP];
      SP--;
      create_tuple_i(&TTemp[SP++],1);
      T_tuple_find(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-2]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-2]=TTemp[SP];
      SP--;
      destroy_tuple(hv_IndicesRot180);
      hv_IndicesRot180=TTemp[--SP];

      /*IndicesRot270 := find((PhiDelta [>] rad(225)) and (PhiDelta [<=] rad(315)),1)*/
      create_tuple_i(&TTemp[SP++],225);
      T_tuple_rad(TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      T_tuple_greater_elem(hv_PhiDelta,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      create_tuple_i(&TTemp[SP++],315);
      T_tuple_rad(TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      T_tuple_less_equal_elem(hv_PhiDelta,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      T_tuple_and(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-2]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-2]=TTemp[SP];
      SP--;
      create_tuple_i(&TTemp[SP++],1);
      T_tuple_find(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-2]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-2]=TTemp[SP];
      SP--;
      destroy_tuple(hv_IndicesRot270);
      hv_IndicesRot270=TTemp[--SP];

      /*SwapIndices := []*/
      create_tuple(&TTemp[SP++],0);
      destroy_tuple(hv_SwapIndices);
      hv_SwapIndices=TTemp[--SP];

      /*========== if (IndicesRot90 != -1) ==========*/
      create_tuple_i(&TTemp[SP++],-1);
      T_tuple_not_equal(hv_IndicesRot90,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      if(get_i(TTemp[SP-1],0))
      {
        /*BBoxPhiNew[IndicesRot90] := BBoxPhiNew[IndicesRot90] + rad(90)*/
        copy_tuple(hv_BBoxPhiNew,&TTemp[SP++]);
        T_tuple_select(TTemp[SP-1],hv_IndicesRot90,&TTemp[SP]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-1]=TTemp[SP];
        create_tuple_i(&TTemp[SP++],90);
        T_tuple_rad(TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-1]=TTemp[SP];
        T_tuple_add(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-2]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-2]=TTemp[SP];
        SP--;
        replace_elements(&hv_BBoxPhiNew,&hv_IndicesRot90,&TTemp[SP-1]);
        destroy_tuple(TTemp[--SP]);
        /*SwapIndices := [SwapIndices,IndicesRot90]*/
        copy_tuple(hv_SwapIndices,&TTemp[SP++]);
        T_tuple_concat(TTemp[SP-1],hv_IndicesRot90,&TTemp[SP]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-1]=TTemp[SP];
        destroy_tuple(hv_SwapIndices);
        hv_SwapIndices=TTemp[--SP];

      }
      destroy_tuple(TTemp[--SP]);
      /*========== end if ==========*/
      /*========== if (IndicesRot180 != -1) ==========*/
      create_tuple_i(&TTemp[SP++],-1);
      T_tuple_not_equal(hv_IndicesRot180,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      if(get_i(TTemp[SP-1],0))
      {
        /*BBoxPhiNew[IndicesRot180] := BBoxPhiNew[IndicesRot180] + rad(180)*/
        copy_tuple(hv_BBoxPhiNew,&TTemp[SP++]);
        T_tuple_select(TTemp[SP-1],hv_IndicesRot180,&TTemp[SP]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-1]=TTemp[SP];
        create_tuple_i(&TTemp[SP++],180);
        T_tuple_rad(TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-1]=TTemp[SP];
        T_tuple_add(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-2]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-2]=TTemp[SP];
        SP--;
        replace_elements(&hv_BBoxPhiNew,&hv_IndicesRot180,&TTemp[SP-1]);
        destroy_tuple(TTemp[--SP]);
      }
      destroy_tuple(TTemp[--SP]);
      /*========== end if ==========*/
      /*========== if (IndicesRot270 != -1) ==========*/
      create_tuple_i(&TTemp[SP++],-1);
      T_tuple_not_equal(hv_IndicesRot270,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      if(get_i(TTemp[SP-1],0))
      {
        /*BBoxPhiNew[IndicesRot270] := BBoxPhiNew[IndicesRot270] + rad(270)*/
        copy_tuple(hv_BBoxPhiNew,&TTemp[SP++]);
        T_tuple_select(TTemp[SP-1],hv_IndicesRot270,&TTemp[SP]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-1]=TTemp[SP];
        create_tuple_i(&TTemp[SP++],270);
        T_tuple_rad(TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-1]=TTemp[SP];
        T_tuple_add(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-2]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-2]=TTemp[SP];
        SP--;
        replace_elements(&hv_BBoxPhiNew,&hv_IndicesRot270,&TTemp[SP-1]);
        destroy_tuple(TTemp[--SP]);
        /*SwapIndices := [SwapIndices,IndicesRot270]*/
        copy_tuple(hv_SwapIndices,&TTemp[SP++]);
        T_tuple_concat(TTemp[SP-1],hv_IndicesRot270,&TTemp[SP]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-1]=TTemp[SP];
        destroy_tuple(hv_SwapIndices);
        hv_SwapIndices=TTemp[--SP];

      }
      destroy_tuple(TTemp[--SP]);
      /*========== end if ==========*/
      /*========== if (SwapIndices != []) ==========*/
      create_tuple(&TTemp[SP++],0);
      T_tuple_not_equal(hv_SwapIndices,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      if(get_i(TTemp[SP-1],0))
      {
        /*Tmp := BBoxLength1New[SwapIndices]*/
        T_tuple_select(hv_BBoxLength1New,hv_SwapIndices,&TTemp[SP++]);
        destroy_tuple(hv_Tmp);
        hv_Tmp=TTemp[--SP];

        /*BBoxLength1New[SwapIndices] := BBoxLength2New[SwapIndices]*/
        T_tuple_select(hv_BBoxLength2New,hv_SwapIndices,&TTemp[SP++]);
        replace_elements(&hv_BBoxLength1New,&hv_SwapIndices,&TTemp[SP-1]);
        destroy_tuple(TTemp[--SP]);
        /*BBoxLength2New[SwapIndices] := Tmp*/
        replace_elements(&hv_BBoxLength2New,&hv_SwapIndices,&hv_Tmp);
      }
      destroy_tuple(TTemp[--SP]);
      /*========== end if ==========*/
      /*Change angles such that they lie in the range (-180°, 180°].*/
      /*BBoxPhiNewIndices := find(BBoxPhiNew [>] rad(180),1)*/
      create_tuple_i(&TTemp[SP++],180);
      T_tuple_rad(TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      T_tuple_greater_elem(hv_BBoxPhiNew,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      create_tuple_i(&TTemp[SP++],1);
      T_tuple_find(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-2]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-2]=TTemp[SP];
      SP--;
      destroy_tuple(hv_BBoxPhiNewIndices);
      hv_BBoxPhiNewIndices=TTemp[--SP];

      /*========== if (BBoxPhiNewIndices != -1) ==========*/
      create_tuple_i(&TTemp[SP++],-1);
      T_tuple_not_equal(hv_BBoxPhiNewIndices,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      if(get_i(TTemp[SP-1],0))
      {
        /*BBoxPhiNew[BBoxPhiNewIndices] := BBoxPhiNew[BBoxPhiNewIndices] - rad(360)*/
        copy_tuple(hv_BBoxPhiNew,&TTemp[SP++]);
        T_tuple_select(TTemp[SP-1],hv_BBoxPhiNewIndices,&TTemp[SP]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-1]=TTemp[SP];
        create_tuple_i(&TTemp[SP++],360);
        T_tuple_rad(TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-1]=TTemp[SP];
        T_tuple_sub(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-2]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-2]=TTemp[SP];
        SP--;
        replace_elements(&hv_BBoxPhiNew,&hv_BBoxPhiNewIndices,&TTemp[SP-1]);
        destroy_tuple(TTemp[--SP]);
      }
      destroy_tuple(TTemp[--SP]);
      /*========== end if ==========*/
      /**/
    }
    else
    {
      /*BBoxColNew := BBoxColNew * FactorResampleWidth*/
      copy_tuple(hv_BBoxColNew,&TTemp[SP++]);
      T_tuple_mult(TTemp[SP-1],hv_FactorResampleWidth,&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      destroy_tuple(hv_BBoxColNew);
      hv_BBoxColNew=TTemp[--SP];

      /*BBoxRowNew := BBoxRowNew * FactorResampleWidth*/
      copy_tuple(hv_BBoxRowNew,&TTemp[SP++]);
      T_tuple_mult(TTemp[SP-1],hv_FactorResampleWidth,&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      destroy_tuple(hv_BBoxRowNew);
      hv_BBoxRowNew=TTemp[--SP];

      /*BBoxLength1New := BBoxLength1New * FactorResampleWidth*/
      copy_tuple(hv_BBoxLength1New,&TTemp[SP++]);
      T_tuple_mult(TTemp[SP-1],hv_FactorResampleWidth,&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      destroy_tuple(hv_BBoxLength1New);
      hv_BBoxLength1New=TTemp[--SP];

      /*BBoxLength2New := BBoxLength2New * FactorResampleWidth*/
      copy_tuple(hv_BBoxLength2New,&TTemp[SP++]);
      T_tuple_mult(TTemp[SP-1],hv_FactorResampleWidth,&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      destroy_tuple(hv_BBoxLength2New);
      hv_BBoxLength2New=TTemp[--SP];

      /*Phi stays the same.*/
    }
    destroy_tuple(TTemp[--SP]);
    /*========== end if ==========*/
    /**/
  }
  destroy_tuple(TTemp[--SP]);
  /*========== end if ==========*/
  /**/
  /*Adapt the bounding box angles such that they are within the correct range,*/
  /*which is (-180°,180°] for 'ignore_direction'==false and (-90°,90°] else.*/
  /*PhiThreshold := rad(180) - IgnoreDirection * rad(90)*/
  create_tuple_i(&TTemp[SP++],180);
  T_tuple_rad(TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-1]=TTemp[SP];
  create_tuple_i(&TTemp[SP++],90);
  T_tuple_rad(TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-1]=TTemp[SP];
  T_tuple_mult(hv_IgnoreDirection,TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-1]=TTemp[SP];
  T_tuple_sub(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-2]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-2]=TTemp[SP];
  SP--;
  destroy_tuple(hv_PhiThreshold);
  hv_PhiThreshold=TTemp[--SP];

  /*PhiDelta := 2 * PhiThreshold*/
  create_tuple_i(&TTemp[SP++],2);
  T_tuple_mult(TTemp[SP-1],hv_PhiThreshold,&TTemp[SP]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-1]=TTemp[SP];
  destroy_tuple(hv_PhiDelta);
  hv_PhiDelta=TTemp[--SP];

  /*Correct angles that are too large.*/
  /*PhiToCorrect := find(BBoxPhiNew [>] PhiThreshold,1)*/
  T_tuple_greater_elem(hv_BBoxPhiNew,hv_PhiThreshold,&TTemp[SP++]);
  create_tuple_i(&TTemp[SP++],1);
  T_tuple_find(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-2]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-2]=TTemp[SP];
  SP--;
  destroy_tuple(hv_PhiToCorrect);
  hv_PhiToCorrect=TTemp[--SP];

  /*========== if (PhiToCorrect != -1 and PhiToCorrect != []) ==========*/
  create_tuple_i(&TTemp[SP++],-1);
  T_tuple_not_equal(hv_PhiToCorrect,TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-1]=TTemp[SP];
  create_tuple(&TTemp[SP++],0);
  T_tuple_not_equal(hv_PhiToCorrect,TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-1]=TTemp[SP];
  T_tuple_and(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-2]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-2]=TTemp[SP];
  SP--;
  if(get_i(TTemp[SP-1],0))
  {
    /*NumCorrections := int((BBoxPhiNew[PhiToCorrect] - PhiThreshold) / PhiDelta) + 1*/
    T_tuple_select(hv_BBoxPhiNew,hv_PhiToCorrect,&TTemp[SP++]);
    T_tuple_sub(TTemp[SP-1],hv_PhiThreshold,&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    T_tuple_div(TTemp[SP-1],hv_PhiDelta,&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    T_tuple_int(TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    create_tuple_i(&TTemp[SP++],1);
    T_tuple_add(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-2]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-2]=TTemp[SP];
    SP--;
    destroy_tuple(hv_NumCorrections);
    hv_NumCorrections=TTemp[--SP];

    /*BBoxPhiNew[PhiToCorrect] := BBoxPhiNew[PhiToCorrect] - NumCorrections * PhiDelta*/
    copy_tuple(hv_BBoxPhiNew,&TTemp[SP++]);
    T_tuple_select(TTemp[SP-1],hv_PhiToCorrect,&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    T_tuple_mult(hv_NumCorrections,hv_PhiDelta,&TTemp[SP++]);
    T_tuple_sub(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-2]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-2]=TTemp[SP];
    SP--;
    replace_elements(&hv_BBoxPhiNew,&hv_PhiToCorrect,&TTemp[SP-1]);
    destroy_tuple(TTemp[--SP]);
  }
  destroy_tuple(TTemp[--SP]);
  /*========== end if ==========*/
  /*Correct angles that are too small.*/
  /*PhiToCorrect := find(BBoxPhiNew [<=] -PhiThreshold,1)*/
  T_tuple_neg(hv_PhiThreshold,&TTemp[SP++]);
  T_tuple_less_equal_elem(hv_BBoxPhiNew,TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-1]=TTemp[SP];
  create_tuple_i(&TTemp[SP++],1);
  T_tuple_find(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-2]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-2]=TTemp[SP];
  SP--;
  destroy_tuple(hv_PhiToCorrect);
  hv_PhiToCorrect=TTemp[--SP];

  /*========== if (PhiToCorrect != -1 and PhiToCorrect != []) ==========*/
  create_tuple_i(&TTemp[SP++],-1);
  T_tuple_not_equal(hv_PhiToCorrect,TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-1]=TTemp[SP];
  create_tuple(&TTemp[SP++],0);
  T_tuple_not_equal(hv_PhiToCorrect,TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-1]=TTemp[SP];
  T_tuple_and(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-2]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-2]=TTemp[SP];
  SP--;
  if(get_i(TTemp[SP-1],0))
  {
    /*NumCorrections := int(abs(BBoxPhiNew[PhiToCorrect] + PhiThreshold) / PhiDelta) + 1*/
    T_tuple_select(hv_BBoxPhiNew,hv_PhiToCorrect,&TTemp[SP++]);
    T_tuple_add(TTemp[SP-1],hv_PhiThreshold,&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    T_tuple_abs(TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    T_tuple_div(TTemp[SP-1],hv_PhiDelta,&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    T_tuple_int(TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    create_tuple_i(&TTemp[SP++],1);
    T_tuple_add(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-2]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-2]=TTemp[SP];
    SP--;
    destroy_tuple(hv_NumCorrections);
    hv_NumCorrections=TTemp[--SP];

    /*BBoxPhiNew[PhiToCorrect] := BBoxPhiNew[PhiToCorrect] + NumCorrections * PhiDelta*/
    copy_tuple(hv_BBoxPhiNew,&TTemp[SP++]);
    T_tuple_select(TTemp[SP-1],hv_PhiToCorrect,&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    T_tuple_mult(hv_NumCorrections,hv_PhiDelta,&TTemp[SP++]);
    T_tuple_add(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-2]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-2]=TTemp[SP];
    SP--;
    replace_elements(&hv_BBoxPhiNew,&hv_PhiToCorrect,&TTemp[SP-1]);
    destroy_tuple(TTemp[--SP]);
  }
  destroy_tuple(TTemp[--SP]);
  /*========== end if ==========*/
  /**/
  /*Check that there are no invalid boxes.*/
  /*========== if (|BBoxRowNew| > 0) ==========*/
  T_tuple_length(hv_BBoxRowNew,&TTemp[SP++]);
  create_tuple_i(&TTemp[SP++],0);
  T_tuple_greater(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-2]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-2]=TTemp[SP];
  SP--;
  if(get_i(TTemp[SP-1],0))
  {
    /*BoxesInvalid := sum(BBoxLength1New [==] 0) + sum(BBoxLength2New [==] 0)*/
    create_tuple_i(&TTemp[SP++],0);
    T_tuple_equal_elem(hv_BBoxLength1New,TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    T_tuple_sum(TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    create_tuple_i(&TTemp[SP++],0);
    T_tuple_equal_elem(hv_BBoxLength2New,TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    T_tuple_sum(TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    T_tuple_add(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-2]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-2]=TTemp[SP];
    SP--;
    destroy_tuple(hv_BoxesInvalid);
    hv_BoxesInvalid=TTemp[--SP];

    /*========== if (BoxesInvalid > 0) ==========*/
    create_tuple_i(&TTemp[SP++],0);
    T_tuple_greater(hv_BoxesInvalid,TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    if(get_i(TTemp[SP-1],0))
    {
      /*get_dict_tuple (DLSample, 'image_id', ImageId)*/
      create_tuple_s(&TTemp[SP++],"image_id");
      destroy_tuple(hv_ImageId);
      /***/T_get_dict_tuple(hv_DLSample, TTemp[SP-1], &hv_ImageId);
      destroy_tuple(TTemp[--SP]);

      /* throw(...); only in hdevelop*/
    }
    destroy_tuple(TTemp[--SP]);
    /*========== end if ==========*/
  }
  destroy_tuple(TTemp[--SP]);
  /*========== end if ==========*/
  /*set_dict_tuple (DLSample, 'bbox_row', BBoxRowNew)*/
  create_tuple_s(&TTemp[SP++],"bbox_row");
  /***/T_set_dict_tuple(hv_DLSample, TTemp[SP-1], hv_BBoxRowNew);
  destroy_tuple(TTemp[--SP]);

  /*set_dict_tuple (DLSample, 'bbox_col', BBoxColNew)*/
  create_tuple_s(&TTemp[SP++],"bbox_col");
  /***/T_set_dict_tuple(hv_DLSample, TTemp[SP-1], hv_BBoxColNew);
  destroy_tuple(TTemp[--SP]);

  /*set_dict_tuple (DLSample, 'bbox_length1', BBoxLength1New)*/
  create_tuple_s(&TTemp[SP++],"bbox_length1");
  /***/T_set_dict_tuple(hv_DLSample, TTemp[SP-1], hv_BBoxLength1New);
  destroy_tuple(TTemp[--SP]);

  /*set_dict_tuple (DLSample, 'bbox_length2', BBoxLength2New)*/
  create_tuple_s(&TTemp[SP++],"bbox_length2");
  /***/T_set_dict_tuple(hv_DLSample, TTemp[SP-1], hv_BBoxLength2New);
  destroy_tuple(TTemp[--SP]);

  /*set_dict_tuple (DLSample, 'bbox_phi', BBoxPhiNew)*/
  create_tuple_s(&TTemp[SP++],"bbox_phi");
  /***/T_set_dict_tuple(hv_DLSample, TTemp[SP-1], hv_BBoxPhiNew);
  destroy_tuple(TTemp[--SP]);

  /*set_dict_tuple (DLSample, 'bbox_label_id', BBoxLabelNew)*/
  create_tuple_s(&TTemp[SP++],"bbox_label_id");
  /***/T_set_dict_tuple(hv_DLSample, TTemp[SP-1], hv_BBoxLabelNew);
  destroy_tuple(TTemp[--SP]);

  /**/
  /*========== return ==========*/

  /* Clear temporary tuple stack */
  while (SP > 0)
    destroy_tuple(TTemp[--SP]);
  /* Clear temporary tuple vectors stack*/
  while (SPTV > 0)
    V_destroy_vector(TVTemp[--SPTV]);
  /* Clear local iconic variables */
  clear_obj(ho_DomainRaw);
  clear_obj(ho_Rectangle2XLD);
  clear_obj(ho_Rectangle2XLDSheared);

  /* Clear local control variables */
  destroy_tuple(hv_ImageWidth);
  destroy_tuple(hv_ImageHeight);
  destroy_tuple(hv_DomainHandling);
  destroy_tuple(hv_IgnoreDirection);
  destroy_tuple(hv_ClassIDsNoOrientation);
  destroy_tuple(hv_KeyExists);
  destroy_tuple(hv_BBoxRow);
  destroy_tuple(hv_BBoxCol);
  destroy_tuple(hv_BBoxLength1);
  destroy_tuple(hv_BBoxLength2);
  destroy_tuple(hv_BBoxPhi);
  destroy_tuple(hv_BBoxLabel);
  destroy_tuple(hv_Exception);
  destroy_tuple(hv_ImageId);
  destroy_tuple(hv_ExceptionMessage);
  destroy_tuple(hv_BoxesInvalid);
  destroy_tuple(hv_DomainRow1);
  destroy_tuple(hv_DomainColumn1);
  destroy_tuple(hv_DomainRow2);
  destroy_tuple(hv_DomainColumn2);
  destroy_tuple(hv_WidthRaw);
  destroy_tuple(hv_HeightRaw);
  destroy_tuple(hv_MaskDelete);
  destroy_tuple(hv_MaskNewBbox);
  destroy_tuple(hv_BBoxRowNew);
  destroy_tuple(hv_BBoxColNew);
  destroy_tuple(hv_BBoxLength1New);
  destroy_tuple(hv_BBoxLength2New);
  destroy_tuple(hv_BBoxPhiNew);
  destroy_tuple(hv_BBoxLabelNew);
  destroy_tuple(hv_ClassIDsNoOrientationIndices);
  destroy_tuple(hv_Index);
  destroy_tuple(hv_ClassIDsNoOrientationIndicesTmp);
  destroy_tuple(hv_DirectionLength1Row);
  destroy_tuple(hv_DirectionLength1Col);
  destroy_tuple(hv_DirectionLength2Row);
  destroy_tuple(hv_DirectionLength2Col);
  destroy_tuple(hv_Corner1Row);
  destroy_tuple(hv_Corner1Col);
  destroy_tuple(hv_Corner2Row);
  destroy_tuple(hv_Corner2Col);
  destroy_tuple(hv_FactorResampleWidth);
  destroy_tuple(hv_FactorResampleHeight);
  destroy_tuple(hv_BBoxRow1);
  destroy_tuple(hv_BBoxCol1);
  destroy_tuple(hv_BBoxRow2);
  destroy_tuple(hv_BBoxCol2);
  destroy_tuple(hv_BBoxRow3);
  destroy_tuple(hv_BBoxCol3);
  destroy_tuple(hv_BBoxRow4);
  destroy_tuple(hv_BBoxCol4);
  destroy_tuple(hv_BBoxCol1New);
  destroy_tuple(hv_BBoxCol2New);
  destroy_tuple(hv_BBoxCol3New);
  destroy_tuple(hv_BBoxCol4New);
  destroy_tuple(hv_BBoxRow1New);
  destroy_tuple(hv_BBoxRow2New);
  destroy_tuple(hv_BBoxRow3New);
  destroy_tuple(hv_BBoxRow4New);
  destroy_tuple(hv_HomMat2DIdentity);
  destroy_tuple(hv_HomMat2DScale);
  destroy_tuple(hv__);
  destroy_tuple(hv_BBoxPhiTmp);
  destroy_tuple(hv_PhiDelta);
  destroy_tuple(hv_PhiDeltaNegativeIndices);
  destroy_tuple(hv_IndicesRot90);
  destroy_tuple(hv_IndicesRot180);
  destroy_tuple(hv_IndicesRot270);
  destroy_tuple(hv_SwapIndices);
  destroy_tuple(hv_Tmp);
  destroy_tuple(hv_BBoxPhiNewIndices);
  destroy_tuple(hv_PhiThreshold);
  destroy_tuple(hv_PhiToCorrect);
  destroy_tuple(hv_NumCorrections);

  return;


  /****************************************************/
  /******************     End procedure   *************/
  /****************************************************/

}

/* Chapter: Deep Learning / Model*/
/* Short Description: Preprocess images for deep-learning-based training and inference. */
void preprocess_dl_model_images (Hobject ho_Images, Hobject *ho_ImagesPreprocessed, 
    Htuple hv_DLPreprocessParam)
{


  /* Stack for temporary tuples */
  Htuple   TTemp[100];
  int      SP=0;
  /* Stack for temporary objects */
  Hobject  OTemp[20] = {0};
  int      SPO=0;
  /* Stack for temporary tuple vectors */
  Hvector  TVTemp[100] = {0};
  int      SPTV=0;

  /* Local iconic variables */
  Hobject  ho_PreservedDomains, ho_ImageSelected;
  Hobject  ho_DomainSelected, ho_ImagesScaled, ho_ImageScaled;
  Hobject  ho_Channel, ho_ChannelScaled, ho_ThreeChannelImage;
  Hobject  ho_SingleChannelImage;

  /* Local control variables */
  Htuple  hv_ImageWidth, hv_ImageHeight, hv_ImageNumChannels;
  Htuple  hv_ImageRangeMin, hv_ImageRangeMax, hv_DomainHandling;
  Htuple  hv_NormalizationType, hv_ModelType, hv_NumImages;
  Htuple  hv_Type, hv_NumMatches, hv_InputNumChannels, hv_OutputNumChannels;
  Htuple  hv_NumChannels1, hv_NumChannels3, hv_AreInputNumChannels1;
  Htuple  hv_AreInputNumChannels3, hv_AreInputNumChannels1Or3;
  Htuple  hv_ValidNumChannels, hv_ValidNumChannelsText, hv_PreserveDomain;
  Htuple  hv_Row1, hv_Column1, hv_Row2, hv_Column2, hv_UniqRow1;
  Htuple  hv_UniqColumn1, hv_UniqRow2, hv_UniqColumn2, hv_RectangleIndex;
  Htuple  hv_OriginalWidth, hv_OriginalHeight, hv_UniqWidth;
  Htuple  hv_UniqHeight, hv_ScaleWidth, hv_ScaleHeight, hv_ScaleIndex;
  Htuple  hv_ImageIndex, hv_NumChannels, hv_ChannelIndex;
  Htuple  hv_Min, hv_Max, hv_Range, hv_Scale, hv_Shift, hv_MeanValues;
  Htuple  hv_DeviationValues, hv_UseDefaultNormalizationValues;
  Htuple  hv_Exception, hv_Indices, hv_RescaleRange, hv_CurrentNumChannels;
  Htuple  hv_DiffNumChannelsIndices, hv_Index, hv_DiffNumChannelsIndex;
  Htuple  hv_NumDomains, hv_DomainIndex;

  /* Local copy input parameter variables */
  Hobject  ho_Images_COPY_INP_TMP;


  /* Initialize iconic variables */
  gen_empty_obj(&ho_PreservedDomains);
  gen_empty_obj(&ho_ImageSelected);
  gen_empty_obj(&ho_DomainSelected);
  gen_empty_obj(&ho_ImagesScaled);
  gen_empty_obj(&ho_ImageScaled);
  gen_empty_obj(&ho_Channel);
  gen_empty_obj(&ho_ChannelScaled);
  gen_empty_obj(&ho_ThreeChannelImage);
  gen_empty_obj(&ho_SingleChannelImage);
  gen_empty_obj(&(*ho_ImagesPreprocessed));
  copy_obj(ho_Images,&ho_Images_COPY_INP_TMP,1,-1);

  /* Initialize control variables */
  create_tuple(&hv_ImageWidth,0);
  create_tuple(&hv_ImageHeight,0);
  create_tuple(&hv_ImageNumChannels,0);
  create_tuple(&hv_ImageRangeMin,0);
  create_tuple(&hv_ImageRangeMax,0);
  create_tuple(&hv_DomainHandling,0);
  create_tuple(&hv_NormalizationType,0);
  create_tuple(&hv_ModelType,0);
  create_tuple(&hv_NumImages,0);
  create_tuple(&hv_Type,0);
  create_tuple(&hv_NumMatches,0);
  create_tuple(&hv_InputNumChannels,0);
  create_tuple(&hv_OutputNumChannels,0);
  create_tuple(&hv_NumChannels1,0);
  create_tuple(&hv_NumChannels3,0);
  create_tuple(&hv_AreInputNumChannels1,0);
  create_tuple(&hv_AreInputNumChannels3,0);
  create_tuple(&hv_AreInputNumChannels1Or3,0);
  create_tuple(&hv_ValidNumChannels,0);
  create_tuple(&hv_ValidNumChannelsText,0);
  create_tuple(&hv_PreserveDomain,0);
  create_tuple(&hv_Row1,0);
  create_tuple(&hv_Column1,0);
  create_tuple(&hv_Row2,0);
  create_tuple(&hv_Column2,0);
  create_tuple(&hv_UniqRow1,0);
  create_tuple(&hv_UniqColumn1,0);
  create_tuple(&hv_UniqRow2,0);
  create_tuple(&hv_UniqColumn2,0);
  create_tuple(&hv_RectangleIndex,0);
  create_tuple(&hv_OriginalWidth,0);
  create_tuple(&hv_OriginalHeight,0);
  create_tuple(&hv_UniqWidth,0);
  create_tuple(&hv_UniqHeight,0);
  create_tuple(&hv_ScaleWidth,0);
  create_tuple(&hv_ScaleHeight,0);
  create_tuple(&hv_ScaleIndex,0);
  create_tuple(&hv_ImageIndex,0);
  create_tuple(&hv_NumChannels,0);
  create_tuple(&hv_ChannelIndex,0);
  create_tuple(&hv_Min,0);
  create_tuple(&hv_Max,0);
  create_tuple(&hv_Range,0);
  create_tuple(&hv_Scale,0);
  create_tuple(&hv_Shift,0);
  create_tuple(&hv_MeanValues,0);
  create_tuple(&hv_DeviationValues,0);
  create_tuple(&hv_UseDefaultNormalizationValues,0);
  create_tuple(&hv_Exception,0);
  create_tuple(&hv_Indices,0);
  create_tuple(&hv_RescaleRange,0);
  create_tuple(&hv_CurrentNumChannels,0);
  create_tuple(&hv_DiffNumChannelsIndices,0);
  create_tuple(&hv_Index,0);
  create_tuple(&hv_DiffNumChannelsIndex,0);
  create_tuple(&hv_NumDomains,0);
  create_tuple(&hv_DomainIndex,0);

  /****************************************************/
  /******************   Begin procedure   *************/
  /****************************************************/

  /**/
  /*This procedure preprocesses the provided Images according to the parameters in*/
  /*the dictionary DLPreprocessParam. Note that depending on the images, additional*/
  /*preprocessing steps might be beneficial.*/
  /**/
  /*Validate the preprocessing parameters.*/
  /*check_dl_preprocess_param (DLPreprocessParam)*/
  /***/check_dl_preprocess_param(hv_DLPreprocessParam);

  /**/
  /*Get the preprocessing parameters.*/
  /*get_dict_tuple (DLPreprocessParam, 'image_width', ImageWidth)*/
  create_tuple_s(&TTemp[SP++],"image_width");
  destroy_tuple(hv_ImageWidth);
  /***/T_get_dict_tuple(hv_DLPreprocessParam, TTemp[SP-1], &hv_ImageWidth);
  destroy_tuple(TTemp[--SP]);

  /*get_dict_tuple (DLPreprocessParam, 'image_height', ImageHeight)*/
  create_tuple_s(&TTemp[SP++],"image_height");
  destroy_tuple(hv_ImageHeight);
  /***/T_get_dict_tuple(hv_DLPreprocessParam, TTemp[SP-1], &hv_ImageHeight);
  destroy_tuple(TTemp[--SP]);

  /*get_dict_tuple (DLPreprocessParam, 'image_num_channels', ImageNumChannels)*/
  create_tuple_s(&TTemp[SP++],"image_num_channels");
  destroy_tuple(hv_ImageNumChannels);
  /***/T_get_dict_tuple(hv_DLPreprocessParam, TTemp[SP-1], &hv_ImageNumChannels);
  destroy_tuple(TTemp[--SP]);

  /*get_dict_tuple (DLPreprocessParam, 'image_range_min', ImageRangeMin)*/
  create_tuple_s(&TTemp[SP++],"image_range_min");
  destroy_tuple(hv_ImageRangeMin);
  /***/T_get_dict_tuple(hv_DLPreprocessParam, TTemp[SP-1], &hv_ImageRangeMin);
  destroy_tuple(TTemp[--SP]);

  /*get_dict_tuple (DLPreprocessParam, 'image_range_max', ImageRangeMax)*/
  create_tuple_s(&TTemp[SP++],"image_range_max");
  destroy_tuple(hv_ImageRangeMax);
  /***/T_get_dict_tuple(hv_DLPreprocessParam, TTemp[SP-1], &hv_ImageRangeMax);
  destroy_tuple(TTemp[--SP]);

  /*get_dict_tuple (DLPreprocessParam, 'domain_handling', DomainHandling)*/
  create_tuple_s(&TTemp[SP++],"domain_handling");
  destroy_tuple(hv_DomainHandling);
  /***/T_get_dict_tuple(hv_DLPreprocessParam, TTemp[SP-1], &hv_DomainHandling);
  destroy_tuple(TTemp[--SP]);

  /*get_dict_tuple (DLPreprocessParam, 'normalization_type', NormalizationType)*/
  create_tuple_s(&TTemp[SP++],"normalization_type");
  destroy_tuple(hv_NormalizationType);
  /***/T_get_dict_tuple(hv_DLPreprocessParam, TTemp[SP-1], &hv_NormalizationType);
  destroy_tuple(TTemp[--SP]);

  /*get_dict_tuple (DLPreprocessParam, 'model_type', ModelType)*/
  create_tuple_s(&TTemp[SP++],"model_type");
  destroy_tuple(hv_ModelType);
  /***/T_get_dict_tuple(hv_DLPreprocessParam, TTemp[SP-1], &hv_ModelType);
  destroy_tuple(TTemp[--SP]);

  /**/
  /*Validate the type of the input images.*/
  /*count_obj (Images, NumImages)*/
  destroy_tuple(hv_NumImages);
  /***/T_count_obj(ho_Images_COPY_INP_TMP, &hv_NumImages);

  /*========== if (NumImages == 0) ==========*/
  create_tuple_i(&TTemp[SP++],0);
  T_tuple_equal(hv_NumImages,TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-1]=TTemp[SP];
  if(get_i(TTemp[SP-1],0))
  {
    /* throw(...); only in hdevelop*/
  }
  destroy_tuple(TTemp[--SP]);
  /*========== end if ==========*/
  /*get_image_type (Images, Type)*/
  destroy_tuple(hv_Type);
  /***/T_get_image_type(ho_Images_COPY_INP_TMP, &hv_Type);

  /*tuple_regexp_test (Type, 'byte|int|real', NumMatches)*/
  create_tuple_s(&TTemp[SP++],"byte|int|real");
  destroy_tuple(hv_NumMatches);
  /***/T_tuple_regexp_test(hv_Type, TTemp[SP-1], &hv_NumMatches);
  destroy_tuple(TTemp[--SP]);

  /*========== if (NumMatches != NumImages) ==========*/
  T_tuple_not_equal(hv_NumMatches,hv_NumImages,&TTemp[SP++]);
  if(get_i(TTemp[SP-1],0))
  {
    /* throw(...); only in hdevelop*/
  }
  destroy_tuple(TTemp[--SP]);
  /*========== end if ==========*/
  /**/
  /*Handle ocr_recognition models.*/
  /*========== if (ModelType == 'ocr_recognition') ==========*/
  create_tuple_s(&TTemp[SP++],"ocr_recognition");
  T_tuple_equal(hv_ModelType,TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-1]=TTemp[SP];
  if(get_i(TTemp[SP-1],0))
  {
    /*preprocess_dl_model_images_ocr_recognition (Images, ImagesPreprocessed, DLPreprocessParam)*/
    clear_obj((*ho_ImagesPreprocessed));
    /***/preprocess_dl_model_images_ocr_recognition(ho_Images_COPY_INP_TMP, &(*ho_ImagesPreprocessed), 
        hv_DLPreprocessParam);

    /*========== return ==========*/

    /* Clear temporary tuple stack */
    while (SP > 0)
      destroy_tuple(TTemp[--SP]);
    /* Clear temporary tuple vectors stack*/
    while (SPTV > 0)
      V_destroy_vector(TVTemp[--SPTV]);
    /* Clear local iconic variables */
    clear_obj(ho_PreservedDomains);
    clear_obj(ho_ImageSelected);
    clear_obj(ho_DomainSelected);
    clear_obj(ho_ImagesScaled);
    clear_obj(ho_ImageScaled);
    clear_obj(ho_Channel);
    clear_obj(ho_ChannelScaled);
    clear_obj(ho_ThreeChannelImage);
    clear_obj(ho_SingleChannelImage);
    clear_obj(ho_Images_COPY_INP_TMP);

    /* Clear local control variables */
    destroy_tuple(hv_ImageWidth);
    destroy_tuple(hv_ImageHeight);
    destroy_tuple(hv_ImageNumChannels);
    destroy_tuple(hv_ImageRangeMin);
    destroy_tuple(hv_ImageRangeMax);
    destroy_tuple(hv_DomainHandling);
    destroy_tuple(hv_NormalizationType);
    destroy_tuple(hv_ModelType);
    destroy_tuple(hv_NumImages);
    destroy_tuple(hv_Type);
    destroy_tuple(hv_NumMatches);
    destroy_tuple(hv_InputNumChannels);
    destroy_tuple(hv_OutputNumChannels);
    destroy_tuple(hv_NumChannels1);
    destroy_tuple(hv_NumChannels3);
    destroy_tuple(hv_AreInputNumChannels1);
    destroy_tuple(hv_AreInputNumChannels3);
    destroy_tuple(hv_AreInputNumChannels1Or3);
    destroy_tuple(hv_ValidNumChannels);
    destroy_tuple(hv_ValidNumChannelsText);
    destroy_tuple(hv_PreserveDomain);
    destroy_tuple(hv_Row1);
    destroy_tuple(hv_Column1);
    destroy_tuple(hv_Row2);
    destroy_tuple(hv_Column2);
    destroy_tuple(hv_UniqRow1);
    destroy_tuple(hv_UniqColumn1);
    destroy_tuple(hv_UniqRow2);
    destroy_tuple(hv_UniqColumn2);
    destroy_tuple(hv_RectangleIndex);
    destroy_tuple(hv_OriginalWidth);
    destroy_tuple(hv_OriginalHeight);
    destroy_tuple(hv_UniqWidth);
    destroy_tuple(hv_UniqHeight);
    destroy_tuple(hv_ScaleWidth);
    destroy_tuple(hv_ScaleHeight);
    destroy_tuple(hv_ScaleIndex);
    destroy_tuple(hv_ImageIndex);
    destroy_tuple(hv_NumChannels);
    destroy_tuple(hv_ChannelIndex);
    destroy_tuple(hv_Min);
    destroy_tuple(hv_Max);
    destroy_tuple(hv_Range);
    destroy_tuple(hv_Scale);
    destroy_tuple(hv_Shift);
    destroy_tuple(hv_MeanValues);
    destroy_tuple(hv_DeviationValues);
    destroy_tuple(hv_UseDefaultNormalizationValues);
    destroy_tuple(hv_Exception);
    destroy_tuple(hv_Indices);
    destroy_tuple(hv_RescaleRange);
    destroy_tuple(hv_CurrentNumChannels);
    destroy_tuple(hv_DiffNumChannelsIndices);
    destroy_tuple(hv_Index);
    destroy_tuple(hv_DiffNumChannelsIndex);
    destroy_tuple(hv_NumDomains);
    destroy_tuple(hv_DomainIndex);

    return;
  }
  destroy_tuple(TTemp[--SP]);
  /*========== end if ==========*/
  /**/
  /*Handle ocr_detection models.*/
  /*========== if (ModelType == 'ocr_detection') ==========*/
  create_tuple_s(&TTemp[SP++],"ocr_detection");
  T_tuple_equal(hv_ModelType,TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-1]=TTemp[SP];
  if(get_i(TTemp[SP-1],0))
  {
    /*preprocess_dl_model_images_ocr_detection (Images, ImagesPreprocessed, DLPreprocessParam)*/
    clear_obj((*ho_ImagesPreprocessed));
    /***/preprocess_dl_model_images_ocr_detection(ho_Images_COPY_INP_TMP, &(*ho_ImagesPreprocessed), 
        hv_DLPreprocessParam);

    /*========== return ==========*/

    /* Clear temporary tuple stack */
    while (SP > 0)
      destroy_tuple(TTemp[--SP]);
    /* Clear temporary tuple vectors stack*/
    while (SPTV > 0)
      V_destroy_vector(TVTemp[--SPTV]);
    /* Clear local iconic variables */
    clear_obj(ho_PreservedDomains);
    clear_obj(ho_ImageSelected);
    clear_obj(ho_DomainSelected);
    clear_obj(ho_ImagesScaled);
    clear_obj(ho_ImageScaled);
    clear_obj(ho_Channel);
    clear_obj(ho_ChannelScaled);
    clear_obj(ho_ThreeChannelImage);
    clear_obj(ho_SingleChannelImage);
    clear_obj(ho_Images_COPY_INP_TMP);

    /* Clear local control variables */
    destroy_tuple(hv_ImageWidth);
    destroy_tuple(hv_ImageHeight);
    destroy_tuple(hv_ImageNumChannels);
    destroy_tuple(hv_ImageRangeMin);
    destroy_tuple(hv_ImageRangeMax);
    destroy_tuple(hv_DomainHandling);
    destroy_tuple(hv_NormalizationType);
    destroy_tuple(hv_ModelType);
    destroy_tuple(hv_NumImages);
    destroy_tuple(hv_Type);
    destroy_tuple(hv_NumMatches);
    destroy_tuple(hv_InputNumChannels);
    destroy_tuple(hv_OutputNumChannels);
    destroy_tuple(hv_NumChannels1);
    destroy_tuple(hv_NumChannels3);
    destroy_tuple(hv_AreInputNumChannels1);
    destroy_tuple(hv_AreInputNumChannels3);
    destroy_tuple(hv_AreInputNumChannels1Or3);
    destroy_tuple(hv_ValidNumChannels);
    destroy_tuple(hv_ValidNumChannelsText);
    destroy_tuple(hv_PreserveDomain);
    destroy_tuple(hv_Row1);
    destroy_tuple(hv_Column1);
    destroy_tuple(hv_Row2);
    destroy_tuple(hv_Column2);
    destroy_tuple(hv_UniqRow1);
    destroy_tuple(hv_UniqColumn1);
    destroy_tuple(hv_UniqRow2);
    destroy_tuple(hv_UniqColumn2);
    destroy_tuple(hv_RectangleIndex);
    destroy_tuple(hv_OriginalWidth);
    destroy_tuple(hv_OriginalHeight);
    destroy_tuple(hv_UniqWidth);
    destroy_tuple(hv_UniqHeight);
    destroy_tuple(hv_ScaleWidth);
    destroy_tuple(hv_ScaleHeight);
    destroy_tuple(hv_ScaleIndex);
    destroy_tuple(hv_ImageIndex);
    destroy_tuple(hv_NumChannels);
    destroy_tuple(hv_ChannelIndex);
    destroy_tuple(hv_Min);
    destroy_tuple(hv_Max);
    destroy_tuple(hv_Range);
    destroy_tuple(hv_Scale);
    destroy_tuple(hv_Shift);
    destroy_tuple(hv_MeanValues);
    destroy_tuple(hv_DeviationValues);
    destroy_tuple(hv_UseDefaultNormalizationValues);
    destroy_tuple(hv_Exception);
    destroy_tuple(hv_Indices);
    destroy_tuple(hv_RescaleRange);
    destroy_tuple(hv_CurrentNumChannels);
    destroy_tuple(hv_DiffNumChannelsIndices);
    destroy_tuple(hv_Index);
    destroy_tuple(hv_DiffNumChannelsIndex);
    destroy_tuple(hv_NumDomains);
    destroy_tuple(hv_DomainIndex);

    return;
  }
  destroy_tuple(TTemp[--SP]);
  /*========== end if ==========*/
  /**/
  /*Validate the number channels of the input images.*/
  /*count_channels (Images, InputNumChannels)*/
  destroy_tuple(hv_InputNumChannels);
  /***/T_count_channels(ho_Images_COPY_INP_TMP, &hv_InputNumChannels);

  /*OutputNumChannels := gen_tuple_const(NumImages,ImageNumChannels)*/
  T_tuple_gen_const(hv_NumImages,hv_ImageNumChannels,&TTemp[SP++]);
  destroy_tuple(hv_OutputNumChannels);
  hv_OutputNumChannels=TTemp[--SP];

  /*Only for 'image_num_channels' 1 and 3 combinations of 1- and 3-channel images are allowed.*/
  /*========== if (ImageNumChannels == 1 or ImageNumChannels == 3) ==========*/
  create_tuple_i(&TTemp[SP++],1);
  T_tuple_equal(hv_ImageNumChannels,TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-1]=TTemp[SP];
  create_tuple_i(&TTemp[SP++],3);
  T_tuple_equal(hv_ImageNumChannels,TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-1]=TTemp[SP];
  T_tuple_or(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-2]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-2]=TTemp[SP];
  SP--;
  if(get_i(TTemp[SP-1],0))
  {
    /*NumChannels1 := gen_tuple_const(NumImages,1)*/
    create_tuple_i(&TTemp[SP++],1);
    T_tuple_gen_const(hv_NumImages,TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    destroy_tuple(hv_NumChannels1);
    hv_NumChannels1=TTemp[--SP];

    /*NumChannels3 := gen_tuple_const(NumImages,3)*/
    create_tuple_i(&TTemp[SP++],3);
    T_tuple_gen_const(hv_NumImages,TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    destroy_tuple(hv_NumChannels3);
    hv_NumChannels3=TTemp[--SP];

    /*AreInputNumChannels1 := InputNumChannels [==] NumChannels1*/
    T_tuple_equal_elem(hv_InputNumChannels,hv_NumChannels1,&TTemp[SP++]);
    destroy_tuple(hv_AreInputNumChannels1);
    hv_AreInputNumChannels1=TTemp[--SP];

    /*AreInputNumChannels3 := InputNumChannels [==] NumChannels3*/
    T_tuple_equal_elem(hv_InputNumChannels,hv_NumChannels3,&TTemp[SP++]);
    destroy_tuple(hv_AreInputNumChannels3);
    hv_AreInputNumChannels3=TTemp[--SP];

    /*AreInputNumChannels1Or3 := AreInputNumChannels1 + AreInputNumChannels3*/
    T_tuple_add(hv_AreInputNumChannels1,hv_AreInputNumChannels3,&TTemp[SP++]);
    destroy_tuple(hv_AreInputNumChannels1Or3);
    hv_AreInputNumChannels1Or3=TTemp[--SP];

    /*ValidNumChannels := AreInputNumChannels1Or3 == NumChannels1*/
    T_tuple_equal(hv_AreInputNumChannels1Or3,hv_NumChannels1,&TTemp[SP++]);
    destroy_tuple(hv_ValidNumChannels);
    hv_ValidNumChannels=TTemp[--SP];

    /*ValidNumChannelsText := 'Valid numbers of channels for the specified model are 1 or 3.'*/
    reuse_tuple_s(&hv_ValidNumChannelsText,"Valid numbers of channels for the specified model are 1 or 3.");
  }
  else
  {
    /*ValidNumChannels := InputNumChannels == OutputNumChannels*/
    T_tuple_equal(hv_InputNumChannels,hv_OutputNumChannels,&TTemp[SP++]);
    destroy_tuple(hv_ValidNumChannels);
    hv_ValidNumChannels=TTemp[--SP];

    /*ValidNumChannelsText := 'Valid number of channels for the specified model is ' + ImageNumChannels + '.'*/
    create_tuple_s(&TTemp[SP++],"Valid number of channels for the specified model is ");
    T_tuple_add(TTemp[SP-1],hv_ImageNumChannels,&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    create_tuple_s(&TTemp[SP++],".");
    T_tuple_add(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-2]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-2]=TTemp[SP];
    SP--;
    destroy_tuple(hv_ValidNumChannelsText);
    hv_ValidNumChannelsText=TTemp[--SP];

  }
  destroy_tuple(TTemp[--SP]);
  /*========== end if ==========*/
  /*========== if (not ValidNumChannels) ==========*/
  T_tuple_not(hv_ValidNumChannels,&TTemp[SP++]);
  if(get_i(TTemp[SP-1],0))
  {
    /* throw(...); only in hdevelop*/
  }
  destroy_tuple(TTemp[--SP]);
  /*========== end if ==========*/
  /*Preprocess the images.*/
  /**/
  /*For models of type '3d_gripping_point_detection', the preprocessing steps need to be performed on full*/
  /*domain images while the domains are preserved and set back into the images after the preprocessing.*/
  /*PreserveDomain := false*/
  reuse_tuple_i(&hv_PreserveDomain,0);

  /*========== if (ModelType == '3d_gripping_point_detection' and (DomainHandling == 'crop_domain' or DomainHandling == 'keep_domain')) ==========*/
  create_tuple_s(&TTemp[SP++],"3d_gripping_point_detection");
  T_tuple_equal(hv_ModelType,TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-1]=TTemp[SP];
  create_tuple_s(&TTemp[SP++],"crop_domain");
  T_tuple_equal(hv_DomainHandling,TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-1]=TTemp[SP];
  create_tuple_s(&TTemp[SP++],"keep_domain");
  T_tuple_equal(hv_DomainHandling,TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-1]=TTemp[SP];
  T_tuple_or(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-2]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-2]=TTemp[SP];
  SP--;
  T_tuple_and(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-2]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-2]=TTemp[SP];
  SP--;
  if(get_i(TTemp[SP-1],0))
  {
    /*PreserveDomain := true*/
    reuse_tuple_i(&hv_PreserveDomain,1);

    /*get_domain (Images, PreservedDomains)*/
    clear_obj(ho_PreservedDomains);
    /***/get_domain(ho_Images_COPY_INP_TMP, &ho_PreservedDomains);

    /*full_domain (Images, Images)*/
    /***/full_domain(ho_Images_COPY_INP_TMP, &(OTemp[SPO]));
    SPO++;
    clear_obj(ho_Images_COPY_INP_TMP);
    ho_Images_COPY_INP_TMP = OTemp[--SPO];

  }
  destroy_tuple(TTemp[--SP]);
  /*========== end if ==========*/
  /**/
  /*Apply the domain to the images.*/
  /*========== if (DomainHandling == 'full_domain') ==========*/
  create_tuple_s(&TTemp[SP++],"full_domain");
  T_tuple_equal(hv_DomainHandling,TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-1]=TTemp[SP];
  if(get_i(TTemp[SP-1],0))
  {
    /*full_domain (Images, Images)*/
    /***/full_domain(ho_Images_COPY_INP_TMP, &(OTemp[SPO]));
    SPO++;
    clear_obj(ho_Images_COPY_INP_TMP);
    ho_Images_COPY_INP_TMP = OTemp[--SPO];

  }
  else
  {
  destroy_tuple(TTemp[--SP]);
  /*========== elseif (DomainHandling == 'crop_domain') ==========*/

  create_tuple_s(&TTemp[SP++],"crop_domain");
  T_tuple_equal(hv_DomainHandling,TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-1]=TTemp[SP];
  if(get_i(TTemp[SP-1],0))
  {
    /*========== if (PreserveDomain) ==========*/
    copy_tuple(hv_PreserveDomain,&TTemp[SP++]);
    if(get_i(TTemp[SP-1],0))
    {
      /*In case of preserved domain, the crop is performed with the smallest rectangle of the*/
      /*domain to avoid out of domain pixels being set to 0.*/
      /*smallest_rectangle1 (PreservedDomains, Row1, Column1, Row2, Column2)*/
      destroy_tuple(hv_Row1);
      destroy_tuple(hv_Column1);
      destroy_tuple(hv_Row2);
      destroy_tuple(hv_Column2);
      /***/T_smallest_rectangle1(ho_PreservedDomains, &hv_Row1, &hv_Column1, &hv_Row2, 
          &hv_Column2);

      /*tuple_uniq (Row1, UniqRow1)*/
      destroy_tuple(hv_UniqRow1);
      /***/T_tuple_uniq(hv_Row1, &hv_UniqRow1);

      /*tuple_uniq (Column1, UniqColumn1)*/
      destroy_tuple(hv_UniqColumn1);
      /***/T_tuple_uniq(hv_Column1, &hv_UniqColumn1);

      /*tuple_uniq (Row2, UniqRow2)*/
      destroy_tuple(hv_UniqRow2);
      /***/T_tuple_uniq(hv_Row2, &hv_UniqRow2);

      /*tuple_uniq (Column2, UniqColumn2)*/
      destroy_tuple(hv_UniqColumn2);
      /***/T_tuple_uniq(hv_Column2, &hv_UniqColumn2);

      /*========== if (|UniqRow1| == 1 and |UniqColumn1| == 1 and |UniqRow2| == 1 and |UniqColumn2| == 1) ==========*/
      T_tuple_length(hv_UniqRow1,&TTemp[SP++]);
      create_tuple_i(&TTemp[SP++],1);
      T_tuple_equal(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-2]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-2]=TTemp[SP];
      SP--;
      T_tuple_length(hv_UniqColumn1,&TTemp[SP++]);
      create_tuple_i(&TTemp[SP++],1);
      T_tuple_equal(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-2]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-2]=TTemp[SP];
      SP--;
      T_tuple_and(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-2]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-2]=TTemp[SP];
      SP--;
      T_tuple_length(hv_UniqRow2,&TTemp[SP++]);
      create_tuple_i(&TTemp[SP++],1);
      T_tuple_equal(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-2]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-2]=TTemp[SP];
      SP--;
      T_tuple_and(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-2]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-2]=TTemp[SP];
      SP--;
      T_tuple_length(hv_UniqColumn2,&TTemp[SP++]);
      create_tuple_i(&TTemp[SP++],1);
      T_tuple_equal(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-2]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-2]=TTemp[SP];
      SP--;
      T_tuple_and(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-2]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-2]=TTemp[SP];
      SP--;
      if(get_i(TTemp[SP-1],0))
      {
        /*crop_rectangle1 (Images, Images, UniqRow1, UniqColumn1, UniqRow2, UniqColumn2)*/
        /***/T_crop_rectangle1(ho_Images_COPY_INP_TMP, &(OTemp[SPO]), hv_UniqRow1, 
            hv_UniqColumn1, hv_UniqRow2, hv_UniqColumn2);
        SPO++;
        clear_obj(ho_Images_COPY_INP_TMP);
        ho_Images_COPY_INP_TMP = OTemp[--SPO];

        /*move_region (PreservedDomains, PreservedDomains, -UniqRow1, -UniqColumn1)*/
        T_tuple_neg(hv_UniqRow1,&TTemp[SP++]);
        T_tuple_neg(hv_UniqColumn1,&TTemp[SP++]);
        /***/T_move_region(ho_PreservedDomains, &(OTemp[SPO]), TTemp[SP-2], TTemp[SP-1]);
        SPO++;
        clear_obj(ho_PreservedDomains);
        ho_PreservedDomains = OTemp[--SPO];
        destroy_tuple(TTemp[--SP]);
        destroy_tuple(TTemp[--SP]);

      }
      else
      {
        /*========== for RectangleIndex := 0 to |Row1| - 1 by 1 ==========*/
        T_tuple_length(hv_Row1,&TTemp[SP++]);
        create_tuple_i(&TTemp[SP++],1);
        T_tuple_sub(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-2]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-2]=TTemp[SP];
        SP--;
        create_tuple_i(&TTemp[SP++],1);
        create_tuple_i(&TTemp[SP++],0);
        T_tuple_greater(TTemp[SP-1],TTemp[SP-3],&TTemp[SP]);
        SP++;
        T_tuple_equal(TTemp[SP-2],TTemp[SP-4],&TTemp[SP]);
        if(get_i(TTemp[SP],0) ||
           (!((( get_i(TTemp[SP-1],0)) && (get_d(TTemp[SP-3],0)>0)) ||
              ((!get_i(TTemp[SP-1],0)) && (get_d(TTemp[SP-3],0)<0)))))
        {
         destroy_tuple(TTemp[SP--]);
         destroy_tuple(TTemp[SP]);
         T_tuple_sub(TTemp[SP-1],TTemp[SP-2],&TTemp[SP]);
         destroy_tuple(hv_RectangleIndex);
         copy_tuple(TTemp[SP],&hv_RectangleIndex);
         destroy_tuple(TTemp[SP--]);
         destroy_tuple(TTemp[SP]);
         for(;;)
         {
         T_tuple_add(hv_RectangleIndex,TTemp[SP-1],&TTemp[SP]);
         destroy_tuple(hv_RectangleIndex);
         copy_tuple(TTemp[SP],&hv_RectangleIndex);
         destroy_tuple(TTemp[SP]);
         if(get_d(TTemp[SP-1],0)<0)
          T_tuple_less(hv_RectangleIndex,TTemp[SP-2],&TTemp[SP]);
         else
          T_tuple_greater(hv_RectangleIndex,TTemp[SP-2],&TTemp[SP]);
         if(get_i(TTemp[SP],0)) break;
         destroy_tuple(TTemp[SP]);
         /*========== for ==========*/

          /*select_obj (Images, ImageSelected, RectangleIndex + 1)*/
          create_tuple_i(&TTemp[SP++],1);
          T_tuple_add(hv_RectangleIndex,TTemp[SP-1],&TTemp[SP]);
          destroy_tuple(TTemp[SP-1]);
          TTemp[SP-1]=TTemp[SP];
          clear_obj(ho_ImageSelected);
          /***/T_select_obj(ho_Images_COPY_INP_TMP, &ho_ImageSelected, TTemp[SP-1]);
          destroy_tuple(TTemp[--SP]);

          /*crop_rectangle1 (ImageSelected, ImageSelected, Row1[RectangleIndex], Column1[RectangleIndex], Row2[RectangleIndex], Column2[RectangleIndex])*/
          T_tuple_select(hv_Row1,hv_RectangleIndex,&TTemp[SP++]);
          T_tuple_select(hv_Column1,hv_RectangleIndex,&TTemp[SP++]);
          T_tuple_select(hv_Row2,hv_RectangleIndex,&TTemp[SP++]);
          T_tuple_select(hv_Column2,hv_RectangleIndex,&TTemp[SP++]);
          /***/T_crop_rectangle1(ho_ImageSelected, &(OTemp[SPO]), TTemp[SP-4], TTemp[SP-3], 
              TTemp[SP-2], TTemp[SP-1]);
          SPO++;
          clear_obj(ho_ImageSelected);
          ho_ImageSelected = OTemp[--SPO];
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(TTemp[--SP]);

          /*replace_obj (Images, ImageSelected, Images, RectangleIndex + 1)*/
          create_tuple_i(&TTemp[SP++],1);
          T_tuple_add(hv_RectangleIndex,TTemp[SP-1],&TTemp[SP]);
          destroy_tuple(TTemp[SP-1]);
          TTemp[SP-1]=TTemp[SP];
          /***/T_replace_obj(ho_Images_COPY_INP_TMP, ho_ImageSelected, &(OTemp[SPO]), 
              TTemp[SP-1]);
          SPO++;
          clear_obj(ho_Images_COPY_INP_TMP);
          ho_Images_COPY_INP_TMP = OTemp[--SPO];
          destroy_tuple(TTemp[--SP]);

          /*select_obj (PreservedDomains, DomainSelected, RectangleIndex + 1)*/
          create_tuple_i(&TTemp[SP++],1);
          T_tuple_add(hv_RectangleIndex,TTemp[SP-1],&TTemp[SP]);
          destroy_tuple(TTemp[SP-1]);
          TTemp[SP-1]=TTemp[SP];
          clear_obj(ho_DomainSelected);
          /***/T_select_obj(ho_PreservedDomains, &ho_DomainSelected, TTemp[SP-1]);
          destroy_tuple(TTemp[--SP]);

          /*move_region (DomainSelected, DomainSelected, -Row1[RectangleIndex], -Column1[RectangleIndex])*/
          T_tuple_select(hv_Row1,hv_RectangleIndex,&TTemp[SP++]);
          T_tuple_neg(TTemp[SP-1],&TTemp[SP]);
          destroy_tuple(TTemp[SP-1]);
          TTemp[SP-1]=TTemp[SP];
          T_tuple_select(hv_Column1,hv_RectangleIndex,&TTemp[SP++]);
          T_tuple_neg(TTemp[SP-1],&TTemp[SP]);
          destroy_tuple(TTemp[SP-1]);
          TTemp[SP-1]=TTemp[SP];
          /***/T_move_region(ho_DomainSelected, &(OTemp[SPO]), TTemp[SP-2], TTemp[SP-1]);
          SPO++;
          clear_obj(ho_DomainSelected);
          ho_DomainSelected = OTemp[--SPO];
          destroy_tuple(TTemp[--SP]);
          destroy_tuple(TTemp[--SP]);

          /*replace_obj (PreservedDomains, DomainSelected, PreservedDomains, RectangleIndex + 1)*/
          create_tuple_i(&TTemp[SP++],1);
          T_tuple_add(hv_RectangleIndex,TTemp[SP-1],&TTemp[SP]);
          destroy_tuple(TTemp[SP-1]);
          TTemp[SP-1]=TTemp[SP];
          /***/T_replace_obj(ho_PreservedDomains, ho_DomainSelected, &(OTemp[SPO]), 
              TTemp[SP-1]);
          SPO++;
          clear_obj(ho_PreservedDomains);
          ho_PreservedDomains = OTemp[--SPO];
          destroy_tuple(TTemp[--SP]);

         }
         destroy_tuple(TTemp[SP--]);
         destroy_tuple(TTemp[SP--]);
         destroy_tuple(TTemp[SP]);
        }
        else
        {
         destroy_tuple(TTemp[SP--]);
         destroy_tuple(TTemp[SP--]);
         destroy_tuple(TTemp[SP--]);
         destroy_tuple(TTemp[SP--]);
         destroy_tuple(TTemp[SP]);
        }/*========== end for ========*/

      }
      destroy_tuple(TTemp[--SP]);
      /*========== end if ==========*/
    }
    else
    {
      /*crop_domain (Images, Images)*/
      /***/crop_domain(ho_Images_COPY_INP_TMP, &(OTemp[SPO]));
      SPO++;
      clear_obj(ho_Images_COPY_INP_TMP);
      ho_Images_COPY_INP_TMP = OTemp[--SPO];

    }
    destroy_tuple(TTemp[--SP]);
    /*========== end if ==========*/
  }
  else
  {
  destroy_tuple(TTemp[--SP]);
  /*========== elseif (DomainHandling == 'keep_domain' and (ModelType == 'anomaly_detection' or ModelType == '3d_gripping_point_detection')) ==========*/

  create_tuple_s(&TTemp[SP++],"keep_domain");
  T_tuple_equal(hv_DomainHandling,TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-1]=TTemp[SP];
  create_tuple_s(&TTemp[SP++],"anomaly_detection");
  T_tuple_equal(hv_ModelType,TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-1]=TTemp[SP];
  create_tuple_s(&TTemp[SP++],"3d_gripping_point_detection");
  T_tuple_equal(hv_ModelType,TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-1]=TTemp[SP];
  T_tuple_or(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-2]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-2]=TTemp[SP];
  SP--;
  T_tuple_and(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-2]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-2]=TTemp[SP];
  SP--;
  if(get_i(TTemp[SP-1],0))
  {
    /*The option 'keep_domain' is only supported for models of 'type' = 'anomaly_detection' or '3d_gripping_point_detection'.*/
  }
  else
  {
    /* throw(...); only in hdevelop*/
  }
  }
  }
  destroy_tuple(TTemp[--SP]);
  /*========== end if ==========*/
  /**/
  /*Zoom preserved domains before zooming the images.*/
  /*========== if (PreserveDomain) ==========*/
  copy_tuple(hv_PreserveDomain,&TTemp[SP++]);
  if(get_i(TTemp[SP-1],0))
  {
    /*get_image_size (Images, OriginalWidth, OriginalHeight)*/
    destroy_tuple(hv_OriginalWidth);
    destroy_tuple(hv_OriginalHeight);
    /***/T_get_image_size(ho_Images_COPY_INP_TMP, &hv_OriginalWidth, &hv_OriginalHeight);

    /*tuple_uniq (OriginalWidth, UniqWidth)*/
    destroy_tuple(hv_UniqWidth);
    /***/T_tuple_uniq(hv_OriginalWidth, &hv_UniqWidth);

    /*tuple_uniq (OriginalHeight, UniqHeight)*/
    destroy_tuple(hv_UniqHeight);
    /***/T_tuple_uniq(hv_OriginalHeight, &hv_UniqHeight);

    /*========== if (|UniqWidth| == 1 and |UniqHeight| == 1) ==========*/
    T_tuple_length(hv_UniqWidth,&TTemp[SP++]);
    create_tuple_i(&TTemp[SP++],1);
    T_tuple_equal(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-2]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-2]=TTemp[SP];
    SP--;
    T_tuple_length(hv_UniqHeight,&TTemp[SP++]);
    create_tuple_i(&TTemp[SP++],1);
    T_tuple_equal(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-2]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-2]=TTemp[SP];
    SP--;
    T_tuple_and(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-2]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-2]=TTemp[SP];
    SP--;
    if(get_i(TTemp[SP-1],0))
    {
      /*ScaleWidth := ImageWidth / real(UniqWidth)*/
      T_tuple_real(hv_UniqWidth,&TTemp[SP++]);
      T_tuple_div(hv_ImageWidth,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      destroy_tuple(hv_ScaleWidth);
      hv_ScaleWidth=TTemp[--SP];

      /*ScaleHeight := ImageHeight / real(UniqHeight)*/
      T_tuple_real(hv_UniqHeight,&TTemp[SP++]);
      T_tuple_div(hv_ImageHeight,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      destroy_tuple(hv_ScaleHeight);
      hv_ScaleHeight=TTemp[--SP];

      /*zoom_region (PreservedDomains, PreservedDomains, ScaleWidth, ScaleHeight)*/
      /***/T_zoom_region(ho_PreservedDomains, &(OTemp[SPO]), hv_ScaleWidth, hv_ScaleHeight);
      SPO++;
      clear_obj(ho_PreservedDomains);
      ho_PreservedDomains = OTemp[--SPO];

    }
    else
    {
      /*ScaleWidth := ImageWidth / real(OriginalWidth)*/
      T_tuple_real(hv_OriginalWidth,&TTemp[SP++]);
      T_tuple_div(hv_ImageWidth,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      destroy_tuple(hv_ScaleWidth);
      hv_ScaleWidth=TTemp[--SP];

      /*ScaleHeight := ImageHeight / real(OriginalHeight)*/
      T_tuple_real(hv_OriginalHeight,&TTemp[SP++]);
      T_tuple_div(hv_ImageHeight,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      destroy_tuple(hv_ScaleHeight);
      hv_ScaleHeight=TTemp[--SP];

      /*========== for ScaleIndex := 0 to |ScaleWidth| - 1 by 1 ==========*/
      T_tuple_length(hv_ScaleWidth,&TTemp[SP++]);
      create_tuple_i(&TTemp[SP++],1);
      T_tuple_sub(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-2]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-2]=TTemp[SP];
      SP--;
      create_tuple_i(&TTemp[SP++],1);
      create_tuple_i(&TTemp[SP++],0);
      T_tuple_greater(TTemp[SP-1],TTemp[SP-3],&TTemp[SP]);
      SP++;
      T_tuple_equal(TTemp[SP-2],TTemp[SP-4],&TTemp[SP]);
      if(get_i(TTemp[SP],0) ||
         (!((( get_i(TTemp[SP-1],0)) && (get_d(TTemp[SP-3],0)>0)) ||
            ((!get_i(TTemp[SP-1],0)) && (get_d(TTemp[SP-3],0)<0)))))
      {
       destroy_tuple(TTemp[SP--]);
       destroy_tuple(TTemp[SP]);
       T_tuple_sub(TTemp[SP-1],TTemp[SP-2],&TTemp[SP]);
       destroy_tuple(hv_ScaleIndex);
       copy_tuple(TTemp[SP],&hv_ScaleIndex);
       destroy_tuple(TTemp[SP--]);
       destroy_tuple(TTemp[SP]);
       for(;;)
       {
       T_tuple_add(hv_ScaleIndex,TTemp[SP-1],&TTemp[SP]);
       destroy_tuple(hv_ScaleIndex);
       copy_tuple(TTemp[SP],&hv_ScaleIndex);
       destroy_tuple(TTemp[SP]);
       if(get_d(TTemp[SP-1],0)<0)
        T_tuple_less(hv_ScaleIndex,TTemp[SP-2],&TTemp[SP]);
       else
        T_tuple_greater(hv_ScaleIndex,TTemp[SP-2],&TTemp[SP]);
       if(get_i(TTemp[SP],0)) break;
       destroy_tuple(TTemp[SP]);
       /*========== for ==========*/

        /*select_obj (PreservedDomains, DomainSelected, ScaleIndex + 1)*/
        create_tuple_i(&TTemp[SP++],1);
        T_tuple_add(hv_ScaleIndex,TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-1]=TTemp[SP];
        clear_obj(ho_DomainSelected);
        /***/T_select_obj(ho_PreservedDomains, &ho_DomainSelected, TTemp[SP-1]);
        destroy_tuple(TTemp[--SP]);

        /*zoom_region (DomainSelected, DomainSelected, ScaleWidth[ScaleIndex], ScaleHeight[ScaleIndex])*/
        T_tuple_select(hv_ScaleWidth,hv_ScaleIndex,&TTemp[SP++]);
        T_tuple_select(hv_ScaleHeight,hv_ScaleIndex,&TTemp[SP++]);
        /***/T_zoom_region(ho_DomainSelected, &(OTemp[SPO]), TTemp[SP-2], TTemp[SP-1]);
        SPO++;
        clear_obj(ho_DomainSelected);
        ho_DomainSelected = OTemp[--SPO];
        destroy_tuple(TTemp[--SP]);
        destroy_tuple(TTemp[--SP]);

        /*replace_obj (PreservedDomains, DomainSelected, PreservedDomains, ScaleIndex + 1)*/
        create_tuple_i(&TTemp[SP++],1);
        T_tuple_add(hv_ScaleIndex,TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-1]=TTemp[SP];
        /***/T_replace_obj(ho_PreservedDomains, ho_DomainSelected, &(OTemp[SPO]), 
            TTemp[SP-1]);
        SPO++;
        clear_obj(ho_PreservedDomains);
        ho_PreservedDomains = OTemp[--SPO];
        destroy_tuple(TTemp[--SP]);

       }
       destroy_tuple(TTemp[SP--]);
       destroy_tuple(TTemp[SP--]);
       destroy_tuple(TTemp[SP]);
      }
      else
      {
       destroy_tuple(TTemp[SP--]);
       destroy_tuple(TTemp[SP--]);
       destroy_tuple(TTemp[SP--]);
       destroy_tuple(TTemp[SP--]);
       destroy_tuple(TTemp[SP]);
      }/*========== end for ========*/

    }
    destroy_tuple(TTemp[--SP]);
    /*========== end if ==========*/
  }
  destroy_tuple(TTemp[--SP]);
  /*========== end if ==========*/
  /**/
  /*Convert the images to real and zoom the images.*/
  /*Zoom first to speed up if all image types are supported by zoom_image_size.*/
  /*========== if (regexp_test(Type,'int1|int4|int8') == 0) ==========*/
  create_tuple_s(&TTemp[SP++],"int1|int4|int8");
  T_tuple_regexp_test(hv_Type,TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-1]=TTemp[SP];
  create_tuple_i(&TTemp[SP++],0);
  T_tuple_equal(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-2]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-2]=TTemp[SP];
  SP--;
  if(get_i(TTemp[SP-1],0))
  {
    /*zoom_image_size (Images, Images, ImageWidth, ImageHeight, 'constant')*/
    create_tuple_s(&TTemp[SP++],"constant");
    /***/T_zoom_image_size(ho_Images_COPY_INP_TMP, &(OTemp[SPO]), hv_ImageWidth, 
        hv_ImageHeight, TTemp[SP-1]);
    SPO++;
    clear_obj(ho_Images_COPY_INP_TMP);
    ho_Images_COPY_INP_TMP = OTemp[--SPO];
    destroy_tuple(TTemp[--SP]);

    /*convert_image_type (Images, Images, 'real')*/
    /***/convert_image_type(ho_Images_COPY_INP_TMP, &(OTemp[SPO]), "real");
    SPO++;
    clear_obj(ho_Images_COPY_INP_TMP);
    ho_Images_COPY_INP_TMP = OTemp[--SPO];

  }
  else
  {
    /*convert_image_type (Images, Images, 'real')*/
    /***/convert_image_type(ho_Images_COPY_INP_TMP, &(OTemp[SPO]), "real");
    SPO++;
    clear_obj(ho_Images_COPY_INP_TMP);
    ho_Images_COPY_INP_TMP = OTemp[--SPO];

    /*zoom_image_size (Images, Images, ImageWidth, ImageHeight, 'constant')*/
    create_tuple_s(&TTemp[SP++],"constant");
    /***/T_zoom_image_size(ho_Images_COPY_INP_TMP, &(OTemp[SPO]), hv_ImageWidth, 
        hv_ImageHeight, TTemp[SP-1]);
    SPO++;
    clear_obj(ho_Images_COPY_INP_TMP);
    ho_Images_COPY_INP_TMP = OTemp[--SPO];
    destroy_tuple(TTemp[--SP]);

  }
  destroy_tuple(TTemp[--SP]);
  /*========== end if ==========*/
  /**/
  /*========== if (NormalizationType == 'all_channels') ==========*/
  create_tuple_s(&TTemp[SP++],"all_channels");
  T_tuple_equal(hv_NormalizationType,TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-1]=TTemp[SP];
  if(get_i(TTemp[SP-1],0))
  {
    /*Scale for each image the gray values of all channels to ImageRangeMin-ImageRangeMax.*/
    /*gen_empty_obj (ImagesScaled)*/
    clear_obj(ho_ImagesScaled);
    /***/gen_empty_obj(&ho_ImagesScaled);

    /*========== for ImageIndex := 1 to NumImages by 1 ==========*/
    copy_tuple(hv_NumImages,&TTemp[SP++]);
    create_tuple_i(&TTemp[SP++],1);
    create_tuple_i(&TTemp[SP++],1);
    T_tuple_greater(TTemp[SP-1],TTemp[SP-3],&TTemp[SP]);
    SP++;
    T_tuple_equal(TTemp[SP-2],TTemp[SP-4],&TTemp[SP]);
    if(get_i(TTemp[SP],0) ||
       (!((( get_i(TTemp[SP-1],0)) && (get_d(TTemp[SP-3],0)>0)) ||
          ((!get_i(TTemp[SP-1],0)) && (get_d(TTemp[SP-3],0)<0)))))
    {
     destroy_tuple(TTemp[SP--]);
     destroy_tuple(TTemp[SP]);
     T_tuple_sub(TTemp[SP-1],TTemp[SP-2],&TTemp[SP]);
     destroy_tuple(hv_ImageIndex);
     copy_tuple(TTemp[SP],&hv_ImageIndex);
     destroy_tuple(TTemp[SP--]);
     destroy_tuple(TTemp[SP]);
     for(;;)
     {
     T_tuple_add(hv_ImageIndex,TTemp[SP-1],&TTemp[SP]);
     destroy_tuple(hv_ImageIndex);
     copy_tuple(TTemp[SP],&hv_ImageIndex);
     destroy_tuple(TTemp[SP]);
     if(get_d(TTemp[SP-1],0)<0)
      T_tuple_less(hv_ImageIndex,TTemp[SP-2],&TTemp[SP]);
     else
      T_tuple_greater(hv_ImageIndex,TTemp[SP-2],&TTemp[SP]);
     if(get_i(TTemp[SP],0)) break;
     destroy_tuple(TTemp[SP]);
     /*========== for ==========*/

      /*select_obj (Images, ImageSelected, ImageIndex)*/
      clear_obj(ho_ImageSelected);
      /***/T_select_obj(ho_Images_COPY_INP_TMP, &ho_ImageSelected, hv_ImageIndex);

      /*count_channels (ImageSelected, NumChannels)*/
      destroy_tuple(hv_NumChannels);
      /***/T_count_channels(ho_ImageSelected, &hv_NumChannels);

      /*gen_empty_obj (ImageScaled)*/
      clear_obj(ho_ImageScaled);
      /***/gen_empty_obj(&ho_ImageScaled);

      /*========== for ChannelIndex := 1 to NumChannels by 1 ==========*/
      copy_tuple(hv_NumChannels,&TTemp[SP++]);
      create_tuple_i(&TTemp[SP++],1);
      create_tuple_i(&TTemp[SP++],1);
      T_tuple_greater(TTemp[SP-1],TTemp[SP-3],&TTemp[SP]);
      SP++;
      T_tuple_equal(TTemp[SP-2],TTemp[SP-4],&TTemp[SP]);
      if(get_i(TTemp[SP],0) ||
         (!((( get_i(TTemp[SP-1],0)) && (get_d(TTemp[SP-3],0)>0)) ||
            ((!get_i(TTemp[SP-1],0)) && (get_d(TTemp[SP-3],0)<0)))))
      {
       destroy_tuple(TTemp[SP--]);
       destroy_tuple(TTemp[SP]);
       T_tuple_sub(TTemp[SP-1],TTemp[SP-2],&TTemp[SP]);
       destroy_tuple(hv_ChannelIndex);
       copy_tuple(TTemp[SP],&hv_ChannelIndex);
       destroy_tuple(TTemp[SP--]);
       destroy_tuple(TTemp[SP]);
       for(;;)
       {
       T_tuple_add(hv_ChannelIndex,TTemp[SP-1],&TTemp[SP]);
       destroy_tuple(hv_ChannelIndex);
       copy_tuple(TTemp[SP],&hv_ChannelIndex);
       destroy_tuple(TTemp[SP]);
       if(get_d(TTemp[SP-1],0)<0)
        T_tuple_less(hv_ChannelIndex,TTemp[SP-2],&TTemp[SP]);
       else
        T_tuple_greater(hv_ChannelIndex,TTemp[SP-2],&TTemp[SP]);
       if(get_i(TTemp[SP],0)) break;
       destroy_tuple(TTemp[SP]);
       /*========== for ==========*/

        /*access_channel (ImageSelected, Channel, ChannelIndex)*/
        clear_obj(ho_Channel);
        /***/T_access_channel(ho_ImageSelected, &ho_Channel, hv_ChannelIndex);

        /*min_max_gray (Channel, Channel, 0, Min, Max, Range)*/
        create_tuple_i(&TTemp[SP++],0);
        destroy_tuple(hv_Min);
        destroy_tuple(hv_Max);
        destroy_tuple(hv_Range);
        /***/T_min_max_gray(ho_Channel, ho_Channel, TTemp[SP-1], &hv_Min, &hv_Max, 
            &hv_Range);
        destroy_tuple(TTemp[--SP]);

        /*========== if (Max - Min == 0) ==========*/
        T_tuple_sub(hv_Max,hv_Min,&TTemp[SP++]);
        create_tuple_i(&TTemp[SP++],0);
        T_tuple_equal(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-2]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-2]=TTemp[SP];
        SP--;
        if(get_i(TTemp[SP-1],0))
        {
          /*Scale := 1*/
          reuse_tuple_i(&hv_Scale,1);

        }
        else
        {
          /*Scale := (ImageRangeMax - ImageRangeMin) / (Max - Min)*/
          T_tuple_sub(hv_ImageRangeMax,hv_ImageRangeMin,&TTemp[SP++]);
          T_tuple_sub(hv_Max,hv_Min,&TTemp[SP++]);
          T_tuple_div(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
          destroy_tuple(TTemp[SP-2]);
          destroy_tuple(TTemp[SP-1]);
          TTemp[SP-2]=TTemp[SP];
          SP--;
          destroy_tuple(hv_Scale);
          hv_Scale=TTemp[--SP];

        }
        destroy_tuple(TTemp[--SP]);
        /*========== end if ==========*/
        /*Shift := -Scale * Min + ImageRangeMin*/
        T_tuple_neg(hv_Scale,&TTemp[SP++]);
        T_tuple_mult(TTemp[SP-1],hv_Min,&TTemp[SP]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-1]=TTemp[SP];
        T_tuple_add(TTemp[SP-1],hv_ImageRangeMin,&TTemp[SP]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-1]=TTemp[SP];
        destroy_tuple(hv_Shift);
        hv_Shift=TTemp[--SP];

        /*scale_image (Channel, ChannelScaled, Scale, Shift)*/
        clear_obj(ho_ChannelScaled);
        /***/T_scale_image(ho_Channel, &ho_ChannelScaled, hv_Scale, hv_Shift);

        /*append_channel (ImageScaled, ChannelScaled, ImageScaled)*/
        /***/append_channel(ho_ImageScaled, ho_ChannelScaled, &(OTemp[SPO]));
        SPO++;
        clear_obj(ho_ImageScaled);
        ho_ImageScaled = OTemp[--SPO];

       }
       destroy_tuple(TTemp[SP--]);
       destroy_tuple(TTemp[SP--]);
       destroy_tuple(TTemp[SP]);
      }
      else
      {
       destroy_tuple(TTemp[SP--]);
       destroy_tuple(TTemp[SP--]);
       destroy_tuple(TTemp[SP--]);
       destroy_tuple(TTemp[SP--]);
       destroy_tuple(TTemp[SP]);
      }/*========== end for ========*/

      /*concat_obj (ImagesScaled, ImageScaled, ImagesScaled)*/
      /***/concat_obj(ho_ImagesScaled, ho_ImageScaled, &(OTemp[SPO]));
      SPO++;
      clear_obj(ho_ImagesScaled);
      ho_ImagesScaled = OTemp[--SPO];

     }
     destroy_tuple(TTemp[SP--]);
     destroy_tuple(TTemp[SP--]);
     destroy_tuple(TTemp[SP]);
    }
    else
    {
     destroy_tuple(TTemp[SP--]);
     destroy_tuple(TTemp[SP--]);
     destroy_tuple(TTemp[SP--]);
     destroy_tuple(TTemp[SP--]);
     destroy_tuple(TTemp[SP]);
    }/*========== end for ========*/

    /*Images := ImagesScaled*/
    clear_obj(ho_Images_COPY_INP_TMP);
    copy_obj(ho_ImagesScaled,&ho_Images_COPY_INP_TMP,1,-1);

  }
  else
  {
  destroy_tuple(TTemp[--SP]);
  /*========== elseif (NormalizationType == 'first_channel') ==========*/

  create_tuple_s(&TTemp[SP++],"first_channel");
  T_tuple_equal(hv_NormalizationType,TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-1]=TTemp[SP];
  if(get_i(TTemp[SP-1],0))
  {
    /*Scale for each image the gray values of first channel to ImageRangeMin-ImageRangeMax.*/
    /*gen_empty_obj (ImagesScaled)*/
    clear_obj(ho_ImagesScaled);
    /***/gen_empty_obj(&ho_ImagesScaled);

    /*========== for ImageIndex := 1 to NumImages by 1 ==========*/
    copy_tuple(hv_NumImages,&TTemp[SP++]);
    create_tuple_i(&TTemp[SP++],1);
    create_tuple_i(&TTemp[SP++],1);
    T_tuple_greater(TTemp[SP-1],TTemp[SP-3],&TTemp[SP]);
    SP++;
    T_tuple_equal(TTemp[SP-2],TTemp[SP-4],&TTemp[SP]);
    if(get_i(TTemp[SP],0) ||
       (!((( get_i(TTemp[SP-1],0)) && (get_d(TTemp[SP-3],0)>0)) ||
          ((!get_i(TTemp[SP-1],0)) && (get_d(TTemp[SP-3],0)<0)))))
    {
     destroy_tuple(TTemp[SP--]);
     destroy_tuple(TTemp[SP]);
     T_tuple_sub(TTemp[SP-1],TTemp[SP-2],&TTemp[SP]);
     destroy_tuple(hv_ImageIndex);
     copy_tuple(TTemp[SP],&hv_ImageIndex);
     destroy_tuple(TTemp[SP--]);
     destroy_tuple(TTemp[SP]);
     for(;;)
     {
     T_tuple_add(hv_ImageIndex,TTemp[SP-1],&TTemp[SP]);
     destroy_tuple(hv_ImageIndex);
     copy_tuple(TTemp[SP],&hv_ImageIndex);
     destroy_tuple(TTemp[SP]);
     if(get_d(TTemp[SP-1],0)<0)
      T_tuple_less(hv_ImageIndex,TTemp[SP-2],&TTemp[SP]);
     else
      T_tuple_greater(hv_ImageIndex,TTemp[SP-2],&TTemp[SP]);
     if(get_i(TTemp[SP],0)) break;
     destroy_tuple(TTemp[SP]);
     /*========== for ==========*/

      /*select_obj (Images, ImageSelected, ImageIndex)*/
      clear_obj(ho_ImageSelected);
      /***/T_select_obj(ho_Images_COPY_INP_TMP, &ho_ImageSelected, hv_ImageIndex);

      /*min_max_gray (ImageSelected, ImageSelected, 0, Min, Max, Range)*/
      create_tuple_i(&TTemp[SP++],0);
      destroy_tuple(hv_Min);
      destroy_tuple(hv_Max);
      destroy_tuple(hv_Range);
      /***/T_min_max_gray(ho_ImageSelected, ho_ImageSelected, TTemp[SP-1], &hv_Min, 
          &hv_Max, &hv_Range);
      destroy_tuple(TTemp[--SP]);

      /*========== if (Max - Min == 0) ==========*/
      T_tuple_sub(hv_Max,hv_Min,&TTemp[SP++]);
      create_tuple_i(&TTemp[SP++],0);
      T_tuple_equal(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-2]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-2]=TTemp[SP];
      SP--;
      if(get_i(TTemp[SP-1],0))
      {
        /*Scale := 1*/
        reuse_tuple_i(&hv_Scale,1);

      }
      else
      {
        /*Scale := (ImageRangeMax - ImageRangeMin) / (Max - Min)*/
        T_tuple_sub(hv_ImageRangeMax,hv_ImageRangeMin,&TTemp[SP++]);
        T_tuple_sub(hv_Max,hv_Min,&TTemp[SP++]);
        T_tuple_div(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-2]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-2]=TTemp[SP];
        SP--;
        destroy_tuple(hv_Scale);
        hv_Scale=TTemp[--SP];

      }
      destroy_tuple(TTemp[--SP]);
      /*========== end if ==========*/
      /*Shift := -Scale * Min + ImageRangeMin*/
      T_tuple_neg(hv_Scale,&TTemp[SP++]);
      T_tuple_mult(TTemp[SP-1],hv_Min,&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      T_tuple_add(TTemp[SP-1],hv_ImageRangeMin,&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      destroy_tuple(hv_Shift);
      hv_Shift=TTemp[--SP];

      /*scale_image (ImageSelected, ImageSelected, Scale, Shift)*/
      /***/T_scale_image(ho_ImageSelected, &(OTemp[SPO]), hv_Scale, hv_Shift);
      SPO++;
      clear_obj(ho_ImageSelected);
      ho_ImageSelected = OTemp[--SPO];

      /*concat_obj (ImagesScaled, ImageSelected, ImagesScaled)*/
      /***/concat_obj(ho_ImagesScaled, ho_ImageSelected, &(OTemp[SPO]));
      SPO++;
      clear_obj(ho_ImagesScaled);
      ho_ImagesScaled = OTemp[--SPO];

     }
     destroy_tuple(TTemp[SP--]);
     destroy_tuple(TTemp[SP--]);
     destroy_tuple(TTemp[SP]);
    }
    else
    {
     destroy_tuple(TTemp[SP--]);
     destroy_tuple(TTemp[SP--]);
     destroy_tuple(TTemp[SP--]);
     destroy_tuple(TTemp[SP--]);
     destroy_tuple(TTemp[SP]);
    }/*========== end for ========*/

    /*Images := ImagesScaled*/
    clear_obj(ho_Images_COPY_INP_TMP);
    copy_obj(ho_ImagesScaled,&ho_Images_COPY_INP_TMP,1,-1);

  }
  else
  {
  destroy_tuple(TTemp[--SP]);
  /*========== elseif (NormalizationType == 'constant_values') ==========*/

  create_tuple_s(&TTemp[SP++],"constant_values");
  T_tuple_equal(hv_NormalizationType,TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-1]=TTemp[SP];
  if(get_i(TTemp[SP-1],0))
  {
    /*Scale for each image the gray values of all channels to the corresponding channel DeviationValues[].*/
    /* try(...); only in hdevelop*/
      /*get_dict_tuple (DLPreprocessParam, 'mean_values_normalization', MeanValues)*/
      create_tuple_s(&TTemp[SP++],"mean_values_normalization");
      destroy_tuple(hv_MeanValues);
      /***/T_get_dict_tuple(hv_DLPreprocessParam, TTemp[SP-1], &hv_MeanValues);
      destroy_tuple(TTemp[--SP]);

      /*get_dict_tuple (DLPreprocessParam, 'deviation_values_normalization', DeviationValues)*/
      create_tuple_s(&TTemp[SP++],"deviation_values_normalization");
      destroy_tuple(hv_DeviationValues);
      /***/T_get_dict_tuple(hv_DLPreprocessParam, TTemp[SP-1], &hv_DeviationValues);
      destroy_tuple(TTemp[--SP]);

      /*UseDefaultNormalizationValues := false*/
      reuse_tuple_i(&hv_UseDefaultNormalizationValues,0);

    /* catch(...); only in hdevelop*/
      /* assign(...); only in hdevelop*/
      /* assign(...); only in hdevelop*/
      /* assign(...); only in hdevelop*/
    /* endtry(...); only in hdevelop*/
    /*gen_empty_obj (ImagesScaled)*/
    clear_obj(ho_ImagesScaled);
    /***/gen_empty_obj(&ho_ImagesScaled);

    /*========== for ImageIndex := 1 to NumImages by 1 ==========*/
    copy_tuple(hv_NumImages,&TTemp[SP++]);
    create_tuple_i(&TTemp[SP++],1);
    create_tuple_i(&TTemp[SP++],1);
    T_tuple_greater(TTemp[SP-1],TTemp[SP-3],&TTemp[SP]);
    SP++;
    T_tuple_equal(TTemp[SP-2],TTemp[SP-4],&TTemp[SP]);
    if(get_i(TTemp[SP],0) ||
       (!((( get_i(TTemp[SP-1],0)) && (get_d(TTemp[SP-3],0)>0)) ||
          ((!get_i(TTemp[SP-1],0)) && (get_d(TTemp[SP-3],0)<0)))))
    {
     destroy_tuple(TTemp[SP--]);
     destroy_tuple(TTemp[SP]);
     T_tuple_sub(TTemp[SP-1],TTemp[SP-2],&TTemp[SP]);
     destroy_tuple(hv_ImageIndex);
     copy_tuple(TTemp[SP],&hv_ImageIndex);
     destroy_tuple(TTemp[SP--]);
     destroy_tuple(TTemp[SP]);
     for(;;)
     {
     T_tuple_add(hv_ImageIndex,TTemp[SP-1],&TTemp[SP]);
     destroy_tuple(hv_ImageIndex);
     copy_tuple(TTemp[SP],&hv_ImageIndex);
     destroy_tuple(TTemp[SP]);
     if(get_d(TTemp[SP-1],0)<0)
      T_tuple_less(hv_ImageIndex,TTemp[SP-2],&TTemp[SP]);
     else
      T_tuple_greater(hv_ImageIndex,TTemp[SP-2],&TTemp[SP]);
     if(get_i(TTemp[SP],0)) break;
     destroy_tuple(TTemp[SP]);
     /*========== for ==========*/

      /*select_obj (Images, ImageSelected, ImageIndex)*/
      clear_obj(ho_ImageSelected);
      /***/T_select_obj(ho_Images_COPY_INP_TMP, &ho_ImageSelected, hv_ImageIndex);

      /*count_channels (ImageSelected, NumChannels)*/
      destroy_tuple(hv_NumChannels);
      /***/T_count_channels(ho_ImageSelected, &hv_NumChannels);

      /*Ensure that the number of channels is equal |DeviationValues| and |MeanValues|*/
      /*========== if (UseDefaultNormalizationValues) ==========*/
      copy_tuple(hv_UseDefaultNormalizationValues,&TTemp[SP++]);
      if(get_i(TTemp[SP-1],0))
      {
        /*========== if (NumChannels == 1) ==========*/
        create_tuple_i(&TTemp[SP++],1);
        T_tuple_equal(hv_NumChannels,TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-1]=TTemp[SP];
        if(get_i(TTemp[SP-1],0))
        {
          /*compose3 (ImageSelected, ImageSelected, ImageSelected, ImageSelected)*/
          /***/compose3(ho_ImageSelected, ho_ImageSelected, ho_ImageSelected, &(OTemp[SPO])
              );
          SPO++;
          clear_obj(ho_ImageSelected);
          ho_ImageSelected = OTemp[--SPO];

          /*count_channels (ImageSelected, NumChannels)*/
          destroy_tuple(hv_NumChannels);
          /***/T_count_channels(ho_ImageSelected, &hv_NumChannels);

        }
        else
        {
        destroy_tuple(TTemp[--SP]);
        /*========== elseif (NumChannels != 3) ==========*/

        create_tuple_i(&TTemp[SP++],3);
        T_tuple_not_equal(hv_NumChannels,TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-1]=TTemp[SP];
        if(get_i(TTemp[SP-1],0))
        {
          /* throw(...); only in hdevelop*/
        }
        }
        destroy_tuple(TTemp[--SP]);
        /*========== end if ==========*/
      }
      destroy_tuple(TTemp[--SP]);
      /*========== end if ==========*/
      /*========== if (|MeanValues| != NumChannels or |DeviationValues| != NumChannels) ==========*/
      T_tuple_length(hv_MeanValues,&TTemp[SP++]);
      T_tuple_not_equal(TTemp[SP-1],hv_NumChannels,&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      T_tuple_length(hv_DeviationValues,&TTemp[SP++]);
      T_tuple_not_equal(TTemp[SP-1],hv_NumChannels,&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      T_tuple_or(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-2]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-2]=TTemp[SP];
      SP--;
      if(get_i(TTemp[SP-1],0))
      {
        /* throw(...); only in hdevelop*/
      }
      destroy_tuple(TTemp[--SP]);
      /*========== end if ==========*/
      /*gen_empty_obj (ImageScaled)*/
      clear_obj(ho_ImageScaled);
      /***/gen_empty_obj(&ho_ImageScaled);

      /*========== for ChannelIndex := 1 to NumChannels by 1 ==========*/
      copy_tuple(hv_NumChannels,&TTemp[SP++]);
      create_tuple_i(&TTemp[SP++],1);
      create_tuple_i(&TTemp[SP++],1);
      T_tuple_greater(TTemp[SP-1],TTemp[SP-3],&TTemp[SP]);
      SP++;
      T_tuple_equal(TTemp[SP-2],TTemp[SP-4],&TTemp[SP]);
      if(get_i(TTemp[SP],0) ||
         (!((( get_i(TTemp[SP-1],0)) && (get_d(TTemp[SP-3],0)>0)) ||
            ((!get_i(TTemp[SP-1],0)) && (get_d(TTemp[SP-3],0)<0)))))
      {
       destroy_tuple(TTemp[SP--]);
       destroy_tuple(TTemp[SP]);
       T_tuple_sub(TTemp[SP-1],TTemp[SP-2],&TTemp[SP]);
       destroy_tuple(hv_ChannelIndex);
       copy_tuple(TTemp[SP],&hv_ChannelIndex);
       destroy_tuple(TTemp[SP--]);
       destroy_tuple(TTemp[SP]);
       for(;;)
       {
       T_tuple_add(hv_ChannelIndex,TTemp[SP-1],&TTemp[SP]);
       destroy_tuple(hv_ChannelIndex);
       copy_tuple(TTemp[SP],&hv_ChannelIndex);
       destroy_tuple(TTemp[SP]);
       if(get_d(TTemp[SP-1],0)<0)
        T_tuple_less(hv_ChannelIndex,TTemp[SP-2],&TTemp[SP]);
       else
        T_tuple_greater(hv_ChannelIndex,TTemp[SP-2],&TTemp[SP]);
       if(get_i(TTemp[SP],0)) break;
       destroy_tuple(TTemp[SP]);
       /*========== for ==========*/

        /*access_channel (ImageSelected, Channel, ChannelIndex)*/
        clear_obj(ho_Channel);
        /***/T_access_channel(ho_ImageSelected, &ho_Channel, hv_ChannelIndex);

        /*Scale := 1.0 / DeviationValues[ChannelIndex - 1]*/
        create_tuple_d(&TTemp[SP++],1.0);
        create_tuple_i(&TTemp[SP++],1);
        T_tuple_sub(hv_ChannelIndex,TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-1]=TTemp[SP];
        T_tuple_select(hv_DeviationValues,TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-1]=TTemp[SP];
        T_tuple_div(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-2]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-2]=TTemp[SP];
        SP--;
        destroy_tuple(hv_Scale);
        hv_Scale=TTemp[--SP];

        /*Shift := -Scale * MeanValues[ChannelIndex - 1]*/
        T_tuple_neg(hv_Scale,&TTemp[SP++]);
        create_tuple_i(&TTemp[SP++],1);
        T_tuple_sub(hv_ChannelIndex,TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-1]=TTemp[SP];
        T_tuple_select(hv_MeanValues,TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-1]=TTemp[SP];
        T_tuple_mult(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-2]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-2]=TTemp[SP];
        SP--;
        destroy_tuple(hv_Shift);
        hv_Shift=TTemp[--SP];

        /*scale_image (Channel, ChannelScaled, Scale, Shift)*/
        clear_obj(ho_ChannelScaled);
        /***/T_scale_image(ho_Channel, &ho_ChannelScaled, hv_Scale, hv_Shift);

        /*append_channel (ImageScaled, ChannelScaled, ImageScaled)*/
        /***/append_channel(ho_ImageScaled, ho_ChannelScaled, &(OTemp[SPO]));
        SPO++;
        clear_obj(ho_ImageScaled);
        ho_ImageScaled = OTemp[--SPO];

       }
       destroy_tuple(TTemp[SP--]);
       destroy_tuple(TTemp[SP--]);
       destroy_tuple(TTemp[SP]);
      }
      else
      {
       destroy_tuple(TTemp[SP--]);
       destroy_tuple(TTemp[SP--]);
       destroy_tuple(TTemp[SP--]);
       destroy_tuple(TTemp[SP--]);
       destroy_tuple(TTemp[SP]);
      }/*========== end for ========*/

      /*concat_obj (ImagesScaled, ImageScaled, ImagesScaled)*/
      /***/concat_obj(ho_ImagesScaled, ho_ImageScaled, &(OTemp[SPO]));
      SPO++;
      clear_obj(ho_ImagesScaled);
      ho_ImagesScaled = OTemp[--SPO];

     }
     destroy_tuple(TTemp[SP--]);
     destroy_tuple(TTemp[SP--]);
     destroy_tuple(TTemp[SP]);
    }
    else
    {
     destroy_tuple(TTemp[SP--]);
     destroy_tuple(TTemp[SP--]);
     destroy_tuple(TTemp[SP--]);
     destroy_tuple(TTemp[SP--]);
     destroy_tuple(TTemp[SP]);
    }/*========== end for ========*/

    /*Images := ImagesScaled*/
    clear_obj(ho_Images_COPY_INP_TMP);
    copy_obj(ho_ImagesScaled,&ho_Images_COPY_INP_TMP,1,-1);

  }
  else
  {
  destroy_tuple(TTemp[--SP]);
  /*========== elseif (NormalizationType == 'none') ==========*/

  create_tuple_s(&TTemp[SP++],"none");
  T_tuple_equal(hv_NormalizationType,TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-1]=TTemp[SP];
  if(get_i(TTemp[SP-1],0))
  {
    /*tuple_find (Type, 'byte', Indices)*/
    create_tuple_s(&TTemp[SP++],"byte");
    destroy_tuple(hv_Indices);
    /***/T_tuple_find(hv_Type, TTemp[SP-1], &hv_Indices);
    destroy_tuple(TTemp[--SP]);

    /*========== if (Indices != -1) ==========*/
    create_tuple_i(&TTemp[SP++],-1);
    T_tuple_not_equal(hv_Indices,TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    if(get_i(TTemp[SP-1],0))
    {
      /*Shift the gray values from [0-255] to the expected range for byte images.*/
      /*RescaleRange := (ImageRangeMax - ImageRangeMin) / 255.0*/
      T_tuple_sub(hv_ImageRangeMax,hv_ImageRangeMin,&TTemp[SP++]);
      create_tuple_d(&TTemp[SP++],255.0);
      T_tuple_div(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-2]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-2]=TTemp[SP];
      SP--;
      destroy_tuple(hv_RescaleRange);
      hv_RescaleRange=TTemp[--SP];

      /*select_obj (Images, ImageSelected, Indices + 1)*/
      create_tuple_i(&TTemp[SP++],1);
      T_tuple_add(hv_Indices,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      clear_obj(ho_ImageSelected);
      /***/T_select_obj(ho_Images_COPY_INP_TMP, &ho_ImageSelected, TTemp[SP-1]);
      destroy_tuple(TTemp[--SP]);

      /*scale_image (ImageSelected, ImageSelected, RescaleRange, ImageRangeMin)*/
      /***/T_scale_image(ho_ImageSelected, &(OTemp[SPO]), hv_RescaleRange, hv_ImageRangeMin);
      SPO++;
      clear_obj(ho_ImageSelected);
      ho_ImageSelected = OTemp[--SPO];

      /*replace_obj (Images, ImageSelected, Images, Indices + 1)*/
      create_tuple_i(&TTemp[SP++],1);
      T_tuple_add(hv_Indices,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      /***/T_replace_obj(ho_Images_COPY_INP_TMP, ho_ImageSelected, &(OTemp[SPO]), 
          TTemp[SP-1]);
      SPO++;
      clear_obj(ho_Images_COPY_INP_TMP);
      ho_Images_COPY_INP_TMP = OTemp[--SPO];
      destroy_tuple(TTemp[--SP]);

    }
    destroy_tuple(TTemp[--SP]);
    /*========== end if ==========*/
  }
  else
  {
  destroy_tuple(TTemp[--SP]);
  /*========== elseif (NormalizationType != 'none') ==========*/

  create_tuple_s(&TTemp[SP++],"none");
  T_tuple_not_equal(hv_NormalizationType,TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-1]=TTemp[SP];
  if(get_i(TTemp[SP-1],0))
  {
    /* throw(...); only in hdevelop*/
  }
  }
  }
  }
  }
  destroy_tuple(TTemp[--SP]);
  /*========== end if ==========*/
  /**/
  /*Ensure that the number of channels of the resulting images is consistent with the*/
  /*number of channels of the given model. The only exceptions that are adapted below*/
  /*are combinations of 1- and 3-channel images if ImageNumChannels is either 1 or 3.*/
  /*========== if (ImageNumChannels == 1 or ImageNumChannels == 3) ==========*/
  create_tuple_i(&TTemp[SP++],1);
  T_tuple_equal(hv_ImageNumChannels,TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-1]=TTemp[SP];
  create_tuple_i(&TTemp[SP++],3);
  T_tuple_equal(hv_ImageNumChannels,TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-1]=TTemp[SP];
  T_tuple_or(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-2]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-2]=TTemp[SP];
  SP--;
  if(get_i(TTemp[SP-1],0))
  {
    /*count_channels (Images, CurrentNumChannels)*/
    destroy_tuple(hv_CurrentNumChannels);
    /***/T_count_channels(ho_Images_COPY_INP_TMP, &hv_CurrentNumChannels);

    /*tuple_find (CurrentNumChannels [!=] OutputNumChannels, 1, DiffNumChannelsIndices)*/
    T_tuple_not_equal_elem(hv_CurrentNumChannels,hv_OutputNumChannels,&TTemp[SP++]);
    create_tuple_i(&TTemp[SP++],1);
    destroy_tuple(hv_DiffNumChannelsIndices);
    /***/T_tuple_find(TTemp[SP-2], TTemp[SP-1], &hv_DiffNumChannelsIndices);
    destroy_tuple(TTemp[--SP]);
    destroy_tuple(TTemp[--SP]);

    /*========== if (DiffNumChannelsIndices != -1) ==========*/
    create_tuple_i(&TTemp[SP++],-1);
    T_tuple_not_equal(hv_DiffNumChannelsIndices,TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    if(get_i(TTemp[SP-1],0))
    {
      /*========== for Index := 0 to |DiffNumChannelsIndices| - 1 by 1 ==========*/
      T_tuple_length(hv_DiffNumChannelsIndices,&TTemp[SP++]);
      create_tuple_i(&TTemp[SP++],1);
      T_tuple_sub(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-2]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-2]=TTemp[SP];
      SP--;
      create_tuple_i(&TTemp[SP++],1);
      create_tuple_i(&TTemp[SP++],0);
      T_tuple_greater(TTemp[SP-1],TTemp[SP-3],&TTemp[SP]);
      SP++;
      T_tuple_equal(TTemp[SP-2],TTemp[SP-4],&TTemp[SP]);
      if(get_i(TTemp[SP],0) ||
         (!((( get_i(TTemp[SP-1],0)) && (get_d(TTemp[SP-3],0)>0)) ||
            ((!get_i(TTemp[SP-1],0)) && (get_d(TTemp[SP-3],0)<0)))))
      {
       destroy_tuple(TTemp[SP--]);
       destroy_tuple(TTemp[SP]);
       T_tuple_sub(TTemp[SP-1],TTemp[SP-2],&TTemp[SP]);
       destroy_tuple(hv_Index);
       copy_tuple(TTemp[SP],&hv_Index);
       destroy_tuple(TTemp[SP--]);
       destroy_tuple(TTemp[SP]);
       for(;;)
       {
       T_tuple_add(hv_Index,TTemp[SP-1],&TTemp[SP]);
       destroy_tuple(hv_Index);
       copy_tuple(TTemp[SP],&hv_Index);
       destroy_tuple(TTemp[SP]);
       if(get_d(TTemp[SP-1],0)<0)
        T_tuple_less(hv_Index,TTemp[SP-2],&TTemp[SP]);
       else
        T_tuple_greater(hv_Index,TTemp[SP-2],&TTemp[SP]);
       if(get_i(TTemp[SP],0)) break;
       destroy_tuple(TTemp[SP]);
       /*========== for ==========*/

        /*DiffNumChannelsIndex := DiffNumChannelsIndices[Index]*/
        T_tuple_select(hv_DiffNumChannelsIndices,hv_Index,&TTemp[SP++]);
        destroy_tuple(hv_DiffNumChannelsIndex);
        hv_DiffNumChannelsIndex=TTemp[--SP];

        /*ImageIndex := DiffNumChannelsIndex + 1*/
        create_tuple_i(&TTemp[SP++],1);
        T_tuple_add(hv_DiffNumChannelsIndex,TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-1]=TTemp[SP];
        destroy_tuple(hv_ImageIndex);
        hv_ImageIndex=TTemp[--SP];

        /*NumChannels := CurrentNumChannels[ImageIndex - 1]*/
        create_tuple_i(&TTemp[SP++],1);
        T_tuple_sub(hv_ImageIndex,TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-1]=TTemp[SP];
        T_tuple_select(hv_CurrentNumChannels,TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-1]=TTemp[SP];
        destroy_tuple(hv_NumChannels);
        hv_NumChannels=TTemp[--SP];

        /*select_obj (Images, ImageSelected, ImageIndex)*/
        clear_obj(ho_ImageSelected);
        /***/T_select_obj(ho_Images_COPY_INP_TMP, &ho_ImageSelected, hv_ImageIndex);

        /*========== if (NumChannels == 1 and ImageNumChannels == 3) ==========*/
        create_tuple_i(&TTemp[SP++],1);
        T_tuple_equal(hv_NumChannels,TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-1]=TTemp[SP];
        create_tuple_i(&TTemp[SP++],3);
        T_tuple_equal(hv_ImageNumChannels,TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-1]=TTemp[SP];
        T_tuple_and(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-2]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-2]=TTemp[SP];
        SP--;
        if(get_i(TTemp[SP-1],0))
        {
          /*Conversion from 1- to 3-channel image required*/
          /*compose3 (ImageSelected, ImageSelected, ImageSelected, ThreeChannelImage)*/
          clear_obj(ho_ThreeChannelImage);
          /***/compose3(ho_ImageSelected, ho_ImageSelected, ho_ImageSelected, &ho_ThreeChannelImage
              );

          /*replace_obj (Images, ThreeChannelImage, Images, ImageIndex)*/
          /***/T_replace_obj(ho_Images_COPY_INP_TMP, ho_ThreeChannelImage, &(OTemp[SPO]), 
              hv_ImageIndex);
          SPO++;
          clear_obj(ho_Images_COPY_INP_TMP);
          ho_Images_COPY_INP_TMP = OTemp[--SPO];

        }
        else
        {
        destroy_tuple(TTemp[--SP]);
        /*========== elseif (NumChannels == 3 and ImageNumChannels == 1) ==========*/

        create_tuple_i(&TTemp[SP++],3);
        T_tuple_equal(hv_NumChannels,TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-1]=TTemp[SP];
        create_tuple_i(&TTemp[SP++],1);
        T_tuple_equal(hv_ImageNumChannels,TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-1]=TTemp[SP];
        T_tuple_and(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-2]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-2]=TTemp[SP];
        SP--;
        if(get_i(TTemp[SP-1],0))
        {
          /*Conversion from 3- to 1-channel image required*/
          /*rgb1_to_gray (ImageSelected, SingleChannelImage)*/
          clear_obj(ho_SingleChannelImage);
          /***/rgb1_to_gray(ho_ImageSelected, &ho_SingleChannelImage);

          /*replace_obj (Images, SingleChannelImage, Images, ImageIndex)*/
          /***/T_replace_obj(ho_Images_COPY_INP_TMP, ho_SingleChannelImage, &(OTemp[SPO]), 
              hv_ImageIndex);
          SPO++;
          clear_obj(ho_Images_COPY_INP_TMP);
          ho_Images_COPY_INP_TMP = OTemp[--SPO];

        }
        else
        {
          /* throw(...); only in hdevelop*/
        }
        }
        destroy_tuple(TTemp[--SP]);
        /*========== end if ==========*/
       }
       destroy_tuple(TTemp[SP--]);
       destroy_tuple(TTemp[SP--]);
       destroy_tuple(TTemp[SP]);
      }
      else
      {
       destroy_tuple(TTemp[SP--]);
       destroy_tuple(TTemp[SP--]);
       destroy_tuple(TTemp[SP--]);
       destroy_tuple(TTemp[SP--]);
       destroy_tuple(TTemp[SP]);
      }/*========== end for ========*/

    }
    destroy_tuple(TTemp[--SP]);
    /*========== end if ==========*/
  }
  destroy_tuple(TTemp[--SP]);
  /*========== end if ==========*/
  /**/
  /*In case the image domains were preserved, they need to be set back into the images.*/
  /*========== if (PreserveDomain) ==========*/
  copy_tuple(hv_PreserveDomain,&TTemp[SP++]);
  if(get_i(TTemp[SP-1],0))
  {
    /*count_obj (PreservedDomains, NumDomains)*/
    destroy_tuple(hv_NumDomains);
    /***/T_count_obj(ho_PreservedDomains, &hv_NumDomains);

    /*========== for DomainIndex := 1 to NumDomains by 1 ==========*/
    copy_tuple(hv_NumDomains,&TTemp[SP++]);
    create_tuple_i(&TTemp[SP++],1);
    create_tuple_i(&TTemp[SP++],1);
    T_tuple_greater(TTemp[SP-1],TTemp[SP-3],&TTemp[SP]);
    SP++;
    T_tuple_equal(TTemp[SP-2],TTemp[SP-4],&TTemp[SP]);
    if(get_i(TTemp[SP],0) ||
       (!((( get_i(TTemp[SP-1],0)) && (get_d(TTemp[SP-3],0)>0)) ||
          ((!get_i(TTemp[SP-1],0)) && (get_d(TTemp[SP-3],0)<0)))))
    {
     destroy_tuple(TTemp[SP--]);
     destroy_tuple(TTemp[SP]);
     T_tuple_sub(TTemp[SP-1],TTemp[SP-2],&TTemp[SP]);
     destroy_tuple(hv_DomainIndex);
     copy_tuple(TTemp[SP],&hv_DomainIndex);
     destroy_tuple(TTemp[SP--]);
     destroy_tuple(TTemp[SP]);
     for(;;)
     {
     T_tuple_add(hv_DomainIndex,TTemp[SP-1],&TTemp[SP]);
     destroy_tuple(hv_DomainIndex);
     copy_tuple(TTemp[SP],&hv_DomainIndex);
     destroy_tuple(TTemp[SP]);
     if(get_d(TTemp[SP-1],0)<0)
      T_tuple_less(hv_DomainIndex,TTemp[SP-2],&TTemp[SP]);
     else
      T_tuple_greater(hv_DomainIndex,TTemp[SP-2],&TTemp[SP]);
     if(get_i(TTemp[SP],0)) break;
     destroy_tuple(TTemp[SP]);
     /*========== for ==========*/

      /*select_obj (Images, ImageSelected, DomainIndex)*/
      clear_obj(ho_ImageSelected);
      /***/T_select_obj(ho_Images_COPY_INP_TMP, &ho_ImageSelected, hv_DomainIndex);

      /*select_obj (PreservedDomains, DomainSelected, DomainIndex)*/
      clear_obj(ho_DomainSelected);
      /***/T_select_obj(ho_PreservedDomains, &ho_DomainSelected, hv_DomainIndex);

      /*reduce_domain (ImageSelected, DomainSelected, ImageSelected)*/
      /***/reduce_domain(ho_ImageSelected, ho_DomainSelected, &(OTemp[SPO]));
      SPO++;
      clear_obj(ho_ImageSelected);
      ho_ImageSelected = OTemp[--SPO];

      /*replace_obj (Images, ImageSelected, Images, DomainIndex)*/
      /***/T_replace_obj(ho_Images_COPY_INP_TMP, ho_ImageSelected, &(OTemp[SPO]), 
          hv_DomainIndex);
      SPO++;
      clear_obj(ho_Images_COPY_INP_TMP);
      ho_Images_COPY_INP_TMP = OTemp[--SPO];

     }
     destroy_tuple(TTemp[SP--]);
     destroy_tuple(TTemp[SP--]);
     destroy_tuple(TTemp[SP]);
    }
    else
    {
     destroy_tuple(TTemp[SP--]);
     destroy_tuple(TTemp[SP--]);
     destroy_tuple(TTemp[SP--]);
     destroy_tuple(TTemp[SP--]);
     destroy_tuple(TTemp[SP]);
    }/*========== end for ========*/

  }
  destroy_tuple(TTemp[--SP]);
  /*========== end if ==========*/
  /**/
  /*Write preprocessed images to output variable.*/
  /*ImagesPreprocessed := Images*/
  clear_obj((*ho_ImagesPreprocessed));
  copy_obj(ho_Images_COPY_INP_TMP,&(*ho_ImagesPreprocessed),1,-1);

  /**/
  /*========== return ==========*/

  /* Clear temporary tuple stack */
  while (SP > 0)
    destroy_tuple(TTemp[--SP]);
  /* Clear temporary tuple vectors stack*/
  while (SPTV > 0)
    V_destroy_vector(TVTemp[--SPTV]);
  /* Clear local iconic variables */
  clear_obj(ho_PreservedDomains);
  clear_obj(ho_ImageSelected);
  clear_obj(ho_DomainSelected);
  clear_obj(ho_ImagesScaled);
  clear_obj(ho_ImageScaled);
  clear_obj(ho_Channel);
  clear_obj(ho_ChannelScaled);
  clear_obj(ho_ThreeChannelImage);
  clear_obj(ho_SingleChannelImage);
  clear_obj(ho_Images_COPY_INP_TMP);

  /* Clear local control variables */
  destroy_tuple(hv_ImageWidth);
  destroy_tuple(hv_ImageHeight);
  destroy_tuple(hv_ImageNumChannels);
  destroy_tuple(hv_ImageRangeMin);
  destroy_tuple(hv_ImageRangeMax);
  destroy_tuple(hv_DomainHandling);
  destroy_tuple(hv_NormalizationType);
  destroy_tuple(hv_ModelType);
  destroy_tuple(hv_NumImages);
  destroy_tuple(hv_Type);
  destroy_tuple(hv_NumMatches);
  destroy_tuple(hv_InputNumChannels);
  destroy_tuple(hv_OutputNumChannels);
  destroy_tuple(hv_NumChannels1);
  destroy_tuple(hv_NumChannels3);
  destroy_tuple(hv_AreInputNumChannels1);
  destroy_tuple(hv_AreInputNumChannels3);
  destroy_tuple(hv_AreInputNumChannels1Or3);
  destroy_tuple(hv_ValidNumChannels);
  destroy_tuple(hv_ValidNumChannelsText);
  destroy_tuple(hv_PreserveDomain);
  destroy_tuple(hv_Row1);
  destroy_tuple(hv_Column1);
  destroy_tuple(hv_Row2);
  destroy_tuple(hv_Column2);
  destroy_tuple(hv_UniqRow1);
  destroy_tuple(hv_UniqColumn1);
  destroy_tuple(hv_UniqRow2);
  destroy_tuple(hv_UniqColumn2);
  destroy_tuple(hv_RectangleIndex);
  destroy_tuple(hv_OriginalWidth);
  destroy_tuple(hv_OriginalHeight);
  destroy_tuple(hv_UniqWidth);
  destroy_tuple(hv_UniqHeight);
  destroy_tuple(hv_ScaleWidth);
  destroy_tuple(hv_ScaleHeight);
  destroy_tuple(hv_ScaleIndex);
  destroy_tuple(hv_ImageIndex);
  destroy_tuple(hv_NumChannels);
  destroy_tuple(hv_ChannelIndex);
  destroy_tuple(hv_Min);
  destroy_tuple(hv_Max);
  destroy_tuple(hv_Range);
  destroy_tuple(hv_Scale);
  destroy_tuple(hv_Shift);
  destroy_tuple(hv_MeanValues);
  destroy_tuple(hv_DeviationValues);
  destroy_tuple(hv_UseDefaultNormalizationValues);
  destroy_tuple(hv_Exception);
  destroy_tuple(hv_Indices);
  destroy_tuple(hv_RescaleRange);
  destroy_tuple(hv_CurrentNumChannels);
  destroy_tuple(hv_DiffNumChannelsIndices);
  destroy_tuple(hv_Index);
  destroy_tuple(hv_DiffNumChannelsIndex);
  destroy_tuple(hv_NumDomains);
  destroy_tuple(hv_DomainIndex);

  return;

  /****************************************************/
  /******************     End procedure   *************/
  /****************************************************/

}

/* Chapter: OCR / Deep OCR*/
/* Short Description: Preprocess images for deep-learning-based training and inference of Deep OCR detection models. */
void preprocess_dl_model_images_ocr_detection (Hobject ho_Images, Hobject *ho_ImagesPreprocessed, 
    Htuple hv_DLPreprocessParam)
{


  /* Stack for temporary tuples */
  Htuple   TTemp[100];
  int      SP=0;
  /* Stack for temporary objects */
  Hobject  OTemp[20] = {0};
  int      SPO=0;
  /* Stack for temporary tuple vectors */
  Hvector  TVTemp[100] = {0};
  int      SPTV=0;

  /* Local iconic variables */
  Hobject  ho_Image, ho_ImageScaled, ho_Channel;
  Hobject  ho_ChannelScaled, ho_ImageG, ho_ImageB;

  /* Local control variables */
  Htuple  hv_ImageWidth, hv_ImageHeight, hv_ImageNumChannels;
  Htuple  hv_ImageRangeMin, hv_ImageRangeMax, hv_DomainHandling;
  Htuple  hv_NormalizationType, hv_ModelType, hv_NumImages;
  Htuple  hv_NumChannels, hv_ImageTypes, hv_InputImageWidths;
  Htuple  hv_InputImageHeights, hv_ImageRange, hv_I, hv_InputImageWidth;
  Htuple  hv_InputImageHeight, hv_ZoomFactorWidth, hv_ZoomFactorHeight;
  Htuple  hv_ZoomHeight, hv_ZoomWidth, hv_ChannelIndex, hv_Min;
  Htuple  hv_Max, hv_Range, hv_Scale, hv_Shift;

  /* Local copy input parameter variables */
  Hobject  ho_Images_COPY_INP_TMP;


  /* Initialize iconic variables */
  gen_empty_obj(&ho_Image);
  gen_empty_obj(&ho_ImageScaled);
  gen_empty_obj(&ho_Channel);
  gen_empty_obj(&ho_ChannelScaled);
  gen_empty_obj(&ho_ImageG);
  gen_empty_obj(&ho_ImageB);
  gen_empty_obj(&(*ho_ImagesPreprocessed));
  copy_obj(ho_Images,&ho_Images_COPY_INP_TMP,1,-1);

  /* Initialize control variables */
  create_tuple(&hv_ImageWidth,0);
  create_tuple(&hv_ImageHeight,0);
  create_tuple(&hv_ImageNumChannels,0);
  create_tuple(&hv_ImageRangeMin,0);
  create_tuple(&hv_ImageRangeMax,0);
  create_tuple(&hv_DomainHandling,0);
  create_tuple(&hv_NormalizationType,0);
  create_tuple(&hv_ModelType,0);
  create_tuple(&hv_NumImages,0);
  create_tuple(&hv_NumChannels,0);
  create_tuple(&hv_ImageTypes,0);
  create_tuple(&hv_InputImageWidths,0);
  create_tuple(&hv_InputImageHeights,0);
  create_tuple(&hv_ImageRange,0);
  create_tuple(&hv_I,0);
  create_tuple(&hv_InputImageWidth,0);
  create_tuple(&hv_InputImageHeight,0);
  create_tuple(&hv_ZoomFactorWidth,0);
  create_tuple(&hv_ZoomFactorHeight,0);
  create_tuple(&hv_ZoomHeight,0);
  create_tuple(&hv_ZoomWidth,0);
  create_tuple(&hv_ChannelIndex,0);
  create_tuple(&hv_Min,0);
  create_tuple(&hv_Max,0);
  create_tuple(&hv_Range,0);
  create_tuple(&hv_Scale,0);
  create_tuple(&hv_Shift,0);

  /****************************************************/
  /******************   Begin procedure   *************/
  /****************************************************/

  /*This procedure preprocesses the provided images according to the parameters*/
  /*in the dictionary DLPreprocessParam for an ocr_detection model.*/
  /**/
  /*Check the validity of the preprocessing parameters.*/
  /*check_dl_preprocess_param (DLPreprocessParam)*/
  /***/check_dl_preprocess_param(hv_DLPreprocessParam);

  /**/
  /*Get the preprocessing parameters.*/
  /*get_dict_tuple (DLPreprocessParam, 'image_width', ImageWidth)*/
  create_tuple_s(&TTemp[SP++],"image_width");
  destroy_tuple(hv_ImageWidth);
  /***/T_get_dict_tuple(hv_DLPreprocessParam, TTemp[SP-1], &hv_ImageWidth);
  destroy_tuple(TTemp[--SP]);

  /*get_dict_tuple (DLPreprocessParam, 'image_height', ImageHeight)*/
  create_tuple_s(&TTemp[SP++],"image_height");
  destroy_tuple(hv_ImageHeight);
  /***/T_get_dict_tuple(hv_DLPreprocessParam, TTemp[SP-1], &hv_ImageHeight);
  destroy_tuple(TTemp[--SP]);

  /*get_dict_tuple (DLPreprocessParam, 'image_num_channels', ImageNumChannels)*/
  create_tuple_s(&TTemp[SP++],"image_num_channels");
  destroy_tuple(hv_ImageNumChannels);
  /***/T_get_dict_tuple(hv_DLPreprocessParam, TTemp[SP-1], &hv_ImageNumChannels);
  destroy_tuple(TTemp[--SP]);

  /*get_dict_tuple (DLPreprocessParam, 'image_range_min', ImageRangeMin)*/
  create_tuple_s(&TTemp[SP++],"image_range_min");
  destroy_tuple(hv_ImageRangeMin);
  /***/T_get_dict_tuple(hv_DLPreprocessParam, TTemp[SP-1], &hv_ImageRangeMin);
  destroy_tuple(TTemp[--SP]);

  /*get_dict_tuple (DLPreprocessParam, 'image_range_max', ImageRangeMax)*/
  create_tuple_s(&TTemp[SP++],"image_range_max");
  destroy_tuple(hv_ImageRangeMax);
  /***/T_get_dict_tuple(hv_DLPreprocessParam, TTemp[SP-1], &hv_ImageRangeMax);
  destroy_tuple(TTemp[--SP]);

  /*get_dict_tuple (DLPreprocessParam, 'domain_handling', DomainHandling)*/
  create_tuple_s(&TTemp[SP++],"domain_handling");
  destroy_tuple(hv_DomainHandling);
  /***/T_get_dict_tuple(hv_DLPreprocessParam, TTemp[SP-1], &hv_DomainHandling);
  destroy_tuple(TTemp[--SP]);

  /*get_dict_tuple (DLPreprocessParam, 'normalization_type', NormalizationType)*/
  create_tuple_s(&TTemp[SP++],"normalization_type");
  destroy_tuple(hv_NormalizationType);
  /***/T_get_dict_tuple(hv_DLPreprocessParam, TTemp[SP-1], &hv_NormalizationType);
  destroy_tuple(TTemp[--SP]);

  /*get_dict_tuple (DLPreprocessParam, 'model_type', ModelType)*/
  create_tuple_s(&TTemp[SP++],"model_type");
  destroy_tuple(hv_ModelType);
  /***/T_get_dict_tuple(hv_DLPreprocessParam, TTemp[SP-1], &hv_ModelType);
  destroy_tuple(TTemp[--SP]);

  /**/
  /*Check the preprocessing parameters.*/
  /*========== if (ModelType != 'ocr_detection') ==========*/
  create_tuple_s(&TTemp[SP++],"ocr_detection");
  T_tuple_not_equal(hv_ModelType,TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-1]=TTemp[SP];
  if(get_i(TTemp[SP-1],0))
  {
    /* throw(...); only in hdevelop*/
  }
  destroy_tuple(TTemp[--SP]);
  /*========== end if ==========*/
  /*========== if (ImageNumChannels != 3) ==========*/
  create_tuple_i(&TTemp[SP++],3);
  T_tuple_not_equal(hv_ImageNumChannels,TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-1]=TTemp[SP];
  if(get_i(TTemp[SP-1],0))
  {
    /* throw(...); only in hdevelop*/
  }
  destroy_tuple(TTemp[--SP]);
  /*========== end if ==========*/
  /*========== if (DomainHandling != 'full_domain') ==========*/
  create_tuple_s(&TTemp[SP++],"full_domain");
  T_tuple_not_equal(hv_DomainHandling,TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-1]=TTemp[SP];
  if(get_i(TTemp[SP-1],0))
  {
    /* throw(...); only in hdevelop*/
  }
  destroy_tuple(TTemp[--SP]);
  /*========== end if ==========*/
  /*========== if (NormalizationType != 'none' and NormalizationType != 'all_channels') ==========*/
  create_tuple_s(&TTemp[SP++],"none");
  T_tuple_not_equal(hv_NormalizationType,TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-1]=TTemp[SP];
  create_tuple_s(&TTemp[SP++],"all_channels");
  T_tuple_not_equal(hv_NormalizationType,TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-1]=TTemp[SP];
  T_tuple_and(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-2]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-2]=TTemp[SP];
  SP--;
  if(get_i(TTemp[SP-1],0))
  {
    /* throw(...); only in hdevelop*/
  }
  destroy_tuple(TTemp[--SP]);
  /*========== end if ==========*/
  /**/
  /*Get the image properties.*/
  /*count_obj (Images, NumImages)*/
  destroy_tuple(hv_NumImages);
  /***/T_count_obj(ho_Images_COPY_INP_TMP, &hv_NumImages);

  /*count_channels (Images, NumChannels)*/
  destroy_tuple(hv_NumChannels);
  /***/T_count_channels(ho_Images_COPY_INP_TMP, &hv_NumChannels);

  /*get_image_type (Images, ImageTypes)*/
  destroy_tuple(hv_ImageTypes);
  /***/T_get_image_type(ho_Images_COPY_INP_TMP, &hv_ImageTypes);

  /*get_image_size (Images, InputImageWidths, InputImageHeights)*/
  destroy_tuple(hv_InputImageWidths);
  destroy_tuple(hv_InputImageHeights);
  /***/T_get_image_size(ho_Images_COPY_INP_TMP, &hv_InputImageWidths, &hv_InputImageHeights);

  /**/
  /*Check the image properties.*/
  /*========== if (NumImages == 0) ==========*/
  create_tuple_i(&TTemp[SP++],0);
  T_tuple_equal(hv_NumImages,TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-1]=TTemp[SP];
  if(get_i(TTemp[SP-1],0))
  {
    /* throw(...); only in hdevelop*/
  }
  destroy_tuple(TTemp[--SP]);
  /*========== end if ==========*/
  /*========== if (NumImages != regexp_test(ImageTypes,'byte')) ==========*/
  create_tuple_s(&TTemp[SP++],"byte");
  T_tuple_regexp_test(hv_ImageTypes,TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-1]=TTemp[SP];
  T_tuple_not_equal(hv_NumImages,TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-1]=TTemp[SP];
  if(get_i(TTemp[SP-1],0))
  {
    /* throw(...); only in hdevelop*/
  }
  destroy_tuple(TTemp[--SP]);
  /*========== end if ==========*/
  /*========== if (NumImages != sum(NumChannels [==] 1 or NumChannels [==] 3)) ==========*/
  create_tuple_i(&TTemp[SP++],1);
  T_tuple_equal_elem(hv_NumChannels,TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-1]=TTemp[SP];
  create_tuple_i(&TTemp[SP++],3);
  T_tuple_equal_elem(hv_NumChannels,TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-1]=TTemp[SP];
  T_tuple_or(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-2]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-2]=TTemp[SP];
  SP--;
  T_tuple_sum(TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-1]=TTemp[SP];
  T_tuple_not_equal(hv_NumImages,TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-1]=TTemp[SP];
  if(get_i(TTemp[SP-1],0))
  {
    /* throw(...); only in hdevelop*/
  }
  destroy_tuple(TTemp[--SP]);
  /*========== end if ==========*/
  /**/
  /*Preprocess the images.*/
  /*ImageRange := real(ImageRangeMax - ImageRangeMin)*/
  T_tuple_sub(hv_ImageRangeMax,hv_ImageRangeMin,&TTemp[SP++]);
  T_tuple_real(TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-1]=TTemp[SP];
  destroy_tuple(hv_ImageRange);
  hv_ImageRange=TTemp[--SP];

  /*========== for I := 0 to NumImages - 1 by 1 ==========*/
  create_tuple_i(&TTemp[SP++],1);
  T_tuple_sub(hv_NumImages,TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-1]=TTemp[SP];
  create_tuple_i(&TTemp[SP++],1);
  create_tuple_i(&TTemp[SP++],0);
  T_tuple_greater(TTemp[SP-1],TTemp[SP-3],&TTemp[SP]);
  SP++;
  T_tuple_equal(TTemp[SP-2],TTemp[SP-4],&TTemp[SP]);
  if(get_i(TTemp[SP],0) ||
     (!((( get_i(TTemp[SP-1],0)) && (get_d(TTemp[SP-3],0)>0)) ||
        ((!get_i(TTemp[SP-1],0)) && (get_d(TTemp[SP-3],0)<0)))))
  {
   destroy_tuple(TTemp[SP--]);
   destroy_tuple(TTemp[SP]);
   T_tuple_sub(TTemp[SP-1],TTemp[SP-2],&TTemp[SP]);
   destroy_tuple(hv_I);
   copy_tuple(TTemp[SP],&hv_I);
   destroy_tuple(TTemp[SP--]);
   destroy_tuple(TTemp[SP]);
   for(;;)
   {
   T_tuple_add(hv_I,TTemp[SP-1],&TTemp[SP]);
   destroy_tuple(hv_I);
   copy_tuple(TTemp[SP],&hv_I);
   destroy_tuple(TTemp[SP]);
   if(get_d(TTemp[SP-1],0)<0)
    T_tuple_less(hv_I,TTemp[SP-2],&TTemp[SP]);
   else
    T_tuple_greater(hv_I,TTemp[SP-2],&TTemp[SP]);
   if(get_i(TTemp[SP],0)) break;
   destroy_tuple(TTemp[SP]);
   /*========== for ==========*/

    /*InputImageWidth := InputImageWidths[I]*/
    T_tuple_select(hv_InputImageWidths,hv_I,&TTemp[SP++]);
    destroy_tuple(hv_InputImageWidth);
    hv_InputImageWidth=TTemp[--SP];

    /*InputImageHeight := InputImageHeights[I]*/
    T_tuple_select(hv_InputImageHeights,hv_I,&TTemp[SP++]);
    destroy_tuple(hv_InputImageHeight);
    hv_InputImageHeight=TTemp[--SP];

    /**/
    /*select_obj (Images, Image, I + 1)*/
    create_tuple_i(&TTemp[SP++],1);
    T_tuple_add(hv_I,TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    clear_obj(ho_Image);
    /***/T_select_obj(ho_Images_COPY_INP_TMP, &ho_Image, TTemp[SP-1]);
    destroy_tuple(TTemp[--SP]);

    /**/
    /*Calculate aspect-ratio preserving zoom factors*/
    /*calculate_dl_image_zoom_factors (InputImageWidth, InputImageHeight, ImageWidth, ImageHeight, DLPreprocessParam, ZoomFactorWidth, ZoomFactorHeight)*/
    destroy_tuple(hv_ZoomFactorWidth);
    destroy_tuple(hv_ZoomFactorHeight);
    /***/calculate_dl_image_zoom_factors(hv_InputImageWidth, hv_InputImageHeight, 
        hv_ImageWidth, hv_ImageHeight, hv_DLPreprocessParam, &hv_ZoomFactorWidth, 
        &hv_ZoomFactorHeight);

    /**/
    /*Zoom image*/
    /*ZoomHeight := round(ZoomFactorHeight * InputImageHeight)*/
    T_tuple_mult(hv_ZoomFactorHeight,hv_InputImageHeight,&TTemp[SP++]);
    T_tuple_round(TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    destroy_tuple(hv_ZoomHeight);
    hv_ZoomHeight=TTemp[--SP];

    /*ZoomWidth := round(ZoomFactorWidth * InputImageWidth)*/
    T_tuple_mult(hv_ZoomFactorWidth,hv_InputImageWidth,&TTemp[SP++]);
    T_tuple_round(TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    destroy_tuple(hv_ZoomWidth);
    hv_ZoomWidth=TTemp[--SP];

    /*zoom_image_size (Image, Image, ZoomWidth, ZoomHeight, 'constant')*/
    create_tuple_s(&TTemp[SP++],"constant");
    /***/T_zoom_image_size(ho_Image, &(OTemp[SPO]), hv_ZoomWidth, hv_ZoomHeight, 
        TTemp[SP-1]);
    SPO++;
    clear_obj(ho_Image);
    ho_Image = OTemp[--SPO];
    destroy_tuple(TTemp[--SP]);

    /**/
    /*Convert to real and normalize*/
    /*convert_image_type (Image, Image, 'real')*/
    /***/convert_image_type(ho_Image, &(OTemp[SPO]), "real");
    SPO++;
    clear_obj(ho_Image);
    ho_Image = OTemp[--SPO];

    /*========== if (NormalizationType == 'all_channels') ==========*/
    create_tuple_s(&TTemp[SP++],"all_channels");
    T_tuple_equal(hv_NormalizationType,TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    if(get_i(TTemp[SP-1],0))
    {
      /*gen_empty_obj (ImageScaled)*/
      clear_obj(ho_ImageScaled);
      /***/gen_empty_obj(&ho_ImageScaled);

      /*========== for ChannelIndex := 1 to NumChannels[I] by 1 ==========*/
      T_tuple_select(hv_NumChannels,hv_I,&TTemp[SP++]);
      create_tuple_i(&TTemp[SP++],1);
      create_tuple_i(&TTemp[SP++],1);
      T_tuple_greater(TTemp[SP-1],TTemp[SP-3],&TTemp[SP]);
      SP++;
      T_tuple_equal(TTemp[SP-2],TTemp[SP-4],&TTemp[SP]);
      if(get_i(TTemp[SP],0) ||
         (!((( get_i(TTemp[SP-1],0)) && (get_d(TTemp[SP-3],0)>0)) ||
            ((!get_i(TTemp[SP-1],0)) && (get_d(TTemp[SP-3],0)<0)))))
      {
       destroy_tuple(TTemp[SP--]);
       destroy_tuple(TTemp[SP]);
       T_tuple_sub(TTemp[SP-1],TTemp[SP-2],&TTemp[SP]);
       destroy_tuple(hv_ChannelIndex);
       copy_tuple(TTemp[SP],&hv_ChannelIndex);
       destroy_tuple(TTemp[SP--]);
       destroy_tuple(TTemp[SP]);
       for(;;)
       {
       T_tuple_add(hv_ChannelIndex,TTemp[SP-1],&TTemp[SP]);
       destroy_tuple(hv_ChannelIndex);
       copy_tuple(TTemp[SP],&hv_ChannelIndex);
       destroy_tuple(TTemp[SP]);
       if(get_d(TTemp[SP-1],0)<0)
        T_tuple_less(hv_ChannelIndex,TTemp[SP-2],&TTemp[SP]);
       else
        T_tuple_greater(hv_ChannelIndex,TTemp[SP-2],&TTemp[SP]);
       if(get_i(TTemp[SP],0)) break;
       destroy_tuple(TTemp[SP]);
       /*========== for ==========*/

        /*access_channel (Image, Channel, ChannelIndex)*/
        clear_obj(ho_Channel);
        /***/T_access_channel(ho_Image, &ho_Channel, hv_ChannelIndex);

        /*min_max_gray (Channel, Channel, 0, Min, Max, Range)*/
        create_tuple_i(&TTemp[SP++],0);
        destroy_tuple(hv_Min);
        destroy_tuple(hv_Max);
        destroy_tuple(hv_Range);
        /***/T_min_max_gray(ho_Channel, ho_Channel, TTemp[SP-1], &hv_Min, &hv_Max, 
            &hv_Range);
        destroy_tuple(TTemp[--SP]);

        /*========== if (Max - Min == 0) ==========*/
        T_tuple_sub(hv_Max,hv_Min,&TTemp[SP++]);
        create_tuple_i(&TTemp[SP++],0);
        T_tuple_equal(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-2]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-2]=TTemp[SP];
        SP--;
        if(get_i(TTemp[SP-1],0))
        {
          /*Scale := 1*/
          reuse_tuple_i(&hv_Scale,1);

        }
        else
        {
          /*Scale := (ImageRangeMax - ImageRangeMin) / (Max - Min)*/
          T_tuple_sub(hv_ImageRangeMax,hv_ImageRangeMin,&TTemp[SP++]);
          T_tuple_sub(hv_Max,hv_Min,&TTemp[SP++]);
          T_tuple_div(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
          destroy_tuple(TTemp[SP-2]);
          destroy_tuple(TTemp[SP-1]);
          TTemp[SP-2]=TTemp[SP];
          SP--;
          destroy_tuple(hv_Scale);
          hv_Scale=TTemp[--SP];

        }
        destroy_tuple(TTemp[--SP]);
        /*========== end if ==========*/
        /*Shift := -Scale * Min + ImageRangeMin*/
        T_tuple_neg(hv_Scale,&TTemp[SP++]);
        T_tuple_mult(TTemp[SP-1],hv_Min,&TTemp[SP]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-1]=TTemp[SP];
        T_tuple_add(TTemp[SP-1],hv_ImageRangeMin,&TTemp[SP]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-1]=TTemp[SP];
        destroy_tuple(hv_Shift);
        hv_Shift=TTemp[--SP];

        /*scale_image (Channel, ChannelScaled, Scale, Shift)*/
        clear_obj(ho_ChannelScaled);
        /***/T_scale_image(ho_Channel, &ho_ChannelScaled, hv_Scale, hv_Shift);

        /*append_channel (ImageScaled, ChannelScaled, ImageScaled)*/
        /***/append_channel(ho_ImageScaled, ho_ChannelScaled, &(OTemp[SPO]));
        SPO++;
        clear_obj(ho_ImageScaled);
        ho_ImageScaled = OTemp[--SPO];

       }
       destroy_tuple(TTemp[SP--]);
       destroy_tuple(TTemp[SP--]);
       destroy_tuple(TTemp[SP]);
      }
      else
      {
       destroy_tuple(TTemp[SP--]);
       destroy_tuple(TTemp[SP--]);
       destroy_tuple(TTemp[SP--]);
       destroy_tuple(TTemp[SP--]);
       destroy_tuple(TTemp[SP]);
      }/*========== end for ========*/

      /*Image := ImageScaled*/
      clear_obj(ho_Image);
      copy_obj(ho_ImageScaled,&ho_Image,1,-1);

    }
    else
    {
    destroy_tuple(TTemp[--SP]);
    /*========== elseif (NormalizationType == 'none') ==========*/

    create_tuple_s(&TTemp[SP++],"none");
    T_tuple_equal(hv_NormalizationType,TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    if(get_i(TTemp[SP-1],0))
    {
      /*scale_image (Image, Image, ImageRange / 255.0, ImageRangeMin)*/
      create_tuple_d(&TTemp[SP++],255.0);
      T_tuple_div(hv_ImageRange,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      /***/T_scale_image(ho_Image, &(OTemp[SPO]), TTemp[SP-1], hv_ImageRangeMin);
      SPO++;
      clear_obj(ho_Image);
      ho_Image = OTemp[--SPO];
      destroy_tuple(TTemp[--SP]);

    }
    }
    destroy_tuple(TTemp[--SP]);
    /*========== end if ==========*/
    /**/
    /*Obtain an RGB image.*/
    /*========== if (NumChannels[I] == 1) ==========*/
    T_tuple_select(hv_NumChannels,hv_I,&TTemp[SP++]);
    create_tuple_i(&TTemp[SP++],1);
    T_tuple_equal(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-2]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-2]=TTemp[SP];
    SP--;
    if(get_i(TTemp[SP-1],0))
    {
      /*copy_image (Image, ImageG)*/
      clear_obj(ho_ImageG);
      /***/copy_image(ho_Image, &ho_ImageG);

      /*copy_image (Image, ImageB)*/
      clear_obj(ho_ImageB);
      /***/copy_image(ho_Image, &ho_ImageB);

      /*compose3 (Image, ImageG, ImageB, Image)*/
      /***/compose3(ho_Image, ho_ImageG, ho_ImageB, &(OTemp[SPO]));
      SPO++;
      clear_obj(ho_Image);
      ho_Image = OTemp[--SPO];

    }
    destroy_tuple(TTemp[--SP]);
    /*========== end if ==========*/
    /**/
    /*Apply padding to fit the desired image size.*/
    /*The padding value is zero, corresponding to the*/
    /*border handling of the convolution layers.*/
    /*change_format (Image, Image, ImageWidth, ImageHeight)*/
    /***/T_change_format(ho_Image, &(OTemp[SPO]), hv_ImageWidth, hv_ImageHeight);
    SPO++;
    clear_obj(ho_Image);
    ho_Image = OTemp[--SPO];

    /*replace_obj (Images, Image, Images, I + 1)*/
    create_tuple_i(&TTemp[SP++],1);
    T_tuple_add(hv_I,TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    /***/T_replace_obj(ho_Images_COPY_INP_TMP, ho_Image, &(OTemp[SPO]), TTemp[SP-1]);
    SPO++;
    clear_obj(ho_Images_COPY_INP_TMP);
    ho_Images_COPY_INP_TMP = OTemp[--SPO];
    destroy_tuple(TTemp[--SP]);

   }
   destroy_tuple(TTemp[SP--]);
   destroy_tuple(TTemp[SP--]);
   destroy_tuple(TTemp[SP]);
  }
  else
  {
   destroy_tuple(TTemp[SP--]);
   destroy_tuple(TTemp[SP--]);
   destroy_tuple(TTemp[SP--]);
   destroy_tuple(TTemp[SP--]);
   destroy_tuple(TTemp[SP]);
  }/*========== end for ========*/

  /**/
  /*Return the preprocessed images.*/
  /*ImagesPreprocessed := Images*/
  clear_obj((*ho_ImagesPreprocessed));
  copy_obj(ho_Images_COPY_INP_TMP,&(*ho_ImagesPreprocessed),1,-1);

  /*========== return ==========*/

  /* Clear temporary tuple stack */
  while (SP > 0)
    destroy_tuple(TTemp[--SP]);
  /* Clear temporary tuple vectors stack*/
  while (SPTV > 0)
    V_destroy_vector(TVTemp[--SPTV]);
  /* Clear local iconic variables */
  clear_obj(ho_Image);
  clear_obj(ho_ImageScaled);
  clear_obj(ho_Channel);
  clear_obj(ho_ChannelScaled);
  clear_obj(ho_ImageG);
  clear_obj(ho_ImageB);
  clear_obj(ho_Images_COPY_INP_TMP);

  /* Clear local control variables */
  destroy_tuple(hv_ImageWidth);
  destroy_tuple(hv_ImageHeight);
  destroy_tuple(hv_ImageNumChannels);
  destroy_tuple(hv_ImageRangeMin);
  destroy_tuple(hv_ImageRangeMax);
  destroy_tuple(hv_DomainHandling);
  destroy_tuple(hv_NormalizationType);
  destroy_tuple(hv_ModelType);
  destroy_tuple(hv_NumImages);
  destroy_tuple(hv_NumChannels);
  destroy_tuple(hv_ImageTypes);
  destroy_tuple(hv_InputImageWidths);
  destroy_tuple(hv_InputImageHeights);
  destroy_tuple(hv_ImageRange);
  destroy_tuple(hv_I);
  destroy_tuple(hv_InputImageWidth);
  destroy_tuple(hv_InputImageHeight);
  destroy_tuple(hv_ZoomFactorWidth);
  destroy_tuple(hv_ZoomFactorHeight);
  destroy_tuple(hv_ZoomHeight);
  destroy_tuple(hv_ZoomWidth);
  destroy_tuple(hv_ChannelIndex);
  destroy_tuple(hv_Min);
  destroy_tuple(hv_Max);
  destroy_tuple(hv_Range);
  destroy_tuple(hv_Scale);
  destroy_tuple(hv_Shift);

  return;

  /****************************************************/
  /******************     End procedure   *************/
  /****************************************************/

}

/* Chapter: OCR / Deep OCR*/
/* Short Description: Preprocess images for deep-learning-based training and inference of Deep OCR recognition models. */
void preprocess_dl_model_images_ocr_recognition (Hobject ho_Images, Hobject *ho_ImagesPreprocessed, 
    Htuple hv_DLPreprocessParam)
{


  /* Stack for temporary tuples */
  Htuple   TTemp[100];
  int      SP=0;
  /* Stack for temporary objects */
  Hobject  OTemp[20] = {0};
  int      SPO=0;
  /* Stack for temporary tuple vectors */
  Hvector  TVTemp[100] = {0};
  int      SPTV=0;

  /* Local iconic variables */
  Hobject  ho_TargetImage, ho_Image;

  /* Local control variables */
  Htuple  hv_ImageWidth, hv_ImageHeight, hv_ImageNumChannels;
  Htuple  hv_ImageRangeMin, hv_ImageRangeMax, hv_DomainHandling;
  Htuple  hv_NormalizationType, hv_ModelType, hv_NumImages;
  Htuple  hv_NumChannels, hv_ImageTypes, hv_InputImageWidths;
  Htuple  hv_InputImageHeights, hv_PaddingGrayval, hv_ImageRange;
  Htuple  hv_I, hv_InputImageWidth, hv_InputImageHeight, hv_InputImageWidthHeightRatio;
  Htuple  hv_ZoomHeight, hv_ZoomWidth, hv_GrayvalMin, hv_GrayvalMax;
  Htuple  hv_Range, hv_GrayvalRange, hv_Scale, hv_Shift;

  /* Local copy input parameter variables */
  Hobject  ho_Images_COPY_INP_TMP;


  /* Initialize iconic variables */
  gen_empty_obj(&ho_TargetImage);
  gen_empty_obj(&ho_Image);
  gen_empty_obj(&(*ho_ImagesPreprocessed));
  copy_obj(ho_Images,&ho_Images_COPY_INP_TMP,1,-1);

  /* Initialize control variables */
  create_tuple(&hv_ImageWidth,0);
  create_tuple(&hv_ImageHeight,0);
  create_tuple(&hv_ImageNumChannels,0);
  create_tuple(&hv_ImageRangeMin,0);
  create_tuple(&hv_ImageRangeMax,0);
  create_tuple(&hv_DomainHandling,0);
  create_tuple(&hv_NormalizationType,0);
  create_tuple(&hv_ModelType,0);
  create_tuple(&hv_NumImages,0);
  create_tuple(&hv_NumChannels,0);
  create_tuple(&hv_ImageTypes,0);
  create_tuple(&hv_InputImageWidths,0);
  create_tuple(&hv_InputImageHeights,0);
  create_tuple(&hv_PaddingGrayval,0);
  create_tuple(&hv_ImageRange,0);
  create_tuple(&hv_I,0);
  create_tuple(&hv_InputImageWidth,0);
  create_tuple(&hv_InputImageHeight,0);
  create_tuple(&hv_InputImageWidthHeightRatio,0);
  create_tuple(&hv_ZoomHeight,0);
  create_tuple(&hv_ZoomWidth,0);
  create_tuple(&hv_GrayvalMin,0);
  create_tuple(&hv_GrayvalMax,0);
  create_tuple(&hv_Range,0);
  create_tuple(&hv_GrayvalRange,0);
  create_tuple(&hv_Scale,0);
  create_tuple(&hv_Shift,0);

  /****************************************************/
  /******************   Begin procedure   *************/
  /****************************************************/

  /*This procedure preprocesses the provided Images according to the parameters*/
  /*in the dictionary DLPreprocessParam for an ocr_recognition model.*/
  /**/
  /*Check the validity of the preprocessing parameters.*/
  /*check_dl_preprocess_param (DLPreprocessParam)*/
  /***/check_dl_preprocess_param(hv_DLPreprocessParam);

  /**/
  /*Get the preprocessing parameters.*/
  /*get_dict_tuple (DLPreprocessParam, 'image_width', ImageWidth)*/
  create_tuple_s(&TTemp[SP++],"image_width");
  destroy_tuple(hv_ImageWidth);
  /***/T_get_dict_tuple(hv_DLPreprocessParam, TTemp[SP-1], &hv_ImageWidth);
  destroy_tuple(TTemp[--SP]);

  /*get_dict_tuple (DLPreprocessParam, 'image_height', ImageHeight)*/
  create_tuple_s(&TTemp[SP++],"image_height");
  destroy_tuple(hv_ImageHeight);
  /***/T_get_dict_tuple(hv_DLPreprocessParam, TTemp[SP-1], &hv_ImageHeight);
  destroy_tuple(TTemp[--SP]);

  /*get_dict_tuple (DLPreprocessParam, 'image_num_channels', ImageNumChannels)*/
  create_tuple_s(&TTemp[SP++],"image_num_channels");
  destroy_tuple(hv_ImageNumChannels);
  /***/T_get_dict_tuple(hv_DLPreprocessParam, TTemp[SP-1], &hv_ImageNumChannels);
  destroy_tuple(TTemp[--SP]);

  /*get_dict_tuple (DLPreprocessParam, 'image_range_min', ImageRangeMin)*/
  create_tuple_s(&TTemp[SP++],"image_range_min");
  destroy_tuple(hv_ImageRangeMin);
  /***/T_get_dict_tuple(hv_DLPreprocessParam, TTemp[SP-1], &hv_ImageRangeMin);
  destroy_tuple(TTemp[--SP]);

  /*get_dict_tuple (DLPreprocessParam, 'image_range_max', ImageRangeMax)*/
  create_tuple_s(&TTemp[SP++],"image_range_max");
  destroy_tuple(hv_ImageRangeMax);
  /***/T_get_dict_tuple(hv_DLPreprocessParam, TTemp[SP-1], &hv_ImageRangeMax);
  destroy_tuple(TTemp[--SP]);

  /*get_dict_tuple (DLPreprocessParam, 'domain_handling', DomainHandling)*/
  create_tuple_s(&TTemp[SP++],"domain_handling");
  destroy_tuple(hv_DomainHandling);
  /***/T_get_dict_tuple(hv_DLPreprocessParam, TTemp[SP-1], &hv_DomainHandling);
  destroy_tuple(TTemp[--SP]);

  /*get_dict_tuple (DLPreprocessParam, 'normalization_type', NormalizationType)*/
  create_tuple_s(&TTemp[SP++],"normalization_type");
  destroy_tuple(hv_NormalizationType);
  /***/T_get_dict_tuple(hv_DLPreprocessParam, TTemp[SP-1], &hv_NormalizationType);
  destroy_tuple(TTemp[--SP]);

  /*get_dict_tuple (DLPreprocessParam, 'model_type', ModelType)*/
  create_tuple_s(&TTemp[SP++],"model_type");
  destroy_tuple(hv_ModelType);
  /***/T_get_dict_tuple(hv_DLPreprocessParam, TTemp[SP-1], &hv_ModelType);
  destroy_tuple(TTemp[--SP]);

  /**/
  /*Check the preprocessing parameters.*/
  /*========== if (ModelType != 'ocr_recognition') ==========*/
  create_tuple_s(&TTemp[SP++],"ocr_recognition");
  T_tuple_not_equal(hv_ModelType,TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-1]=TTemp[SP];
  if(get_i(TTemp[SP-1],0))
  {
    /* throw(...); only in hdevelop*/
  }
  destroy_tuple(TTemp[--SP]);
  /*========== end if ==========*/
  /*========== if (ImageNumChannels != 1) ==========*/
  create_tuple_i(&TTemp[SP++],1);
  T_tuple_not_equal(hv_ImageNumChannels,TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-1]=TTemp[SP];
  if(get_i(TTemp[SP-1],0))
  {
    /* throw(...); only in hdevelop*/
  }
  destroy_tuple(TTemp[--SP]);
  /*========== end if ==========*/
  /*========== if (DomainHandling != 'full_domain') ==========*/
  create_tuple_s(&TTemp[SP++],"full_domain");
  T_tuple_not_equal(hv_DomainHandling,TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-1]=TTemp[SP];
  if(get_i(TTemp[SP-1],0))
  {
    /* throw(...); only in hdevelop*/
  }
  destroy_tuple(TTemp[--SP]);
  /*========== end if ==========*/
  /*========== if (NormalizationType != 'none' and NormalizationType != 'first_channel' and NormalizationType != 'all_channels') ==========*/
  create_tuple_s(&TTemp[SP++],"none");
  T_tuple_not_equal(hv_NormalizationType,TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-1]=TTemp[SP];
  create_tuple_s(&TTemp[SP++],"first_channel");
  T_tuple_not_equal(hv_NormalizationType,TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-1]=TTemp[SP];
  T_tuple_and(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-2]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-2]=TTemp[SP];
  SP--;
  create_tuple_s(&TTemp[SP++],"all_channels");
  T_tuple_not_equal(hv_NormalizationType,TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-1]=TTemp[SP];
  T_tuple_and(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-2]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-2]=TTemp[SP];
  SP--;
  if(get_i(TTemp[SP-1],0))
  {
    /* throw(...); only in hdevelop*/
  }
  destroy_tuple(TTemp[--SP]);
  /*========== end if ==========*/
  /**/
  /*Get the image properties.*/
  /*count_obj (Images, NumImages)*/
  destroy_tuple(hv_NumImages);
  /***/T_count_obj(ho_Images_COPY_INP_TMP, &hv_NumImages);

  /*count_channels (Images, NumChannels)*/
  destroy_tuple(hv_NumChannels);
  /***/T_count_channels(ho_Images_COPY_INP_TMP, &hv_NumChannels);

  /*get_image_type (Images, ImageTypes)*/
  destroy_tuple(hv_ImageTypes);
  /***/T_get_image_type(ho_Images_COPY_INP_TMP, &hv_ImageTypes);

  /*get_image_size (Images, InputImageWidths, InputImageHeights)*/
  destroy_tuple(hv_InputImageWidths);
  destroy_tuple(hv_InputImageHeights);
  /***/T_get_image_size(ho_Images_COPY_INP_TMP, &hv_InputImageWidths, &hv_InputImageHeights);

  /**/
  /*Check the image properties.*/
  /*========== if (NumImages == 0) ==========*/
  create_tuple_i(&TTemp[SP++],0);
  T_tuple_equal(hv_NumImages,TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-1]=TTemp[SP];
  if(get_i(TTemp[SP-1],0))
  {
    /* throw(...); only in hdevelop*/
  }
  destroy_tuple(TTemp[--SP]);
  /*========== end if ==========*/
  /*========== if (NumImages != regexp_test(ImageTypes,'byte|real')) ==========*/
  create_tuple_s(&TTemp[SP++],"byte|real");
  T_tuple_regexp_test(hv_ImageTypes,TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-1]=TTemp[SP];
  T_tuple_not_equal(hv_NumImages,TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-1]=TTemp[SP];
  if(get_i(TTemp[SP-1],0))
  {
    /* throw(...); only in hdevelop*/
  }
  destroy_tuple(TTemp[--SP]);
  /*========== end if ==========*/
  /*========== if (NumImages != sum(NumChannels [==] 1 or NumChannels [==] 3)) ==========*/
  create_tuple_i(&TTemp[SP++],1);
  T_tuple_equal_elem(hv_NumChannels,TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-1]=TTemp[SP];
  create_tuple_i(&TTemp[SP++],3);
  T_tuple_equal_elem(hv_NumChannels,TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-1]=TTemp[SP];
  T_tuple_or(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-2]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-2]=TTemp[SP];
  SP--;
  T_tuple_sum(TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-1]=TTemp[SP];
  T_tuple_not_equal(hv_NumImages,TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-1]=TTemp[SP];
  if(get_i(TTemp[SP-1],0))
  {
    /* throw(...); only in hdevelop*/
  }
  destroy_tuple(TTemp[--SP]);
  /*========== end if ==========*/
  /**/
  /*Preprocess the images.*/
  /*PaddingGrayval := 0.0*/
  reuse_tuple_d(&hv_PaddingGrayval,0.0);

  /*ImageRange := real(ImageRangeMax - ImageRangeMin)*/
  T_tuple_sub(hv_ImageRangeMax,hv_ImageRangeMin,&TTemp[SP++]);
  T_tuple_real(TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-1]=TTemp[SP];
  destroy_tuple(hv_ImageRange);
  hv_ImageRange=TTemp[--SP];

  /*gen_image_const (TargetImage, 'real', ImageWidth, ImageHeight)*/
  create_tuple_s(&TTemp[SP++],"real");
  clear_obj(ho_TargetImage);
  /***/T_gen_image_const(&ho_TargetImage, TTemp[SP-1], hv_ImageWidth, hv_ImageHeight);
  destroy_tuple(TTemp[--SP]);

  /*overpaint_region (TargetImage, TargetImage, PaddingGrayval, 'fill')*/
  create_tuple_s(&TTemp[SP++],"fill");
  /***/T_overpaint_region(ho_TargetImage, ho_TargetImage, hv_PaddingGrayval, TTemp[SP-1]);
  destroy_tuple(TTemp[--SP]);

  /*========== for I := 0 to NumImages - 1 by 1 ==========*/
  create_tuple_i(&TTemp[SP++],1);
  T_tuple_sub(hv_NumImages,TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-1]=TTemp[SP];
  create_tuple_i(&TTemp[SP++],1);
  create_tuple_i(&TTemp[SP++],0);
  T_tuple_greater(TTemp[SP-1],TTemp[SP-3],&TTemp[SP]);
  SP++;
  T_tuple_equal(TTemp[SP-2],TTemp[SP-4],&TTemp[SP]);
  if(get_i(TTemp[SP],0) ||
     (!((( get_i(TTemp[SP-1],0)) && (get_d(TTemp[SP-3],0)>0)) ||
        ((!get_i(TTemp[SP-1],0)) && (get_d(TTemp[SP-3],0)<0)))))
  {
   destroy_tuple(TTemp[SP--]);
   destroy_tuple(TTemp[SP]);
   T_tuple_sub(TTemp[SP-1],TTemp[SP-2],&TTemp[SP]);
   destroy_tuple(hv_I);
   copy_tuple(TTemp[SP],&hv_I);
   destroy_tuple(TTemp[SP--]);
   destroy_tuple(TTemp[SP]);
   for(;;)
   {
   T_tuple_add(hv_I,TTemp[SP-1],&TTemp[SP]);
   destroy_tuple(hv_I);
   copy_tuple(TTemp[SP],&hv_I);
   destroy_tuple(TTemp[SP]);
   if(get_d(TTemp[SP-1],0)<0)
    T_tuple_less(hv_I,TTemp[SP-2],&TTemp[SP]);
   else
    T_tuple_greater(hv_I,TTemp[SP-2],&TTemp[SP]);
   if(get_i(TTemp[SP],0)) break;
   destroy_tuple(TTemp[SP]);
   /*========== for ==========*/

    /*InputImageWidth := InputImageWidths[I]*/
    T_tuple_select(hv_InputImageWidths,hv_I,&TTemp[SP++]);
    destroy_tuple(hv_InputImageWidth);
    hv_InputImageWidth=TTemp[--SP];

    /*InputImageHeight := InputImageHeights[I]*/
    T_tuple_select(hv_InputImageHeights,hv_I,&TTemp[SP++]);
    destroy_tuple(hv_InputImageHeight);
    hv_InputImageHeight=TTemp[--SP];

    /*InputImageWidthHeightRatio := InputImageWidth / real(InputImageHeight)*/
    T_tuple_real(hv_InputImageHeight,&TTemp[SP++]);
    T_tuple_div(hv_InputImageWidth,TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    destroy_tuple(hv_InputImageWidthHeightRatio);
    hv_InputImageWidthHeightRatio=TTemp[--SP];

    /**/
    /*select_obj (Images, Image, I + 1)*/
    create_tuple_i(&TTemp[SP++],1);
    T_tuple_add(hv_I,TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    clear_obj(ho_Image);
    /***/T_select_obj(ho_Images_COPY_INP_TMP, &ho_Image, TTemp[SP-1]);
    destroy_tuple(TTemp[--SP]);

    /*full_domain (Image, Image)*/
    /***/full_domain(ho_Image, &(OTemp[SPO]));
    SPO++;
    clear_obj(ho_Image);
    ho_Image = OTemp[--SPO];

    /*========== if (NumChannels[I] == 3) ==========*/
    T_tuple_select(hv_NumChannels,hv_I,&TTemp[SP++]);
    create_tuple_i(&TTemp[SP++],3);
    T_tuple_equal(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-2]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-2]=TTemp[SP];
    SP--;
    if(get_i(TTemp[SP-1],0))
    {
      /*rgb1_to_gray (Image, Image)*/
      /***/rgb1_to_gray(ho_Image, &(OTemp[SPO]));
      SPO++;
      clear_obj(ho_Image);
      ho_Image = OTemp[--SPO];

    }
    destroy_tuple(TTemp[--SP]);
    /*========== end if ==========*/
    /**/
    /*ZoomHeight := ImageHeight*/
    destroy_tuple(hv_ZoomHeight);
    copy_tuple(hv_ImageHeight,&hv_ZoomHeight);

    /*ZoomWidth := min2(ImageWidth,int(ImageHeight * InputImageWidthHeightRatio))*/
    T_tuple_mult(hv_ImageHeight,hv_InputImageWidthHeightRatio,&TTemp[SP++]);
    T_tuple_int(TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    T_tuple_min2(hv_ImageWidth,TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    destroy_tuple(hv_ZoomWidth);
    hv_ZoomWidth=TTemp[--SP];

    /*zoom_image_size (Image, Image, ZoomWidth, ZoomHeight, 'constant')*/
    create_tuple_s(&TTemp[SP++],"constant");
    /***/T_zoom_image_size(ho_Image, &(OTemp[SPO]), hv_ZoomWidth, hv_ZoomHeight, 
        TTemp[SP-1]);
    SPO++;
    clear_obj(ho_Image);
    ho_Image = OTemp[--SPO];
    destroy_tuple(TTemp[--SP]);

    /*========== if (ImageTypes[I] == 'byte') ==========*/
    T_tuple_select(hv_ImageTypes,hv_I,&TTemp[SP++]);
    create_tuple_s(&TTemp[SP++],"byte");
    T_tuple_equal(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-2]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-2]=TTemp[SP];
    SP--;
    if(get_i(TTemp[SP-1],0))
    {
      /*convert_image_type (Image, Image, 'real')*/
      /***/convert_image_type(ho_Image, &(OTemp[SPO]), "real");
      SPO++;
      clear_obj(ho_Image);
      ho_Image = OTemp[--SPO];

    }
    destroy_tuple(TTemp[--SP]);
    /*========== end if ==========*/
    /*========== if (NormalizationType == 'first_channel' or NormalizationType == 'all_channels') ==========*/
    create_tuple_s(&TTemp[SP++],"first_channel");
    T_tuple_equal(hv_NormalizationType,TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    create_tuple_s(&TTemp[SP++],"all_channels");
    T_tuple_equal(hv_NormalizationType,TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    T_tuple_or(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-2]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-2]=TTemp[SP];
    SP--;
    if(get_i(TTemp[SP-1],0))
    {
      /*min_max_gray (Image, Image, 0, GrayvalMin, GrayvalMax, Range)*/
      create_tuple_i(&TTemp[SP++],0);
      destroy_tuple(hv_GrayvalMin);
      destroy_tuple(hv_GrayvalMax);
      destroy_tuple(hv_Range);
      /***/T_min_max_gray(ho_Image, ho_Image, TTemp[SP-1], &hv_GrayvalMin, &hv_GrayvalMax, 
          &hv_Range);
      destroy_tuple(TTemp[--SP]);

      /*GrayvalRange := real(GrayvalMax - GrayvalMin)*/
      T_tuple_sub(hv_GrayvalMax,hv_GrayvalMin,&TTemp[SP++]);
      T_tuple_real(TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      destroy_tuple(hv_GrayvalRange);
      hv_GrayvalRange=TTemp[--SP];

      /*========== if (GrayvalRange == 0.0) ==========*/
      create_tuple_d(&TTemp[SP++],0.0);
      T_tuple_equal(hv_GrayvalRange,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      if(get_i(TTemp[SP-1],0))
      {
        /*Scale := 1.0*/
        reuse_tuple_d(&hv_Scale,1.0);

      }
      else
      {
        /*Scale := ImageRange / GrayvalRange*/
        T_tuple_div(hv_ImageRange,hv_GrayvalRange,&TTemp[SP++]);
        destroy_tuple(hv_Scale);
        hv_Scale=TTemp[--SP];

      }
      destroy_tuple(TTemp[--SP]);
      /*========== end if ==========*/
      /*Shift := -Scale * GrayvalMin + ImageRangeMin*/
      T_tuple_neg(hv_Scale,&TTemp[SP++]);
      T_tuple_mult(TTemp[SP-1],hv_GrayvalMin,&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      T_tuple_add(TTemp[SP-1],hv_ImageRangeMin,&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      destroy_tuple(hv_Shift);
      hv_Shift=TTemp[--SP];

      /*scale_image (Image, Image, Scale, Shift)*/
      /***/T_scale_image(ho_Image, &(OTemp[SPO]), hv_Scale, hv_Shift);
      SPO++;
      clear_obj(ho_Image);
      ho_Image = OTemp[--SPO];

    }
    else
    {
    destroy_tuple(TTemp[--SP]);
    /*========== elseif (NormalizationType == 'none') ==========*/

    create_tuple_s(&TTemp[SP++],"none");
    T_tuple_equal(hv_NormalizationType,TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    if(get_i(TTemp[SP-1],0))
    {
      /*========== if (ImageTypes[I] == 'byte') ==========*/
      T_tuple_select(hv_ImageTypes,hv_I,&TTemp[SP++]);
      create_tuple_s(&TTemp[SP++],"byte");
      T_tuple_equal(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-2]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-2]=TTemp[SP];
      SP--;
      if(get_i(TTemp[SP-1],0))
      {
        /*scale_image (Image, Image, ImageRange / 255.0, ImageRangeMin)*/
        create_tuple_d(&TTemp[SP++],255.0);
        T_tuple_div(hv_ImageRange,TTemp[SP-1],&TTemp[SP]);
        destroy_tuple(TTemp[SP-1]);
        TTemp[SP-1]=TTemp[SP];
        /***/T_scale_image(ho_Image, &(OTemp[SPO]), TTemp[SP-1], hv_ImageRangeMin);
        SPO++;
        clear_obj(ho_Image);
        ho_Image = OTemp[--SPO];
        destroy_tuple(TTemp[--SP]);

      }
      destroy_tuple(TTemp[--SP]);
      /*========== end if ==========*/
    }
    }
    destroy_tuple(TTemp[--SP]);
    /*========== end if ==========*/
    /**/
    /*overpaint_gray (TargetImage, Image)*/
    /***/overpaint_gray(ho_TargetImage, ho_Image);

    /*reduce_domain (TargetImage, Image, TargetImage)*/
    /***/reduce_domain(ho_TargetImage, ho_Image, &(OTemp[SPO]));
    SPO++;
    clear_obj(ho_TargetImage);
    ho_TargetImage = OTemp[--SPO];

    /*replace_obj (Images, TargetImage, Images, I + 1)*/
    create_tuple_i(&TTemp[SP++],1);
    T_tuple_add(hv_I,TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    /***/T_replace_obj(ho_Images_COPY_INP_TMP, ho_TargetImage, &(OTemp[SPO]), TTemp[SP-1]);
    SPO++;
    clear_obj(ho_Images_COPY_INP_TMP);
    ho_Images_COPY_INP_TMP = OTemp[--SPO];
    destroy_tuple(TTemp[--SP]);

   }
   destroy_tuple(TTemp[SP--]);
   destroy_tuple(TTemp[SP--]);
   destroy_tuple(TTemp[SP]);
  }
  else
  {
   destroy_tuple(TTemp[SP--]);
   destroy_tuple(TTemp[SP--]);
   destroy_tuple(TTemp[SP--]);
   destroy_tuple(TTemp[SP--]);
   destroy_tuple(TTemp[SP]);
  }/*========== end for ========*/

  /**/
  /*Return the preprocessed images.*/
  /*ImagesPreprocessed := Images*/
  clear_obj((*ho_ImagesPreprocessed));
  copy_obj(ho_Images_COPY_INP_TMP,&(*ho_ImagesPreprocessed),1,-1);

  /*========== return ==========*/

  /* Clear temporary tuple stack */
  while (SP > 0)
    destroy_tuple(TTemp[--SP]);
  /* Clear temporary tuple vectors stack*/
  while (SPTV > 0)
    V_destroy_vector(TVTemp[--SPTV]);
  /* Clear local iconic variables */
  clear_obj(ho_TargetImage);
  clear_obj(ho_Image);
  clear_obj(ho_Images_COPY_INP_TMP);

  /* Clear local control variables */
  destroy_tuple(hv_ImageWidth);
  destroy_tuple(hv_ImageHeight);
  destroy_tuple(hv_ImageNumChannels);
  destroy_tuple(hv_ImageRangeMin);
  destroy_tuple(hv_ImageRangeMax);
  destroy_tuple(hv_DomainHandling);
  destroy_tuple(hv_NormalizationType);
  destroy_tuple(hv_ModelType);
  destroy_tuple(hv_NumImages);
  destroy_tuple(hv_NumChannels);
  destroy_tuple(hv_ImageTypes);
  destroy_tuple(hv_InputImageWidths);
  destroy_tuple(hv_InputImageHeights);
  destroy_tuple(hv_PaddingGrayval);
  destroy_tuple(hv_ImageRange);
  destroy_tuple(hv_I);
  destroy_tuple(hv_InputImageWidth);
  destroy_tuple(hv_InputImageHeight);
  destroy_tuple(hv_InputImageWidthHeightRatio);
  destroy_tuple(hv_ZoomHeight);
  destroy_tuple(hv_ZoomWidth);
  destroy_tuple(hv_GrayvalMin);
  destroy_tuple(hv_GrayvalMax);
  destroy_tuple(hv_Range);
  destroy_tuple(hv_GrayvalRange);
  destroy_tuple(hv_Scale);
  destroy_tuple(hv_Shift);

  return;

  /****************************************************/
  /******************     End procedure   *************/
  /****************************************************/

}

/* Chapter: Deep Learning / Object Detection and Instance Segmentation*/
/* Short Description: Preprocess the instance segmentation masks for a sample given by the dictionary DLSample. */
void preprocess_dl_model_instance_masks (Hobject ho_ImageRaw, Htuple hv_DLSample, 
    Htuple hv_DLPreprocessParam)
{


  /* Stack for temporary tuples */
  Htuple   TTemp[100];
  int      SP=0;
  /* Stack for temporary objects */
  Hobject  OTemp[20] = {0};
  int      SPO=0;
  /* Stack for temporary tuple vectors */
  Hvector  TVTemp[100] = {0};
  int      SPTV=0;

  /* Local iconic variables */
  Hobject  ho_InstanceMasks, ho_Domain;

  /* Local control variables */
  Htuple  hv_ImageWidth, hv_ImageHeight, hv_DomainHandling;
  Htuple  hv_NumMasks, hv_WidthRaw, hv_HeightRaw, hv_DomainRow1;
  Htuple  hv_DomainColumn1, hv_DomainRow2, hv_DomainColumn2;
  Htuple  hv_FactorResampleWidth, hv_FactorResampleHeight;

  /* Initialize iconic variables */
  gen_empty_obj(&ho_InstanceMasks);
  gen_empty_obj(&ho_Domain);

  /* Initialize control variables */
  create_tuple(&hv_ImageWidth,0);
  create_tuple(&hv_ImageHeight,0);
  create_tuple(&hv_DomainHandling,0);
  create_tuple(&hv_NumMasks,0);
  create_tuple(&hv_WidthRaw,0);
  create_tuple(&hv_HeightRaw,0);
  create_tuple(&hv_DomainRow1,0);
  create_tuple(&hv_DomainColumn1,0);
  create_tuple(&hv_DomainRow2,0);
  create_tuple(&hv_DomainColumn2,0);
  create_tuple(&hv_FactorResampleWidth,0);
  create_tuple(&hv_FactorResampleHeight,0);

  /****************************************************/
  /******************   Begin procedure   *************/
  /****************************************************/

  /**/
  /*This procedure preprocesses the instance masks of a DLSample.*/
  /**/
  /*Check preprocess parameters.*/
  /*check_dl_preprocess_param (DLPreprocessParam)*/
  /***/check_dl_preprocess_param(hv_DLPreprocessParam);

  /**/
  /*Get relevant preprocess parameters.*/
  /*get_dict_tuple (DLPreprocessParam, 'image_width', ImageWidth)*/
  create_tuple_s(&TTemp[SP++],"image_width");
  destroy_tuple(hv_ImageWidth);
  /***/T_get_dict_tuple(hv_DLPreprocessParam, TTemp[SP-1], &hv_ImageWidth);
  destroy_tuple(TTemp[--SP]);

  /*get_dict_tuple (DLPreprocessParam, 'image_height', ImageHeight)*/
  create_tuple_s(&TTemp[SP++],"image_height");
  destroy_tuple(hv_ImageHeight);
  /***/T_get_dict_tuple(hv_DLPreprocessParam, TTemp[SP-1], &hv_ImageHeight);
  destroy_tuple(TTemp[--SP]);

  /*get_dict_tuple (DLPreprocessParam, 'domain_handling', DomainHandling)*/
  create_tuple_s(&TTemp[SP++],"domain_handling");
  destroy_tuple(hv_DomainHandling);
  /***/T_get_dict_tuple(hv_DLPreprocessParam, TTemp[SP-1], &hv_DomainHandling);
  destroy_tuple(TTemp[--SP]);

  /**/
  /*Get the preprocessed instance masks.*/
  /*get_dict_object (InstanceMasks, DLSample, 'mask')*/
  create_tuple_s(&TTemp[SP++],"mask");
  clear_obj(ho_InstanceMasks);
  /***/T_get_dict_object(&ho_InstanceMasks, hv_DLSample, TTemp[SP-1]);
  destroy_tuple(TTemp[--SP]);

  /**/
  /*Get the number of instance masks.*/
  /*count_obj (InstanceMasks, NumMasks)*/
  destroy_tuple(hv_NumMasks);
  /***/T_count_obj(ho_InstanceMasks, &hv_NumMasks);

  /**/
  /*Domain handling of the image to be preprocessed.*/
  /**/
  /*get_image_size (ImageRaw, WidthRaw, HeightRaw)*/
  destroy_tuple(hv_WidthRaw);
  destroy_tuple(hv_HeightRaw);
  /***/T_get_image_size(ho_ImageRaw, &hv_WidthRaw, &hv_HeightRaw);

  /*========== if (DomainHandling == 'crop_domain') ==========*/
  create_tuple_s(&TTemp[SP++],"crop_domain");
  T_tuple_equal(hv_DomainHandling,TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-1]=TTemp[SP];
  if(get_i(TTemp[SP-1],0))
  {
    /*Clip and translate masks w.r.t. the image domain*/
    /*get_domain (ImageRaw, Domain)*/
    clear_obj(ho_Domain);
    /***/get_domain(ho_ImageRaw, &ho_Domain);

    /*smallest_rectangle1 (Domain, DomainRow1, DomainColumn1, DomainRow2, DomainColumn2)*/
    destroy_tuple(hv_DomainRow1);
    destroy_tuple(hv_DomainColumn1);
    destroy_tuple(hv_DomainRow2);
    destroy_tuple(hv_DomainColumn2);
    /***/T_smallest_rectangle1(ho_Domain, &hv_DomainRow1, &hv_DomainColumn1, &hv_DomainRow2, 
        &hv_DomainColumn2);

    /**/
    /*Clip the remaining regions to the domain.*/
    /*clip_region (InstanceMasks, InstanceMasks, DomainRow1, DomainColumn1, DomainRow2, DomainColumn2)*/
    /***/T_clip_region(ho_InstanceMasks, &(OTemp[SPO]), hv_DomainRow1, hv_DomainColumn1, 
        hv_DomainRow2, hv_DomainColumn2);
    SPO++;
    clear_obj(ho_InstanceMasks);
    ho_InstanceMasks = OTemp[--SPO];

    /*WidthRaw := DomainColumn2 - DomainColumn1 + 1.0*/
    T_tuple_sub(hv_DomainColumn2,hv_DomainColumn1,&TTemp[SP++]);
    create_tuple_d(&TTemp[SP++],1.0);
    T_tuple_add(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-2]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-2]=TTemp[SP];
    SP--;
    destroy_tuple(hv_WidthRaw);
    hv_WidthRaw=TTemp[--SP];

    /*HeightRaw := DomainRow2 - DomainRow1 + 1.0*/
    T_tuple_sub(hv_DomainRow2,hv_DomainRow1,&TTemp[SP++]);
    create_tuple_d(&TTemp[SP++],1.0);
    T_tuple_add(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-2]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-2]=TTemp[SP];
    SP--;
    destroy_tuple(hv_HeightRaw);
    hv_HeightRaw=TTemp[--SP];

    /*We need to move the remaining regions back to the origin,*/
    /*because crop_domain will be applied to the image*/
    /*move_region (InstanceMasks, InstanceMasks, -DomainRow1, -DomainColumn1)*/
    T_tuple_neg(hv_DomainRow1,&TTemp[SP++]);
    T_tuple_neg(hv_DomainColumn1,&TTemp[SP++]);
    /***/T_move_region(ho_InstanceMasks, &(OTemp[SPO]), TTemp[SP-2], TTemp[SP-1]);
    SPO++;
    clear_obj(ho_InstanceMasks);
    ho_InstanceMasks = OTemp[--SPO];
    destroy_tuple(TTemp[--SP]);
    destroy_tuple(TTemp[--SP]);

  }
  else
  {
  destroy_tuple(TTemp[--SP]);
  /*========== elseif (DomainHandling != 'full_domain') ==========*/

  create_tuple_s(&TTemp[SP++],"full_domain");
  T_tuple_not_equal(hv_DomainHandling,TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-1]=TTemp[SP];
  if(get_i(TTemp[SP-1],0))
  {
    /* throw(...); only in hdevelop*/
  }
  }
  destroy_tuple(TTemp[--SP]);
  /*========== end if ==========*/
  /**/
  /*Zoom masks only if the image has a different size than the specified size.*/
  /*========== if (ImageWidth [!=] WidthRaw or ImageHeight [!=] HeightRaw) ==========*/
  T_tuple_not_equal_elem(hv_ImageWidth,hv_WidthRaw,&TTemp[SP++]);
  T_tuple_not_equal_elem(hv_ImageHeight,hv_HeightRaw,&TTemp[SP++]);
  T_tuple_or(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-2]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-2]=TTemp[SP];
  SP--;
  if(get_i(TTemp[SP-1],0))
  {
    /*Calculate rescaling factor.*/
    /*FactorResampleWidth := real(ImageWidth) / WidthRaw*/
    T_tuple_real(hv_ImageWidth,&TTemp[SP++]);
    T_tuple_div(TTemp[SP-1],hv_WidthRaw,&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    destroy_tuple(hv_FactorResampleWidth);
    hv_FactorResampleWidth=TTemp[--SP];

    /*FactorResampleHeight := real(ImageHeight) / HeightRaw*/
    T_tuple_real(hv_ImageHeight,&TTemp[SP++]);
    T_tuple_div(TTemp[SP-1],hv_HeightRaw,&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    destroy_tuple(hv_FactorResampleHeight);
    hv_FactorResampleHeight=TTemp[--SP];


    /*Zoom the masks.*/
    /*zoom_region (InstanceMasks, InstanceMasks, FactorResampleWidth, FactorResampleHeight)*/
    /***/T_zoom_region(ho_InstanceMasks, &(OTemp[SPO]), hv_FactorResampleWidth, hv_FactorResampleHeight);
    SPO++;
    clear_obj(ho_InstanceMasks);
    ho_InstanceMasks = OTemp[--SPO];

  }
  destroy_tuple(TTemp[--SP]);
  /*========== end if ==========*/
  /**/
  /*Set the preprocessed instance masks.*/
  /*set_dict_object (InstanceMasks, DLSample, 'mask')*/
  create_tuple_s(&TTemp[SP++],"mask");
  /***/T_set_dict_object(ho_InstanceMasks, hv_DLSample, TTemp[SP-1]);
  destroy_tuple(TTemp[--SP]);

  /**/
  /**/
  /*========== return ==========*/

  /* Clear temporary tuple stack */
  while (SP > 0)
    destroy_tuple(TTemp[--SP]);
  /* Clear temporary tuple vectors stack*/
  while (SPTV > 0)
    V_destroy_vector(TVTemp[--SPTV]);
  /* Clear local iconic variables */
  clear_obj(ho_InstanceMasks);
  clear_obj(ho_Domain);

  /* Clear local control variables */
  destroy_tuple(hv_ImageWidth);
  destroy_tuple(hv_ImageHeight);
  destroy_tuple(hv_DomainHandling);
  destroy_tuple(hv_NumMasks);
  destroy_tuple(hv_WidthRaw);
  destroy_tuple(hv_HeightRaw);
  destroy_tuple(hv_DomainRow1);
  destroy_tuple(hv_DomainColumn1);
  destroy_tuple(hv_DomainRow2);
  destroy_tuple(hv_DomainColumn2);
  destroy_tuple(hv_FactorResampleWidth);
  destroy_tuple(hv_FactorResampleHeight);

  return;

  /****************************************************/
  /******************     End procedure   *************/
  /****************************************************/

}

/* Chapter: Deep Learning / Semantic Segmentation and Edge Extraction*/
/* Short Description: Preprocess segmentation and weight images for deep-learning-based segmentation training and inference. */
void preprocess_dl_model_segmentations (Hobject ho_ImagesRaw, Hobject ho_Segmentations, 
    Hobject *ho_SegmentationsPreprocessed, Htuple hv_DLPreprocessParam)
{


  /* Stack for temporary tuples */
  Htuple   TTemp[100];
  int      SP=0;
  /* Stack for temporary objects */
  Hobject  OTemp[20] = {0};
  int      SPO=0;
  /* Stack for temporary tuple vectors */
  Hvector  TVTemp[100] = {0};
  int      SPTV=0;

  /* Local iconic variables */
  Hobject  ho_Domain, ho_SelectedSeg, ho_SelectedDomain;

  /* Local control variables */
  Htuple  hv_NumberImages, hv_NumberSegmentations;
  Htuple  hv_Width, hv_Height, hv_WidthSeg, hv_HeightSeg;
  Htuple  hv_DLModelType, hv_ImageWidth, hv_ImageHeight, hv_ImageNumChannels;
  Htuple  hv_ImageRangeMin, hv_ImageRangeMax, hv_DomainHandling;
  Htuple  hv_SetBackgroundID, hv_ClassesToBackground, hv_IgnoreClassIDs;
  Htuple  hv_IsInt, hv_IndexImage, hv_ImageWidthRaw, hv_ImageHeightRaw;
  Htuple  hv_EqualWidth, hv_EqualHeight, hv_Type, hv_EqualReal;

  /* Local copy input parameter variables */
  Hobject  ho_Segmentations_COPY_INP_TMP;


  /* Initialize iconic variables */
  gen_empty_obj(&ho_Domain);
  gen_empty_obj(&ho_SelectedSeg);
  gen_empty_obj(&ho_SelectedDomain);
  gen_empty_obj(&(*ho_SegmentationsPreprocessed));
  copy_obj(ho_Segmentations,&ho_Segmentations_COPY_INP_TMP,1,-1);

  /* Initialize control variables */
  create_tuple(&hv_NumberImages,0);
  create_tuple(&hv_NumberSegmentations,0);
  create_tuple(&hv_Width,0);
  create_tuple(&hv_Height,0);
  create_tuple(&hv_WidthSeg,0);
  create_tuple(&hv_HeightSeg,0);
  create_tuple(&hv_DLModelType,0);
  create_tuple(&hv_ImageWidth,0);
  create_tuple(&hv_ImageHeight,0);
  create_tuple(&hv_ImageNumChannels,0);
  create_tuple(&hv_ImageRangeMin,0);
  create_tuple(&hv_ImageRangeMax,0);
  create_tuple(&hv_DomainHandling,0);
  create_tuple(&hv_SetBackgroundID,0);
  create_tuple(&hv_ClassesToBackground,0);
  create_tuple(&hv_IgnoreClassIDs,0);
  create_tuple(&hv_IsInt,0);
  create_tuple(&hv_IndexImage,0);
  create_tuple(&hv_ImageWidthRaw,0);
  create_tuple(&hv_ImageHeightRaw,0);
  create_tuple(&hv_EqualWidth,0);
  create_tuple(&hv_EqualHeight,0);
  create_tuple(&hv_Type,0);
  create_tuple(&hv_EqualReal,0);

  /****************************************************/
  /******************   Begin procedure   *************/
  /****************************************************/

  /**/
  /*This procedure preprocesses the segmentation or weight images*/
  /*given by Segmentations so that they can be handled by*/
  /*train_dl_model_batch and apply_dl_model.*/
  /**/
  /*Check input data.*/
  /*Examine number of images.*/
  /*count_obj (ImagesRaw, NumberImages)*/
  destroy_tuple(hv_NumberImages);
  /***/T_count_obj(ho_ImagesRaw, &hv_NumberImages);

  /*count_obj (Segmentations, NumberSegmentations)*/
  destroy_tuple(hv_NumberSegmentations);
  /***/T_count_obj(ho_Segmentations_COPY_INP_TMP, &hv_NumberSegmentations);

  /*========== if (NumberImages != NumberSegmentations) ==========*/
  T_tuple_not_equal(hv_NumberImages,hv_NumberSegmentations,&TTemp[SP++]);
  if(get_i(TTemp[SP-1],0))
  {
    /* throw(...); only in hdevelop*/
  }
  destroy_tuple(TTemp[--SP]);
  /*========== end if ==========*/
  /*Size of images.*/
  /*get_image_size (ImagesRaw, Width, Height)*/
  destroy_tuple(hv_Width);
  destroy_tuple(hv_Height);
  /***/T_get_image_size(ho_ImagesRaw, &hv_Width, &hv_Height);

  /*get_image_size (Segmentations, WidthSeg, HeightSeg)*/
  destroy_tuple(hv_WidthSeg);
  destroy_tuple(hv_HeightSeg);
  /***/T_get_image_size(ho_Segmentations_COPY_INP_TMP, &hv_WidthSeg, &hv_HeightSeg);

  /*========== if (Width != WidthSeg or Height != HeightSeg) ==========*/
  T_tuple_not_equal(hv_Width,hv_WidthSeg,&TTemp[SP++]);
  T_tuple_not_equal(hv_Height,hv_HeightSeg,&TTemp[SP++]);
  T_tuple_or(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-2]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-2]=TTemp[SP];
  SP--;
  if(get_i(TTemp[SP-1],0))
  {
    /* throw(...); only in hdevelop*/
  }
  destroy_tuple(TTemp[--SP]);
  /*========== end if ==========*/
  /*Check the validity of the preprocessing parameters.*/
  /*check_dl_preprocess_param (DLPreprocessParam)*/
  /***/check_dl_preprocess_param(hv_DLPreprocessParam);

  /**/
  /*Get the relevant preprocessing parameters.*/
  /*get_dict_tuple (DLPreprocessParam, 'model_type', DLModelType)*/
  create_tuple_s(&TTemp[SP++],"model_type");
  destroy_tuple(hv_DLModelType);
  /***/T_get_dict_tuple(hv_DLPreprocessParam, TTemp[SP-1], &hv_DLModelType);
  destroy_tuple(TTemp[--SP]);

  /*get_dict_tuple (DLPreprocessParam, 'image_width', ImageWidth)*/
  create_tuple_s(&TTemp[SP++],"image_width");
  destroy_tuple(hv_ImageWidth);
  /***/T_get_dict_tuple(hv_DLPreprocessParam, TTemp[SP-1], &hv_ImageWidth);
  destroy_tuple(TTemp[--SP]);

  /*get_dict_tuple (DLPreprocessParam, 'image_height', ImageHeight)*/
  create_tuple_s(&TTemp[SP++],"image_height");
  destroy_tuple(hv_ImageHeight);
  /***/T_get_dict_tuple(hv_DLPreprocessParam, TTemp[SP-1], &hv_ImageHeight);
  destroy_tuple(TTemp[--SP]);

  /*get_dict_tuple (DLPreprocessParam, 'image_num_channels', ImageNumChannels)*/
  create_tuple_s(&TTemp[SP++],"image_num_channels");
  destroy_tuple(hv_ImageNumChannels);
  /***/T_get_dict_tuple(hv_DLPreprocessParam, TTemp[SP-1], &hv_ImageNumChannels);
  destroy_tuple(TTemp[--SP]);

  /*get_dict_tuple (DLPreprocessParam, 'image_range_min', ImageRangeMin)*/
  create_tuple_s(&TTemp[SP++],"image_range_min");
  destroy_tuple(hv_ImageRangeMin);
  /***/T_get_dict_tuple(hv_DLPreprocessParam, TTemp[SP-1], &hv_ImageRangeMin);
  destroy_tuple(TTemp[--SP]);

  /*get_dict_tuple (DLPreprocessParam, 'image_range_max', ImageRangeMax)*/
  create_tuple_s(&TTemp[SP++],"image_range_max");
  destroy_tuple(hv_ImageRangeMax);
  /***/T_get_dict_tuple(hv_DLPreprocessParam, TTemp[SP-1], &hv_ImageRangeMax);
  destroy_tuple(TTemp[--SP]);

  /*get_dict_tuple (DLPreprocessParam, 'domain_handling', DomainHandling)*/
  create_tuple_s(&TTemp[SP++],"domain_handling");
  destroy_tuple(hv_DomainHandling);
  /***/T_get_dict_tuple(hv_DLPreprocessParam, TTemp[SP-1], &hv_DomainHandling);
  destroy_tuple(TTemp[--SP]);

  /*Segmentation specific parameters.*/
  /*get_dict_tuple (DLPreprocessParam, 'set_background_id', SetBackgroundID)*/
  create_tuple_s(&TTemp[SP++],"set_background_id");
  destroy_tuple(hv_SetBackgroundID);
  /***/T_get_dict_tuple(hv_DLPreprocessParam, TTemp[SP-1], &hv_SetBackgroundID);
  destroy_tuple(TTemp[--SP]);

  /*get_dict_tuple (DLPreprocessParam, 'class_ids_background', ClassesToBackground)*/
  create_tuple_s(&TTemp[SP++],"class_ids_background");
  destroy_tuple(hv_ClassesToBackground);
  /***/T_get_dict_tuple(hv_DLPreprocessParam, TTemp[SP-1], &hv_ClassesToBackground);
  destroy_tuple(TTemp[--SP]);

  /*get_dict_tuple (DLPreprocessParam, 'ignore_class_ids', IgnoreClassIDs)*/
  create_tuple_s(&TTemp[SP++],"ignore_class_ids");
  destroy_tuple(hv_IgnoreClassIDs);
  /***/T_get_dict_tuple(hv_DLPreprocessParam, TTemp[SP-1], &hv_IgnoreClassIDs);
  destroy_tuple(TTemp[--SP]);

  /**/
  /*Check the input parameter for setting the background ID.*/
  /*========== if (SetBackgroundID != []) ==========*/
  create_tuple(&TTemp[SP++],0);
  T_tuple_not_equal(hv_SetBackgroundID,TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-1]=TTemp[SP];
  if(get_i(TTemp[SP-1],0))
  {
    /*Check that the model is a segmentation model.*/
    /*========== if (DLModelType != 'segmentation') ==========*/
    create_tuple_s(&TTemp[SP++],"segmentation");
    T_tuple_not_equal(hv_DLModelType,TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    if(get_i(TTemp[SP-1],0))
    {
      /* throw(...); only in hdevelop*/
    }
    destroy_tuple(TTemp[--SP]);
    /*========== end if ==========*/
    /*Check the background ID.*/
    /*tuple_is_int_elem (SetBackgroundID, IsInt)*/
    destroy_tuple(hv_IsInt);
    /***/T_tuple_is_int_elem(hv_SetBackgroundID, &hv_IsInt);

    /*========== if (|SetBackgroundID| != 1) ==========*/
    T_tuple_length(hv_SetBackgroundID,&TTemp[SP++]);
    create_tuple_i(&TTemp[SP++],1);
    T_tuple_not_equal(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-2]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-2]=TTemp[SP];
    SP--;
    if(get_i(TTemp[SP-1],0))
    {
      /* throw(...); only in hdevelop*/
    }
    else
    {
    destroy_tuple(TTemp[--SP]);
    /*========== elseif (not IsInt) ==========*/

    T_tuple_not(hv_IsInt,&TTemp[SP++]);
    if(get_i(TTemp[SP-1],0))
    {
      /*Given class_id has to be of type int.*/
      /* throw(...); only in hdevelop*/
    }
    }
    destroy_tuple(TTemp[--SP]);
    /*========== end if ==========*/
    /*Check the values of ClassesToBackground.*/
    /*========== if (|ClassesToBackground| == 0) ==========*/
    T_tuple_length(hv_ClassesToBackground,&TTemp[SP++]);
    create_tuple_i(&TTemp[SP++],0);
    T_tuple_equal(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-2]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-2]=TTemp[SP];
    SP--;
    if(get_i(TTemp[SP-1],0))
    {
      /*Check that the given classes are of length > 0.*/
      /* throw(...); only in hdevelop*/
    }
    else
    {
    destroy_tuple(TTemp[--SP]);
    /*========== elseif (intersection(ClassesToBackground,IgnoreClassIDs) != []) ==========*/

    T_tuple_intersection(hv_ClassesToBackground,hv_IgnoreClassIDs,&TTemp[SP++]);
    create_tuple(&TTemp[SP++],0);
    T_tuple_not_equal(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-2]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-2]=TTemp[SP];
    SP--;
    if(get_i(TTemp[SP-1],0))
    {
      /*Check that class_ids_background is not included in the ignore_class_ids of the DLModel.*/
      /* throw(...); only in hdevelop*/
    }
    }
    destroy_tuple(TTemp[--SP]);
    /*========== end if ==========*/
  }
  destroy_tuple(TTemp[--SP]);
  /*========== end if ==========*/
  /**/
  /*Domain handling of the image to be preprocessed.*/
  /**/
  /*========== if (DomainHandling == 'full_domain' or DomainHandling == 'keep_domain') ==========*/
  create_tuple_s(&TTemp[SP++],"full_domain");
  T_tuple_equal(hv_DomainHandling,TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-1]=TTemp[SP];
  create_tuple_s(&TTemp[SP++],"keep_domain");
  T_tuple_equal(hv_DomainHandling,TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-1]=TTemp[SP];
  T_tuple_or(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-2]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-2]=TTemp[SP];
  SP--;
  if(get_i(TTemp[SP-1],0))
  {
    /*full_domain (Segmentations, Segmentations)*/
    /***/full_domain(ho_Segmentations_COPY_INP_TMP, &(OTemp[SPO]));
    SPO++;
    clear_obj(ho_Segmentations_COPY_INP_TMP);
    ho_Segmentations_COPY_INP_TMP = OTemp[--SPO];

  }
  else
  {
  destroy_tuple(TTemp[--SP]);
  /*========== elseif (DomainHandling == 'crop_domain') ==========*/

  create_tuple_s(&TTemp[SP++],"crop_domain");
  T_tuple_equal(hv_DomainHandling,TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-1]=TTemp[SP];
  if(get_i(TTemp[SP-1],0))
  {
    /*If the domain should be cropped the domain has to be transferred*/
    /*from the raw image to the segmentation image.*/
    /*get_domain (ImagesRaw, Domain)*/
    clear_obj(ho_Domain);
    /***/get_domain(ho_ImagesRaw, &ho_Domain);

    /*========== for IndexImage := 1 to NumberImages by 1 ==========*/
    copy_tuple(hv_NumberImages,&TTemp[SP++]);
    create_tuple_i(&TTemp[SP++],1);
    create_tuple_i(&TTemp[SP++],1);
    T_tuple_greater(TTemp[SP-1],TTemp[SP-3],&TTemp[SP]);
    SP++;
    T_tuple_equal(TTemp[SP-2],TTemp[SP-4],&TTemp[SP]);
    if(get_i(TTemp[SP],0) ||
       (!((( get_i(TTemp[SP-1],0)) && (get_d(TTemp[SP-3],0)>0)) ||
          ((!get_i(TTemp[SP-1],0)) && (get_d(TTemp[SP-3],0)<0)))))
    {
     destroy_tuple(TTemp[SP--]);
     destroy_tuple(TTemp[SP]);
     T_tuple_sub(TTemp[SP-1],TTemp[SP-2],&TTemp[SP]);
     destroy_tuple(hv_IndexImage);
     copy_tuple(TTemp[SP],&hv_IndexImage);
     destroy_tuple(TTemp[SP--]);
     destroy_tuple(TTemp[SP]);
     for(;;)
     {
     T_tuple_add(hv_IndexImage,TTemp[SP-1],&TTemp[SP]);
     destroy_tuple(hv_IndexImage);
     copy_tuple(TTemp[SP],&hv_IndexImage);
     destroy_tuple(TTemp[SP]);
     if(get_d(TTemp[SP-1],0)<0)
      T_tuple_less(hv_IndexImage,TTemp[SP-2],&TTemp[SP]);
     else
      T_tuple_greater(hv_IndexImage,TTemp[SP-2],&TTemp[SP]);
     if(get_i(TTemp[SP],0)) break;
     destroy_tuple(TTemp[SP]);
     /*========== for ==========*/

      /*select_obj (Segmentations, SelectedSeg, IndexImage)*/
      clear_obj(ho_SelectedSeg);
      /***/T_select_obj(ho_Segmentations_COPY_INP_TMP, &ho_SelectedSeg, hv_IndexImage);

      /*select_obj (Domain, SelectedDomain, IndexImage)*/
      clear_obj(ho_SelectedDomain);
      /***/T_select_obj(ho_Domain, &ho_SelectedDomain, hv_IndexImage);

      /*change_domain (SelectedSeg, SelectedDomain, SelectedSeg)*/
      /***/change_domain(ho_SelectedSeg, ho_SelectedDomain, &(OTemp[SPO]));
      SPO++;
      clear_obj(ho_SelectedSeg);
      ho_SelectedSeg = OTemp[--SPO];

      /*replace_obj (Segmentations, SelectedSeg, Segmentations, IndexImage)*/
      /***/T_replace_obj(ho_Segmentations_COPY_INP_TMP, ho_SelectedSeg, &(OTemp[SPO]), 
          hv_IndexImage);
      SPO++;
      clear_obj(ho_Segmentations_COPY_INP_TMP);
      ho_Segmentations_COPY_INP_TMP = OTemp[--SPO];

     }
     destroy_tuple(TTemp[SP--]);
     destroy_tuple(TTemp[SP--]);
     destroy_tuple(TTemp[SP]);
    }
    else
    {
     destroy_tuple(TTemp[SP--]);
     destroy_tuple(TTemp[SP--]);
     destroy_tuple(TTemp[SP--]);
     destroy_tuple(TTemp[SP--]);
     destroy_tuple(TTemp[SP]);
    }/*========== end for ========*/

    /*crop_domain (Segmentations, Segmentations)*/
    /***/crop_domain(ho_Segmentations_COPY_INP_TMP, &(OTemp[SPO]));
    SPO++;
    clear_obj(ho_Segmentations_COPY_INP_TMP);
    ho_Segmentations_COPY_INP_TMP = OTemp[--SPO];

  }
  else
  {
    /* throw(...); only in hdevelop*/
  }
  }
  destroy_tuple(TTemp[--SP]);
  /*========== end if ==========*/
  /**/
  /*Preprocess the segmentation images.*/
  /**/
  /*Set all background classes to the given background class ID.*/
  /*========== if (SetBackgroundID != []) ==========*/
  create_tuple(&TTemp[SP++],0);
  T_tuple_not_equal(hv_SetBackgroundID,TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-1]=TTemp[SP];
  if(get_i(TTemp[SP-1],0))
  {
    /*reassign_pixel_values (Segmentations, Segmentations, ClassesToBackground, SetBackgroundID)*/
    /***/reassign_pixel_values(ho_Segmentations_COPY_INP_TMP, &(OTemp[SPO]), hv_ClassesToBackground, 
        hv_SetBackgroundID);
    SPO++;
    clear_obj(ho_Segmentations_COPY_INP_TMP);
    ho_Segmentations_COPY_INP_TMP = OTemp[--SPO];

  }
  destroy_tuple(TTemp[--SP]);
  /*========== end if ==========*/
  /**/
  /*Zoom images only if they have a different size than the specified size.*/
  /*get_image_size (Segmentations, ImageWidthRaw, ImageHeightRaw)*/
  destroy_tuple(hv_ImageWidthRaw);
  destroy_tuple(hv_ImageHeightRaw);
  /***/T_get_image_size(ho_Segmentations_COPY_INP_TMP, &hv_ImageWidthRaw, &hv_ImageHeightRaw);

  /*EqualWidth := ImageWidth [==] ImageWidthRaw*/
  T_tuple_equal_elem(hv_ImageWidth,hv_ImageWidthRaw,&TTemp[SP++]);
  destroy_tuple(hv_EqualWidth);
  hv_EqualWidth=TTemp[--SP];

  /*EqualHeight := ImageHeight [==] ImageHeightRaw*/
  T_tuple_equal_elem(hv_ImageHeight,hv_ImageHeightRaw,&TTemp[SP++]);
  destroy_tuple(hv_EqualHeight);
  hv_EqualHeight=TTemp[--SP];

  /*========== if (min(EqualWidth) == 0 or min(EqualHeight) == 0) ==========*/
  T_tuple_min(hv_EqualWidth,&TTemp[SP++]);
  create_tuple_i(&TTemp[SP++],0);
  T_tuple_equal(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-2]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-2]=TTemp[SP];
  SP--;
  T_tuple_min(hv_EqualHeight,&TTemp[SP++]);
  create_tuple_i(&TTemp[SP++],0);
  T_tuple_equal(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-2]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-2]=TTemp[SP];
  SP--;
  T_tuple_or(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-2]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-2]=TTemp[SP];
  SP--;
  if(get_i(TTemp[SP-1],0))
  {
    /*zoom_image_size (Segmentations, Segmentations, ImageWidth, ImageHeight, 'nearest_neighbor')*/
    create_tuple_s(&TTemp[SP++],"nearest_neighbor");
    /***/T_zoom_image_size(ho_Segmentations_COPY_INP_TMP, &(OTemp[SPO]), hv_ImageWidth, 
        hv_ImageHeight, TTemp[SP-1]);
    SPO++;
    clear_obj(ho_Segmentations_COPY_INP_TMP);
    ho_Segmentations_COPY_INP_TMP = OTemp[--SPO];
    destroy_tuple(TTemp[--SP]);

  }
  destroy_tuple(TTemp[--SP]);
  /*========== end if ==========*/
  /**/
  /*Check the type of the input images*/
  /*and convert if necessary.*/
  /*get_image_type (Segmentations, Type)*/
  destroy_tuple(hv_Type);
  /***/T_get_image_type(ho_Segmentations_COPY_INP_TMP, &hv_Type);

  /*EqualReal := Type [==] 'real'*/
  create_tuple_s(&TTemp[SP++],"real");
  T_tuple_equal_elem(hv_Type,TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-1]=TTemp[SP];
  destroy_tuple(hv_EqualReal);
  hv_EqualReal=TTemp[--SP];

  /**/
  /*========== if (min(EqualReal) == 0) ==========*/
  T_tuple_min(hv_EqualReal,&TTemp[SP++]);
  create_tuple_i(&TTemp[SP++],0);
  T_tuple_equal(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-2]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-2]=TTemp[SP];
  SP--;
  if(get_i(TTemp[SP-1],0))
  {
    /*Convert the image type to 'real',*/
    /*because the model expects 'real' images.*/
    /*convert_image_type (Segmentations, Segmentations, 'real')*/
    /***/convert_image_type(ho_Segmentations_COPY_INP_TMP, &(OTemp[SPO]), "real");
    SPO++;
    clear_obj(ho_Segmentations_COPY_INP_TMP);
    ho_Segmentations_COPY_INP_TMP = OTemp[--SPO];

  }
  destroy_tuple(TTemp[--SP]);
  /*========== end if ==========*/
  /**/
  /*Write preprocessed Segmentations to output variable.*/
  /*SegmentationsPreprocessed := Segmentations*/
  clear_obj((*ho_SegmentationsPreprocessed));
  copy_obj(ho_Segmentations_COPY_INP_TMP,&(*ho_SegmentationsPreprocessed),1,-1);

  /*========== return ==========*/

  /* Clear temporary tuple stack */
  while (SP > 0)
    destroy_tuple(TTemp[--SP]);
  /* Clear temporary tuple vectors stack*/
  while (SPTV > 0)
    V_destroy_vector(TVTemp[--SPTV]);
  /* Clear local iconic variables */
  clear_obj(ho_Domain);
  clear_obj(ho_SelectedSeg);
  clear_obj(ho_SelectedDomain);
  clear_obj(ho_Segmentations_COPY_INP_TMP);

  /* Clear local control variables */
  destroy_tuple(hv_NumberImages);
  destroy_tuple(hv_NumberSegmentations);
  destroy_tuple(hv_Width);
  destroy_tuple(hv_Height);
  destroy_tuple(hv_WidthSeg);
  destroy_tuple(hv_HeightSeg);
  destroy_tuple(hv_DLModelType);
  destroy_tuple(hv_ImageWidth);
  destroy_tuple(hv_ImageHeight);
  destroy_tuple(hv_ImageNumChannels);
  destroy_tuple(hv_ImageRangeMin);
  destroy_tuple(hv_ImageRangeMax);
  destroy_tuple(hv_DomainHandling);
  destroy_tuple(hv_SetBackgroundID);
  destroy_tuple(hv_ClassesToBackground);
  destroy_tuple(hv_IgnoreClassIDs);
  destroy_tuple(hv_IsInt);
  destroy_tuple(hv_IndexImage);
  destroy_tuple(hv_ImageWidthRaw);
  destroy_tuple(hv_ImageHeightRaw);
  destroy_tuple(hv_EqualWidth);
  destroy_tuple(hv_EqualHeight);
  destroy_tuple(hv_Type);
  destroy_tuple(hv_EqualReal);

  return;

  /****************************************************/
  /******************     End procedure   *************/
  /****************************************************/

}

/* Chapter: Deep Learning / Model*/
/* Short Description: Preprocess given DLSamples according to the preprocessing parameters given in DLPreprocessParam. */
void preprocess_dl_samples (Htuple hv_DLSampleBatch, Htuple hv_DLPreprocessParam)
{

  /* Stack for temporary tuples */
  Htuple   TTemp[100];
  int      SP=0;
  /* Stack for temporary tuple vectors */
  Hvector  TVTemp[100] = {0};
  int      SPTV=0;

  /* Local iconic variables */
  Hobject  ho_ImageRaw, ho_ImagePreprocessed, ho_AnomalyImageRaw;
  Hobject  ho_AnomalyImagePreprocessed, ho_SegmentationRaw;
  Hobject  ho_SegmentationPreprocessed, ho_ImageRawDomain;

  /* Local control variables */
  Htuple  hv_SampleIndex, hv_DLSample, hv_ImageExists;
  Htuple  hv_KeysExists, hv_AnomalyParamExist, hv_Rectangle1ParamExist;
  Htuple  hv_Rectangle2ParamExist, hv_InstanceMaskParamExist;
  Htuple  hv_SegmentationParamExist, hv_OCRParamExist;

  /* Local copy input parameter variables */
  Htuple   hv_DLPreprocessParam_COPY_INP_TMP;


  /* Initialize iconic variables */
  gen_empty_obj(&ho_ImageRaw);
  gen_empty_obj(&ho_ImagePreprocessed);
  gen_empty_obj(&ho_AnomalyImageRaw);
  gen_empty_obj(&ho_AnomalyImagePreprocessed);
  gen_empty_obj(&ho_SegmentationRaw);
  gen_empty_obj(&ho_SegmentationPreprocessed);
  gen_empty_obj(&ho_ImageRawDomain);

  /* Initialize control variables */
  create_tuple(&hv_SampleIndex,0);
  create_tuple(&hv_DLSample,0);
  create_tuple(&hv_ImageExists,0);
  create_tuple(&hv_KeysExists,0);
  create_tuple(&hv_AnomalyParamExist,0);
  create_tuple(&hv_Rectangle1ParamExist,0);
  create_tuple(&hv_Rectangle2ParamExist,0);
  create_tuple(&hv_InstanceMaskParamExist,0);
  create_tuple(&hv_SegmentationParamExist,0);
  create_tuple(&hv_OCRParamExist,0);
  copy_tuple(hv_DLPreprocessParam,&hv_DLPreprocessParam_COPY_INP_TMP);

  /****************************************************/
  /******************   Begin procedure   *************/
  /****************************************************/

  /**/
  /*This procedure preprocesses all images of the sample dictionaries*/
  /*in the tuple DLSampleBatch.*/
  /*The images are preprocessed according to the parameters provided*/
  /*in DLPreprocessParam.*/
  /**/
  /*Check the validity of the preprocessing parameters.*/
  /*The procedure check_dl_preprocess_param might change DLPreprocessParam.*/
  /*To avoid race conditions when preprocess_dl_samples is used from*/
  /*multiple threads with the same DLPreprocessParam dictionary,*/
  /*work on a copy.*/
  /*copy_dict (DLPreprocessParam, [], [], DLPreprocessParam)*/
  copy_tuple(hv_DLPreprocessParam_COPY_INP_TMP,&TTemp[SP++]);
  create_tuple(&TTemp[SP++],0);
  create_tuple(&TTemp[SP++],0);
  destroy_tuple(hv_DLPreprocessParam_COPY_INP_TMP);
  /***/T_copy_dict(TTemp[SP-3], TTemp[SP-2], TTemp[SP-1], &hv_DLPreprocessParam_COPY_INP_TMP);
  destroy_tuple(TTemp[--SP]);
  destroy_tuple(TTemp[--SP]);
  destroy_tuple(TTemp[--SP]);

  /*check_dl_preprocess_param (DLPreprocessParam)*/
  /***/check_dl_preprocess_param(hv_DLPreprocessParam_COPY_INP_TMP);

  /**/
  /**/
  /**/
  /*Preprocess the sample entries.*/
  /**/
  /*========== for SampleIndex := 0 to |DLSampleBatch| - 1 by 1 ==========*/
  T_tuple_length(hv_DLSampleBatch,&TTemp[SP++]);
  create_tuple_i(&TTemp[SP++],1);
  T_tuple_sub(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-2]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-2]=TTemp[SP];
  SP--;
  create_tuple_i(&TTemp[SP++],1);
  create_tuple_i(&TTemp[SP++],0);
  T_tuple_greater(TTemp[SP-1],TTemp[SP-3],&TTemp[SP]);
  SP++;
  T_tuple_equal(TTemp[SP-2],TTemp[SP-4],&TTemp[SP]);
  if(get_i(TTemp[SP],0) ||
     (!((( get_i(TTemp[SP-1],0)) && (get_d(TTemp[SP-3],0)>0)) ||
        ((!get_i(TTemp[SP-1],0)) && (get_d(TTemp[SP-3],0)<0)))))
  {
   destroy_tuple(TTemp[SP--]);
   destroy_tuple(TTemp[SP]);
   T_tuple_sub(TTemp[SP-1],TTemp[SP-2],&TTemp[SP]);
   destroy_tuple(hv_SampleIndex);
   copy_tuple(TTemp[SP],&hv_SampleIndex);
   destroy_tuple(TTemp[SP--]);
   destroy_tuple(TTemp[SP]);
   for(;;)
   {
   T_tuple_add(hv_SampleIndex,TTemp[SP-1],&TTemp[SP]);
   destroy_tuple(hv_SampleIndex);
   copy_tuple(TTemp[SP],&hv_SampleIndex);
   destroy_tuple(TTemp[SP]);
   if(get_d(TTemp[SP-1],0)<0)
    T_tuple_less(hv_SampleIndex,TTemp[SP-2],&TTemp[SP]);
   else
    T_tuple_greater(hv_SampleIndex,TTemp[SP-2],&TTemp[SP]);
   if(get_i(TTemp[SP],0)) break;
   destroy_tuple(TTemp[SP]);
   /*========== for ==========*/

    /*DLSample := DLSampleBatch[SampleIndex]*/
    T_tuple_select(hv_DLSampleBatch,hv_SampleIndex,&TTemp[SP++]);
    destroy_tuple(hv_DLSample);
    hv_DLSample=TTemp[--SP];

    /**/
    /*Preprocess augmentation data.*/
    /*preprocess_dl_model_augmentation_data (DLSample, DLPreprocessParam)*/
    /***/preprocess_dl_model_augmentation_data(hv_DLSample, hv_DLPreprocessParam_COPY_INP_TMP);

    /**/
    /*Check the existence of the sample keys.*/
    /*get_dict_param (DLSample, 'key_exists', 'image', ImageExists)*/
    create_tuple_s(&TTemp[SP++],"key_exists");
    create_tuple_s(&TTemp[SP++],"image");
    destroy_tuple(hv_ImageExists);
    /***/T_get_dict_param(hv_DLSample, TTemp[SP-2], TTemp[SP-1], &hv_ImageExists);
    destroy_tuple(TTemp[--SP]);
    destroy_tuple(TTemp[--SP]);

    /**/
    /*Preprocess the images.*/
    /*========== if (ImageExists) ==========*/
    copy_tuple(hv_ImageExists,&TTemp[SP++]);
    if(get_i(TTemp[SP-1],0))
    {
      /**/
      /*Get the image.*/
      /*get_dict_object (ImageRaw, DLSample, 'image')*/
      create_tuple_s(&TTemp[SP++],"image");
      clear_obj(ho_ImageRaw);
      /***/T_get_dict_object(&ho_ImageRaw, hv_DLSample, TTemp[SP-1]);
      destroy_tuple(TTemp[--SP]);

      /**/
      /*Preprocess the image.*/
      /*preprocess_dl_model_images (ImageRaw, ImagePreprocessed, DLPreprocessParam)*/
      clear_obj(ho_ImagePreprocessed);
      /***/preprocess_dl_model_images(ho_ImageRaw, &ho_ImagePreprocessed, hv_DLPreprocessParam_COPY_INP_TMP);

      /**/
      /*Replace the image in the dictionary.*/
      /*set_dict_object (ImagePreprocessed, DLSample, 'image')*/
      create_tuple_s(&TTemp[SP++],"image");
      /***/T_set_dict_object(ho_ImagePreprocessed, hv_DLSample, TTemp[SP-1]);
      destroy_tuple(TTemp[--SP]);

      /**/
      /*Check existence of model specific sample keys:*/
      /*- 'anomaly_ground_truth':*/
      /*  For model 'type' = 'anomaly_detection' and*/
      /*  model 'type' = 'gc_anomaly_detection'*/
      /*- 'bbox_row1':*/
      /*  For 'instance_type' = 'rectangle1' and*/
      /*  model 'type' = 'detection'*/
      /*- 'bbox_phi':*/
      /*  For 'instance_type' = 'rectangle2' and*/
      /*  model 'type' = 'detection'*/
      /*- 'mask':*/
      /*  For 'instance_type' = 'rectangle1',*/
      /*  model 'type' = 'detection', and*/
      /*  'instance_segmentation' = true*/
      /*- 'segmentation_image':*/
      /*  For model 'type' = 'segmentation'*/
      /*get_dict_param (DLSample, 'key_exists', ['anomaly_ground_truth', 'bbox_row1', 'bbox_phi', 'mask', 'segmentation_image', 'word'], KeysExists)*/
      create_tuple_s(&TTemp[SP++],"key_exists");
      create_tuple(&TTemp[SP++],6);
      set_s(TTemp[SP-1],"anomaly_ground_truth",0);
      set_s(TTemp[SP-1],"bbox_row1",1);
      set_s(TTemp[SP-1],"bbox_phi",2);
      set_s(TTemp[SP-1],"mask",3);
      set_s(TTemp[SP-1],"segmentation_image",4);
      set_s(TTemp[SP-1],"word",5);
      destroy_tuple(hv_KeysExists);
      /***/T_get_dict_param(hv_DLSample, TTemp[SP-2], TTemp[SP-1], &hv_KeysExists);
      destroy_tuple(TTemp[--SP]);
      destroy_tuple(TTemp[--SP]);

      /*AnomalyParamExist := KeysExists[0]*/
      create_tuple_i(&TTemp[SP++],0);
      T_tuple_select(hv_KeysExists,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      destroy_tuple(hv_AnomalyParamExist);
      hv_AnomalyParamExist=TTemp[--SP];

      /*Rectangle1ParamExist := KeysExists[1]*/
      create_tuple_i(&TTemp[SP++],1);
      T_tuple_select(hv_KeysExists,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      destroy_tuple(hv_Rectangle1ParamExist);
      hv_Rectangle1ParamExist=TTemp[--SP];

      /*Rectangle2ParamExist := KeysExists[2]*/
      create_tuple_i(&TTemp[SP++],2);
      T_tuple_select(hv_KeysExists,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      destroy_tuple(hv_Rectangle2ParamExist);
      hv_Rectangle2ParamExist=TTemp[--SP];

      /*InstanceMaskParamExist := KeysExists[3]*/
      create_tuple_i(&TTemp[SP++],3);
      T_tuple_select(hv_KeysExists,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      destroy_tuple(hv_InstanceMaskParamExist);
      hv_InstanceMaskParamExist=TTemp[--SP];

      /*SegmentationParamExist := KeysExists[4]*/
      create_tuple_i(&TTemp[SP++],4);
      T_tuple_select(hv_KeysExists,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      destroy_tuple(hv_SegmentationParamExist);
      hv_SegmentationParamExist=TTemp[--SP];

      /*OCRParamExist := KeysExists[5]*/
      create_tuple_i(&TTemp[SP++],5);
      T_tuple_select(hv_KeysExists,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      destroy_tuple(hv_OCRParamExist);
      hv_OCRParamExist=TTemp[--SP];

      /**/
      /*Preprocess the anomaly ground truth for*/
      /*model 'type' = 'anomaly_detection' or*/
      /*model 'type' = 'gc_anomaly_detection' if present.*/
      /*========== if (AnomalyParamExist) ==========*/
      copy_tuple(hv_AnomalyParamExist,&TTemp[SP++]);
      if(get_i(TTemp[SP-1],0))
      {
        /**/
        /*Get the anomaly image.*/
        /*get_dict_object (AnomalyImageRaw, DLSample, 'anomaly_ground_truth')*/
        create_tuple_s(&TTemp[SP++],"anomaly_ground_truth");
        clear_obj(ho_AnomalyImageRaw);
        /***/T_get_dict_object(&ho_AnomalyImageRaw, hv_DLSample, TTemp[SP-1]);
        destroy_tuple(TTemp[--SP]);

        /**/
        /*Preprocess the anomaly image.*/
        /*preprocess_dl_model_anomaly (AnomalyImageRaw, AnomalyImagePreprocessed, DLPreprocessParam)*/
        clear_obj(ho_AnomalyImagePreprocessed);
        /***/preprocess_dl_model_anomaly(ho_AnomalyImageRaw, &ho_AnomalyImagePreprocessed, 
            hv_DLPreprocessParam_COPY_INP_TMP);

        /**/
        /*Set preprocessed anomaly image.*/
        /*set_dict_object (AnomalyImagePreprocessed, DLSample, 'anomaly_ground_truth')*/
        create_tuple_s(&TTemp[SP++],"anomaly_ground_truth");
        /***/T_set_dict_object(ho_AnomalyImagePreprocessed, hv_DLSample, TTemp[SP-1]);
        destroy_tuple(TTemp[--SP]);

      }
      destroy_tuple(TTemp[--SP]);
      /*========== end if ==========*/
      /**/
      /*Preprocess depending on the model type.*/
      /*If bounding boxes are given, rescale them as well.*/
      /*========== if (Rectangle1ParamExist) ==========*/
      copy_tuple(hv_Rectangle1ParamExist,&TTemp[SP++]);
      if(get_i(TTemp[SP-1],0))
      {
        /**/
        /*Preprocess the bounding boxes of type 'rectangle1'.*/
        /*preprocess_dl_model_bbox_rect1 (ImageRaw, DLSample, DLPreprocessParam)*/
        /***/preprocess_dl_model_bbox_rect1(ho_ImageRaw, hv_DLSample, hv_DLPreprocessParam_COPY_INP_TMP);

      }
      else
      {
      destroy_tuple(TTemp[--SP]);
      /*========== elseif (Rectangle2ParamExist) ==========*/

      copy_tuple(hv_Rectangle2ParamExist,&TTemp[SP++]);
      if(get_i(TTemp[SP-1],0))
      {
        /**/
        /*Preprocess the bounding boxes of type 'rectangle2'.*/
        /*preprocess_dl_model_bbox_rect2 (ImageRaw, DLSample, DLPreprocessParam)*/
        /***/preprocess_dl_model_bbox_rect2(ho_ImageRaw, hv_DLSample, hv_DLPreprocessParam_COPY_INP_TMP);

      }
      }
      destroy_tuple(TTemp[--SP]);
      /*========== end if ==========*/
      /*========== if (InstanceMaskParamExist) ==========*/
      copy_tuple(hv_InstanceMaskParamExist,&TTemp[SP++]);
      if(get_i(TTemp[SP-1],0))
      {
        /**/
        /*Preprocess the instance masks.*/
        /*preprocess_dl_model_instance_masks (ImageRaw, DLSample, DLPreprocessParam)*/
        /***/preprocess_dl_model_instance_masks(ho_ImageRaw, hv_DLSample, hv_DLPreprocessParam_COPY_INP_TMP);

      }
      destroy_tuple(TTemp[--SP]);
      /*========== end if ==========*/
      /**/
      /*Preprocess the segmentation image if present.*/
      /*========== if (SegmentationParamExist) ==========*/
      copy_tuple(hv_SegmentationParamExist,&TTemp[SP++]);
      if(get_i(TTemp[SP-1],0))
      {
        /**/
        /*Get the segmentation image.*/
        /*get_dict_object (SegmentationRaw, DLSample, 'segmentation_image')*/
        create_tuple_s(&TTemp[SP++],"segmentation_image");
        clear_obj(ho_SegmentationRaw);
        /***/T_get_dict_object(&ho_SegmentationRaw, hv_DLSample, TTemp[SP-1]);
        destroy_tuple(TTemp[--SP]);

        /**/
        /*Preprocess the segmentation image.*/
        /*preprocess_dl_model_segmentations (ImageRaw, SegmentationRaw, SegmentationPreprocessed, DLPreprocessParam)*/
        clear_obj(ho_SegmentationPreprocessed);
        /***/preprocess_dl_model_segmentations(ho_ImageRaw, ho_SegmentationRaw, &ho_SegmentationPreprocessed, 
            hv_DLPreprocessParam_COPY_INP_TMP);

        /**/
        /*Set preprocessed segmentation image.*/
        /*set_dict_object (SegmentationPreprocessed, DLSample, 'segmentation_image')*/
        create_tuple_s(&TTemp[SP++],"segmentation_image");
        /***/T_set_dict_object(ho_SegmentationPreprocessed, hv_DLSample, TTemp[SP-1]);
        destroy_tuple(TTemp[--SP]);

      }
      destroy_tuple(TTemp[--SP]);
      /*========== end if ==========*/
      /**/
      /*Preprocess the word bounding boxes and generate targets.*/
      /*========== if (OCRParamExist and Rectangle2ParamExist) ==========*/
      T_tuple_and(hv_OCRParamExist,hv_Rectangle2ParamExist,&TTemp[SP++]);
      if(get_i(TTemp[SP-1],0))
      {
        /**/
        /*Preprocess Sample.*/
        /*gen_dl_ocr_detection_targets (DLSample, DLPreprocessParam)*/
        /***/gen_dl_ocr_detection_targets(hv_DLSample, hv_DLPreprocessParam_COPY_INP_TMP);

      }
      destroy_tuple(TTemp[--SP]);
      /*========== end if ==========*/
      /**/
      /*Preprocess 3D relevant data if present.*/
      /*get_dict_param (DLSample, 'key_exists', ['x', 'y', 'z', 'normals'], KeysExists)*/
      create_tuple_s(&TTemp[SP++],"key_exists");
      create_tuple(&TTemp[SP++],4);
      set_s(TTemp[SP-1],"x",0);
      set_s(TTemp[SP-1],"y",1);
      set_s(TTemp[SP-1],"z",2);
      set_s(TTemp[SP-1],"normals",3);
      destroy_tuple(hv_KeysExists);
      /***/T_get_dict_param(hv_DLSample, TTemp[SP-2], TTemp[SP-1], &hv_KeysExists);
      destroy_tuple(TTemp[--SP]);
      destroy_tuple(TTemp[--SP]);

      /*========== if (max(KeysExists)) ==========*/
      T_tuple_max(hv_KeysExists,&TTemp[SP++]);
      if(get_i(TTemp[SP-1],0))
      {
        /*We need to handle crop_domain before preprocess_dl_model_3d_data*/
        /*if it is necessary.*/
        /*Note, we are not cropping the image of DLSample because it has*/
        /*been done by preprocess_dl_model_images.*/
        /*Since we always keep the domain of 3D data we do not need to handle*/
        /*'keep_domain' or 'full_domain'.*/
        /*get_domain (ImageRaw, ImageRawDomain)*/
        clear_obj(ho_ImageRawDomain);
        /***/get_domain(ho_ImageRaw, &ho_ImageRawDomain);

        /*crop_dl_sample_image (ImageRawDomain, DLSample, 'x', DLPreprocessParam)*/
        create_tuple_s(&TTemp[SP++],"x");
        /***/crop_dl_sample_image(ho_ImageRawDomain, hv_DLSample, TTemp[SP-1], hv_DLPreprocessParam_COPY_INP_TMP);
        destroy_tuple(TTemp[--SP]);

        /*crop_dl_sample_image (ImageRawDomain, DLSample, 'y', DLPreprocessParam)*/
        create_tuple_s(&TTemp[SP++],"y");
        /***/crop_dl_sample_image(ho_ImageRawDomain, hv_DLSample, TTemp[SP-1], hv_DLPreprocessParam_COPY_INP_TMP);
        destroy_tuple(TTemp[--SP]);

        /*crop_dl_sample_image (ImageRawDomain, DLSample, 'z', DLPreprocessParam)*/
        create_tuple_s(&TTemp[SP++],"z");
        /***/crop_dl_sample_image(ho_ImageRawDomain, hv_DLSample, TTemp[SP-1], hv_DLPreprocessParam_COPY_INP_TMP);
        destroy_tuple(TTemp[--SP]);

        /*crop_dl_sample_image (ImageRawDomain, DLSample, 'normals', DLPreprocessParam)*/
        create_tuple_s(&TTemp[SP++],"normals");
        /***/crop_dl_sample_image(ho_ImageRawDomain, hv_DLSample, TTemp[SP-1], hv_DLPreprocessParam_COPY_INP_TMP);
        destroy_tuple(TTemp[--SP]);

        /**/
        /*preprocess_dl_model_3d_data (DLSample, DLPreprocessParam)*/
        /***/preprocess_dl_model_3d_data(hv_DLSample, hv_DLPreprocessParam_COPY_INP_TMP);

      }
      destroy_tuple(TTemp[--SP]);
      /*========== end if ==========*/
    }
    else
    {
      /* throw(...); only in hdevelop*/
    }
    destroy_tuple(TTemp[--SP]);
    /*========== end if ==========*/
   }
   destroy_tuple(TTemp[SP--]);
   destroy_tuple(TTemp[SP--]);
   destroy_tuple(TTemp[SP]);
  }
  else
  {
   destroy_tuple(TTemp[SP--]);
   destroy_tuple(TTemp[SP--]);
   destroy_tuple(TTemp[SP--]);
   destroy_tuple(TTemp[SP--]);
   destroy_tuple(TTemp[SP]);
  }/*========== end for ========*/

  /**/
  /*========== return ==========*/

  /* Clear temporary tuple stack */
  while (SP > 0)
    destroy_tuple(TTemp[--SP]);
  /* Clear temporary tuple vectors stack*/
  while (SPTV > 0)
    V_destroy_vector(TVTemp[--SPTV]);
  /* Clear local iconic variables */
  clear_obj(ho_ImageRaw);
  clear_obj(ho_ImagePreprocessed);
  clear_obj(ho_AnomalyImageRaw);
  clear_obj(ho_AnomalyImagePreprocessed);
  clear_obj(ho_SegmentationRaw);
  clear_obj(ho_SegmentationPreprocessed);
  clear_obj(ho_ImageRawDomain);

  /* Clear local control variables */
  destroy_tuple(hv_SampleIndex);
  destroy_tuple(hv_DLSample);
  destroy_tuple(hv_ImageExists);
  destroy_tuple(hv_KeysExists);
  destroy_tuple(hv_AnomalyParamExist);
  destroy_tuple(hv_Rectangle1ParamExist);
  destroy_tuple(hv_Rectangle2ParamExist);
  destroy_tuple(hv_InstanceMaskParamExist);
  destroy_tuple(hv_SegmentationParamExist);
  destroy_tuple(hv_OCRParamExist);
  destroy_tuple(hv_DLPreprocessParam_COPY_INP_TMP);

  return;

  /****************************************************/
  /******************     End procedure   *************/
  /****************************************************/

}

/* Chapter: Image / Manipulation*/
/* Short Description: Change value of ValuesToChange in Image to NewValue. */
void reassign_pixel_values (Hobject ho_Image, Hobject *ho_ImageOut, Htuple hv_ValuesToChange, 
    Htuple hv_NewValue)
{


  /* Stack for temporary tuples */
  Htuple   TTemp[100];
  int      SP=0;
  /* Stack for temporary objects */
  Hobject  OTemp[20] = {0};
  int      SPO=0;
  /* Stack for temporary tuple vectors */
  Hvector  TVTemp[100] = {0};
  int      SPTV=0;

  /* Local iconic variables */
  Hobject  ho_RegionToChange, ho_RegionClass;

  /* Local control variables */
  Htuple  hv_IndexReset;

  /* Initialize iconic variables */
  gen_empty_obj(&ho_RegionToChange);
  gen_empty_obj(&ho_RegionClass);
  gen_empty_obj(&(*ho_ImageOut));

  /* Initialize control variables */
  create_tuple(&hv_IndexReset,0);

  /****************************************************/
  /******************   Begin procedure   *************/
  /****************************************************/

  /**/
  /*This procedure sets all pixels of Image*/
  /*with the values given in ValuesToChange to the given value NewValue.*/
  /**/
  /*gen_empty_region (RegionToChange)*/
  clear_obj(ho_RegionToChange);
  /***/gen_empty_region(&ho_RegionToChange);

  /*========== for IndexReset := 0 to |ValuesToChange| - 1 by 1 ==========*/
  T_tuple_length(hv_ValuesToChange,&TTemp[SP++]);
  create_tuple_i(&TTemp[SP++],1);
  T_tuple_sub(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-2]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-2]=TTemp[SP];
  SP--;
  create_tuple_i(&TTemp[SP++],1);
  create_tuple_i(&TTemp[SP++],0);
  T_tuple_greater(TTemp[SP-1],TTemp[SP-3],&TTemp[SP]);
  SP++;
  T_tuple_equal(TTemp[SP-2],TTemp[SP-4],&TTemp[SP]);
  if(get_i(TTemp[SP],0) ||
     (!((( get_i(TTemp[SP-1],0)) && (get_d(TTemp[SP-3],0)>0)) ||
        ((!get_i(TTemp[SP-1],0)) && (get_d(TTemp[SP-3],0)<0)))))
  {
   destroy_tuple(TTemp[SP--]);
   destroy_tuple(TTemp[SP]);
   T_tuple_sub(TTemp[SP-1],TTemp[SP-2],&TTemp[SP]);
   destroy_tuple(hv_IndexReset);
   copy_tuple(TTemp[SP],&hv_IndexReset);
   destroy_tuple(TTemp[SP--]);
   destroy_tuple(TTemp[SP]);
   for(;;)
   {
   T_tuple_add(hv_IndexReset,TTemp[SP-1],&TTemp[SP]);
   destroy_tuple(hv_IndexReset);
   copy_tuple(TTemp[SP],&hv_IndexReset);
   destroy_tuple(TTemp[SP]);
   if(get_d(TTemp[SP-1],0)<0)
    T_tuple_less(hv_IndexReset,TTemp[SP-2],&TTemp[SP]);
   else
    T_tuple_greater(hv_IndexReset,TTemp[SP-2],&TTemp[SP]);
   if(get_i(TTemp[SP],0)) break;
   destroy_tuple(TTemp[SP]);
   /*========== for ==========*/

    /*threshold (Image, RegionClass, ValuesToChange[IndexReset], ValuesToChange[IndexReset])*/
    T_tuple_select(hv_ValuesToChange,hv_IndexReset,&TTemp[SP++]);
    T_tuple_select(hv_ValuesToChange,hv_IndexReset,&TTemp[SP++]);
    clear_obj(ho_RegionClass);
    /***/T_threshold(ho_Image, &ho_RegionClass, TTemp[SP-2], TTemp[SP-1]);
    destroy_tuple(TTemp[--SP]);
    destroy_tuple(TTemp[--SP]);

    /*union2 (RegionToChange, RegionClass, RegionToChange)*/
    /***/union2(ho_RegionToChange, ho_RegionClass, &(OTemp[SPO]));
    SPO++;
    clear_obj(ho_RegionToChange);
    ho_RegionToChange = OTemp[--SPO];

   }
   destroy_tuple(TTemp[SP--]);
   destroy_tuple(TTemp[SP--]);
   destroy_tuple(TTemp[SP]);
  }
  else
  {
   destroy_tuple(TTemp[SP--]);
   destroy_tuple(TTemp[SP--]);
   destroy_tuple(TTemp[SP--]);
   destroy_tuple(TTemp[SP--]);
   destroy_tuple(TTemp[SP]);
  }/*========== end for ========*/

  /*overpaint_region (Image, RegionToChange, NewValue, 'fill')*/
  create_tuple_s(&TTemp[SP++],"fill");
  /***/T_overpaint_region(ho_Image, ho_RegionToChange, hv_NewValue, TTemp[SP-1]);
  destroy_tuple(TTemp[--SP]);

  /*ImageOut := Image*/
  clear_obj((*ho_ImageOut));
  copy_obj(ho_Image,&(*ho_ImageOut),1,-1);

  /*========== return ==========*/

  /* Clear temporary tuple stack */
  while (SP > 0)
    destroy_tuple(TTemp[--SP]);
  /* Clear temporary tuple vectors stack*/
  while (SPTV > 0)
    V_destroy_vector(TVTemp[--SPTV]);
  /* Clear local iconic variables */
  clear_obj(ho_RegionToChange);
  clear_obj(ho_RegionClass);

  /* Clear local control variables */
  destroy_tuple(hv_IndexReset);

  return;

  /****************************************************/
  /******************     End procedure   *************/
  /****************************************************/

}

/* Chapter: Deep Learning / Model*/
/* Short Description: Remove invalid 3D pixels from a given domain. */
void remove_invalid_3d_pixels (Hobject ho_ImageX, Hobject ho_ImageY, Hobject ho_ImageZ, 
    Hobject ho_Domain, Hobject *ho_DomainOut, Htuple hv_InvalidPixelValue)
{


  /* Stack for temporary objects */
  Hobject  OTemp[20] = {0};
  int      SPO=0;

  /* Local iconic variables */
  Hobject  ho_ImageXOut, ho_ImageYOut, ho_ImageZOut;
  Hobject  ho_RegionInvalX, ho_RegionInvalY, ho_RegionInvalZ;
  Hobject  ho_RegionInvalXY, ho_RegionInval, ho_RegionInvalComplement;

  /* Initialize iconic variables */
  gen_empty_obj(&ho_ImageXOut);
  gen_empty_obj(&ho_ImageYOut);
  gen_empty_obj(&ho_ImageZOut);
  gen_empty_obj(&ho_RegionInvalX);
  gen_empty_obj(&ho_RegionInvalY);
  gen_empty_obj(&ho_RegionInvalZ);
  gen_empty_obj(&ho_RegionInvalXY);
  gen_empty_obj(&ho_RegionInval);
  gen_empty_obj(&ho_RegionInvalComplement);
  gen_empty_obj(&(*ho_DomainOut));

  /****************************************************/
  /******************   Begin procedure   *************/
  /****************************************************/

  /*DomainOut := Domain*/
  clear_obj((*ho_DomainOut));
  copy_obj(ho_Domain,&(*ho_DomainOut),1,-1);

  /*ImageXOut := ImageX*/
  clear_obj(ho_ImageXOut);
  copy_obj(ho_ImageX,&ho_ImageXOut,1,-1);

  /*ImageYOut := ImageY*/
  clear_obj(ho_ImageYOut);
  copy_obj(ho_ImageY,&ho_ImageYOut,1,-1);

  /*ImageZOut := ImageZ*/
  clear_obj(ho_ImageZOut);
  copy_obj(ho_ImageZ,&ho_ImageZOut,1,-1);

  /*reduce_domain (ImageXOut, DomainOut, ImageXOut)*/
  /***/reduce_domain(ho_ImageXOut, (*ho_DomainOut), &(OTemp[SPO]));
  SPO++;
  clear_obj(ho_ImageXOut);
  ho_ImageXOut = OTemp[--SPO];

  /*reduce_domain (ImageYOut, DomainOut, ImageYOut)*/
  /***/reduce_domain(ho_ImageYOut, (*ho_DomainOut), &(OTemp[SPO]));
  SPO++;
  clear_obj(ho_ImageYOut);
  ho_ImageYOut = OTemp[--SPO];

  /*reduce_domain (ImageZOut, DomainOut, ImageZOut)*/
  /***/reduce_domain(ho_ImageZOut, (*ho_DomainOut), &(OTemp[SPO]));
  SPO++;
  clear_obj(ho_ImageZOut);
  ho_ImageZOut = OTemp[--SPO];

  /*threshold (ImageXOut, RegionInvalX, InvalidPixelValue, InvalidPixelValue)*/
  clear_obj(ho_RegionInvalX);
  /***/T_threshold(ho_ImageXOut, &ho_RegionInvalX, hv_InvalidPixelValue, hv_InvalidPixelValue);

  /*threshold (ImageYOut, RegionInvalY, InvalidPixelValue, InvalidPixelValue)*/
  clear_obj(ho_RegionInvalY);
  /***/T_threshold(ho_ImageYOut, &ho_RegionInvalY, hv_InvalidPixelValue, hv_InvalidPixelValue);

  /*threshold (ImageZOut, RegionInvalZ, InvalidPixelValue, InvalidPixelValue)*/
  clear_obj(ho_RegionInvalZ);
  /***/T_threshold(ho_ImageZOut, &ho_RegionInvalZ, hv_InvalidPixelValue, hv_InvalidPixelValue);

  /*intersection (RegionInvalX, RegionInvalY, RegionInvalXY)*/
  clear_obj(ho_RegionInvalXY);
  /***/intersection(ho_RegionInvalX, ho_RegionInvalY, &ho_RegionInvalXY);

  /*intersection (RegionInvalXY, RegionInvalZ, RegionInval)*/
  clear_obj(ho_RegionInval);
  /***/intersection(ho_RegionInvalXY, ho_RegionInvalZ, &ho_RegionInval);

  /*complement (RegionInval, RegionInvalComplement)*/
  clear_obj(ho_RegionInvalComplement);
  /***/complement(ho_RegionInval, &ho_RegionInvalComplement);

  /*intersection (DomainOut, RegionInvalComplement, DomainOut)*/
  /***/intersection((*ho_DomainOut), ho_RegionInvalComplement, &(OTemp[SPO]));
  SPO++;
  clear_obj((*ho_DomainOut));
  (*ho_DomainOut) = OTemp[--SPO];

  /*========== return ==========*/

  /* Clear local iconic variables */
  clear_obj(ho_ImageXOut);
  clear_obj(ho_ImageYOut);
  clear_obj(ho_ImageZOut);
  clear_obj(ho_RegionInvalX);
  clear_obj(ho_RegionInvalY);
  clear_obj(ho_RegionInvalZ);
  clear_obj(ho_RegionInvalXY);
  clear_obj(ho_RegionInval);
  clear_obj(ho_RegionInvalComplement);

  return;

  /****************************************************/
  /******************     End procedure   *************/
  /****************************************************/

}

/* Chapter: Deep Learning / Model*/
/* Short Description: Replace legacy preprocessing parameters or values. */
void replace_legacy_preprocessing_parameters (Htuple hv_DLPreprocessParam)
{

  /* Stack for temporary tuples */
  Htuple   TTemp[100];
  int      SP=0;
  /* Stack for temporary tuple vectors */
  Hvector  TVTemp[100] = {0};
  int      SPTV=0;

  /* Local iconic variables */

  /* Local control variables */
  Htuple  hv_Exception, hv_NormalizationTypeExists;
  Htuple  hv_NormalizationType, hv_LegacyNormalizationKeyExists;
  Htuple  hv_ContrastNormalization;

  /* Initialize control variables */
  create_tuple(&hv_Exception,0);
  create_tuple(&hv_NormalizationTypeExists,0);
  create_tuple(&hv_NormalizationType,0);
  create_tuple(&hv_LegacyNormalizationKeyExists,0);
  create_tuple(&hv_ContrastNormalization,0);

  /****************************************************/
  /******************   Begin procedure   *************/
  /****************************************************/

  /**/
  /*This procedure adapts the dictionary DLPreprocessParam*/
  /*if a legacy preprocessing parameter is set.*/
  /**/
  /*Map legacy value set to new parameter.*/
  /*Exception := false*/
  reuse_tuple_i(&hv_Exception,0);

  /* try(...); only in hdevelop*/
    /*get_dict_param (DLPreprocessParam, 'key_exists', 'normalization_type', NormalizationTypeExists)*/
    create_tuple_s(&TTemp[SP++],"key_exists");
    create_tuple_s(&TTemp[SP++],"normalization_type");
    destroy_tuple(hv_NormalizationTypeExists);
    /***/T_get_dict_param(hv_DLPreprocessParam, TTemp[SP-2], TTemp[SP-1], &hv_NormalizationTypeExists);
    destroy_tuple(TTemp[--SP]);
    destroy_tuple(TTemp[--SP]);

    /**/
    /*========== if (NormalizationTypeExists) ==========*/
    copy_tuple(hv_NormalizationTypeExists,&TTemp[SP++]);
    if(get_i(TTemp[SP-1],0))
    {
      /*get_dict_tuple (DLPreprocessParam, 'normalization_type', NormalizationType)*/
      create_tuple_s(&TTemp[SP++],"normalization_type");
      destroy_tuple(hv_NormalizationType);
      /***/T_get_dict_tuple(hv_DLPreprocessParam, TTemp[SP-1], &hv_NormalizationType);
      destroy_tuple(TTemp[--SP]);

      /*========== if (NormalizationType == 'true') ==========*/
      create_tuple_s(&TTemp[SP++],"true");
      T_tuple_equal(hv_NormalizationType,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      if(get_i(TTemp[SP-1],0))
      {
        /*NormalizationType := 'first_channel'*/
        reuse_tuple_s(&hv_NormalizationType,"first_channel");
      }
      else
      {
      destroy_tuple(TTemp[--SP]);
      /*========== elseif (NormalizationType == 'false') ==========*/

      create_tuple_s(&TTemp[SP++],"false");
      T_tuple_equal(hv_NormalizationType,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      if(get_i(TTemp[SP-1],0))
      {
        /*NormalizationType := 'none'*/
        reuse_tuple_s(&hv_NormalizationType,"none");
      }
      }
      destroy_tuple(TTemp[--SP]);
      /*========== end if ==========*/
      /*set_dict_tuple (DLPreprocessParam, 'normalization_type', NormalizationType)*/
      create_tuple_s(&TTemp[SP++],"normalization_type");
      /***/T_set_dict_tuple(hv_DLPreprocessParam, TTemp[SP-1], hv_NormalizationType);
      destroy_tuple(TTemp[--SP]);

    }
    destroy_tuple(TTemp[--SP]);
    /*========== end if ==========*/
  /* catch(...); only in hdevelop*/
  /* endtry(...); only in hdevelop*/
  /**/
  /*Map legacy parameter to new parameter and corresponding value.*/
  /*Exception := false*/
  reuse_tuple_i(&hv_Exception,0);

  /* try(...); only in hdevelop*/
    /*get_dict_param (DLPreprocessParam, 'key_exists', 'contrast_normalization', LegacyNormalizationKeyExists)*/
    create_tuple_s(&TTemp[SP++],"key_exists");
    create_tuple_s(&TTemp[SP++],"contrast_normalization");
    destroy_tuple(hv_LegacyNormalizationKeyExists);
    /***/T_get_dict_param(hv_DLPreprocessParam, TTemp[SP-2], TTemp[SP-1], &hv_LegacyNormalizationKeyExists);
    destroy_tuple(TTemp[--SP]);
    destroy_tuple(TTemp[--SP]);

    /*========== if (LegacyNormalizationKeyExists) ==========*/
    copy_tuple(hv_LegacyNormalizationKeyExists,&TTemp[SP++]);
    if(get_i(TTemp[SP-1],0))
    {
      /*get_dict_tuple (DLPreprocessParam, 'contrast_normalization', ContrastNormalization)*/
      create_tuple_s(&TTemp[SP++],"contrast_normalization");
      destroy_tuple(hv_ContrastNormalization);
      /***/T_get_dict_tuple(hv_DLPreprocessParam, TTemp[SP-1], &hv_ContrastNormalization);
      destroy_tuple(TTemp[--SP]);

      /*Replace 'contrast_normalization' by 'normalization_type'.*/
      /*========== if (ContrastNormalization == 'false') ==========*/
      create_tuple_s(&TTemp[SP++],"false");
      T_tuple_equal(hv_ContrastNormalization,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      if(get_i(TTemp[SP-1],0))
      {
        /*set_dict_tuple (DLPreprocessParam, 'normalization_type', 'none')*/
        create_tuple_s(&TTemp[SP++],"normalization_type");
        create_tuple_s(&TTemp[SP++],"none");
        /***/T_set_dict_tuple(hv_DLPreprocessParam, TTemp[SP-2], TTemp[SP-1]);
        destroy_tuple(TTemp[--SP]);
        destroy_tuple(TTemp[--SP]);

      }
      else
      {
      destroy_tuple(TTemp[--SP]);
      /*========== elseif (ContrastNormalization == 'true') ==========*/

      create_tuple_s(&TTemp[SP++],"true");
      T_tuple_equal(hv_ContrastNormalization,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      if(get_i(TTemp[SP-1],0))
      {
        /*set_dict_tuple (DLPreprocessParam, 'normalization_type', 'first_channel')*/
        create_tuple_s(&TTemp[SP++],"normalization_type");
        create_tuple_s(&TTemp[SP++],"first_channel");
        /***/T_set_dict_tuple(hv_DLPreprocessParam, TTemp[SP-2], TTemp[SP-1]);
        destroy_tuple(TTemp[--SP]);
        destroy_tuple(TTemp[--SP]);

      }
      }
      destroy_tuple(TTemp[--SP]);
      /*========== end if ==========*/
      /*remove_dict_key (DLPreprocessParam, 'contrast_normalization')*/
      create_tuple_s(&TTemp[SP++],"contrast_normalization");
      /***/T_remove_dict_key(hv_DLPreprocessParam, TTemp[SP-1]);
      destroy_tuple(TTemp[--SP]);

    }
    destroy_tuple(TTemp[--SP]);
    /*========== end if ==========*/
  /* catch(...); only in hdevelop*/
  /* endtry(...); only in hdevelop*/
  /*========== return ==========*/

  /* Clear temporary tuple stack */
  while (SP > 0)
    destroy_tuple(TTemp[--SP]);
  /* Clear temporary tuple vectors stack*/
  while (SPTV > 0)
    V_destroy_vector(TVTemp[--SPTV]);
  /* Clear local control variables */
  destroy_tuple(hv_Exception);
  destroy_tuple(hv_NormalizationTypeExists);
  destroy_tuple(hv_NormalizationType);
  destroy_tuple(hv_LegacyNormalizationKeyExists);
  destroy_tuple(hv_ContrastNormalization);

  return;

  /****************************************************/
  /******************     End procedure   *************/
  /****************************************************/

}

/* Chapter: Filters / Arithmetic*/
/* Short Description: Scale the gray values of an image from the interval [Min,Max] to [0,255] */
void scale_image_range (Hobject ho_Image, Hobject *ho_ImageScaled, Htuple hv_Min, 
    Htuple hv_Max)
{


    /* Stack for temporary tuples */
    Htuple   TTemp[100];
    int      SP=0;
    /* Stack for temporary objects */
    Hobject  OTemp[20] = {0};
    int      SPO=0;
    /* Stack for temporary tuple vectors */
    Hvector  TVTemp[100] = {0};
    int      SPTV=0;

    /* Local iconic variables */
    Hobject  ho_ImageSelected, ho_SelectedChannel;
    Hobject  ho_LowerRegion, ho_UpperRegion, ho_ImageSelectedScaled;

    /* Local control variables */
    Htuple  hv_LowerLimit, hv_UpperLimit, hv_Mult;
    Htuple  hv_Add, hv_NumImages, hv_ImageIndex, hv_Channels;
    Htuple  hv_ChannelIndex, hv_MinGray, hv_MaxGray, hv_Range;

    /* Local copy input parameter variables */
    Hobject  ho_Image_COPY_INP_TMP;
    Htuple   hv_Max_COPY_INP_TMP;
    Htuple   hv_Min_COPY_INP_TMP;


    /* Initialize iconic variables */
    gen_empty_obj(&ho_ImageSelected);
    gen_empty_obj(&ho_SelectedChannel);
    gen_empty_obj(&ho_LowerRegion);
    gen_empty_obj(&ho_UpperRegion);
    gen_empty_obj(&ho_ImageSelectedScaled);
    gen_empty_obj(&(*ho_ImageScaled));
    copy_obj(ho_Image,&ho_Image_COPY_INP_TMP,1,-1);

    /* Initialize control variables */
    create_tuple(&hv_LowerLimit,0);
    create_tuple(&hv_UpperLimit,0);
    create_tuple(&hv_Mult,0);
    create_tuple(&hv_Add,0);
    create_tuple(&hv_NumImages,0);
    create_tuple(&hv_ImageIndex,0);
    create_tuple(&hv_Channels,0);
    create_tuple(&hv_ChannelIndex,0);
    create_tuple(&hv_MinGray,0);
    create_tuple(&hv_MaxGray,0);
    create_tuple(&hv_Range,0);
    copy_tuple(hv_Max,&hv_Max_COPY_INP_TMP);
    copy_tuple(hv_Min,&hv_Min_COPY_INP_TMP);

    /****************************************************/
    /******************   Begin procedure   *************/
    /****************************************************/

  /*Convenience procedure to scale the gray values of the*/
  /*input image Image from the interval [Min,Max]*/
  /*to the interval [0,255] (default).*/
  /*Gray values < 0 or > 255 (after scaling) are clipped.*/
  /**/
  /*If the image shall be scaled to an interval different from [0,255],*/
  /*this can be achieved by passing tuples with 2 values [From, To]*/
  /*as Min and Max.*/
  /*Example:*/
  /*scale_image_range(Image:ImageScaled:[100,50],[200,250])*/
  /*maps the gray values of Image from the interval [100,200] to [50,250].*/
  /*All other gray values will be clipped.*/
  /**/
  /*input parameters:*/
  /*Image: the input image*/
  /*Min: the minimum gray value which will be mapped to 0*/
  /*     If a tuple with two values is given, the first value will*/
  /*     be mapped to the second value.*/
  /*Max: The maximum gray value which will be mapped to 255*/
  /*     If a tuple with two values is given, the first value will*/
  /*     be mapped to the second value.*/
  /**/
  /*Output parameter:*/
  /*ImageScale: the resulting scaled image.*/
  /**/
  /*========== if (|Min| == 2) ==========*/
  T_tuple_length(hv_Min_COPY_INP_TMP,&TTemp[SP++]);
  create_tuple_i(&TTemp[SP++],2);
  T_tuple_equal(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-2]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-2]=TTemp[SP];
  SP--;
  if(get_i(TTemp[SP-1],0))
  {
    /*LowerLimit := Min[1]*/
    create_tuple_i(&TTemp[SP++],1);
    T_tuple_select(hv_Min_COPY_INP_TMP,TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    destroy_tuple(hv_LowerLimit);
    hv_LowerLimit=TTemp[--SP];

    /*Min := Min[0]*/
    copy_tuple(hv_Min_COPY_INP_TMP,&TTemp[SP++]);
    create_tuple_i(&TTemp[SP++],0);
    T_tuple_select(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-2]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-2]=TTemp[SP];
    SP--;
    destroy_tuple(hv_Min_COPY_INP_TMP);
    hv_Min_COPY_INP_TMP=TTemp[--SP];

  }
  else
  {
    /*LowerLimit := 0.0*/
    reuse_tuple_d(&hv_LowerLimit,0.0);

  }
  destroy_tuple(TTemp[--SP]);
  /*========== end if ==========*/
  /*========== if (|Max| == 2) ==========*/
  T_tuple_length(hv_Max_COPY_INP_TMP,&TTemp[SP++]);
  create_tuple_i(&TTemp[SP++],2);
  T_tuple_equal(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-2]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-2]=TTemp[SP];
  SP--;
  if(get_i(TTemp[SP-1],0))
  {
    /*UpperLimit := Max[1]*/
    create_tuple_i(&TTemp[SP++],1);
    T_tuple_select(hv_Max_COPY_INP_TMP,TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    destroy_tuple(hv_UpperLimit);
    hv_UpperLimit=TTemp[--SP];

    /*Max := Max[0]*/
    copy_tuple(hv_Max_COPY_INP_TMP,&TTemp[SP++]);
    create_tuple_i(&TTemp[SP++],0);
    T_tuple_select(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-2]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-2]=TTemp[SP];
    SP--;
    destroy_tuple(hv_Max_COPY_INP_TMP);
    hv_Max_COPY_INP_TMP=TTemp[--SP];

  }
  else
  {
    /*UpperLimit := 255.0*/
    reuse_tuple_d(&hv_UpperLimit,255.0);

  }
  destroy_tuple(TTemp[--SP]);
  /*========== end if ==========*/
  /**/
  /*Calculate scaling parameters.*/
  /*Only scale if the scaling range is not zero.*/
  /*========== if (not (abs(Max - Min) < 1.0E-6)) ==========*/
  T_tuple_sub(hv_Max_COPY_INP_TMP,hv_Min_COPY_INP_TMP,&TTemp[SP++]);
  T_tuple_abs(TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-1]=TTemp[SP];
  create_tuple_d(&TTemp[SP++],1.0E-6);
  T_tuple_less(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-2]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-2]=TTemp[SP];
  SP--;
  T_tuple_not(TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-1]=TTemp[SP];
  if(get_i(TTemp[SP-1],0))
  {
    /*Mult := real(UpperLimit - LowerLimit) / (Max - Min)*/
    T_tuple_sub(hv_UpperLimit,hv_LowerLimit,&TTemp[SP++]);
    T_tuple_real(TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    T_tuple_sub(hv_Max_COPY_INP_TMP,hv_Min_COPY_INP_TMP,&TTemp[SP++]);
    T_tuple_div(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-2]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-2]=TTemp[SP];
    SP--;
    destroy_tuple(hv_Mult);
    hv_Mult=TTemp[--SP];

    /*Add := -Mult * Min + LowerLimit*/
    T_tuple_neg(hv_Mult,&TTemp[SP++]);
    T_tuple_mult(TTemp[SP-1],hv_Min_COPY_INP_TMP,&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    T_tuple_add(TTemp[SP-1],hv_LowerLimit,&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    destroy_tuple(hv_Add);
    hv_Add=TTemp[--SP];

    /*Scale image.*/
    /*scale_image (Image, Image, Mult, Add)*/
    /***/T_scale_image(ho_Image_COPY_INP_TMP, &(OTemp[SPO]), hv_Mult, hv_Add);
    SPO++;
    clear_obj(ho_Image_COPY_INP_TMP);
    ho_Image_COPY_INP_TMP = OTemp[--SPO];

  }
  destroy_tuple(TTemp[--SP]);
  /*========== end if ==========*/
  /**/
  /*Clip gray values if necessary.*/
  /*This must be done for each image and channel separately.*/
  /*gen_empty_obj (ImageScaled)*/
  clear_obj((*ho_ImageScaled));
  /***/gen_empty_obj(&(*ho_ImageScaled));

  /*count_obj (Image, NumImages)*/
  destroy_tuple(hv_NumImages);
  /***/T_count_obj(ho_Image_COPY_INP_TMP, &hv_NumImages);

  /*========== for ImageIndex := 1 to NumImages by 1 ==========*/
  copy_tuple(hv_NumImages,&TTemp[SP++]);
  create_tuple_i(&TTemp[SP++],1);
  create_tuple_i(&TTemp[SP++],1);
  T_tuple_greater(TTemp[SP-1],TTemp[SP-3],&TTemp[SP]);
  SP++;
  T_tuple_equal(TTemp[SP-2],TTemp[SP-4],&TTemp[SP]);
  if(get_i(TTemp[SP],0) ||
     (!((( get_i(TTemp[SP-1],0)) && (get_d(TTemp[SP-3],0)>0)) ||
        ((!get_i(TTemp[SP-1],0)) && (get_d(TTemp[SP-3],0)<0)))))
  {
   destroy_tuple(TTemp[SP--]);
   destroy_tuple(TTemp[SP]);
   T_tuple_sub(TTemp[SP-1],TTemp[SP-2],&TTemp[SP]);
   destroy_tuple(hv_ImageIndex);
   copy_tuple(TTemp[SP],&hv_ImageIndex);
   destroy_tuple(TTemp[SP--]);
   destroy_tuple(TTemp[SP]);
   for(;;)
   {
   T_tuple_add(hv_ImageIndex,TTemp[SP-1],&TTemp[SP]);
   destroy_tuple(hv_ImageIndex);
   copy_tuple(TTemp[SP],&hv_ImageIndex);
   destroy_tuple(TTemp[SP]);
   if(get_d(TTemp[SP-1],0)<0)
    T_tuple_less(hv_ImageIndex,TTemp[SP-2],&TTemp[SP]);
   else
    T_tuple_greater(hv_ImageIndex,TTemp[SP-2],&TTemp[SP]);
   if(get_i(TTemp[SP],0)) break;
   destroy_tuple(TTemp[SP]);
   /*========== for ==========*/

    /*select_obj (Image, ImageSelected, ImageIndex)*/
    clear_obj(ho_ImageSelected);
    /***/T_select_obj(ho_Image_COPY_INP_TMP, &ho_ImageSelected, hv_ImageIndex);

    /*count_channels (ImageSelected, Channels)*/
    destroy_tuple(hv_Channels);
    /***/T_count_channels(ho_ImageSelected, &hv_Channels);

    /*========== for ChannelIndex := 1 to Channels by 1 ==========*/
    copy_tuple(hv_Channels,&TTemp[SP++]);
    create_tuple_i(&TTemp[SP++],1);
    create_tuple_i(&TTemp[SP++],1);
    T_tuple_greater(TTemp[SP-1],TTemp[SP-3],&TTemp[SP]);
    SP++;
    T_tuple_equal(TTemp[SP-2],TTemp[SP-4],&TTemp[SP]);
    if(get_i(TTemp[SP],0) ||
       (!((( get_i(TTemp[SP-1],0)) && (get_d(TTemp[SP-3],0)>0)) ||
          ((!get_i(TTemp[SP-1],0)) && (get_d(TTemp[SP-3],0)<0)))))
    {
     destroy_tuple(TTemp[SP--]);
     destroy_tuple(TTemp[SP]);
     T_tuple_sub(TTemp[SP-1],TTemp[SP-2],&TTemp[SP]);
     destroy_tuple(hv_ChannelIndex);
     copy_tuple(TTemp[SP],&hv_ChannelIndex);
     destroy_tuple(TTemp[SP--]);
     destroy_tuple(TTemp[SP]);
     for(;;)
     {
     T_tuple_add(hv_ChannelIndex,TTemp[SP-1],&TTemp[SP]);
     destroy_tuple(hv_ChannelIndex);
     copy_tuple(TTemp[SP],&hv_ChannelIndex);
     destroy_tuple(TTemp[SP]);
     if(get_d(TTemp[SP-1],0)<0)
      T_tuple_less(hv_ChannelIndex,TTemp[SP-2],&TTemp[SP]);
     else
      T_tuple_greater(hv_ChannelIndex,TTemp[SP-2],&TTemp[SP]);
     if(get_i(TTemp[SP],0)) break;
     destroy_tuple(TTemp[SP]);
     /*========== for ==========*/

      /*access_channel (ImageSelected, SelectedChannel, ChannelIndex)*/
      clear_obj(ho_SelectedChannel);
      /***/T_access_channel(ho_ImageSelected, &ho_SelectedChannel, hv_ChannelIndex);

      /*min_max_gray (SelectedChannel, SelectedChannel, 0, MinGray, MaxGray, Range)*/
      create_tuple_i(&TTemp[SP++],0);
      destroy_tuple(hv_MinGray);
      destroy_tuple(hv_MaxGray);
      destroy_tuple(hv_Range);
      /***/T_min_max_gray(ho_SelectedChannel, ho_SelectedChannel, TTemp[SP-1], &hv_MinGray, 
          &hv_MaxGray, &hv_Range);
      destroy_tuple(TTemp[--SP]);

      /*threshold (SelectedChannel, LowerRegion, min([MinGray,LowerLimit]), LowerLimit)*/
      T_tuple_concat(hv_MinGray,hv_LowerLimit,&TTemp[SP++]);
      T_tuple_min(TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      clear_obj(ho_LowerRegion);
      /***/T_threshold(ho_SelectedChannel, &ho_LowerRegion, TTemp[SP-1], hv_LowerLimit);
      destroy_tuple(TTemp[--SP]);

      /*threshold (SelectedChannel, UpperRegion, UpperLimit, max([UpperLimit,MaxGray]))*/
      T_tuple_concat(hv_UpperLimit,hv_MaxGray,&TTemp[SP++]);
      T_tuple_max(TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      clear_obj(ho_UpperRegion);
      /***/T_threshold(ho_SelectedChannel, &ho_UpperRegion, hv_UpperLimit, TTemp[SP-1]);
      destroy_tuple(TTemp[--SP]);

      /*paint_region (LowerRegion, SelectedChannel, SelectedChannel, LowerLimit, 'fill')*/
      create_tuple_s(&TTemp[SP++],"fill");
      /***/T_paint_region(ho_LowerRegion, ho_SelectedChannel, &(OTemp[SPO]), hv_LowerLimit, 
          TTemp[SP-1]);
      SPO++;
      clear_obj(ho_SelectedChannel);
      ho_SelectedChannel = OTemp[--SPO];
      destroy_tuple(TTemp[--SP]);

      /*paint_region (UpperRegion, SelectedChannel, SelectedChannel, UpperLimit, 'fill')*/
      create_tuple_s(&TTemp[SP++],"fill");
      /***/T_paint_region(ho_UpperRegion, ho_SelectedChannel, &(OTemp[SPO]), hv_UpperLimit, 
          TTemp[SP-1]);
      SPO++;
      clear_obj(ho_SelectedChannel);
      ho_SelectedChannel = OTemp[--SPO];
      destroy_tuple(TTemp[--SP]);

      /*========== if (ChannelIndex == 1) ==========*/
      create_tuple_i(&TTemp[SP++],1);
      T_tuple_equal(hv_ChannelIndex,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      if(get_i(TTemp[SP-1],0))
      {
        /*copy_obj (SelectedChannel, ImageSelectedScaled, 1, 1)*/
        clear_obj(ho_ImageSelectedScaled);
        /***/copy_obj(ho_SelectedChannel, &ho_ImageSelectedScaled, 1, 1);

      }
      else
      {
        /*append_channel (ImageSelectedScaled, SelectedChannel, ImageSelectedScaled)*/
        /***/append_channel(ho_ImageSelectedScaled, ho_SelectedChannel, &(OTemp[SPO])
            );
        SPO++;
        clear_obj(ho_ImageSelectedScaled);
        ho_ImageSelectedScaled = OTemp[--SPO];

      }
      destroy_tuple(TTemp[--SP]);
      /*========== end if ==========*/
     }
     destroy_tuple(TTemp[SP--]);
     destroy_tuple(TTemp[SP--]);
     destroy_tuple(TTemp[SP]);
    }
    else
    {
     destroy_tuple(TTemp[SP--]);
     destroy_tuple(TTemp[SP--]);
     destroy_tuple(TTemp[SP--]);
     destroy_tuple(TTemp[SP--]);
     destroy_tuple(TTemp[SP]);
    }/*========== end for ========*/

    /*concat_obj (ImageScaled, ImageSelectedScaled, ImageScaled)*/
    /***/concat_obj((*ho_ImageScaled), ho_ImageSelectedScaled, &(OTemp[SPO]));
    SPO++;
    clear_obj((*ho_ImageScaled));
    (*ho_ImageScaled) = OTemp[--SPO];

   }
   destroy_tuple(TTemp[SP--]);
   destroy_tuple(TTemp[SP--]);
   destroy_tuple(TTemp[SP]);
  }
  else
  {
   destroy_tuple(TTemp[SP--]);
   destroy_tuple(TTemp[SP--]);
   destroy_tuple(TTemp[SP--]);
   destroy_tuple(TTemp[SP--]);
   destroy_tuple(TTemp[SP]);
  }/*========== end for ========*/

  /*========== return ==========*/

  /* Clear temporary tuple stack */
  while (SP > 0)
    destroy_tuple(TTemp[--SP]);
  /* Clear temporary tuple vectors stack*/
  while (SPTV > 0)
    V_destroy_vector(TVTemp[--SPTV]);
  /* Clear local iconic variables */
  clear_obj(ho_ImageSelected);
  clear_obj(ho_SelectedChannel);
  clear_obj(ho_LowerRegion);
  clear_obj(ho_UpperRegion);
  clear_obj(ho_ImageSelectedScaled);
  clear_obj(ho_Image_COPY_INP_TMP);

  /* Clear local control variables */
  destroy_tuple(hv_LowerLimit);
  destroy_tuple(hv_UpperLimit);
  destroy_tuple(hv_Mult);
  destroy_tuple(hv_Add);
  destroy_tuple(hv_NumImages);
  destroy_tuple(hv_ImageIndex);
  destroy_tuple(hv_Channels);
  destroy_tuple(hv_ChannelIndex);
  destroy_tuple(hv_MinGray);
  destroy_tuple(hv_MaxGray);
  destroy_tuple(hv_Range);
  destroy_tuple(hv_Max_COPY_INP_TMP);
  destroy_tuple(hv_Min_COPY_INP_TMP);

  return;

  /****************************************************/
  /******************     End procedure   *************/
  /****************************************************/

}

/* Chapter: Graphics / Text*/
/* Short Description: Set font independent of OS */
void set_display_font (Htuple hv_WindowHandle, Htuple hv_Size, Htuple hv_Font, Htuple hv_Bold, 
    Htuple hv_Slant)
{

  /* Stack for temporary tuples */
  Htuple   TTemp[100];
  int      SP=0;
  /* Stack for temporary tuple vectors */
  Hvector  TVTemp[100] = {0};
  int      SPTV=0;

  /* Local iconic variables */

  /* Local control variables */
  Htuple  hv_OS, hv_Fonts, hv_Style, hv_Exception;
  Htuple  hv_AvailableFonts, hv_Fdx, hv_Indices;

  /* Local copy input parameter variables */
  Htuple   hv_Font_COPY_INP_TMP;
  Htuple   hv_Size_COPY_INP_TMP;


  /* Initialize control variables */
  create_tuple(&hv_OS,0);
  create_tuple(&hv_Fonts,0);
  create_tuple(&hv_Style,0);
  create_tuple(&hv_Exception,0);
  create_tuple(&hv_AvailableFonts,0);
  create_tuple(&hv_Fdx,0);
  create_tuple(&hv_Indices,0);
  copy_tuple(hv_Font,&hv_Font_COPY_INP_TMP);
  copy_tuple(hv_Size,&hv_Size_COPY_INP_TMP);

  /****************************************************/
  /******************   Begin procedure   *************/
  /****************************************************/

  /*This procedure sets the text font of the current window with*/
  /*the specified attributes.*/
  /**/
  /*Input parameters:*/
  /*WindowHandle: The graphics window for which the font will be set*/
  /*Size: The font size. If Size=-1, the default of 16 is used.*/
  /*Bold: If set to 'true', a bold font is used*/
  /*Slant: If set to 'true', a slanted font is used*/
  /**/
  /*get_system ('operating_system', OS)*/
  create_tuple_s(&TTemp[SP++],"operating_system");
  destroy_tuple(hv_OS);
  /***/T_get_system(TTemp[SP-1], &hv_OS);
  destroy_tuple(TTemp[--SP]);

  /*========== if (Size == [] or Size == -1) ==========*/
  create_tuple(&TTemp[SP++],0);
  T_tuple_equal(hv_Size_COPY_INP_TMP,TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-1]=TTemp[SP];
  create_tuple_i(&TTemp[SP++],-1);
  T_tuple_equal(hv_Size_COPY_INP_TMP,TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-1]=TTemp[SP];
  T_tuple_or(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-2]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-2]=TTemp[SP];
  SP--;
  if(get_i(TTemp[SP-1],0))
  {
    /*Size := 16*/
    reuse_tuple_i(&hv_Size_COPY_INP_TMP,16);

  }
  destroy_tuple(TTemp[--SP]);
  /*========== end if ==========*/
  /*========== if (OS{0:2} == 'Win') ==========*/
  create_tuple_i(&TTemp[SP++],0);
  create_tuple_i(&TTemp[SP++],2);
  T_tuple_substr(hv_OS,TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-2]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-2]=TTemp[SP];
  SP=SP-1;
  create_tuple_s(&TTemp[SP++],"Win");
  T_tuple_equal(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-2]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-2]=TTemp[SP];
  SP--;
  if(get_i(TTemp[SP-1],0))
  {
    /*Restore previous behavior*/
    /*Size := int(1.13677 * Size)*/
    create_tuple_d(&TTemp[SP++],1.13677);
    copy_tuple(hv_Size_COPY_INP_TMP,&TTemp[SP++]);
    T_tuple_mult(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-2]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-2]=TTemp[SP];
    SP--;
    T_tuple_int(TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    destroy_tuple(hv_Size_COPY_INP_TMP);
    hv_Size_COPY_INP_TMP=TTemp[--SP];

  }
  else
  {
    /*Size := int(Size)*/
    copy_tuple(hv_Size_COPY_INP_TMP,&TTemp[SP++]);
    T_tuple_int(TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    destroy_tuple(hv_Size_COPY_INP_TMP);
    hv_Size_COPY_INP_TMP=TTemp[--SP];

  }
  destroy_tuple(TTemp[--SP]);
  /*========== end if ==========*/
  /*========== if (Font == 'Courier') ==========*/
  create_tuple_s(&TTemp[SP++],"Courier");
  T_tuple_equal(hv_Font_COPY_INP_TMP,TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-1]=TTemp[SP];
  if(get_i(TTemp[SP-1],0))
  {
    /*Fonts := ['Courier', 'Courier 10 Pitch', 'Courier New', 'CourierNew', 'Liberation Mono']*/
    create_tuple(&TTemp[SP++],5);
    set_s(TTemp[SP-1],"Courier",0);
    set_s(TTemp[SP-1],"Courier 10 Pitch",1);
    set_s(TTemp[SP-1],"Courier New",2);
    set_s(TTemp[SP-1],"CourierNew",3);
    set_s(TTemp[SP-1],"Liberation Mono",4);
    destroy_tuple(hv_Fonts);
    hv_Fonts=TTemp[--SP];

  }
  else
  {
  destroy_tuple(TTemp[--SP]);
  /*========== elseif (Font == 'mono') ==========*/

  create_tuple_s(&TTemp[SP++],"mono");
  T_tuple_equal(hv_Font_COPY_INP_TMP,TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-1]=TTemp[SP];
  if(get_i(TTemp[SP-1],0))
  {
    /*Fonts := ['Consolas', 'Menlo', 'Courier', 'Courier 10 Pitch', 'FreeMono', 'Liberation Mono']*/
    create_tuple(&TTemp[SP++],6);
    set_s(TTemp[SP-1],"Consolas",0);
    set_s(TTemp[SP-1],"Menlo",1);
    set_s(TTemp[SP-1],"Courier",2);
    set_s(TTemp[SP-1],"Courier 10 Pitch",3);
    set_s(TTemp[SP-1],"FreeMono",4);
    set_s(TTemp[SP-1],"Liberation Mono",5);
    destroy_tuple(hv_Fonts);
    hv_Fonts=TTemp[--SP];

  }
  else
  {
  destroy_tuple(TTemp[--SP]);
  /*========== elseif (Font == 'sans') ==========*/

  create_tuple_s(&TTemp[SP++],"sans");
  T_tuple_equal(hv_Font_COPY_INP_TMP,TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-1]=TTemp[SP];
  if(get_i(TTemp[SP-1],0))
  {
    /*Fonts := ['Luxi Sans', 'DejaVu Sans', 'FreeSans', 'Arial', 'Liberation Sans']*/
    create_tuple(&TTemp[SP++],5);
    set_s(TTemp[SP-1],"Luxi Sans",0);
    set_s(TTemp[SP-1],"DejaVu Sans",1);
    set_s(TTemp[SP-1],"FreeSans",2);
    set_s(TTemp[SP-1],"Arial",3);
    set_s(TTemp[SP-1],"Liberation Sans",4);
    destroy_tuple(hv_Fonts);
    hv_Fonts=TTemp[--SP];

  }
  else
  {
  destroy_tuple(TTemp[--SP]);
  /*========== elseif (Font == 'serif') ==========*/

  create_tuple_s(&TTemp[SP++],"serif");
  T_tuple_equal(hv_Font_COPY_INP_TMP,TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-1]=TTemp[SP];
  if(get_i(TTemp[SP-1],0))
  {
    /*Fonts := ['Times New Roman', 'Luxi Serif', 'DejaVu Serif', 'FreeSerif', 'Utopia', 'Liberation Serif']*/
    create_tuple(&TTemp[SP++],6);
    set_s(TTemp[SP-1],"Times New Roman",0);
    set_s(TTemp[SP-1],"Luxi Serif",1);
    set_s(TTemp[SP-1],"DejaVu Serif",2);
    set_s(TTemp[SP-1],"FreeSerif",3);
    set_s(TTemp[SP-1],"Utopia",4);
    set_s(TTemp[SP-1],"Liberation Serif",5);
    destroy_tuple(hv_Fonts);
    hv_Fonts=TTemp[--SP];

  }
  else
  {
    /*Fonts := Font*/
    destroy_tuple(hv_Fonts);
    copy_tuple(hv_Font_COPY_INP_TMP,&hv_Fonts);

  }
  }
  }
  }
  destroy_tuple(TTemp[--SP]);
  /*========== end if ==========*/
  /*Style := ''*/
  reuse_tuple_s(&hv_Style,"");
  /*========== if (Bold == 'true') ==========*/
  create_tuple_s(&TTemp[SP++],"true");
  T_tuple_equal(hv_Bold,TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-1]=TTemp[SP];
  if(get_i(TTemp[SP-1],0))
  {
    /*Style := Style + 'Bold'*/
    create_tuple_s(&TTemp[SP++],"Bold");
    T_tuple_add(hv_Style,TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(hv_Style);
    hv_Style=TTemp[SP];
    destroy_tuple(TTemp[--SP]);

  }
  else
  {
  destroy_tuple(TTemp[--SP]);
  /*========== elseif (Bold != 'false') ==========*/

  create_tuple_s(&TTemp[SP++],"false");
  T_tuple_not_equal(hv_Bold,TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-1]=TTemp[SP];
  if(get_i(TTemp[SP-1],0))
  {
    /*Exception := 'Wrong value of control parameter Bold'*/
    reuse_tuple_s(&hv_Exception,"Wrong value of control parameter Bold");
    /* throw(...); only in hdevelop*/
  }
  }
  destroy_tuple(TTemp[--SP]);
  /*========== end if ==========*/
  /*========== if (Slant == 'true') ==========*/
  create_tuple_s(&TTemp[SP++],"true");
  T_tuple_equal(hv_Slant,TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-1]=TTemp[SP];
  if(get_i(TTemp[SP-1],0))
  {
    /*Style := Style + 'Italic'*/
    create_tuple_s(&TTemp[SP++],"Italic");
    T_tuple_add(hv_Style,TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(hv_Style);
    hv_Style=TTemp[SP];
    destroy_tuple(TTemp[--SP]);

  }
  else
  {
  destroy_tuple(TTemp[--SP]);
  /*========== elseif (Slant != 'false') ==========*/

  create_tuple_s(&TTemp[SP++],"false");
  T_tuple_not_equal(hv_Slant,TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-1]=TTemp[SP];
  if(get_i(TTemp[SP-1],0))
  {
    /*Exception := 'Wrong value of control parameter Slant'*/
    reuse_tuple_s(&hv_Exception,"Wrong value of control parameter Slant");
    /* throw(...); only in hdevelop*/
  }
  }
  destroy_tuple(TTemp[--SP]);
  /*========== end if ==========*/
  /*========== if (Style == '') ==========*/
  create_tuple_s(&TTemp[SP++],"");
  T_tuple_equal(hv_Style,TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-1]=TTemp[SP];
  if(get_i(TTemp[SP-1],0))
  {
    /*Style := 'Normal'*/
    reuse_tuple_s(&hv_Style,"Normal");
  }
  destroy_tuple(TTemp[--SP]);
  /*========== end if ==========*/
  /*query_font (WindowHandle, AvailableFonts)*/
  destroy_tuple(hv_AvailableFonts);
  /***/T_query_font(hv_WindowHandle, &hv_AvailableFonts);

  /*Font := ''*/
  reuse_tuple_s(&hv_Font_COPY_INP_TMP,"");
  /*========== for Fdx := 0 to |Fonts| - 1 by 1 ==========*/
  T_tuple_length(hv_Fonts,&TTemp[SP++]);
  create_tuple_i(&TTemp[SP++],1);
  T_tuple_sub(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-2]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-2]=TTemp[SP];
  SP--;
  create_tuple_i(&TTemp[SP++],1);
  create_tuple_i(&TTemp[SP++],0);
  T_tuple_greater(TTemp[SP-1],TTemp[SP-3],&TTemp[SP]);
  SP++;
  T_tuple_equal(TTemp[SP-2],TTemp[SP-4],&TTemp[SP]);
  if(get_i(TTemp[SP],0) ||
     (!((( get_i(TTemp[SP-1],0)) && (get_d(TTemp[SP-3],0)>0)) ||
        ((!get_i(TTemp[SP-1],0)) && (get_d(TTemp[SP-3],0)<0)))))
  {
   destroy_tuple(TTemp[SP--]);
   destroy_tuple(TTemp[SP]);
   T_tuple_sub(TTemp[SP-1],TTemp[SP-2],&TTemp[SP]);
   destroy_tuple(hv_Fdx);
   copy_tuple(TTemp[SP],&hv_Fdx);
   destroy_tuple(TTemp[SP--]);
   destroy_tuple(TTemp[SP]);
   for(;;)
   {
   T_tuple_add(hv_Fdx,TTemp[SP-1],&TTemp[SP]);
   destroy_tuple(hv_Fdx);
   copy_tuple(TTemp[SP],&hv_Fdx);
   destroy_tuple(TTemp[SP]);
   if(get_d(TTemp[SP-1],0)<0)
    T_tuple_less(hv_Fdx,TTemp[SP-2],&TTemp[SP]);
   else
    T_tuple_greater(hv_Fdx,TTemp[SP-2],&TTemp[SP]);
   if(get_i(TTemp[SP],0)) break;
   destroy_tuple(TTemp[SP]);
   /*========== for ==========*/

    /*Indices := find(AvailableFonts,Fonts[Fdx])*/
    T_tuple_select(hv_Fonts,hv_Fdx,&TTemp[SP++]);
    T_tuple_find(hv_AvailableFonts,TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    destroy_tuple(hv_Indices);
    hv_Indices=TTemp[--SP];

    /*========== if (|Indices| > 0) ==========*/
    T_tuple_length(hv_Indices,&TTemp[SP++]);
    create_tuple_i(&TTemp[SP++],0);
    T_tuple_greater(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-2]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-2]=TTemp[SP];
    SP--;
    if(get_i(TTemp[SP-1],0))
    {
      /*========== if (Indices[0] >= 0) ==========*/
      create_tuple_i(&TTemp[SP++],0);
      T_tuple_select(hv_Indices,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      create_tuple_i(&TTemp[SP++],0);
      T_tuple_greater_equal(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-2]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-2]=TTemp[SP];
      SP--;
      if(get_i(TTemp[SP-1],0))
      {
        /*Font := Fonts[Fdx]*/
        T_tuple_select(hv_Fonts,hv_Fdx,&TTemp[SP++]);
        destroy_tuple(hv_Font_COPY_INP_TMP);
        hv_Font_COPY_INP_TMP=TTemp[--SP];

        /*break*/
        destroy_tuple(TTemp[--SP]);
        destroy_tuple(TTemp[--SP]);
        create_tuple(&TTemp[SP],0);
        break;
      }
      destroy_tuple(TTemp[--SP]);
      /*========== end if ==========*/
    }
    destroy_tuple(TTemp[--SP]);
    /*========== end if ==========*/
   }
   destroy_tuple(TTemp[SP--]);
   destroy_tuple(TTemp[SP--]);
   destroy_tuple(TTemp[SP]);
  }
  else
  {
   destroy_tuple(TTemp[SP--]);
   destroy_tuple(TTemp[SP--]);
   destroy_tuple(TTemp[SP--]);
   destroy_tuple(TTemp[SP--]);
   destroy_tuple(TTemp[SP]);
  }/*========== end for ========*/

  /*========== if (Font == '') ==========*/
  create_tuple_s(&TTemp[SP++],"");
  T_tuple_equal(hv_Font_COPY_INP_TMP,TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-1]=TTemp[SP];
  if(get_i(TTemp[SP-1],0))
  {
    /* throw(...); only in hdevelop*/
  }
  destroy_tuple(TTemp[--SP]);
  /*========== end if ==========*/
  /*Font := Font + '-' + Style + '-' + Size*/
  copy_tuple(hv_Font_COPY_INP_TMP,&TTemp[SP++]);
  create_tuple_s(&TTemp[SP++],"-");
  T_tuple_add(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-2]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-2]=TTemp[SP];
  SP--;
  T_tuple_add(TTemp[SP-1],hv_Style,&TTemp[SP]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-1]=TTemp[SP];
  create_tuple_s(&TTemp[SP++],"-");
  T_tuple_add(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-2]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-2]=TTemp[SP];
  SP--;
  T_tuple_add(TTemp[SP-1],hv_Size_COPY_INP_TMP,&TTemp[SP]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-1]=TTemp[SP];
  destroy_tuple(hv_Font_COPY_INP_TMP);
  hv_Font_COPY_INP_TMP=TTemp[--SP];

  /*set_font (WindowHandle, Font)*/
  /***/T_set_font(hv_WindowHandle, hv_Font_COPY_INP_TMP);

  /*========== return ==========*/

  /* Clear temporary tuple stack */
  while (SP > 0)
    destroy_tuple(TTemp[--SP]);
  /* Clear temporary tuple vectors stack*/
  while (SPTV > 0)
    V_destroy_vector(TVTemp[--SPTV]);
  /* Clear local control variables */
  destroy_tuple(hv_OS);
  destroy_tuple(hv_Fonts);
  destroy_tuple(hv_Style);
  destroy_tuple(hv_Exception);
  destroy_tuple(hv_AvailableFonts);
  destroy_tuple(hv_Fdx);
  destroy_tuple(hv_Indices);
  destroy_tuple(hv_Font_COPY_INP_TMP);
  destroy_tuple(hv_Size_COPY_INP_TMP);

  return;

  /****************************************************/
  /******************     End procedure   *************/
  /****************************************************/

}

/* Chapter: OCR / Deep OCR*/
/* Short Description: Split rectangle2 into a number of rectangles. */
void split_rectangle2 (Htuple hv_Row, Htuple hv_Column, Htuple hv_Phi, Htuple hv_Length1, 
    Htuple hv_Length2, Htuple hv_NumSplits, Htuple *hv_SplitRow, Htuple *hv_SplitColumn, 
    Htuple *hv_SplitPhi, Htuple *hv_SplitLength1Out, Htuple *hv_SplitLength2Out)
{

  /* Stack for temporary tuples */
  Htuple   TTemp[100];
  int      SP=0;
  /* Stack for temporary tuple vectors */
  Hvector  TVTemp[100] = {0};
  int      SPTV=0;

  /* Local iconic variables */

  /* Local control variables */
  Htuple  hv_SplitLength, hv_TRow, hv_TCol, hv_HomMat2D;

  /* Initialize control variables */
  create_tuple(&hv_SplitLength,0);
  create_tuple(&hv_TRow,0);
  create_tuple(&hv_TCol,0);
  create_tuple(&hv_HomMat2D,0);
  create_tuple(&(*hv_SplitRow),0);
  create_tuple(&(*hv_SplitColumn),0);
  create_tuple(&(*hv_SplitPhi),0);
  create_tuple(&(*hv_SplitLength1Out),0);
  create_tuple(&(*hv_SplitLength2Out),0);

  /****************************************************/
  /******************   Begin procedure   *************/
  /****************************************************/

  /*========== if (NumSplits > 0) ==========*/
  create_tuple_i(&TTemp[SP++],0);
  T_tuple_greater(hv_NumSplits,TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-1]=TTemp[SP];
  if(get_i(TTemp[SP-1],0))
  {
    /*SplitLength := Length1 / real(NumSplits)*/
    T_tuple_real(hv_NumSplits,&TTemp[SP++]);
    T_tuple_div(hv_Length1,TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    destroy_tuple(hv_SplitLength);
    hv_SplitLength=TTemp[--SP];

    /*Assume center (0,0), transform afterwards.*/
    /*TRow := gen_tuple_const(NumSplits,0.0)*/
    create_tuple_d(&TTemp[SP++],0.0);
    T_tuple_gen_const(hv_NumSplits,TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    destroy_tuple(hv_TRow);
    hv_TRow=TTemp[--SP];

    /*TCol := -Length1 + SplitLength + [0:NumSplits - 1] * 2 * SplitLength*/
    T_tuple_neg(hv_Length1,&TTemp[SP++]);
    T_tuple_add(TTemp[SP-1],hv_SplitLength,&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    create_tuple_i(&TTemp[SP++],0);
    create_tuple_i(&TTemp[SP++],1);
    T_tuple_sub(hv_NumSplits,TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    create_tuple_i(&TTemp[SP++],1);
    T_tuple_gen_sequence(TTemp[SP-3],TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    destroy_tuple(TTemp[SP-2]);
    destroy_tuple(TTemp[SP-3]);
    TTemp[SP-3]=TTemp[SP];
    SP=SP-2;
    create_tuple_i(&TTemp[SP++],2);
    T_tuple_mult(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-2]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-2]=TTemp[SP];
    SP--;
    T_tuple_mult(TTemp[SP-1],hv_SplitLength,&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    T_tuple_add(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-2]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-2]=TTemp[SP];
    SP--;
    destroy_tuple(hv_TCol);
    hv_TCol=TTemp[--SP];

    /*hom_mat2d_identity (HomMat2D)*/
    destroy_tuple(hv_HomMat2D);
    /***/T_hom_mat2d_identity(&hv_HomMat2D);

    /*hom_mat2d_rotate (HomMat2D, Phi, 0, 0, HomMat2D)*/
    copy_tuple(hv_HomMat2D,&TTemp[SP++]);
    create_tuple_i(&TTemp[SP++],0);
    create_tuple_i(&TTemp[SP++],0);
    destroy_tuple(hv_HomMat2D);
    /***/T_hom_mat2d_rotate(TTemp[SP-3], hv_Phi, TTemp[SP-2], TTemp[SP-1], &hv_HomMat2D);
    destroy_tuple(TTemp[--SP]);
    destroy_tuple(TTemp[--SP]);
    destroy_tuple(TTemp[--SP]);

    /*hom_mat2d_translate (HomMat2D, Row, Column, HomMat2D)*/
    copy_tuple(hv_HomMat2D,&TTemp[SP++]);
    destroy_tuple(hv_HomMat2D);
    /***/T_hom_mat2d_translate(TTemp[SP-1], hv_Row, hv_Column, &hv_HomMat2D);
    destroy_tuple(TTemp[--SP]);

    /*SplitLength1Out := gen_tuple_const(NumSplits,SplitLength)*/
    T_tuple_gen_const(hv_NumSplits,hv_SplitLength,&TTemp[SP++]);
    destroy_tuple((*hv_SplitLength1Out));
    (*hv_SplitLength1Out)=TTemp[--SP];

    /*SplitLength2Out := gen_tuple_const(NumSplits,Length2)*/
    T_tuple_gen_const(hv_NumSplits,hv_Length2,&TTemp[SP++]);
    destroy_tuple((*hv_SplitLength2Out));
    (*hv_SplitLength2Out)=TTemp[--SP];

    /*SplitPhi := gen_tuple_const(NumSplits,Phi)*/
    T_tuple_gen_const(hv_NumSplits,hv_Phi,&TTemp[SP++]);
    destroy_tuple((*hv_SplitPhi));
    (*hv_SplitPhi)=TTemp[--SP];

    /*affine_trans_point_2d (HomMat2D, TRow, TCol, SplitRow, SplitColumn)*/
    destroy_tuple((*hv_SplitRow));
    destroy_tuple((*hv_SplitColumn));
    /***/T_affine_trans_point_2d(hv_HomMat2D, hv_TRow, hv_TCol, &(*hv_SplitRow), 
        &(*hv_SplitColumn));

  }
  else
  {
    /* throw(...); only in hdevelop*/
  }
  destroy_tuple(TTemp[--SP]);
  /*========== end if ==========*/
  /*========== return ==========*/

  /* Clear temporary tuple stack */
  while (SP > 0)
    destroy_tuple(TTemp[--SP]);
  /* Clear temporary tuple vectors stack*/
  while (SPTV > 0)
    V_destroy_vector(TVTemp[--SPTV]);
  /* Clear local control variables */
  destroy_tuple(hv_SplitLength);
  destroy_tuple(hv_TRow);
  destroy_tuple(hv_TCol);
  destroy_tuple(hv_HomMat2D);

  return;

  /****************************************************/
  /******************     End procedure   *************/
  /****************************************************/

}

/* Chapter: Graphics / Window*/
/* Short Description: Set and return meta information to display images correctly. */
void update_window_meta_information (Htuple hv_WindowHandle, Htuple hv_WidthImage, 
    Htuple hv_HeightImage, Htuple hv_WindowRow1, Htuple hv_WindowColumn1, Htuple hv_MapColorBarWidth, 
    Htuple hv_MarginBottom, Htuple *hv_WindowImageRatioHeight, Htuple *hv_WindowImageRatioWidth, 
    Htuple *hv_SetPartRow2, Htuple *hv_SetPartColumn2, Htuple *hv_PrevWindowCoordinatesOut)
{

  /* Stack for temporary tuples */
  Htuple   TTemp[100];
  int      SP=0;
  /* Stack for temporary tuple vectors */
  Hvector  TVTemp[100] = {0};
  int      SPTV=0;

  /* Local iconic variables */

  /* Local control variables */
  Htuple  hv__, hv_WindowWidth, hv_WindowHeight;
  Htuple  hv_WindowRow2, hv_WindowColumn2, hv_WindowRatio;
  Htuple  hv_ImageRow2, hv_ImageColumn2, hv_ImageRatio, hv_ImageWindowRatioHeight;
  Htuple  hv_ImageRow2InWindow, hv_ImageCol2InWindow;

  /* Array for temporary output ctrl variables */
  Htuple  CExpDummyOCvar[3];

  /* Initialize control variables */
  create_tuple(&hv__,0);
  create_tuple(&hv_WindowWidth,0);
  create_tuple(&hv_WindowHeight,0);
  create_tuple(&hv_WindowRow2,0);
  create_tuple(&hv_WindowColumn2,0);
  create_tuple(&hv_WindowRatio,0);
  create_tuple(&hv_ImageRow2,0);
  create_tuple(&hv_ImageColumn2,0);
  create_tuple(&hv_ImageRatio,0);
  create_tuple(&hv_ImageWindowRatioHeight,0);
  create_tuple(&hv_ImageRow2InWindow,0);
  create_tuple(&hv_ImageCol2InWindow,0);
  create_tuple(&(*hv_WindowImageRatioHeight),0);
  create_tuple(&(*hv_WindowImageRatioWidth),0);
  create_tuple(&(*hv_SetPartRow2),0);
  create_tuple(&(*hv_SetPartColumn2),0);
  create_tuple(&(*hv_PrevWindowCoordinatesOut),0);

  /****************************************************/
  /******************   Begin procedure   *************/
  /****************************************************/

  /**/
  /*This procedure sets and returns meta information to display images correctly.*/
  /**/
  /*Set part for the image to be displayed later and adapt window size (+ MarginBottom + MapColorBarWidth).*/
  /*get_window_extents (WindowHandle, _, _, WindowWidth, WindowHeight)*/
  destroy_tuple(hv__);
  destroy_tuple(hv_WindowWidth);
  destroy_tuple(hv_WindowHeight);
  /***/T_get_window_extents(hv_WindowHandle, &hv__, &(CExpDummyOCvar[0]), &hv_WindowWidth, 
      &hv_WindowHeight);
  destroy_tuple(CExpDummyOCvar[0]);

  /*WindowImageRatioHeight := WindowHeight / (HeightImage * 1.0)*/
  create_tuple_d(&TTemp[SP++],1.0);
  T_tuple_mult(hv_HeightImage,TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-1]=TTemp[SP];
  T_tuple_div(hv_WindowHeight,TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-1]=TTemp[SP];
  destroy_tuple((*hv_WindowImageRatioHeight));
  (*hv_WindowImageRatioHeight)=TTemp[--SP];

  /*WindowImageRatioWidth := WindowWidth / (WidthImage * 1.0)*/
  create_tuple_d(&TTemp[SP++],1.0);
  T_tuple_mult(hv_WidthImage,TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-1]=TTemp[SP];
  T_tuple_div(hv_WindowWidth,TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-1]=TTemp[SP];
  destroy_tuple((*hv_WindowImageRatioWidth));
  (*hv_WindowImageRatioWidth)=TTemp[--SP];

  /**/
  /*Set window part such that image is displayed undistorted.*/
  /*WindowRow2 := WindowHeight*/
  destroy_tuple(hv_WindowRow2);
  copy_tuple(hv_WindowHeight,&hv_WindowRow2);

  /*WindowColumn2 := WindowWidth*/
  destroy_tuple(hv_WindowColumn2);
  copy_tuple(hv_WindowWidth,&hv_WindowColumn2);

  /*WindowRatio := WindowColumn2 / (WindowRow2 * 1.0)*/
  create_tuple_d(&TTemp[SP++],1.0);
  T_tuple_mult(hv_WindowRow2,TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-1]=TTemp[SP];
  T_tuple_div(hv_WindowColumn2,TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-1]=TTemp[SP];
  destroy_tuple(hv_WindowRatio);
  hv_WindowRatio=TTemp[--SP];

  /**/
  /*ImageRow2 := HeightImage + MarginBottom / WindowImageRatioHeight*/
  T_tuple_div(hv_MarginBottom,(*hv_WindowImageRatioHeight),&TTemp[SP++]);
  T_tuple_add(hv_HeightImage,TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-1]=TTemp[SP];
  destroy_tuple(hv_ImageRow2);
  hv_ImageRow2=TTemp[--SP];

  /*ImageColumn2 := WidthImage + MapColorBarWidth / WindowImageRatioWidth*/
  T_tuple_div(hv_MapColorBarWidth,(*hv_WindowImageRatioWidth),&TTemp[SP++]);
  T_tuple_add(hv_WidthImage,TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-1]=TTemp[SP];
  destroy_tuple(hv_ImageColumn2);
  hv_ImageColumn2=TTemp[--SP];

  /*ImageRatio := ImageColumn2 / (ImageRow2 * 1.0)*/
  create_tuple_d(&TTemp[SP++],1.0);
  T_tuple_mult(hv_ImageRow2,TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-1]=TTemp[SP];
  T_tuple_div(hv_ImageColumn2,TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-1]=TTemp[SP];
  destroy_tuple(hv_ImageRatio);
  hv_ImageRatio=TTemp[--SP];

  /*========== if (ImageRatio > WindowRatio) ==========*/
  T_tuple_greater(hv_ImageRatio,hv_WindowRatio,&TTemp[SP++]);
  if(get_i(TTemp[SP-1],0))
  {
    /**/
    /*Extend image until right window border.*/
    /*SetPartColumn2 := ImageColumn2*/
    destroy_tuple((*hv_SetPartColumn2));
    copy_tuple(hv_ImageColumn2,&(*hv_SetPartColumn2));

    /*ImageWindowRatioHeight := ImageColumn2 / (WindowColumn2 * 1.0)*/
    create_tuple_d(&TTemp[SP++],1.0);
    T_tuple_mult(hv_WindowColumn2,TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    T_tuple_div(hv_ImageColumn2,TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    destroy_tuple(hv_ImageWindowRatioHeight);
    hv_ImageWindowRatioHeight=TTemp[--SP];

    /*ImageRow2InWindow := ImageRow2 / ImageWindowRatioHeight*/
    T_tuple_div(hv_ImageRow2,hv_ImageWindowRatioHeight,&TTemp[SP++]);
    destroy_tuple(hv_ImageRow2InWindow);
    hv_ImageRow2InWindow=TTemp[--SP];

    /*SetPartRow2 := ImageRow2 + (WindowRow2 - ImageRow2InWindow) / WindowImageRatioWidth*/
    T_tuple_sub(hv_WindowRow2,hv_ImageRow2InWindow,&TTemp[SP++]);
    T_tuple_div(TTemp[SP-1],(*hv_WindowImageRatioWidth),&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    T_tuple_add(hv_ImageRow2,TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    destroy_tuple((*hv_SetPartRow2));
    (*hv_SetPartRow2)=TTemp[--SP];

  }
  else
  {
    /**/
    /*Extend image until bottom of window.*/
    /*SetPartRow2 := ImageRow2*/
    destroy_tuple((*hv_SetPartRow2));
    copy_tuple(hv_ImageRow2,&(*hv_SetPartRow2));

    /*ImageWindowRatioHeight := ImageRow2 / (WindowRow2 * 1.0)*/
    create_tuple_d(&TTemp[SP++],1.0);
    T_tuple_mult(hv_WindowRow2,TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    T_tuple_div(hv_ImageRow2,TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    destroy_tuple(hv_ImageWindowRatioHeight);
    hv_ImageWindowRatioHeight=TTemp[--SP];

    /*ImageCol2InWindow := ImageColumn2 / ImageWindowRatioHeight*/
    T_tuple_div(hv_ImageColumn2,hv_ImageWindowRatioHeight,&TTemp[SP++]);
    destroy_tuple(hv_ImageCol2InWindow);
    hv_ImageCol2InWindow=TTemp[--SP];

    /*SetPartColumn2 := ImageColumn2 + (WindowColumn2 - ImageCol2InWindow) / WindowImageRatioHeight*/
    T_tuple_sub(hv_WindowColumn2,hv_ImageCol2InWindow,&TTemp[SP++]);
    T_tuple_div(TTemp[SP-1],(*hv_WindowImageRatioHeight),&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    T_tuple_add(hv_ImageColumn2,TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    destroy_tuple((*hv_SetPartColumn2));
    (*hv_SetPartColumn2)=TTemp[--SP];

  }
  destroy_tuple(TTemp[--SP]);
  /*========== end if ==========*/
  if (hdev_window_stack_is_open())
  {
    Htuple active_win;
    create_tuple(&active_win,0);
    hdev_window_stack_get_active(&active_win);
    /*dev_set_part (0, 0, SetPartRow2 - 1, SetPartColumn2 - 1)*/
    create_tuple_i(&TTemp[SP++],0);
    create_tuple_i(&TTemp[SP++],0);
    create_tuple_i(&TTemp[SP++],1);
    T_tuple_sub((*hv_SetPartRow2),TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    create_tuple_i(&TTemp[SP++],1);
    T_tuple_sub((*hv_SetPartColumn2),TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    /***/T_set_part(active_win,TTemp[SP-4], TTemp[SP-3], TTemp[SP-2], TTemp[SP-1]);
    destroy_tuple(TTemp[--SP]);
    destroy_tuple(TTemp[--SP]);
    destroy_tuple(TTemp[--SP]);
    destroy_tuple(TTemp[--SP]);
    destroy_tuple(active_win);
  }
  /**/
  /*Return the coordinates of the new window.*/
  /*PrevWindowCoordinatesOut := [WindowRow1,WindowColumn1,WindowWidth,WindowHeight]*/
  T_tuple_concat(hv_WindowRow1,hv_WindowColumn1,&TTemp[SP++]);
  T_tuple_concat(TTemp[SP-1],hv_WindowWidth,&TTemp[SP]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-1]=TTemp[SP];
  T_tuple_concat(TTemp[SP-1],hv_WindowHeight,&TTemp[SP]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-1]=TTemp[SP];
  destroy_tuple((*hv_PrevWindowCoordinatesOut));
  (*hv_PrevWindowCoordinatesOut)=TTemp[--SP];

  /**/
  /*========== return ==========*/

  /* Clear temporary tuple stack */
  while (SP > 0)
    destroy_tuple(TTemp[--SP]);
  /* Clear temporary tuple vectors stack*/
  while (SPTV > 0)
    V_destroy_vector(TVTemp[--SPTV]);
  /* Clear local control variables */
  destroy_tuple(hv__);
  destroy_tuple(hv_WindowWidth);
  destroy_tuple(hv_WindowHeight);
  destroy_tuple(hv_WindowRow2);
  destroy_tuple(hv_WindowColumn2);
  destroy_tuple(hv_WindowRatio);
  destroy_tuple(hv_ImageRow2);
  destroy_tuple(hv_ImageColumn2);
  destroy_tuple(hv_ImageRatio);
  destroy_tuple(hv_ImageWindowRatioHeight);
  destroy_tuple(hv_ImageRow2InWindow);
  destroy_tuple(hv_ImageCol2InWindow);

  return;

  /****************************************************/
  /******************     End procedure   *************/
  /****************************************************/

}

#ifndef NO_EXPORT_MAIN
/* Main procedure */
void action()
{
  /* Stack for temporary tuples */
  Htuple   TTemp[100];
  int      SP=0;
  /* Stack for temporary tuple vectors */
  Hvector  TVTemp[100] = {0};
  int      SPTV=0;

  /* Local iconic variables */
  Hobject  ho_Image, ho_ResizedImage, ho_Rectangle;
  Hobject  ho_ImagePart;

  /* Local control variables */
  Htuple  hv_ModelPath, hv_PreprocessParamFileName;
  Htuple  hv_TrainedModelFileName, hv_BatchSizeInference;
  Htuple  hv_MinConfidence, hv_MaxOverlap, hv_MaxOverlapClassAgnostic;
  Htuple  hv_DLDeviceHandles, hv_DLDevice, hv_DLModelHandle;
  Htuple  hv_DLPreprocessParam, hv_DLDataInfo, hv_ClassNames;
  Htuple  hv_ClassIDs, hv_WindowHandleDict, hv_TextYPos, hv_TextYPositions;
  Htuple  hv_AcqHandle, hv_DLSampleInference, hv_DLResult;
  Htuple  hv_bboxcol, hv_bboxrow, hv_bboxcol2, hv_bboxrow2;
  Htuple  hv_checkid, hv_num_boxes, hv_i;

  /* Initialize iconic variables */
  gen_empty_obj(&ho_Image);
  gen_empty_obj(&ho_ResizedImage);
  gen_empty_obj(&ho_Rectangle);
  gen_empty_obj(&ho_ImagePart);

  /* Initialize control variables */
  create_tuple(&hv_ModelPath,0);
  create_tuple(&hv_PreprocessParamFileName,0);
  create_tuple(&hv_TrainedModelFileName,0);
  create_tuple(&hv_BatchSizeInference,0);
  create_tuple(&hv_MinConfidence,0);
  create_tuple(&hv_MaxOverlap,0);
  create_tuple(&hv_MaxOverlapClassAgnostic,0);
  create_tuple(&hv_DLDeviceHandles,0);
  create_tuple(&hv_DLDevice,0);
  create_tuple(&hv_DLModelHandle,0);
  create_tuple(&hv_DLPreprocessParam,0);
  create_tuple(&hv_DLDataInfo,0);
  create_tuple(&hv_ClassNames,0);
  create_tuple(&hv_ClassIDs,0);
  create_tuple(&hv_WindowHandleDict,0);
  create_tuple(&hv_TextYPos,0);
  create_tuple(&hv_TextYPositions,0);
  create_tuple(&hv_AcqHandle,0);
  create_tuple(&hv_DLSampleInference,0);
  create_tuple(&hv_DLResult,0);
  create_tuple(&hv_bboxcol,0);
  create_tuple(&hv_bboxrow,0);
  create_tuple(&hv_bboxcol2,0);
  create_tuple(&hv_bboxrow2,0);
  create_tuple(&hv_checkid,0);
  create_tuple(&hv_num_boxes,0);
  create_tuple(&hv_i,0);

  /****************************************************/
  /******************   Begin procedure   *************/
  /****************************************************/

  if (hdev_window_stack_is_open())
  {
    Htuple active_win;
    create_tuple(&active_win,0);
    hdev_window_stack_pop(&active_win);
    T_close_window(active_win);
    destroy_tuple(active_win);
  }

  /*ModelPath := '/home/dika/Pictures/model_baru_pkm'*/
  reuse_tuple_s(&hv_ModelPath,"/home/dika/Pictures/model_baru_pkm");

  /*Model Path*/
  /*PreprocessParamFileName := ModelPath  + '/dl_preprocess_param.hdict'*/
  create_tuple_s(&TTemp[SP++],"/dl_preprocess_param.hdict");
  T_tuple_add(hv_ModelPath,TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-1]=TTemp[SP];
  destroy_tuple(hv_PreprocessParamFileName);
  hv_PreprocessParamFileName=TTemp[--SP];

  /*TrainedModelFileName := ModelPath + '/best_dl_model_detection.hdl'*/
  create_tuple_s(&TTemp[SP++],"/best_dl_model_detection.hdl");
  T_tuple_add(hv_ModelPath,TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-1]=TTemp[SP];
  destroy_tuple(hv_TrainedModelFileName);
  hv_TrainedModelFileName=TTemp[--SP];


  /*Batch size used during inference.*/
  /*BatchSizeInference := 1*/
  reuse_tuple_i(&hv_BatchSizeInference,1);


  /*Postprocessing parameters for the detection model.*/
  /*MinConfidence := 0.7*/
  reuse_tuple_d(&hv_MinConfidence,0.7);

  /*MaxOverlap := 0.2*/
  reuse_tuple_d(&hv_MaxOverlap,0.2);

  /*MaxOverlapClassAgnostic := 0.7*/
  reuse_tuple_d(&hv_MaxOverlapClassAgnostic,0.7);


  /*Inference can be done on a GPU or CPU/*/
  /*If possible a GPU will be used in this program.*/
  /*query_available_dl_devices (['runtime', 'runtime'], ['gpu', 'cpu'], DLDeviceHandles)*/
  create_tuple(&TTemp[SP++],2);
  set_s(TTemp[SP-1],"runtime",0);
  set_s(TTemp[SP-1],"runtime",1);
  create_tuple(&TTemp[SP++],2);
  set_s(TTemp[SP-1],"gpu",0);
  set_s(TTemp[SP-1],"cpu",1);
  destroy_tuple(hv_DLDeviceHandles);
  /***/T_query_available_dl_devices(TTemp[SP-2], TTemp[SP-1], &hv_DLDeviceHandles);
  destroy_tuple(TTemp[--SP]);
  destroy_tuple(TTemp[--SP]);

  /*========== if (|DLDeviceHandles| == 0) ==========*/
  T_tuple_length(hv_DLDeviceHandles,&TTemp[SP++]);
  create_tuple_i(&TTemp[SP++],0);
  T_tuple_equal(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-2]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-2]=TTemp[SP];
  SP--;
  if(get_i(TTemp[SP-1],0))
  {
    /* throw(...); only in hdevelop*/
  }
  destroy_tuple(TTemp[--SP]);
  /*========== end if ==========*/
  /*DLDevice := DLDeviceHandles[0]*/
  create_tuple_i(&TTemp[SP++],0);
  T_tuple_select(hv_DLDeviceHandles,TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-1]=TTemp[SP];
  destroy_tuple(hv_DLDevice);
  hv_DLDevice=TTemp[--SP];


  /*Create Model OCR*/
  /*create_deep_ocr ([], [], DeepOcrHandle)*/
  /*get_deep_ocr_param (DeepOcrHandle, 'recognition_alphabet', RecognitionAlphabet)*/
  /*Wset_deep_ocr_param (DeepOcrHandle, 'device', DLDevice)*/

  /*Read in the trained model.*/
  /*read_dl_model (TrainedModelFileName, DLModelHandle)*/
  destroy_tuple(hv_DLModelHandle);
  /***/T_read_dl_model(hv_TrainedModelFileName, &hv_DLModelHandle);


  /*Set batch size.*/
  /*set_dl_model_param (DLModelHandle, 'batch_size', BatchSizeInference)*/
  create_tuple_s(&TTemp[SP++],"batch_size");
  /***/T_set_dl_model_param(hv_DLModelHandle, TTemp[SP-1], hv_BatchSizeInference);
  destroy_tuple(TTemp[--SP]);


  /*Initialize the model for inference.*/
  /*set_dl_model_param (DLModelHandle, 'device', DLDevice)*/
  create_tuple_s(&TTemp[SP++],"device");
  /***/T_set_dl_model_param(hv_DLModelHandle, TTemp[SP-1], hv_DLDevice);
  destroy_tuple(TTemp[--SP]);


  /*Set postprocessing parameters for model.*/
  /*set_dl_model_param (DLModelHandle, 'min_confidence', MinConfidence)*/
  create_tuple_s(&TTemp[SP++],"min_confidence");
  /***/T_set_dl_model_param(hv_DLModelHandle, TTemp[SP-1], hv_MinConfidence);
  destroy_tuple(TTemp[--SP]);

  /*set_dl_model_param (DLModelHandle, 'max_overlap', MaxOverlap)*/
  create_tuple_s(&TTemp[SP++],"max_overlap");
  /***/T_set_dl_model_param(hv_DLModelHandle, TTemp[SP-1], hv_MaxOverlap);
  destroy_tuple(TTemp[--SP]);

  /*set_dl_model_param (DLModelHandle, 'max_overlap_class_agnostic', MaxOverlapClassAgnostic)*/
  create_tuple_s(&TTemp[SP++],"max_overlap_class_agnostic");
  /***/T_set_dl_model_param(hv_DLModelHandle, TTemp[SP-1], hv_MaxOverlapClassAgnostic);
  destroy_tuple(TTemp[--SP]);


  /*Get the parameters used for preprocessing.*/
  /*read_dict (PreprocessParamFileName, [], [], DLPreprocessParam)*/
  create_tuple(&TTemp[SP++],0);
  create_tuple(&TTemp[SP++],0);
  destroy_tuple(hv_DLPreprocessParam);
  /***/T_read_dict(hv_PreprocessParamFileName, TTemp[SP-2], TTemp[SP-1], &hv_DLPreprocessParam);
  destroy_tuple(TTemp[--SP]);
  destroy_tuple(TTemp[--SP]);



  /*Create dictionary with dataset parameters necessary for displaying.*/
  /*create_dict (DLDataInfo)*/
  destroy_tuple(hv_DLDataInfo);
  /***/T_create_dict(&hv_DLDataInfo);

  /*get_dl_model_param (DLModelHandle, 'class_names', ClassNames)*/
  create_tuple_s(&TTemp[SP++],"class_names");
  destroy_tuple(hv_ClassNames);
  /***/T_get_dl_model_param(hv_DLModelHandle, TTemp[SP-1], &hv_ClassNames);
  destroy_tuple(TTemp[--SP]);

  /*set_dict_tuple (DLDataInfo, ['class_names'], ClassNames)*/
  create_tuple_s(&TTemp[SP++],"class_names");
  /***/T_set_dict_tuple(hv_DLDataInfo, TTemp[SP-1], hv_ClassNames);
  destroy_tuple(TTemp[--SP]);

  /*get_dl_model_param (DLModelHandle, 'class_ids', ClassIDs)*/
  create_tuple_s(&TTemp[SP++],"class_ids");
  destroy_tuple(hv_ClassIDs);
  /***/T_get_dl_model_param(hv_DLModelHandle, TTemp[SP-1], &hv_ClassIDs);
  destroy_tuple(TTemp[--SP]);

  /*set_dict_tuple (DLDataInfo, ['class_ids'], ClassIDs)*/
  create_tuple_s(&TTemp[SP++],"class_ids");
  /***/T_set_dict_tuple(hv_DLDataInfo, TTemp[SP-1], hv_ClassIDs);
  destroy_tuple(TTemp[--SP]);


  /*create_dict (WindowHandleDict)*/
  destroy_tuple(hv_WindowHandleDict);
  /***/T_create_dict(&hv_WindowHandleDict);

  /*TextYPos := 12*/
  reuse_tuple_i(&hv_TextYPos,12);

  /*TextYPositions := []*/
  create_tuple(&TTemp[SP++],0);
  destroy_tuple(hv_TextYPositions);
  hv_TextYPositions=TTemp[--SP];



  /*open_framegrabber ('Video4Linux2', 1, 1, 0, 0, 0, 0, 'progressive', 8, 'default', -1, 'false', 'auto', 'video0', 0, -1, AcqHandle)*/
  create_tuple_s(&TTemp[SP++],"Video4Linux2");
  create_tuple_i(&TTemp[SP++],1);
  create_tuple_i(&TTemp[SP++],1);
  create_tuple_i(&TTemp[SP++],0);
  create_tuple_i(&TTemp[SP++],0);
  create_tuple_i(&TTemp[SP++],0);
  create_tuple_i(&TTemp[SP++],0);
  create_tuple_s(&TTemp[SP++],"progressive");
  create_tuple_i(&TTemp[SP++],8);
  create_tuple_s(&TTemp[SP++],"default");
  create_tuple_i(&TTemp[SP++],-1);
  create_tuple_s(&TTemp[SP++],"false");
  create_tuple_s(&TTemp[SP++],"auto");
  create_tuple_s(&TTemp[SP++],"video0");
  create_tuple_i(&TTemp[SP++],0);
  create_tuple_i(&TTemp[SP++],-1);
  destroy_tuple(hv_AcqHandle);
  /***/T_open_framegrabber(TTemp[SP-16], TTemp[SP-15], TTemp[SP-14], TTemp[SP-13], 
      TTemp[SP-12], TTemp[SP-11], TTemp[SP-10], TTemp[SP-9], TTemp[SP-8], TTemp[SP-7], 
      TTemp[SP-6], TTemp[SP-5], TTemp[SP-4], TTemp[SP-3], TTemp[SP-2], TTemp[SP-1], 
      &hv_AcqHandle);
  destroy_tuple(TTemp[--SP]);
  destroy_tuple(TTemp[--SP]);
  destroy_tuple(TTemp[--SP]);
  destroy_tuple(TTemp[--SP]);
  destroy_tuple(TTemp[--SP]);
  destroy_tuple(TTemp[--SP]);
  destroy_tuple(TTemp[--SP]);
  destroy_tuple(TTemp[--SP]);
  destroy_tuple(TTemp[--SP]);
  destroy_tuple(TTemp[--SP]);
  destroy_tuple(TTemp[--SP]);
  destroy_tuple(TTemp[--SP]);
  destroy_tuple(TTemp[--SP]);
  destroy_tuple(TTemp[--SP]);
  destroy_tuple(TTemp[--SP]);
  destroy_tuple(TTemp[--SP]);

  /*grab_image_start (AcqHandle, -1)*/
  create_tuple_i(&TTemp[SP++],-1);
  /***/T_grab_image_start(hv_AcqHandle, TTemp[SP-1]);
  destroy_tuple(TTemp[--SP]);


  /*========== while (true) ==========*/
  for(;;)
  {
  create_tuple_i(&TTemp[SP++],1);
  if(!get_i(TTemp[SP-1],0)) break;
  destroy_tuple(TTemp[--SP]);
    /*Grab Image*/
    /*grab_image_async (Image, AcqHandle, -1)*/
    create_tuple_i(&TTemp[SP++],-1);
    clear_obj(ho_Image);
    /***/T_grab_image_async(&ho_Image, hv_AcqHandle, TTemp[SP-1]);
    destroy_tuple(TTemp[--SP]);

    /*Resize image*/
    /*zoom_image_size (Image, ResizedImage, 512, 320, 'constant')*/
    clear_obj(ho_ResizedImage);
    /***/zoom_image_size(ho_Image, &ho_ResizedImage, 512, 320, "constant");


    /*detect plate*/
    /*gen_dl_samples_from_images (ResizedImage, DLSampleInference)*/
    destroy_tuple(hv_DLSampleInference);
    /***/gen_dl_samples_from_images(ho_ResizedImage, &hv_DLSampleInference);

    /*preprocess_dl_samples (DLSampleInference, DLPreprocessParam)*/
    /***/preprocess_dl_samples(hv_DLSampleInference, hv_DLPreprocessParam);

    /*apply_dl_model (DLModelHandle, DLSampleInference, [], DLResult)*/
    create_tuple(&TTemp[SP++],0);
    destroy_tuple(hv_DLResult);
    /***/T_apply_dl_model(hv_DLModelHandle, hv_DLSampleInference, TTemp[SP-1], &hv_DLResult);
    destroy_tuple(TTemp[--SP]);

    /*dev_display_dl_data (DLSampleInference, DLResult, DLDataInfo, 'bbox_result', [], WindowHandleDict)*/
    create_tuple_s(&TTemp[SP++],"bbox_result");
    create_tuple(&TTemp[SP++],0);
    /***/dev_display_dl_data(hv_DLSampleInference, hv_DLResult, hv_DLDataInfo, TTemp[SP-2], 
        TTemp[SP-1], hv_WindowHandleDict);
    destroy_tuple(TTemp[--SP]);
    destroy_tuple(TTemp[--SP]);


    /*get bbox of object*/
    /*get_dict_tuple (DLResult, 'bbox_col1', bboxcol)*/
    create_tuple_s(&TTemp[SP++],"bbox_col1");
    destroy_tuple(hv_bboxcol);
    /***/T_get_dict_tuple(hv_DLResult, TTemp[SP-1], &hv_bboxcol);
    destroy_tuple(TTemp[--SP]);

    /*get_dict_tuple (DLResult, 'bbox_row1', bboxrow)*/
    create_tuple_s(&TTemp[SP++],"bbox_row1");
    destroy_tuple(hv_bboxrow);
    /***/T_get_dict_tuple(hv_DLResult, TTemp[SP-1], &hv_bboxrow);
    destroy_tuple(TTemp[--SP]);

    /*get_dict_tuple (DLResult, 'bbox_col2', bboxcol2)*/
    create_tuple_s(&TTemp[SP++],"bbox_col2");
    destroy_tuple(hv_bboxcol2);
    /***/T_get_dict_tuple(hv_DLResult, TTemp[SP-1], &hv_bboxcol2);
    destroy_tuple(TTemp[--SP]);

    /*get_dict_tuple (DLResult, 'bbox_row2', bboxrow2)*/
    create_tuple_s(&TTemp[SP++],"bbox_row2");
    destroy_tuple(hv_bboxrow2);
    /***/T_get_dict_tuple(hv_DLResult, TTemp[SP-1], &hv_bboxrow2);
    destroy_tuple(TTemp[--SP]);

    /*get_dict_tuple (DLResult, 'bbox_class_id', checkid)*/
    create_tuple_s(&TTemp[SP++],"bbox_class_id");
    destroy_tuple(hv_checkid);
    /***/T_get_dict_tuple(hv_DLResult, TTemp[SP-1], &hv_checkid);
    destroy_tuple(TTemp[--SP]);


    /*check class*/
    /*========== if (checkid == 2) ==========*/
    create_tuple_i(&TTemp[SP++],2);
    T_tuple_equal(hv_checkid,TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    if(get_i(TTemp[SP-1],0))
    {
      /*num_boxes := |bboxcol|*/
      T_tuple_length(hv_bboxcol,&TTemp[SP++]);
      destroy_tuple(hv_num_boxes);
      hv_num_boxes=TTemp[--SP];

      /*========== for i := 0 to num_boxes - 1 by 1 ==========*/
      create_tuple_i(&TTemp[SP++],1);
      T_tuple_sub(hv_num_boxes,TTemp[SP-1],&TTemp[SP]);
      destroy_tuple(TTemp[SP-1]);
      TTemp[SP-1]=TTemp[SP];
      create_tuple_i(&TTemp[SP++],1);
      create_tuple_i(&TTemp[SP++],0);
      T_tuple_greater(TTemp[SP-1],TTemp[SP-3],&TTemp[SP]);
      SP++;
      T_tuple_equal(TTemp[SP-2],TTemp[SP-4],&TTemp[SP]);
      if(get_i(TTemp[SP],0) ||
         (!((( get_i(TTemp[SP-1],0)) && (get_d(TTemp[SP-3],0)>0)) ||
            ((!get_i(TTemp[SP-1],0)) && (get_d(TTemp[SP-3],0)<0)))))
      {
       destroy_tuple(TTemp[SP--]);
       destroy_tuple(TTemp[SP]);
       T_tuple_sub(TTemp[SP-1],TTemp[SP-2],&TTemp[SP]);
       destroy_tuple(hv_i);
       copy_tuple(TTemp[SP],&hv_i);
       destroy_tuple(TTemp[SP--]);
       destroy_tuple(TTemp[SP]);
       for(;;)
       {
       T_tuple_add(hv_i,TTemp[SP-1],&TTemp[SP]);
       destroy_tuple(hv_i);
       copy_tuple(TTemp[SP],&hv_i);
       destroy_tuple(TTemp[SP]);
       if(get_d(TTemp[SP-1],0)<0)
        T_tuple_less(hv_i,TTemp[SP-2],&TTemp[SP]);
       else
        T_tuple_greater(hv_i,TTemp[SP-2],&TTemp[SP]);
       if(get_i(TTemp[SP],0)) break;
       destroy_tuple(TTemp[SP]);
       /*========== for ==========*/

        /*Crop plate detection*/
        /*gen_rectangle1 (Rectangle, abs(bboxrow), abs(bboxcol), abs(bboxrow2), abs(bboxcol2))*/
        T_tuple_abs(hv_bboxrow,&TTemp[SP++]);
        T_tuple_abs(hv_bboxcol,&TTemp[SP++]);
        T_tuple_abs(hv_bboxrow2,&TTemp[SP++]);
        T_tuple_abs(hv_bboxcol2,&TTemp[SP++]);
        clear_obj(ho_Rectangle);
        /***/T_gen_rectangle1(&ho_Rectangle, TTemp[SP-4], TTemp[SP-3], TTemp[SP-2], 
            TTemp[SP-1]);
        destroy_tuple(TTemp[--SP]);
        destroy_tuple(TTemp[--SP]);
        destroy_tuple(TTemp[--SP]);
        destroy_tuple(TTemp[--SP]);

        /*reduce_domain (ResizedImage, Rectangle, ImagePart)*/
        clear_obj(ho_ImagePart);
        /***/reduce_domain(ho_ResizedImage, ho_Rectangle, &ho_ImagePart);


        /*Apply deepOCR*/
        /*apply_deep_ocr (ImagePart, DeepOcrHandle, 'auto', DeepOcrResult)*/
        /*dev_display_deep_ocr_results (Image, WindowHandleDict, DeepOcrResult, [], [])*/
        /*wordsOCR := DeepOcrResult.words.word*/
        /*if (i < |TextYPositions|)*/
          /*TextYPos := TextYPositions[i]*/
        /*endif*/
        /*TextYPos := i * 100*/
        /*dev_disp_text (wordsOCR, 'window', 'center', TextYPos, 'red', [], [])*/
        /*dev_display (ImagePart)*/
       }
       destroy_tuple(TTemp[SP--]);
       destroy_tuple(TTemp[SP--]);
       destroy_tuple(TTemp[SP]);
      }
      else
      {
       destroy_tuple(TTemp[SP--]);
       destroy_tuple(TTemp[SP--]);
       destroy_tuple(TTemp[SP--]);
       destroy_tuple(TTemp[SP--]);
       destroy_tuple(TTemp[SP]);
      }/*========== end for ========*/

    }
    destroy_tuple(TTemp[--SP]);
    /*========== end if ==========*/
  }
  destroy_tuple(TTemp[--SP]);
  /*========== end while =====*/

  /****************************************************/
  /******************     End procedure   *************/
  /****************************************************/

  /* Clear temporary tuple stack */
  while (SP > 0)
    destroy_tuple(TTemp[--SP]);
  /* Clear temporary tuple vectors stack*/
  while (SPTV > 0)
    V_destroy_vector(TVTemp[--SPTV]);
  /* Clear local iconic variables */
  clear_obj(ho_Image);
  clear_obj(ho_ResizedImage);
  clear_obj(ho_Rectangle);
  clear_obj(ho_ImagePart);

  /* Clear local control variables */
  destroy_tuple(hv_ModelPath);
  destroy_tuple(hv_PreprocessParamFileName);
  destroy_tuple(hv_TrainedModelFileName);
  destroy_tuple(hv_BatchSizeInference);
  destroy_tuple(hv_MinConfidence);
  destroy_tuple(hv_MaxOverlap);
  destroy_tuple(hv_MaxOverlapClassAgnostic);
  destroy_tuple(hv_DLDeviceHandles);
  destroy_tuple(hv_DLDevice);
  destroy_tuple(hv_DLModelHandle);
  destroy_tuple(hv_DLPreprocessParam);
  destroy_tuple(hv_DLDataInfo);
  destroy_tuple(hv_ClassNames);
  destroy_tuple(hv_ClassIDs);
  destroy_tuple(hv_WindowHandleDict);
  destroy_tuple(hv_TextYPos);
  destroy_tuple(hv_TextYPositions);
  destroy_tuple(hv_AcqHandle);
  destroy_tuple(hv_DLSampleInference);
  destroy_tuple(hv_DLResult);
  destroy_tuple(hv_bboxcol);
  destroy_tuple(hv_bboxrow);
  destroy_tuple(hv_bboxcol2);
  destroy_tuple(hv_bboxrow2);
  destroy_tuple(hv_checkid);
  destroy_tuple(hv_num_boxes);
  destroy_tuple(hv_i);

}


#ifndef NO_EXPORT_APP_MAIN

int main(int argc, char *argv[])
{
  /* Default settings used in HDevelop */
  int ret=0;
  Htuple Parameter, Value;

#if defined(_WIN32)
  set_system("use_window_thread", "true");
#endif

  /* file was stored with local-8-bit encoding
   *   -> set the interface encoding accordingly */
  SetHcInterfaceStringEncodingIsUtf8(FALSE);

  create_tuple(&Parameter,2);
  create_tuple(&Value,2);
  set_s(Parameter,"width",0);
  set_i(Value,512,0);
  set_s(Parameter,"height",1);
  set_i(Value,512,1);
  T_set_system(Parameter,Value);
  destroy_tuple(Value);
  destroy_tuple(Parameter);

  action();

#if defined(_WIN32)
  /*
   * On Windows socket communication is no longer possible after returning
   * from main, so HALCON cannot return floating licenses automatically.
   */
  set_system("return_license", "true");
#endif

  return ret;
}

#endif


#endif


